; BBC Microcomputer OS 0.10
; Reassembly by Toby Nelson, 2020
;
; Table of Contents
; -----------------
;         Chapter 1: Introduction
;         Chapter 2: Memory Layout and Constants
;         Chapter 3: Memory Mapped IO
; ($C000) Chapter 4: Character definitions and VDU tables                         (1216 bytes)
;           Character definitions; Boot message; VDU tables
; ($C4C0) Chapter 5: VDU and OSWORD routines                                      (1629 bytes)
;           VDU 0-6, 8-31, 127. OSWORD 9, 11, 12; VDUCHR entry point; Swap cursor variables
;           Check text or graphics cursor active; Hardware scrolling; Scroll in paged mode
; ($CB1D) Chapter 6: Changing MODEs                                                (475 bytes)
;           MODE change code; OSWORD 10; Clear screen
; ($CCF8) Chapter 7: Graphics cursor and soft character definitions                (872 bytes)
;           OSBYTE 20; Cursor editing mode; Software scroll up/downwards
;           Exchange four VDU variables; Plot character at graphics cursor
;           Graphics cursor handling; MODE 7 character conversion
;           Setup soft character definitions
; ($D060) Chapter 8: PLOT                                                         (1890 bytes)
;           OSBYTE 134; OSWORD 13; PLOT routine; Checking graphics cursor bounds
;           Coordinate conversion; PLOT line; Move graphics cursor; Copy VDU variables
;           PLOT lateral fill; PLOT fill triangle
; ($D7C2) Chapter 9: Cursor editing mode                                           (382 bytes)
;           OSBYTE 132, 133, 135; Cursor editing mode routines
; ($D940) Chapter 10: Resets                                                       (732 bytes)
;           OSBYTE 142; Default vector table; Default MOS variables table; Reset entry point
; ($DC1C) Chapter 11: Interrupt processing                                         (681 bytes)
;           OSBYTE 17; IRQ entry point; BRK handler; IRQ1, IRQ2 handlers; Display string
; ($DEC5) Chapter 12: Command Line Interpreter (star commands)                     (479 bytes)
;           OSBYTE 127, 139; OSRDCH entry point; OSCLI Handler; Table of star commands; *BASIC
;           Reading hex values from strings; Copyright string (backwards)
; ($E0A4) Chapter 13: Writing characters; printer; buffers                         (362 bytes)
;           OSBYTE 123, 156; OSWRCH entry point; Econet / User printer routines; Flush buffers
;           Count or purge buffer (CNPV); Append to buffer
; ($E20E) Chapter 14: Star commands                                                (933 bytes)
;           *LOAD; *SAVE; *SPOOL; *KEY; *FX; OSBYTE 119, 138, 145, 152, 153
;           Clear OSFILE address; Tables of buffer addresses; EVENT entry point
;           Remove from buffer (REMV); Insert into buffer (INSV)
; ($E5B3) Chapter 15: OSBYTE and OSWORD                                            (1360 bytes)
;           VDU 7; OSBYTE 0-14, 16, 18, 19, 117, 118, 124-126, 128-130, 136, 137, 144, 147, 149, 151, 154, 155, 160, 247
;           OSWORD 0-8; OSBYTE entry point; OSWORD entry point; *LINE; *CODE
;           Serial baud rate / sound buffer table; GSINIT; GSREAD
;           Keyboard handling routines
; ($EB03) Chapter 16: Sound and Speech                                             (983 bytes)
;           OSBYTE 158, 159; Sound and speech interrupt processing; ROM/PHROM read byte
; ($EEDA) Chapter 17: Keyboard processing                                          (603 bytes)
;           OSBYTE 15, 21, 120-122, 131; Keyboard processing, translation table, scanning code
;           KEYV entry point; Speech table; *HELP
; ($F135) Chapter 18: Tape and ROM Filing systems                                  (1107 bytes)
;           OSBYTE 140, 141, 143; OSARGS entry; OSFILE entry; OSFIND entry; OSBGET entry
;           OSBPUT entry; File system vector table; FSC entry point; Setup tape options
;           Load and save file; Copy filename; *RUN; *CAT; *OPT; Search for block; Open a file
;           Save a block to tape
; ($F588) Chapter 19: Low Level Tape Operations                                    (801 bytes)
;           Update ACIA; Check EOF; Search for file; Spool or Exec file; Load and save block
;           Load block header; Load and save byte; Update CRC
; ($F8A9) Chapter 20: Filing System Messaging and Error Reporting                  (575 bytes)
;           Print progress; Prompt to record on tape; Print four byte hex
;           Check for ESCAPE during tape operations; Load block from tape
;           Print following message; Data? File? Block? error messages
; ($FAE8) Chapter 21: More Low Level Tape Operations                               (280 bytes)
;           Setup, Claim, and Reset ACIA; Cancel tape operation
;           Activate / deactivate RTS; Zero checksum; Copy filename; Motor on/off
;           Check file is open; Send data to second processor; Setup for cassette write
; ($FC00) Chapter 22: Credits                                                      (768 bytes)
;           Credits string
; ($FF00) Chapter 23: Extended vectors                                             (167 bytes)
;           Extended vector entry points table; Extended vector handler
; ($FFA7) Chapter 24: OS entry points; Tube; FRED; JIM; SHEILA                      (89 bytes)
;           OSBYTE 146, 148, 150, 157; OS Entry points and 6502 Vectors (NMI, Reset, IRQ)
;         Chapter 25: Appendix
;           Circuit diagrams in vector format
;         Chapter 26: Index
;           Index of MOS features as they are seen by user programs
;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 1: Introduction
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; About this document
;
; See mos.png
;
; ***************************************************************************************
;
; This is a fully annotated reassembly of the operating system of the BBC Micro, v0.10.
;
; It attempts to explain every corner of the 16K ROM in some detail, hopefully throwing light
; onto often poorly understood sections, and in general to admire its vision, scope, ingenuity
; and succinctness. It also documents some of its few quirks / bugs. By creating this document
; I understand it a lot better now, and I hope that readers will gain some insight too.
;
; In the comments I often refer to 'NAUG' the 'New Advanced User Guide'
; see https://stardot.org.uk/forums/viewtopic.php?f=42&t=17243.
;
; This document was originally based on the annotated disassembly by Geoff Cox (Micronet,
; 1991) for which I am indebted. It has evolved considerably since it started development
; in late 2019, and development has continued well into 2020.
;
; Just as the BBC Micro hardware contained both innovation and also points of similarity
; with Acorn's System 2 to 5 and Atom microcomputers, so too the MOS operating system
; design shows clear signs of having evolved from their "monitors". As noted above, the
; Atom monitor occupied just 4K, and the System 2 was even smaller, at 2K: nevertheless
; they contributed design ideas to the MOS, and occasional "Historical Notes" below give
; details. The tiny System 1, a control keypad now best known for having appeared in an
; episode of "Blake's 7", had only 512 bytes of ROM and is not really in the same family.
;
; Thanks to Graham Nelson whose Inweb software is used to format/layout the HTML version of
; this document, and for his helpful comments, corrections and suggestions and to Adrian
; Nelson for more corrections and suggestions.
;
; tobymnelson@gmail.com

; ***************************************************************************************
;
; Building with the ACME Assembler
;
; ***************************************************************************************
;
; This document is downloadable ('os010_acme.a') in the syntax for the ACME assembler (as
; well as being browsable in HTML format).
;
; To assemble, producing os010.bin as a binary, and a report file os010_report.txt:
;
;       acme -r os010_report.txt -o os010.bin os010_acme.a
;
; When assembled it should produce a binary file that is byte for byte identical to the
; original OS0.10 ROM image. Its MD5 checksum is 0cad3d0cf0d111aca2b158b9b605913f
;
; To explain some perhaps non-obvious points of the ACME assembler syntax:
;
;     * When a branch uses the '+' symbol, the destination is the next     '+' label.
;     * When a branch uses the '-' symbol, the destination is the previous '-' label.
;     * Symbols '++' and '--' work similarly.
;     * !word outputs a 16 bit value as two bytes in little endian order
;     * !be16 outputs a 16 bit value as two bytes in big endian order
;     * ">.address" means the high byte of .address
;     * "<.address" means the low byte of .address
;
; To download the ACME assembler, see https://github.com/meonwax/acme
; To download this document as assembly language source, see os010_acme.a

; ***************************************************************************************
;
; The Machine Operating System (MOS)
;
; ***************************************************************************************
; An operating system initialises and keeps a computer running properly. This includes
; servicing requests from hardware in a timely manner. An OS also provides a standardised
; set of useful functionality available to user programs.
;
; The 6502 can directly address up to 64k of memory which is broadly assigned as follows:
;
;    $0000-$7FFF (32k) = RAM        (or $0000-$3FFF (16k) = RAM for Model A computer)
;    $8000-$BFFF (16k) = BASIC or other Paged ROM (aka "Sideways ROM")
;    $C000-$FFFF (16k) = Operating System ROM
;
; Each 256 bytes of memory is called a 'page', so addresses $0000 to $00FF is called 'page
; zero', $0100-$01FF is 'page one', etc. Page zero is also known as 'zero page'.
;
; See circuit_mos.png

; ***************************************************************************************
;
; Memory Mapped IO ($FC00-$FEFF)
;
; ***************************************************************************************
; Addresses in the range $FC00-$FEFF are not mapped to the OS ROM as might be expected, but
; are connected to hardware devices. Consequently the CPU can communicate with hardware
; devices by reading and writing to specific addresses in this range.
;
; See Chapter 3.

; ***************************************************************************************
;
; The Internal Hardware We Talk Directly To (via SHEILA)
;
; We use an area of memory mapped I/O called SHEILA ($FE00-$FEFF) to talk to hardware devices
; inside the computer:
;
; Chip              What it does
; ---------------------------------------------------------------------------------------
; CRTC 6845         Cathode Ray Tube Controller. Handles the video screen format and the
;                   cursor height.
; ACIA 6850         } The ACIA and Serial ULA together control the RS-423 and cassette,
; Serial ULA        } including serial printers connected to the RS-423 port.
; Video ULA         Controls video output: timing, logical and physical colours, cursor width.
; System VIA 6522   Controls Sound, Speech, Keyboard, and selects one of four screen hardware
;                   addresses for scrolling purposes
; User VIA 6522     Parallel Printer (Port A) and User Port (Port B).
; ADC 7002          Analogue to Digital Convertor. Analogue input, often for Joysticks.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Power On / Reset
;
; ***************************************************************************************
; When powered on or reset (via the BREAK key) the 6502 executes code at the address
; retrieved from $FFFC/D (See .resetEntryPoint).
; The 'BREAK' key causes a soft reset. 'CTRL BREAK' causes a hard reset. A hard reset
; clears RAM and resets more of the OS variables.

; ***************************************************************************************
;
; Interrupts
;
; ***************************************************************************************
; The BBC Micro is a single processor with no threads or job queues. It uses interrupts
; to run code concurrently with regular code. Interrupt code must finish executing in a
; short amount of time to allow the system to continue updating effectively. Acorn
; recommends it should last less than 2ms (4000 clock cycles).
;
; The CPU receives interrupts generated by hardware devices when they need attention.
;
; There are three interrupt types (NMI; IRQ1; IRQ2)
;
; NMI = non-maskable interrupts
;   These are the highest priority of interrupt. They cannot be disabled. They are only
;   produced by certain additional hardware (hard disk controllers and Econet).
;   When an NMI is generated the 6502 interrupts its normal operation and executes from
;   the location given in the OS at $FFFA-B (i.e. $0D00 = .nmiEntryPoint). This is the
;   NMI handling code. By default this just returns immediately by executing an RTI
;   instruction.
;
; IRQ1 = interrupt request 1
;   This occurs when hardware generates an IRQ, or a BRK instruction occurs. The OS uses
;   this IRQ extensively. If a BRK instruction was the cause then the BRKV vector is used
;   to handle it (the OS uses this to output error messages). Otherwise the operating
;   system checks each hardware in turn to see what needs attention. The OS services the
;   RS-423, cassette, vertical sync, 100Hz timer, interval timer, ADC conversion (e.g. used
;   for analogue joysticks), keyboard, speech (if speech hardware is present), and printer
;   as needed. Based on the 100Hz timers, it also updates sounds and updates the flashing
;   colours.
;
;   Finally any unhandled interrupt gets passed on to IRQ2.
;
; IRQ2 = interrupt request 2
;   This is available for user code to intercept unhandled interrupts. It is the lowest
;   priority of interrupt.
;
; Calls to IRQ1 and IRQ2 handlers are indirected through 'vectors' (2 byte addresses
; stored in RAM at $0200 upwards), meaning the user can intercept them and do their own
; processing (often then passing through any unwanted interrupts back into the original
; default interrupt routine). NMIs cannot be redirected.

; ***************************************************************************************
;
; BRK instruction
;
; ***************************************************************************************
; The BRK instruction is used for error handling. It pushes the program counter and flags
; onto the stack (including a set bit for the BRK flag) and starts executing from the address
; stored at $FFFE/F (which is set to .irqEntryPoint).
;
; The OS uses BRK to display error messages (as does the BASIC ROM). The BRK instruction
; is followed by an error number then the error string to display. The .brkHandler code
; displays the error message then enters the current language. Typically though, as soon
; as the machine has started up it will be running a language such as BASIC. BASIC installs
; its own BRK handler, at which point the OS BRK handler is no longer used.
;
; Note that the BRK instruction is unrelated to the BREAK key. Pressing BREAK causes the 6502
; to RESET.

; ***************************************************************************************
;
; Paged ROMs (aka "Sideways" ROMs)
;
; ***************************************************************************************
; Functionality of the BBC Micro can be extended via the use of Paged ROMs. These ROMs
; can be quickly switched ('paged in') into the memory map as needed at address range
; $8000-$BFFF. Once the ROM code has finished executing the ROM is 'paged out' and the
; previous ROM reinstated into the memory map (which is normally the current language, often
; BASIC).
;
; Paged ROMs can implement programming languages, provide more commands (star commands) to
; the user, or even act as a Read Only filing system (using ROMFS).
;
; An optional speech ROM is also supported, which generates speech from text. It is used
; alongside a Phrase ROM or 'PHROM' that provides the word and phoneme data for generating
; speech.
;
; The BBC Micro has 5 ROM sockets available for Paged ROMs (and the MOS supports up to 16 with
; some additional hardware). In a default configuration (as shipped) the first two ROM sockets
; hold the OS and BASIC.
;
; 'Sideways RAM'
; Later in the BBC Micro's life it was discovered that you could add 'Sideways RAM' instead
; of a ROM. This requires a write signal as the BBC Micro is hard-wired to prevent writing to
; the Sideways area.
;
; A common 'Sideways RAM' implementation consists of an expansion board (aka 'daughter board')
; that plugs into a ROM socket with a flying lead connected to the motherboard. This can
; then be used as either additional program RAM or (perhaps more often) to hold a ROM image.

; ***************************************************************************************
;
; Calling the Operating System
;
; ***************************************************************************************
; There is a standard set of specific addresses (high in memory, between $FFB9 and $FFF7)
; that the user calls to access OS routines. These are detailed below.
;
; The following entry points are the API for user programs, or other ROMs, which want to
; access MOS facilities. Note that they occur at addresses which are guaranteed not to
; change: for example, in all versions of the MOS, OSBYTE is at $FFF4. It is therefore safe
; for a user program to 'JSR .OSBYTE' without knowing which MOS version is present. No other
; addresses in the ROM are safe to jump to from outside the ROM.
;
; Many of these calls are then indirected through a set of 'standard vectors' located in RAM
; at $0200-$0235. A vector is a two byte address. By default each vector contains the address
; within the OS ROM of the relevant routine. Advanced users can change a vector to point to
; their own routine in RAM to handle the call. This allows the user to extend or replace the
; existing functionality provided by the OS.
;
; If a Paged ROM wishes to change the vectors (for example a filing system ROM would want to
; redirect filing system calls to its own routines within its ROM) then a different system of
; overriding these vectors is used. See the 'Extended Vectors' section below.
;
; Incidentally the 6502 based Commodore computers from the Commodore PET, the VIC 20 through
; to the Commodore 64 have a similar arrangement of vectors, with its KERNAL functions.
; See https://www.pagetable.com/?p=926 .

; ***************************************************************************************
;
; OSWRCH (For displaying text and graphics) ($FFEE)
;
; ***************************************************************************************
; OSWRCH is generally used to output text or graphics. Output is usually sent to the screen,
; but it can be redirected to other output devices, such as a printer or a file.
;
; OSWRCH is the equivalent of the 'VDU' command from BASIC, which we use here for brevity.
;
; VDU 32-126 shows ASCII text characters on screen.
; VDU 127 is delete, which removes the previous character.
; VDU 128-255 displays custom characters on screen (or Teletext codes in MODE 7).
; VDU 0-31 have individual special meanings, and often require more VDU calls that act as
; parameters. For example VDU 22 is the code to change display MODE. Calling this does
; nothing on it's own, as it's waiting for the next VDU call (e.g. VDU 2) specifying the
; MODE number to change to.
;
; Complex code is found within VDU 25 (the equivalent of BASIC's PLOT command) and is used
; to plot points, lines, dotted lines, filled triangles, and perform horizontal line fills.
; See Chapter 8.
;
; Because OSWRCH does so much, a large chuck (37%) of the operating system is devoted to it.
;
; See .oswrchEntryPoint.
;
; The BBC Micro defines eight screen MODEs (0-7) each with different combinations of pixel
; resolutions, colours, text vs graphics capability, and therefore memory usage.

; ***************************************************************************************
;
; OSRDCH ($FFE0)
;
; ***************************************************************************************
; Reads a character from the keyboard (or other input source such as RS-423 or file).
; See .osrdchEntryPoint.

; ***************************************************************************************
;
; OSBYTE ($FFF4) (aka *FX)
;
; ***************************************************************************************
; OSBYTE provides a wide range of miscellaneous functionality. This can be accessed from
; BASIC as a '*FX' command. For example:
;
;   *FX 12,2
;
; sets the keyboard auto-repeat rate to a faster value than the default. This is equivalent
; to the assembler version:
;
;   LDA #12
;   LDX #2
;   JSR .OSBYTE
;
; The A,X,Y registers are the parameters to this call to the OS. Register 'A' determines
; the type of the call, and X and Y are the parameters for that type.
; See .osbyteEntryPoint.

; ***************************************************************************************
;
; OSWORD ($FFF1)
;
; ***************************************************************************************
; Some calls to the OS needs more parameters than an OSBYTE can provide. In this case OSWORD
; is used. Registers X and Y together form an address that holds a parameter block of data
; specific to the type of OSWORD given by register 'A'.
;
; OSWORD calls are available to machine code programs but there is no equivalent star
; command like *FX.
; See .oswordEntryPoint.
; See .osbyteAndOSWORDRoutineTable (end of table for OSWORD entry points)

; ***************************************************************************************
;
; Filing System ($FFCE - $FFDD)
;
; ***************************************************************************************
; A filing system is selected via a star command. The OS ships with support for tape (*TAPE)
; and ROM filing systems (*ROM). Support for other filing systems (e.g. *ADFS, the
; Advanced Disk Filing System) can be added using Paged ROMs. There is a range of OS calls
; designed to perform operations on the current filing system:
;
;           OSFIND ($FFCE) - Open or close a file (See .osfindEntryPoint)
;           OSGBPB ($FFD1) - Read / write multiple bytes to an open file. This is not
;                            implemented in this OS for the TAPE/ROM filing systems.
;                            Filing System Paged ROMs implement this.
;           OSBPUT ($FFD4) - Write a single byte to an open file (See .osbputEntryPoint)
;           OSBGET ($FFD7) - Read a single byte to an open file (See .osbgetEntryPoint)
;           OSARGS ($FFDA) - Read / write a file's attributes (See .osargsEntryPoint)
;           OSFILE ($FFDD) - Load / Save an entire file (See .osfileEntryPoint)

; ***************************************************************************************
;
; OSCLI (aka 'star commands') ($FFF7)
;
; ***************************************************************************************
; The OS is shipped with a Command Line Interpreter (CLI). This is a primitive form of
; shell. Commands can be accessed from BASIC or via the OSCLI routine.
;
; BASIC prefixes these with an asterisk, e.g. '*FX' etc. Hence these commands are known as
; 'star commands'. OSCLI executes a command supplied as a string. The OS provides a standard
; set, and Paged ROMs can add more.
; See .oscliEntryPoint.
; See .starCommandTable.
;
; ***************************************************************************************
;
; Others
;
; ***************************************************************************************
; VDUCHR ($FFBC)                  - A cut down form of OSWRCH just for writing to the screen (See .vduChrEntryPoint)
; OSEVEN ($FFBF)                  - Generates an EVENT, a kind of managed interrupt
;                                   (See .eventEntryPoint)
; GSINIT ($FFC2) / GSREAD ($FFC5) - Parse a string in memory (e.g. from an OSCLI command)
;                                   (See .gsinitEntryPoint)
; NVRDCH ($FFC8) / NVWRCH ($FFCB) - Non vectored versions of OSRDCH / OSWRCH
; OSASCI ($FFE3)                  - Write character using OSWRCH, or write CR/LF if CR found
;                                   (See .OSASCI)
; OSNEWL ($FFE7)                  - Write CR/LF (See .OSNEWL)

; ***************************************************************************************
;
; Extended vectors
;
; ***************************************************************************************
; Extended vectors allow Paged ROMs to intercept the standard vectors at $0200 upwards,
; effectively getting them to point to an address *within a specified Paged ROM*.
; A table containing 27 entries is stored at $0D9F (.extendedVectorSpace) with 3 bytes per
; entry:
;      the two byte address
;      a single byte holding the ROM number
;
; To use an extended vector write appropriate values into these locations, then store
; the address '$FF00+3*N' in OS vector at '$0200+2*N' (remembering the old address at
; $0200+2*N if required).
; See Chapter 23.

; ***************************************************************************************
;
; Memory Map for RAM
;
; ***************************************************************************************
; $0000-$008F   Current language workspace
; $0090-$009F   Econet workspace
; $00A0-$00A7   NMI workspace       [unused by the OS, can be used by Paged ROMs]
; $00A8-$00AF   "OS temp workspace" [unused by the OS, can be used by Paged ROMs]
; $00B0-$00CF   Filing System workspace
; $00D0-$00FF   VDU/OS workspace
; $0100-$01FF   6502 stack (the stack works downwards from $01FF)
; $0200-$0235   OS vectors
; $0236-$02FF   OS variables
; $0300-$037F   VDU variables
; $0380-$03DF   Cassette Filing System workspace
; $03E0-$03FF   Keyboard input buffer
; $0400-$07FF   Workspace for the currently active language (e.g. BASIC)
; $0800-$08FF   Sound workspace; Sound buffers; Printer buffer; Envelope storage
; $0900-$09FF   Envelope/Speech/Cassette buffers
; $0A00-$0AFF   Cassette/RS-423 input buffer
; $0B00-$0BFF   Soft key buffer
; $0C00-$0CFF   Soft character ('font') definitions
; $0D00-$0D9E   NMI routine (used by Disc Controllers and Econet)
; $0D9F-$0DEF   Expanded vector set
; $0DF0-$0DFF   Paged ROM workspace storage locations
; $0E00-$7FFF   Available user memory
;
; Available user memory starts at $0E00 for a standard TAPE based machine. At reset time,
; Paged ROMs such as disc controllers can request more RAM pages from $0E00 upwards. This
; will commonly raise the start of user memory to $1900. Soft character definitions (aka
; 'font explosions') also raise the start of available memory.
; See .osbyte20EntryPoint
;
; OSBYTE 131 reads the current OSHWM (OS High Water Mark), the true address of the start
; of user memory after ROMs and font explosions have claimed memory. This often has the
; same value as the PAGE variable in BASIC (unless PAGE is manually changed), which is
; where BASIC programs are located.
; See .osbyte131EntryPoint

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 2: Memory Layout and Constants
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Constants
;
; The following sections list all the constants used. This is followed by the memory
; addresses used, see .fileWorkspaceA.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Characters (VDU codes)
;
; ***************************************************************************************
.charBELL                                   = 7         ; (CTRL-G)
.charBACKSPACE                              = 8         ;
.charLINEFEED                               = 10        ;
.charRETURN                                 = 13        ;
.charDisableVDUOrDeleteLine                 = 21        ; (CTRL-U)
.charESCAPE                                 = 27        ;
.charSPACE                                  = 32        ;
.charEXCLAMATIONMARK                        = 33        ; !
.charDOUBLEQUOTE                            = 34        ; "
.charSTAR                                   = 42        ; *
.charPLUS                                   = 43        ; +
.charCOMMA                                  = 44        ; ,
.charDOT                                    = 46        ; .
.charFORWARDSLASH                           = 47        ; /
.charZERO                                   = 48        ; 0
.charNINE                                   = 57        ; 9
.charQUESTIONMARK                           = 63        ; ?
.charAT                                     = 64        ; @
.charA                                      = 65        ; A
.charF                                      = 70        ; F
.charZ                                      = 90        ; Z
.charUNDERSCORE                             = 95        ; _
.charPOUND                                  = 96        ; £
.chara                                      = 97        ; a
.charz                                      = 122       ; z
.charBAR                                    = 124       ; |
.charDELETE                                 = 127       ;
.charCOPY                                   = $87       ; (character equivalent of the COPY key)
.charUP                                     = $8b       ; (character equivalent of the UP key)
.charKEY10                                  = $9a       ; (character equivalent of code used for *KEY 10)

; ***************************************************************************************
;
; Internal key codes
;
; The internal key code for the space bar is inserted into the first key pressed
; (.firstKeyPressedInternal) on RESET. Otherwise, for example if SHIFT remained in the
; 'first key pressed' after a RESET then the next key press might be misinterpreted as a
; SHIFTed character.
;
; In general the internal key codes are converted to ASCII style codes using a table lookup,
; see .getASCIICode
;
; ***************************************************************************************
.internalKeyNumberSPACEBAR                  = $62       ;

; ***************************************************************************************
;
; Buffer numbers
;
; See NAUG Section 9, Page 136
;
;                                Address         Empty     Start      End
;         Buffer number          Range           Flag      pointer    pointer   Size
;         --------------------------------------------------------------------------------
;         0 = Keyboard           $03E0-$03FF     $02CF     $02D8      $02E1       32 bytes
;         1 = RS-423 Input       $0A00-$0AFF     $02D0     $02D9      $02E2      256 bytes
;         2 = RS-423 Output      $0900-$09BF     $02D1     $02DA      $02E3      192 bytes
;         3 = Printer            $0880-$08BF     $02D2     $02DB      $02E4       64 bytes
;         4 = Sound Channel 0    $0840-$084F     $02D3     $02DC      $02E5       16 bytes
;         5 = Sound Channel 1    $0850-$085F     $02D4     $02DD      $02E6       16 bytes
;         6 = Sound Channel 2    $0860-$086F     $02D5     $02DE      $02E7       16 bytes
;         7 = Sound Channel 3    $0870-$087F     $02D6     $02DF      $02E8       16 bytes
;         8 = Speech             $08C0-$08FF     $02D7     $02E0      $02E9       64 bytes
;
; ***************************************************************************************
.bufferNumberKeyboard                       = 0         ;
.bufferNumberRS423Input                     = 1         ;
.bufferNumberRS423Output                    = 2         ;
.bufferNumberPrinter                        = 3         ;
.bufferNumberSound0                         = 4         ; Noise channel
.bufferNumberSound1                         = 5         ;
.bufferNumberSound2                         = 6         ;
.bufferNumberSound3                         = 7         ;
.bufferNumberHighest                        = 7         ;

; Buffer offsets. When we add the buffer length it sums to 256.
.keyboardInputBufferOffset                  = 256 - 32  ;  32 bytes
.tapeOrRS423InputBufferOffset               = 256 - 256 ; 256 bytes
.rs423OutputBufferOffset                    = 256 - 256 ; 256 bytes
.printerBufferOffset                        = 256 - 64  ;  64 bytes
.soundChannel0BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel1BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel2BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel3BufferOffset                  = 256 - 16  ;  16 bytes

; ***************************************************************************************
;
; Event Types
;
; For information on Events see .eventEntryPoint
;
; ***************************************************************************************
.eventESCAPEConditionDetected               = 0         ; X = buffer number
.eventStartOfVSync                          = 1         ;
.eventADCConversionComplete                 = 3         ; Y = ADC channel number
.eventIntervalTimerCrossingZero             = 10        ; as used by OSWORD 3 / OSWORD 4
.eventClockTimeReached                      = 11        ; clock time reached
.eventOutputBufferInsert                    = 12        ;

; ***************************************************************************************
;
; CRTC registers
;
; See 6845.png
;
; These 18 registers are mostly write only
; See NAUG Section 13.3.3, Page 190
;
; Register  Description                             Default value for MODE
;                                              0     1     2     3     4     5     6     7
; ----------------------------------------------------------------------------------------
; R0        Horizontal total                 127   127   127   127    63    63    63    63
; R1        Characters per line               80    80    80    80    40    40    40    40
; R2        Horizontal sync position          98    98    98    98    49    49    49    51
; R3        Horizontal sync width (bits 0-3)   8     8     8     8     4     4     4     4
;           + Vertical sync width (bits 4-7)   2     2     2     2     2     2     2     2
; R4        Vertical total                    38    38    38    30    38    38    30    30
; R5        Vertical total adjust              0     0     0     2     0     0     2     2
; R6        Vertical displayed characters     32    32    32    25    32    32    25    25
; R7        Vertical sync position            34    34    34    27    34    34    27    27
; R8        Interlace mode (bits 0,1)          1     1     1     1     1     1     1     3
;           + Display delay (bits 4,5)         0     0     0     0     0     0     0     1
;           + Cursor delay (bits 6,7)          0     0     0     0     0     0     0     2
; R9        Scan lines per character           7     7     7     9     7     7     9    18
; R10       Cursor start (bits 0-4)            7     7     7     7     7     7     7    18
;           Cursor type (bit 5)                1     1     1     1     1     1     1     1
;           Cursor blink (bit 6)               1     1     1     1     1     1     1     1
; R11       Cursor end                         8     8     8     9     8     8     9    19
; R12,R13   Screen start address / 8           -     -     -     -     -     -     -     -
; R14,R15   Cursor position                    -     -     -     -     -     -     -     -
; R16,R17   Light pen position                 -     -     -     -     -     -     -     -
;
; R0    = The total number of 'character time units' across the screen - 1 (including
;         non-displayed characters)
; R1    = Number of displayed characters across the screen
; R2    = Horizontal sync pulse (changing this moves the screen left/right)
; R3    = Horz/Vert sync pulse width. Not advisable to change since most TVs/monitors require
;         the standard values.
; R4/R5 = (Integer) number of character rows (R4) + (fractional) number of scan lines (R5)
;         to make a 50Hz refresh rate.
; R6    = Number of displayed character rows
; R7    = Vertical sync position in character rows (moves display up and down by character
;         rows. Used by *TV)
; R8    = bits 0-1 = interlacing (0 or 2 = non interlaced; 1 = interlaced; 2 = interlace and
;         video for MODE 7 support)
;         bits 2-3 = unused
;         bits 4-5 = display blanking delay (0 = no delay; 1 = one character delay; 2 = two
;         character delay; 3 = disable video output)
;         bits 6-7 = cursor blanking delay (0 = No delay; 1 = one character delay; 2 = two
;         character delay; 3 = disable cursor output)
; R9    = scan lines per character - 1
; R10   = cursor start register
;           bit 7 = unused
;           bit 6 = enable / disable blinking
;           bit 5 = blink rate (fast when set)
;           bits 0-4 = cursor start scan line
; R11   = bits 0-4 = cursor end scan line
; R12/R13 = When setting R12/R13 the value to set is related to the screen start address as
; follows:
;
; MODE 0-6: set (screen address / 8)
;   MODE 7: set (screen address - $7400 EOR $2000)
;
; The same logic applies to setting R14/R15 (cursor position)
;
; R16/R17 = light pen position. See NAUG Section 13.3.9, Page 196.
;
; The CRTC registers can be set directly by writing to memory mapped IO. Write the register
; to change in .crtcAddressRegister ($FE00) then write the new value in .crtcAddressWrite
; ($FE01). (The OS sets these registers in .setCRTCRegisterDirect and .setTwoCRTCRegisters)
;
; A more OS friendly method is to use "VDU 23,0,R,V,0,0,0,0,0,0" to set register R to value V.
;
; ***************************************************************************************
.crtcHorizontalTotalRegister                = 0         ;
.crtcHorizontalDisplayedRegister            = 1         ;
.crtcHorizontalSyncPositionRegister         = 2         ;
.crtcSyncWidthRegister                      = 3         ;
.crtcVerticalTotalRegister                  = 4         ;
.crtcVerticalTotalAdjustRegister            = 5         ;
.crtcVerticalDisplayedCharactersRegister    = 6         ;
.crtcVerticalSyncPositionRegister           = 7         ;
.crtcInterlaceAndDelayRegister              = 8         ;
.crtcScanLinesPerCharacterRegister          = 9         ;
.crtcCursorStartRegister                    = 10        ;
.crtcCursorEndRegister                      = 11        ;
.crtcStartScreenAddressHighRegister         = 12        ;
.crtcStartScreenAddressLowRegister          = 13        ;
.crtcCursorPositionHighRegister             = 14        ;
.crtcCursorPositionLowRegister              = 15        ;
.crtcLightPenPositionHighRegister           = 16        ;
.crtcLightPenPositionLowRegister            = 17        ;

; ***************************************************************************************
;
; Tape / ROM filing system synchronisation bytes
;
; See NAUG Section 16.3.1, Page 263 for tape header
; See NAUG Section 17.5.6, Page 317 for ROM header
;
; ***************************************************************************************
.fsSynchronisationByte                      = $2A       ; Tape or ROM filing system synchronisation byte
.romFSMiddleBlockHeaderByte                 = $23       ; ROM filing system header byte
.romFSFinalBlockHeaderByte                  = $2B       ; ROM filing system header byte


; ***************************************************************************************
;
; Memory addresses
;
; For the remainder of this chapter all constants refer to addresses in memory.
;
; See ram.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Zero Page Addresses ($00B0-$00FF)
;
; ***************************************************************************************
.fileWorkspaceA                             = $a0       ; }
.fileWorkspaceB                             = $a1       ; } workspace values are used while we
.fileWorkspaceC                             = $a2       ; } load or save to the tape or ROM
.fileWorkspaceD                             = $a3       ; } file system. They hold different
.fileWorkspaceE                             = $a4       ; } values when saving vs. loading.
.fileWorkspaceF                             = $a5       ; } See uses below.
.fileWorkspaceG                             = $a6       ; }
.fileWorkspaceH                             = $a7       ; }

; when loading from tape or ROM we store the load address, current and next block numbers:
.loadAddressLow                             = .fileWorkspaceA ;
.loadAddressMid1                            = .fileWorkspaceB ;
.loadAddressMid2                            = .fileWorkspaceC ;
.loadAddressHigh                            = .fileWorkspaceD ;

.currentBlockNumberLow                      = .fileWorkspaceE ;
.currentBlockNumberHigh                     = .fileWorkspaceF ;

.nextBlockNumberLow                         = .fileWorkspaceG ;
.nextBlockNumberHigh                        = .fileWorkspaceH ;

; when saving to tape we store the current start address and end address:
.tapeSaveStartAddressLow                    = .fileWorkspaceA ;
.tapeSaveStartAddressMid1                   = .fileWorkspaceB ;
.tapeSaveStartAddressMid2                   = .fileWorkspaceC ;
.tapeSaveStartAddressHigh                   = .fileWorkspaceD ;

.tapeSaveEndAddressLow                      = .fileWorkspaceE ;
.tapeSaveEndAddressMid1                     = .fileWorkspaceF ;
.tapeSaveEndAddressMid2                     = .fileWorkspaceG ;
.tapeSaveEndAddressHigh                     = .fileWorkspaceH ;


.printMessageAddressLow                     = $a8       ; } stores either the address of an
.printMessageAddressHigh                    = $a9       ; } error routine, or the return
                                                        ; } address after printing a message.

.currentBlockHasDataErrorFlag               = $ab       ; set to $FF if the header of the
                                                        ; current block was read OK, but there
                                                        ; has been a data checksum error when
                                                        ; reading the actual data from the
                                                        ; current block. Otherwise $00.
                                                        ; Used to know whether to display the
                                                        ; 'Rewind tape' message.
                                                        ; See .postFileError.
.tapeCurrentOptionsByte                     = $ad       ; current options for the tape
                                                        ; filing system. See .tapeOptionsByte
                                                        ; below.
                                                        ;
                                                        ; options are in the top four bits:
                                                        ;   bit 4 = Abort bit
                                                        ;   bit 5 = Retry bit
                                                        ;   bit 6 }
                                                        ;   bit 7 } Message type:
                                                        ;
                                                        ;       00 = no messages
                                                        ;       10 = short messages
                                                        ;       11 = long messages
                                                        ;
                                                        ; Bits   Errors     Message Type
                                                        ; --------------------------------
                                                        ; 0000   Ignore     no messages
                                                        ; 0001   Abort      no messages
                                                        ; 0010   Retry      no messages
                                                        ; 1000   Ignore     short messages
                                                        ; 1001   Abort      short messages
                                                        ; 1010   Retry      short messages
                                                        ; 1100   Ignore     long messages
                                                        ; 1101   Abort      long messages
                                                        ; 1110   Retry      long messages
.fsTempStorageLow                           = $bb
.fsTempStorage                              = $bc       ; temporary storage used by filing
                                                        ; system routines
.fsCharacterJustReadOrCharToWrite           = $af       ;
.tapeChecksumLow                            = $b0       ; }
.tapeChecksumHigh                           = $b1       ; } CRC checksum
.fsGotACharacterToReadOrWriteFlag           = $b2       ; the top bit is set when a byte of
                                                        ; data from tape or ROM has (a) been
                                                        ; read or (b) is ready to write to
                                                        ; tape, and is ready to be processed.
                                                        ; The value of the byte is stored in
                                                        ; .fsCharacterJustReadOrCharToWrite
.checksumIsValidFlag                        = $b3       ; non-zero value indicates an error
.fsReadProgressState                        = $b4       ; current state of reading from tape
                                                        ; It is one of (0,2,4,6,8,10)
                                                        ; See .postReadByte

.tapeLastBputValue                          = $305      ; Last byte BPUT, see .osbputEntryPoint

.tapeBaudRate                               = $bd       ; current cassette baud rate:
                                                        ; 5 for 1200 baud
                                                        ; 6 for 300 baud
.tapeInterBlockGap                          = $be       ; current duration (in tenths of a
                                                        ; second) of the gap between blocks
                                                        ; of data when saving to tape.
.osfileBlockAddressLow                      = $b0       ; } Address of parameter block for
.osfileBlockAddressHigh                     = $b1       ; } OSFILE
.tempStoreB7                                = $b7       ;
.tapeSendingFlag                            = $0308     ; non-zero = currently sending to tape
.tapeCRCBitCounter                          = $031f     ; loop counter when calculating CRC

.vduStatusByte                              = $36b      ; Each bit holds part the VDU status:
                                                        ; bit 0 = printer enable
                                                        ; bit 1 = scrolling disabled
                                                        ; bit 2 = paged scrolling selected
                                                        ; bit 3 = software scrolling (text window)
                                                        ; bit 4 = not used
                                                        ; bit 5 = graphics cursor enabled (VDU 5)
                                                        ; bit 6 = separated cursors
                                                        ; bit 7 = VDU disabled
.vduCurrentPlotByteMask                     = $cc       ; bits to write a pixel within a byte

.vduTextColourByteOR                        = $cd       ; } bytes to implement current foreground
.vduTextColourByteEOR                       = $ce       ; } and background text colours

.vduGraphicsColourByteOR                    = $cf       ; } bytes to implement current GCOL
.vduGraphicsColourByteEOR                   = $d0       ; } mode and graphics colours

.vduScreenAddressOfGraphicsCursorCellLow    = $c0       ; } address of the top of the cell
.vduScreenAddressOfGraphicsCursorCellHigh   = $c1       ; } on screen containing the graphics
                                                        ; } cursor position

.vduWriteCursorScreenAddressLow             = $c2       ; } address of the top of the cell
.vduWriteCursorScreenAddressHigh            = $c3       ; } on screen for the write cursor

.vduTempStoreC4                             = $c4       ; }
.vduTempStoreC5                             = $c5       ; }
.vduTempStoreC6                             = $c6       ; } store for temporary values,
.vduTempStoreC7                             = $c7       ; } used in multiple VDU related
.vduTempStoreC8                             = $c8       ; } functions.
.vduTempStoreC9                             = $c9       ; }

.vduMultiplicationTableLow                  = $ca       ; stores which multiplication table
.vduMultiplicationTableHigh                 = $cb       ; to use

.tempStoreDB                                = $db       ; }
.tempStoreDC                                = $dc       ; }

.fsStatusByte                               = $aa       ; bit 0  input file open
                                                        ; bit 1  output file open
                                                        ; bit 2  current CATalogue status
                                                        ; bit 3  EOF reached
                                                        ; bit 4  not used
                                                        ; bit 5  not used
                                                        ; bit 6  not used
                                                        ; bit 7  EOF warning given

.tapeOptionsByte                            = $b9       ; options for the tape filing
                                                        ; system
                                                        ;
                                                        ; we store two sets of options, one
                                                        ; for LOAD and SAVE operations on a
                                                        ; whole file (top four bits), and
                                                        ; the other for 'sequential access'
                                                        ; byte by byte (lower four bits).
                                                        ;
                                                        ; Only one of these two sets of
                                                        ; options is active at one time.
                                                        ; These are stored in the top
                                                        ; four bits of .tapeCurrentOptionsByte.
                                                        ; See .tapeCurrentOptionsByte.
                                                        ;
                                                        ;   bit 0/4 = Abort bit
                                                        ;   bit 1/5 = Retry bit
                                                        ;   bit 2/6 }
                                                        ;   bit 3/7 } Message type:
                                                        ;
                                                        ;       00 = no messages
                                                        ;       10 = short messages
                                                        ;       11 = long messages
                                                        ;
                                                        ; Bits   Errors     Message Type
                                                        ; --------------------------------
                                                        ; 0000   Ignore     no messages
                                                        ; 0001   Abort      no messages
                                                        ; 0010   Retry      no messages
                                                        ; 1000   Ignore     short messages
                                                        ; 1001   Abort      short messages
                                                        ; 1010   Retry      short messages
                                                        ; 1100   Ignore     long messages
                                                        ; 1101   Abort      long messages
                                                        ; 1110   Retry      long messages

.stringInputOptions                         = $283      ; When parsing an input string
                                                        ; bit 7 = double-quote character found at start
                                                        ; bit 6 = space character is not a terminator
                                                        ; See .gsinitEntryPoint
.starCommandYParameter                      = $028a
.stringInputPlingFlag                       = $0282     ; When parsing an input string
                                                        ; $80 if previous character is '!'
                                                        ; $00 otherwise
.starCommandXParameter                      = $0289
.readCharacterTimedFlag                     = $e2       ; 0 means read key instantly
                                                        ; 255 means read key timed
.tempWorkspaceE0                            = $e0       ; general workspace
.tapeFilingSystemEnableFlag                 = $e3       ; top bit set if (tape) filing system active
.tempWorkspaceE6                            = $e6       ; general workspace
.tempWorkspaceE7                            = $e7       ; general workspace
.currentStringPointer                       = $0282     ; offset within command string

.autorepeatCountdownTimer                   = $ec
.osword0BufferAddressLow                    = $f5       ; reading line of input by OSWORD 0
.osword0BufferAddressHigh                   = $f6       ;
.rs423TimeoutCounter                        = $02a6     ;  1: the tape FS has control
                                                        ;  0: RS-423 in control, timed out
                                                        ; <0: RS-423 in control, not timed out

.lastKeyPressedInternal                     = $d7       ; see table below
.firstKeyPressedInternal                    = $ed       ; see table below

    ; Situation              .lastKeyPressedInternal    .firstKeyPressedInternal
    ; -------------------------------------------------------------------------
    ; no keys pressed        $00                        $00
    ; one key pressed        first key number           $00
    ; two keys pressed       second key  number         first key number
    ; second key released    $00                        first key number

.osbyteA                                    = $c5       ; }
.oswordA                                    = $c5       ; } stores register values when
.osbyteX                                    = $c6       ; } calling OSBYTE and OSWORD
.oswordX                                    = $c6       ; }
.stackPointerLastBRK                        = $F0       ; stores the stack pointer on a BRK instruction
.osbyteY                                    = $c7       ; } stores register values when
.oswordY                                    = $c7       ; } calling OSBYTE and OSWORD

.acia6850ControlRegisterCopy                = $ea

.stringInputBufferAddressLow                = $fa       ; } Start address of input string
.stringInputBufferAddressHigh               = $fb       ; }

.currentlySelectedROM                       = $0268     ; current Paged ROM selected

.tempStoreFA                                = $fa       ; }
.tempStoreFB                                = $fb       ; } General purpose temporary store

.keyboardLinks                              = $f4       ; Keys 2-9 state as bits
.interruptAccumulator                       = $de       ; used during IRQ processing to
                                                        ; remember the accumulator and also
                                                        ; used during a reset (before
                                                        ; IRQs are enabled)

.displayStringAddressLow                    = $fd       ;                 (- multiple uses)
.brkAddressLow                              = $fd       ; } address after (- multiple uses)
.brkAddressHigh                             = $fe       ; } last BRK      (- multiple uses)
.displayStringAddressHigh                   = $fe       ;                 (- multiple uses)

.escapeFlag                                 = $ff       ; the ESCAPE flag
                                                        ; this is set when an ESCAPE character
                                                        ; (normally .charESCAPE) is entered
                                                        ; into an input buffer.
                                                        ; It should be acknowledged using
                                                        ; OSBYTE 126. This tells the second
                                                        ; processor of the event and clears
                                                        ; the flag.

; ***************************************************************************************
;
; The 6502 Stack ($0100-$01FF)
;
; The 6502 stack starts at $01FF and grows downwards.
;
; ***************************************************************************************
.stackPage                                  = $0100     ; 6502 stack

; ***************************************************************************************
;
; Vectors ($0200-$0235)
;
; Vectors are addresses that can be set to point to a user routine to handle operating system
; calls, overriding or augmenting the standard behaviour. By default they are set to locations
; in the MOS ROM.
;
; See .defaultVectorTable for the default entry points for each vector
; See NAUG Section 6, Page 102
;
; Historical note: Acorn began storing vectors at $0200 with the System 2 (1980) and then
; the Atom (also 1980). Many of the vectors below appear there too, but not .vectorIRQ2V,
; .vectorBYTEV, .vectorWORDV or anything beyond .vectorNETV.
;
; ***************************************************************************************
.page2Start                                 = $0200

.vectorUSERV                                = $0200     ; User vector
.vectorBRKV                                 = $0202     ; BRK vector
.vectorIRQ1V                                = $0204     ; Primary IRQ vector
.vectorIRQ2V                                = $0206     ; Unrecognised IRQ vector
.vectorCLIV                                 = $0208     ; Command line interpreter
.vectorBYTEV                                = $020A     ; OSBYTE call
.vectorWORDV                                = $020C     ; OSWORD call
.vectorWRCHV                                = $020E     ; OSWRCH call
.vectorRDCHV                                = $0210     ; OSRDCH call
.vectorFILEV                                = $0212     ; Load / Save file
.vectorARGSV                                = $0214     ; Load / Save file parameters
.vectorBGETV                                = $0216     ; Get byte from file
.vectorBPUTV                                = $0218     ; Put byte to file
.vectorGBPBV                                = $021A     ; Transfer data to or from a file
.vectorFINDV                                = $021C     ; Open / Close file
.vectorFSCV                                 = $021E     ; Filing system control

.vectorVDUV                                 = $0380     ; Unrecognised PLOT / VDU 23 commands

; ***************************************************************************************
;
; OS Variables ($0236-$02FF)
;
; ***************************************************************************************

; This value is offset when reading / writing OS variables using OSBYTE 166-255
.mosVariablesMinus166                       = .mosVariables - 166
                                                        ; value to add the OSBYTE (166-255)
                                                        ; number to get the address to
                                                        ; read/write
.minEditingCharacter                        = $022b     ;
.maxEditingCharacter                        = $022c     ;
.numberOfSoftKeyDefinitions                 = $0231     ;
.mosVariables                               = $0236     ; Constant value .mosVariablesMinus166
                                                        ; (Read using OSBYTE 166/167)

.verticalSyncCounter                        = $f9       ; decremented every vertical sync
                                                        ; (Read/Write using OSBYTE 176)
.currentInputBuffer                         = $df       ; buffer number for current input
                                                        ; (Read/Write using OSBYTE 177)
.videoULAVideoControlRegisterCopy           = $028b     ; OS copy of video control register
                                                        ; (Read using OSBYTE 184)
.videoULAPaletteValue                       = $0249     ; value last written to the palette:
                                                        ; bits 0-3: physical colour EOR 7
                                                        ; bits 4-7: logical colour
                                                        ; (Read using OSBYTE 185)
.romNumberActiveLastBRK                     = $fc       ; ROM socket number when last BRK occurred
                                                        ; (Read using OSBYTE 186)
.adcCurrentChannel                          = $0233     ; current ADC channel number
                                                        ; (Read using OSBYTE 188)
.maximumADCChannelNumber                    = $0232     ; read maximum ADC channel number
                                                        ; (Read using OSBYTE 189)
.rs423ReadyFlag                             = $0221     ; bit 7 set means RS-423 is ready
                                                        ; otherwise RS-423 is busy
                                                        ; (Read/Write using OSBYTE 191)
.videoULAFlashingColourIntervalCount        = $0224     ; counts down time before flashing the colours
                                                        ; (Read/Write using OSBYTE 193)
.videoULAFirstFlashingColourInterval        = $0223     ; number of frames to spend on the first flashing colour
                                                        ; (Read/Write using OSBYTE 194, but prefer OSBYTE 9)
.videoULASecondFlashingColourInterval       = $0222     ; number of frames to spend on the second flashing colour
                                                        ; (Read/Write using OSBYTE 195, but prefer OSBYTE 10)
.keyboardAutoRepeatDelay                    = $d9       ; delay before a key held down autorepeats in centi-seconds
                                                        ; (Read/write using OSBYTE 196, but prefer OSBYTE 11)
.keyboardAutoRepeatRate                     = $da       ; keyboard autorepeat rate in centi-seconds
                                                        ; (Read/write using OSBYTE 197, but prefer OSBYTE 12)
.execFileHandle                             = $02a3     ; file handle of open EXEC file or zero if none open
                                                        ; (Read/Write using OSBYTE 198)
.spoolFileHandle                            = $02a4     ; file handle of open SPOOL file or zero if none open
                                                        ; (Read/Write using OSBYTE 199)
.keyboardStatusFlags                        = $d8       ; bit 3 = 1 means SHIFT pressed
                                                        ; bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; bit 6 = 1 means CTRL pressed
                                                        ; bit 7 = 1 means SHIFT enabled
                                                        ; (Read/Write using OSBYTE 202)
.soundBELLChannel                           = $022d     ; sound channel for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 211)
.soundBELLAmplitudeEnvelope                 = $022e     ; sound amplitude/envelope for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 212)
.soundBELLPitch                             = $022f     ; sound pitch for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 213)
.soundBELLDuration                          = $0230     ; sound duration for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 214)
.softKeyStringLength                        = $e9       ; length of the current *KEY string being decoded
                                                        ; (Read/Write using OSBYTE 216)
.pagedModeCounter                           = $037b     ; number of lines printed since last paged mode pause
                                                        ; (Read/Write using OSBYTE 217)
.twosComplimentOfNumberOfBytesInVDUQueue    = $0366     ; 255 - bytes in vdu queue
                                                        ; (Read/Write using OSBYTE 218)

.escapeAction                               = $0226     ; 0 = normal ESCAPE action
                                                        ; otherwise ASCII
                                                        ; (Read/Write using OSBYTE 229)
.speechSystemPresentFlag                    = $0220     ; 0 = no speech
                                                        ; 255 = SPEECH present
                                                        ; (Read using OSBYTE 235)
.tempStorage27C                             = $027c     ;
.characterDestinationsAvailableFlags        = $0247     ; bit 0 - enable RS-423 driver
                                                        ; bit 1 - disable VDU driver
                                                        ; bit 2 - disable printer driver
                                                        ; bit 3 - enable printer, independent of CTRL-B/C
                                                        ; bit 4 - disable SPOOLed output
                                                        ; bit 5 - not used
                                                        ; bit 6 - disable printer driver (unless preceded by VDU 1)
                                                        ; bit 7 - not used
                                                        ; (Read using OSBYTE 236)
.cursorEditingType                          = $0248     ; 0 = enable normal cursor editing
                                                        ; 1=disable (cursor keys return codes $87-$8B)
                                                        ; 2=disable (cursor keys and COPY key
                                                        ;      are soft keys 11=COPY,12=LEFT,
                                                        ;      13=RIGHT,14=DOWN,15=UP)
                                                        ; (Read using OSBYTE 237)

.serialULARegisterCopy                      = $024d     ; copy of the Serial ULA control register
                                                        ; (Read using OSBYTE 242)
.timeClockSwitch                            = $d6       ; which five byte clock is in currently use (5 or 10)
                                                        ; (Read using OSBYTE 243)
.printerDestination                         = $0249     ; 0 = no printer output
                                                        ; 1 = parallel printer
                                                        ; 2 = serial printer
                                                        ; 3 = user printer routine
                                                        ; 4 = net printer
                                                        ; 5-255 = user printer routine
                                                        ; (Read/Write using OSBYTE 245)
.printerIgnoreCharacter                     = $024a     ; character that the printer ignores
                                                        ; (Read/Write using OSBYTE 246)

.tempStore284                               = $0284
.tempStore285                               = $0285
.tempStore294                               = $0294

.unknownInterruptDisableFlag                = $d5       ;
.languageROMNumber                          = $0269     ; ROM Number for current language
                                                        ; (Read/Write using OSBYTE 252)
.lastResetType                              = $f8       ; what type of reset was last done?
                                                        ;        0    Soft reset (BREAK)
                                                        ;        1    Power on
                                                        ;        2    Hard reset (CTRL-BREAK)
                                                        ; only used during the boot sequence itself
                                                        ; (Read/Write using OSBYTE 253)
.systemAvailableRAM                         = $f8       ; $40 = 16k (usually Model A)
                                                        ; $80 = 32k (usually Model B)
                                                        ; (Read using OSBYTE 254)

.vduVerticalAdjust                          = $024b     ; *TV value
.vduInterlaceValue                          = $024c     ; *TV interlace value
.timeClockA                                 = $024e     ; } 5 byte clock as read by TIME
.timeClockB                                 = $025d     ; } read and write alternates between
                                                        ; these two 5 byte buffers
                                                        ; (see .timeClockSwitch)
.countdownIntervalTimer                     = $0258     ; 5 byte countdown interval timer (causes an EVENT when it reaches zero)

.romTypeTable                               = $0262     ; the type of each of the sixteen ROMs $0262-$271
.inkeyTimeoutCounterLow                     = $e5       ; } 16 bit value that is decremented
.inkeyTimeoutCounterHigh                    = $e4       ; } at 100Hz while processing a timed keyboard read

.osword0MaxLineLength                       = $0286     ; }
.osword0MinASCIICharacter                   = $0287     ; } copies of the values in the OSWORD 0 parameter block
.osword0MaxASCIICharacter                   = $0288     ; }

.lowByteLastByteFromADCChannel1             = $028c     ;
.lowByteLastByteFromADCChannel2             = $028d     ;
.lowByteLastByteFromADCChannel3             = $028e     ;
.lowByteLastByteFromADCChannel4             = $028f     ;
.highByteLastByteFromADCChannel1            = $0290     ;
.highByteLastByteFromADCChannel2            = $0291     ;
.highByteLastByteFromADCChannel3            = $0292     ;
.highByteLastByteFromADCChannel4            = $0293     ;

; 'Event enabled' flags (0 means disabled, non-zero is enabled)
.eventEnabledFlags                          = $0295     ;
.escapeConditionEventEnabled                = .eventEnabledFlags + .eventESCAPEConditionDetected    ;
.startOfVSyncEventEnabled                   = .eventEnabledFlags + .eventStartOfVSync               ;
.adcConversionCompleteEventEnabled          = .eventEnabledFlags + .eventADCConversionComplete      ;
.intervalTimerCrossingZeroEventEnabled      = .eventEnabledFlags + .eventIntervalTimerCrossingZero  ;
.clockTimeReachedEventEnabled               = .eventEnabledFlags + .eventClockTimeReached           ;
.outputBufferEmptyEventEnabled              = .eventEnabledFlags + .eventOutputBufferInsert         ;

.softKeyExpansionPointer                    = $e8       ; next byte to expand is at
                                                        ; ($0B09 + .softKeyExpansionPointer)

.keyboardFirstAutorepeatCount               = $eb       ;

.soundIsUpdatingFlag                        = $0220     ; aka 'Sound semaphore'
                                                        ; $FF if sound interrupt is updating
                                                        ; $00 otherwise

.bufferEmptyFlags                           = $0880      ;

.keyboardBufferEmptyFlag                    = .bufferEmptyFlags + .bufferNumberKeyboard     ; }
.rs423InputBufferEmptyFlag                  = .bufferEmptyFlags + .bufferNumberRS423Input   ; }
.rs423OutputBufferEmptyFlag                 = .bufferEmptyFlags + .bufferNumberRS423Output  ; }
.printerBufferEmptyFlag                     = $0221      ; }
.soundChannel0BufferEmptyFlag               = .bufferEmptyFlags + .bufferNumberSound0     ; } Bit 7 set if buffer is empty
.soundChannel1BufferEmptyFlag               = .bufferEmptyFlags + .bufferNumberSound1     ; }
.soundChannel2BufferEmptyFlag               = .bufferEmptyFlags + .bufferNumberSound2     ; }
.soundChannel3BufferEmptyFlag               = .bufferEmptyFlags + .bufferNumberSound3     ; }

.bufferStartIndices                         = $0235      ;
.keyboardBufferStartIndex                   = .bufferStartIndices + .bufferNumberKeyboard   ; }
.rs423InputBufferStartIndex                 = .bufferStartIndices + .bufferNumberRS423Input ; }
.rs423OutputBufferStartIndex                = .bufferStartIndices + .bufferNumberRS423Output; }
.printerBufferStartIndex                    = .bufferStartIndices + .bufferNumberPrinter    ; } Offset to next byte to be removed
.soundChannel0BufferStartIndex              = .bufferStartIndices + .bufferNumberSound0     ; } Highest location in each
.soundChannel1BufferStartIndex              = .bufferStartIndices + .bufferNumberSound1     ; }    buffer has offset $FF
.soundChannel2BufferStartIndex              = .bufferStartIndices + .bufferNumberSound2     ; }
.soundChannel3BufferStartIndex              = .bufferStartIndices + .bufferNumberSound3     ; }

.bufferEndIndices                           = $023d     ;
.keyboardBufferEndIndex                     = .bufferEndIndices + .bufferNumberKeyboard     ; }
.rs423InputBufferEndIndex                   = .bufferEndIndices + .bufferNumberRS423Input   ; }
.rs423OutputBufferEndIndex                  = .bufferEndIndices + .bufferNumberRS423Output  ; }
.printerBufferEndIndex                      = .bufferEndIndices + .bufferNumberPrinter      ; }
.soundChannel0BufferEndIndex                = .bufferEndIndices + .bufferNumberSound0       ; } Offset to last byte entered in
.soundChannel1BufferEndIndex                = .bufferEndIndices + .bufferNumberSound1       ; } each buffer
.soundChannel2BufferEndIndex                = .bufferEndIndices + .bufferNumberSound2       ; }
.soundChannel3BufferEndIndex                = .bufferEndIndices + .bufferNumberSound3       ; }

.tapeInputCurrentBlockSizeLow               = $ac       ;
.fsTempStorageAE                            = $ae       ;

.blockFlagOfCurrentlyResidentBlock          = $b8       ; bit 0 = *RUN only
                                                        ; bit 6 = no data
                                                        ; bit 7 = last block

.osfileBlockStart                           = $026a     ;
.osfileFilenameAddressLow                   = $026a     ;
.osfileFilenameAddressHigh                  = $026b     ;
.osfileLoadAddressLow                       = $026c     ; the Load/Exec/Start/End addresses
.osfileLoadAddressMid1                      = $026d     ; are all 32 bit values. The upper
.osfileLoadAddressMid2                      = $026e     ; two bytes are $FF $FF by default,
.osfileLoadAddressHigh                      = $026f     ; meaning the code is for the main
.osfileExecAddressLow                       = $0270     ; processor. If they have other
.osfileExecAddressMid1                      = $0271     ; values the data is sent via the
.osfileExecAddressMid2                      = $0272     ; Tube to the second processor
.osfileExecAddressHigh                      = $0273     ; (if present).
.osfileStartAddressLow                      = $0274     ;
.osfileStartAddressMid1                     = $0275     ;
.osfileStartAddressMid2                     = $0276     ;
.osfileStartAddressHigh                     = $0277     ;
.osfileEndAddressLow                        = $0278     ;
.osfileEndAddressMid1                       = $0279     ;
.osfileEndAddressMid2                       = $027a     ;
.osfileEndAddressHigh                       = $027b     ;

; ***************************************************************************************
;
; VDU Variables ($0300-$37F)
;
; ***************************************************************************************
.vduVariablesStart                          = $0300     ;
.vduVariablesStart2                         = $0320     ;
.vduVariablesStart2c                        = $032c     ;
.vduVariablesStart3                         = $0330     ;
.vduVariablesStart4                         = $0340     ;
.vduVariablesStart44                        = $0344     ;

.vduGraphicsWindowPixelsLeftHigh            = $0336     ; }
.vduGraphicsWindowPixelsLeftLow             = $0337     ; }
.vduGraphicsWindowPixelsBottomHigh          = $0334     ; }
.vduGraphicsWindowPixelsBottomLow           = $0335     ; }
.vduGraphicsWindowPixelsRightHigh           = $0332     ; } graphics window in pixels
.vduGraphicsWindowPixelsRightLow            = $0333     ; }
.vduGraphicsWindowPixelsTopHigh             = $0330     ; }
.vduGraphicsWindowPixelsTopLow              = $0331     ; }

.vduTextWindowLeft                          = $032b     ; }
.vduTextWindowBottom                        = $032a     ; }
.vduTextWindowRight                         = $0329     ; } text window
.vduTextWindowTop                           = $0328     ; }

.vduGraphicsWindowOriginXLow                = $0339     ; }
.vduGraphicsWindowOriginXHigh               = $0338     ; } graphics origin in external
.vduGraphicsWindowOriginYLow                = $033b     ; } coordinates
.vduGraphicsWindowOriginYHigh               = $033a     ; }

.vduGraphicsCursorPositionXLow              = $033d     ; }
.vduGraphicsCursorPositionXHigh             = $033c     ; } graphics cursor position in
.vduGraphicsCursorPositionYLow              = $033f     ; } external coordinates
.vduGraphicsCursorPositionYHigh             = $033e     ; }

.vduOldGraphicsCursorPixelsXLow             = $034b     ; }
.vduOldGraphicsCursorPixelsXHigh            = $034a     ; } old graphics cursor in pixels
.vduOldGraphicsCursorPixelsYLow             = $0349     ; }
.vduOldGraphicsCursorPixelsYHigh            = $0348     ; }

.vduTextCursorXPosition                     = $032c     ; } text cursor position
.vduTextCursorYPosition                     = $032d     ; }

.vduGraphicsCursorVerticalOffsetInCell      = $0378     ; offset within a character cell of
                                                        ; the current graphics cursor Y
                                                        ; coordinate

.vduQueueStartByte                          = $0344     ; } nine bytes for vdu queue (start)

.vduTriangleFillHeightLow                   = $0364     ; }
.vduTriangleFillHeightHigh                  = $0363     ; } height used when filling triangles

.vduPlotLineTemp365                         = $0365     ;

.vduGraphicsCursorPixelsXLow                = $0343     ; current graphics cursor position in
.vduGraphicsCursorPixelsXHigh               = $0342     ; pixels
.vduGraphicsCursorPixelsYLow                = $0341     ;
.vduGraphicsCursorPixelsYHigh               = $0340     ;

.vduWorkspaceA                              = $0344     ; workspace A-V
.vduWorkspaceB                              = $0345     ; these have multiple uses.
.vduWorkspaceC                              = $0346     ; Notably these are used when drawing
.vduWorkspaceD                              = $0347     ; lines and triangles.
.vduWorkspaceE                              = $0348     ;
.vduWorkspaceF                              = $0349     ;
.vduWorkspaceG                              = $034A     ;
.vduWorkspaceH                              = $034B     ;
.vduWorkspaceI                              = $034C     ;
.vduWorkspaceJ                              = $034D     ;
.vduWorkspaceK                              = $034E     ;
.vduWorkspaceL                              = $034F     ;
.vduWorkspaceM                              = $0350     ;
.vduWorkspaceN                              = $0351     ;
.vduWorkspaceO                              = $0352     ;
.vduWorkspaceP                              = $0353     ;
.vduWorkspaceQ                              = $0354     ;
.vduWorkspaceR                              = $0355     ;
.vduWorkspaceS                              = $0356     ;
.vduWorkspaceT                              = $0357     ;
.vduWorkspaceU                              = $0358     ;
.vduWorkspaceV                              = $0359     ;
.vduWorkspaceW                              = $035A     ;

.vduPlotType                                = .vduWorkspaceI ;


.vduClearGraphicsWindowLineCount            = .vduWorkspaceI ; line counter used in VDU 16 (clear graphics window)
.vduMODE7CursorCharacter                    = .vduWorkspaceQ ;

; Plot line variables
.vduPlotLineDeltaXLow                       = .vduWorkspaceH ; 'plot line' variables
.vduPlotLineDeltaXHigh                      = .vduWorkspaceG ;
.vduPlotLineDeltaYLow                       = .vduWorkspaceF ;
.vduPlotLineDeltaYHigh                      = .vduWorkspaceE ;

.vduPlotLineCurrentPointXLow                = .vduWorkspaceO ;
.vduPlotLineCurrentPointXHigh               = .vduWorkspaceN ;

.vduPlotLineCurrentPointYLow                = .vduWorkspaceG ;
.vduPlotLineCurrentPointYHigh               = .vduWorkspaceH ;

.vduPlotLineTerminationValueLow             = .vduWorkspaceK ; } final coordinate in the
.vduPlotLineTerminationValueHigh            = .vduWorkspaceJ ; } dominant axis. Used to check
                                                             ; } when done plotting a line.

.vduPlotLineRoutineLow                      = .vduWorkspaceL ; } address of routine to use
.vduPlotLineRoutineHigh                     = .vduWorkspaceM ; } when drawing a line
.vduPlotLinePlotDottedPixelFlag             = $0363          ; 127 to draw a dot; 128 to skip
.vduPlotLineErrorTermLow                    = .vduWorkspaceS ;
.vduPlotLineErrorTermHigh                   = .vduWorkspaceR ;
.vduPlotLineAbsNonDominantAxisDeltaLow      = .vduWorkspaceW ;
.vduPlotLineAbsNonDominantAxisDeltaHigh     = .vduWorkspaceV ;
.vduPlotLineAbsDominantAxisDeltaLow         = .vduWorkspaceU ;
.vduPlotLineAbsDominantAxisDeltaHigh        = .vduWorkspaceT ;

; Plot triangle variables
.vduPlotTriMainLineErrorTermLow             = $0358          ; 'plot triangle' variables
.vduPlotTriMainLineErrorTermHigh            = .vduWorkspaceB ; tracking the 'main line'
.vduPlotTriMainLineDeltaXLow                = .vduWorkspaceC ;
.vduPlotTriMainLineDeltaXHigh               = $035c          ;
.vduPlotTriMainLineDeltaYLow                = .vduWorkspaceE ;
.vduPlotTriMainLineDeltaYHigh               = .vduWorkspaceF ;
.vduPlotTriMainLineCurrentPointXLow         = $035e ;
.vduPlotTriMainLineCurrentPointXHigh        = .vduWorkspaceH ;
.vduPlotTriMainLineCurrentPointYLow         = .vduWorkspaceI ;
.vduPlotTriMainLineCurrentPointYHigh        = .vduWorkspaceJ ;
.vduPlotTriMainLineXDirectionFlag           = $0362          ;

.vduPlotTriMinorLineErrorTermLow            = $034d          ; 'plot triangle' variables
.vduPlotTriMinorLineErrorTermHigh           = $034e          ; tracking the 'minor line'
.vduPlotTriMinorLineDeltaXLow               = $034f          ;
.vduPlotTriMinorLineDeltaXHigh              = $0351          ;
.vduPlotTriMinorLineDeltaYLow               = .vduWorkspaceP ;
.vduPlotTriMinorLineDeltaYHigh              = .vduWorkspaceQ ;
.vduPlotTriMinorLineCurrentPointXLow        = $0353          ;
.vduPlotTriMinorLineCurrentPointXHigh       = .vduWorkspaceS ;
.vduPlotTriMinorLineCurrentPointYLow        = .vduWorkspaceT ;
.vduPlotTriMinorLineCurrentPointYHigh       = .vduWorkspaceU ;
.vduPlotTriMinorLineXDirectionFlag          = $0357          ;

.vduPlotTriStorageForCoordinates            = $0348     ; eight bytes used when drawing a
                                                        ; triangle to remember the original
                                                        ; XY coordinates (four bytes) and
                                                        ; graphics cursor (four bytes)
                                                        ; ($033E to $0345)

.vduTextCursorCRTCAddressLow                = $032e     ; CRTC address of the cursor
.vduTextCursorCRTCAddressHigh               = $032f     ;

.vduTextWindowWidthInBytesLow               = $0369     ;
.vduTextWindowWidthInBytesHigh              = $036a     ;

.vduStartScreenAddressLowByte               = $0320     ;
.vduStartScreenAddressHighByte              = $0321     ;
.vduBytesPerCharacter                       = $0376     ;
.vduScreenTopLeftAddressLow                 = $0322     ;
.vduScreenTopLeftAddressHigh                = $0323     ;

.vduBytesPerCharacterRowLow                 = $0324     ;
.vduBytesPerCharacterRowHigh                = $0325     ;
.vduBytesPerCharacterRowLow2                = $0326     ;
.vduScreenSizeLowByte                       = $0326     ;
.vduBytesPerCharacterRowHigh2               = $0327     ;
.vduScreenSizeHighByte                      = $0327     ;
.specialOSRoutineAddressLow                 = $0363     ;
.specialOSRoutineAddressHigh                = $0364     ;
.vduCurrentScreenMODE                       = $0367     ;
.vduCurrentScreenMODEGroup                  = $0368     ; MODE group = screen memory size:
                                                        ;          0 = 20k (MODE 0,1,2)
                                                        ;          1 = 16k (MODE 3)
                                                        ;          2 = 10k (MODE 4,5)
                                                        ;          3 =  8k (MODE 6)
                                                        ;          4 =  1k (MODE 7)
.vduForegroundTextColour                    = $036c     ; } Current colours. Stored as the
.vduBackgroundTextColour                    = $036d     ; } byte value to colour the whole
.vduForegroundGraphicsColour                = $036e     ; } byte the given colour
.vduBackgroundGraphicsColour                = $036f     ; }
.vduForegroundGCOLMode                      = $0370     ; GCOL foreground mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
.vduBackgroundGCOLMode                      = $0371     ; GCOL background mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)

.vduJumpVectorLow                           = $0372     ;
.vduJumpVectorHigh                          = $0373     ;

.vduLastCursorStartRegisterValue            = $0374     ;

.vduNumberOfLogicalColoursMinusOne          = $0375     ;
.vduPixelsPerByteMinusOne                   = $0377     ;

.vduColourMaskLeft                          = $0379     ; colour mask left.  Bits for the
                                                        ; setting the leftmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $80
                                                        ; MODE 1,5          = $88
                                                        ; MODE 2            = $AA
.vduColourMaskRight                         = $037a     ; colour mask right. Bits for the
                                                        ; setting the rightmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $01
                                                        ; MODE 1,5          = $11
                                                        ; MODE 2            = $55
.vduTextInputCursorXCoordinate              = $037c     ;
.vduTextInputCursorYCoordinate              = $037d     ;
.vduTeletextCharacterForCursor              = $037f     ;
.vduFontFlags                               = $0382     ; ranges of characters that have SOFT character definitions:
                                                        ;     bit 7 = characters  32-63
                                                        ;     bit 6 = characters  64-95
                                                        ;     bit 5 = characters  96-127
                                                        ;     bit 4 = characters 128-159
                                                        ;     bit 3 = characters 160-191
                                                        ;     bit 2 = characters 192-223
                                                        ;     bit 1 = characters 224-255
                                                        ;     bit 0 = unused
                                                        ; See .osbyte20EntryPoint
.vduFontZoneAddressesHigh1                  = $0383     ; high byte of the address (=page number) for storing character definitions  32-63  (in ROM or RAM)
.vduFontZoneAddressesHigh2                  = $0384     ; high byte of the address (=page number) for storing character definitions  64-95  (in ROM or RAM)
.vduFontZoneAddressesHigh3                  = $0385     ; high byte of the address (=page number) for storing character definitions  96-127 (in ROM or RAM)
.vduFontZoneAddressesHigh4                  = $0386     ; high byte of the address (=page number) for storing character definitions 128-159 (in ROM or RAM)
.vduFontZoneAddressesHigh5                  = $0387     ; high byte of the address (=page number) for storing character definitions 160-191 (in ROM or RAM)
.vduFontZoneAddressesHigh6                  = $0388     ; high byte of the address (=page number) for storing character definitions 192-223 (in ROM or RAM)
.vduFontZoneAddressesHigh7                  = $0389     ; high byte of the address (=page number) for storing character definitions 224-255 (in ROM or RAM)

.vduColourPaletteStart                      = $038A     ; } 16 bytes of palette information
.vduColourPaletteEnd                        = $0399     ; }

.endTextEntryCharacter                      = $037E     ; Normally RETURN?

.vduVariablesEnd                            = $037F     ;

; ***************************************************************************************
;
; Cassette Filing System Workspace ($0380-$03DF)
;
; ***************************************************************************************
.tapeBlockHeaderStart                       = $02b0     ;
.tapeBlockFilename                          = $02b0     ; filename (11 bytes)

.tapeBlockLoadAddressLow                    = $02bc     ; }
.tapeBlockLoadAddressMid1                   = $02bd     ; }
.tapeBlockLoadAddressMid2                   = $02be     ; } load address
.tapeBlockLoadAddressHigh                   = $02bf     ; }
.tapeBlockExecutableAddressLow              = $02c0     ; }
.tapeBlockExecutableAddressMid1             = $02c1     ; }
.tapeBlockExecutableAddressMid2             = $02c2     ; } executable address
.tapeBlockExecutableAddressHigh             = $02c3     ; }
.tapeBlockNumberLow                         = $02c4     ; block number (low byte)
.tapeBlockNumberHigh                        = $02c5     ; block number (high byte)
.tapeBlockLengthLow                         = $02c6     ;
.tapeBlockLengthHigh                        = $02c7     ;
.tapeBlockFlagByte                          = $02c8     ; bit 7=last block, written when
                                                        ; closing a file for output
.tapeBlockSpareByteA                        = $02c9     ;
.tapeBlockSpareByteB                        = $02ca     ;
.tapeBlockSpareByteC                        = $02cb     ;
.tapeBlockSpareByteD                        = $02cc     ;


.bputBufferOffset                           = $02cd     ; offset in buffer for next BPUT
.bputBufferOffsetHigh                       = $02ce     ; high byte of counter
.bgetBufferOffset                           = $02d1     ; offset in buffer for next BGET
.bgetBufferOffsetHigh                       = $02d2     ; high byte of counter

.bgetLoadAddressLow                         = $02d5     ;
.bgetLoadAddressMid1                        = $02d6     ;
.bgetLoadAddressMid2                        = $02d7     ;
.bgetLoadAddressHigh                        = $02d8     ;
.bgetExecutableAddressLow                   = $02d9     ;
.bgetExecutableAddressMid1                  = $02da     ;
.bgetExecutableAddressMid2                  = $02db     ;
.bgetExecutableAddressHigh                  = $02dc     ;
.bgetFilename                               = $02dd     ; zero terminated filename (11 bytes)

.fsFilename                                 = $02e8     ; zero terminated filename (11 bytes)

.fsLoadAddressLow                           = $02f4     ;
.fsLoadAddressMid1                          = $02f5     ;
.fsLoadAddressMid2                          = $02f6     ;
.fsLoadAddressHigh                          = $02f7     ;
.fsExecutionAddressLow                      = $02f8     ;
.fsExecutionAddressMid1                     = $02f9     ;
.fsExecutionAddressMid2                     = $02fa     ;
.fsExecutionAddressHigh                     = $02fb     ;
.fsBlockNumberLow                           = $02fc     ;
.fsBlockNumberHigh                          = $02fd     ;
.fsBlockLengthLow                           = $02fe     ;
.fsBlockLengthHigh                          = $02ff     ;
.fsBlockFlagByte                            = $0300     ; block flag byte:
                                                        ;   bit 0 set = *RUN only
                                                        ;   bit 7 set = last block
.fsSpareByteA                               = $0301     ;
.fsSpareByteB                               = $0302     ;
.fsSpareByteC                               = $0303     ;
.fsSpareByteD                               = $0304     ;

.fsChecksumLow                              = $0305     ; }
.fsChecksumHigh                             = $0306     ; } checksum


.tapeSequentialAccessInterBlockGap          = $0307     ; time between writing blocks (for
                                                        ; sequential access, BGET and BPUT)
                                                        ; to cassette (> 0) in tenths of a second.
.filenameToSearchFor                        = $0309     ; zero terminated filename (11 bytes)
.nextBGETBlockLow                           = $b5       ;
.nextBGETBlockHigh                          = $b6       ;
.fsLastBlockReadFlagsCopy                   = $ba       ;

; ***************************************************************************************
;
; Keyboard Buffer ($03E0-$03FF)
;
; ***************************************************************************************
.keyboardInputBuffer                        = $03E0     ; keyboard input buffer (32 bytes)

; ***************************************************************************************
;
; Sound Workspace ($0800-$083F)
;
; ***************************************************************************************
.channel0Occupancy                          = $0884     ; }
.channel1Occupancy                          = $0885     ; } top bit set if a sound is playing
.channel2Occupancy                          = $0886     ; } on this channel, $00 otherwise
.channel3Occupancy                          = $0887     ; }

.channel0Volume                             = $0888     ; } current volume (loud to soft):
.channel1Volume                             = $0889     ; } SOUND
.channel2Volume                             = $088a     ; } volume  Value
.channel3Volume                             = $088b     ; } -15     $3F
                                                        ; } -14     $37
                                                        ; } -13     $2F
                                                        ; } -12     $27
                                                        ; } -11     $1F
                                                        ; } -10     $17
                                                        ; }  -9     $0F
                                                        ; }  -8     $07
                                                        ; }  -7     $FF
                                                        ; }  -6     $F7
                                                        ; }  -5     $EF
                                                        ; }  -4     $E7
                                                        ; }  -3     $DF
                                                        ; }  -2     $D7
                                                        ; }  -1     $CF
                                                        ; }   0     $C7

.channel0PhaseCounter                       = $088c     ; }
.channel1PhaseCounter                       = $088d     ; }
.channel2PhaseCounter                       = $088e     ; } phase counter for current amplitude envelope (which phase of 'ADSR' is current)
.channel3PhaseCounter                       = $088f     ; }

.channel0BasePitch                          = $0896     ; }
.channel1BasePitch                          = $0897     ; }
.channel2BasePitch                          = $0898     ; } base pitch (pitch at start of current pitch section)
.channel3BasePitch                          = $0899     ; }

.channel0Section                            = $089a     ; }
.channel1Section                            = $089b     ; }
.channel2Section                            = $089c     ; } current pitch section (0-2)
.channel3Section                            = $089d     ; }

.channel0SectionCountdownProgress           = $089e     ; }
.channel1SectionCountdownProgress           = $089f     ; }
.channel2SectionCountdownProgress           = $08a0     ; } current countdown timer within pitch section
.channel3SectionCountdownProgress           = $08a1     ; }

.channel0Duration                           = $08a2     ; }
.channel1Duration                           = $08a3     ; }
.channel2Duration                           = $08a4     ; } remaining duration of current sound in 20ths of a second
.channel3Duration                           = $08a5     ; }

.channel0Countdown20Hz                      = $08a6     ; }
.channel1Countdown20Hz                      = $08a7     ; }
.channel2Countdown20Hz                      = $08a8     ; } Count from 5 to 0 to give a signal every 20th of a second
.channel3Countdown20Hz                      = $08a9     ; }

.channel0EnvelopeOffset                     = $08aa     ; }
.channel1EnvelopeOffset                     = $08ab     ; }
.channel2EnvelopeOffset                     = $08ac     ; } Offset from .envelopeBuffer of current
.channel3EnvelopeOffset                     = $08ad     ; } envelope data (or $FF if no envelope in use)

.channel0StepCountdownProgress              = $08ae     ; }
.channel1StepCountdownProgress              = $08af     ; }
.channel2StepCountdownProgress              = $0890     ; } Amplitude step countdown timer of current envelope
.channel3StepCountdownProgress              = $0891     ; }

.channel0SyncFlag                           = $08b2     ; }
.channel1SyncFlag                           = $08b3     ; }
.channel2SyncFlag                           = $08b4     ; } synchronising flag of current envelope
.channel3SyncFlag                           = $08b5     ; }

.channel0Pitch                              = $08bc     ; }
.channel1Pitch                              = $08bd     ; }
.channel2Pitch                              = $08be     ; } pitch of current envelope
.channel3Pitch                              = $08bf     ; }

.channel0PitchOffset                        = $0892     ; }
.channel1PitchOffset                        = $0893     ; }
.channel2PitchOffset                        = $0894     ; } pitch offset (the actual current pitch = base pitch + pitch offset)
.channel3PitchOffset                        = $0895     ; }

.soundSyncCount                             = $08b6     ; $FF if sync is clear
                                                        ; >$00 is the number of channels to
                                                        ; sync (The 'S' in the 'SOUND &HSFC'
                                                        ; command)
.currentAmplitudeStep                       = $0891     ;
.targetAmplitude                            = $0890     ;
.numberOfSoundChannelsOnHold                = $08b7     ;

.fractionalSemitones                        = $08b8     ; when setting pitch, this is the
                                                        ; value 0-3 between semitones

; The code to play a sound calculates the frequency from the input pitch
; and from that calculates the bytes to send to the sound chip.
; These three variables are used in those calculations (See .setPitchNotNoise).
.soundPitchLow                              = $08b9     ; }
.soundPitchHigh                             = $08ba     ; } pitch to frequency variables
.soundFractional                            = $08bb     ; }

; ***************************************************************************************
;
; Sound, Printer and Envelope Buffers ($0840-$08FF)
;
; ***************************************************************************************
.soundChannel0Buffer                        = $0840     ; 16 byte sound buffer
.soundChannel1Buffer                        = $0850     ; 16 byte sound buffer
.soundChannel2Buffer                        = $0860     ; 16 byte sound buffer
.soundChannel3Buffer                        = $0870     ; 16 byte sound buffer
.printerBuffer                              = $03a0     ; 64 byte printer buffer

.envelopeBuffer                             = $0800     ; 64 byte buffer

; ***************************************************************************************
;
; Tape and Speech Buffers ($0900-$0AFF)
;
; ***************************************************************************************
.tapeOrRS423OutputBuffer                    = $0900     ; 192 byte buffer
.speechBuffer                               = $09C0     ; 64 byte buffer
.tapeOrRS423InputBuffer                     = $0A00     ; 256 byte buffer

; ***************************************************************************************
;
; Soft Key Definitions ($0B00-$0BFF)
; See .starKey.
;
; ***************************************************************************************
.softKeyPage                                = $0b00     ;
.softKeysCurrentEndOffset                   = $0b10     ; offset from $0B01 to the first free
                                                        ; byte after all current soft key
                                                        ; definitions

; ***************************************************************************************
;
; Soft Character Definitions ($0C00-$0CFF)
;
; Also known as 'soft fonts' which are stored in a 'font zone'. This is font zone zero.
; See .osbyte20EntryPoint
;
; ***************************************************************************************
.softCharacterDefinitions                   = $0C00     ; soft character definitions
                                                        ; for characters 224-255

.extendedVectorSpace                        = $0DAF     ; mechanism for changing vectors at
                                                        ; $200+2*n to point into a paged ROM.
                                                        ; pointer to table of 27 entries,
                                                        ; where each entry contains three
                                                        ; bytes:
                                                        ;   ROM address low
                                                        ;   ROM address high
                                                        ;   ROM number

; ***************************************************************************************
;
; User Space ($0E00-$7FFF)
;
; ***************************************************************************************
.initialOSHWM                               = $0E00     ; start of user memory (OSHWM / PAGE)
                                                        ; (before Paged ROMs and soft
                                                        ; character definitions take pages
                                                        ; for their own use)

; ***************************************************************************************
;
; ROM Header Addresses
;
; Paged ROMs are switched into the memory map at $8000-$BFFF. When the MOS wants to identify
; ROMs, it reads the first bytes from each ROM in turn, which is a header containing useful
; information about the ROM.
;
; See .selectROMLoop
;
; ***************************************************************************************
.romStartAddress                            = $8000     ;
.romLanguageEntry                           = $8000     ;
.romServiceEntry                            = $8003     ;
.romTypeByte                                = $8006     ;
.romCopyrightOffsetPointer                  = $8007     ;
.romTitleString                             = $8009     ;

.displayStringArea                          = $db00     ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 3: Memory Mapped IO
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Memory Mapping
;
; Addresses in the range $FC00-$FEFF are not mapped to the OS ROM as might be expected, but
; are connected to hardware devices. Consequently the CPU can communicate with hardware
; devices by reading and writing to specific addresses in this range.
;
; $FC00-$FCFF   - FRED      - Addresses are assigned to external devices:
;                             Winchester Disc / Teletext / Prestel / IEEE488 etc
; $FD00-$FDFF   - JIM       - Access to an optional extra 64K of RAM. See .jimPage.
; $FE00-$FEFF   - SHEILA    - Read / Write hardware internal to the BBC Micro (see next
;                             section).
;
; The OS provides OSBYTE calls for user programs to access these locations.
; See .osbyte146EntryPoint.
;
; Unlike the Commodore 64, this region of memory is permanently assigned to memory mapped IO,
; and is not bank switchable.
;
; Because of this address mapping, the underlying memory in the ROM can't be read or written
; by the OS. This memory stores credits text instead. See Chapter 22.
;
; ***************************************************************************************

; ***************************************************************************************
;
; FRED
;
; Accesses peripherals on the 1Mhz bus. Peripherals are allocated address ranges as follows:
;
;   Address range      Hardware allocated           Later additions
;   ---------------------------------------------------------------------
;   $FC00 - $FC0F      Test hardware                -
;   $FC10 - $FC13      Teletext                     -
;   $FC14 - $FC1F      Prestel                      -
;   $FC20 - $FC27      IEEE 488 Interface           -
;   $FC28 - $FC2F      -                            Econet (Electron)
;   $FC30 - $FC3F      Cambridge Ring Interface     -
;   $FC40 - $FC47      Winchester Disc              } Compact Flash Interface
;   $FC48 - $FC4F      Reserved                     }
;   $FC50 - $FC5F      -                            -
;   $FC60 - $FC6F      Serial expansion             -
;   $FC70 - $FC7F      -                            -
;   $FC80 - $FC8F      Test hardware                -
;   $FC90 - $FC9F      -                            -
;   $FCA0 - $FCAF      -                            -
;   $FCB0 - $FCBF      -                            6522 VIA (Electron)
;   $FCC0 - $FCCF      -                            1770 FDC (Electron)
;   $FCD0 - $FCDF      -                            -
;   $FCE0 - $FCEF      -                            Tube (Electron)
;   $FCF0 - $FCF7      -                            -
;   $FCF8 - $FCFD      -                            RetroClinic DataCentre
;   $FCFE              JIM paging register MSB      -
;   $FCFF              JIM paging register LSB      -
;
; ***************************************************************************************
.fredPage                                   = $FC00     ;

; ***************************************************************************************
;
; JIM
;
; If fitted JIM allows access to either an optional 64K of RAM or even up to 16Mb of RAM, one
; page at a time. Select which page by writing to location $FCFF (the JIM paging register)
; and if a 16 bit register is available also write to $FCFE. Then $FD00-$FDFF can be read
; or written to as RAM. Reading and writing is about half the speed of regular RAM.
;
; ***************************************************************************************
.jimPage                                    = $FD00     ;
.jimPagedEntryPoint                         = $FDFE     ; at reset time, holds the address
                                                        ; to call to initialise JIM hardware

; ***************************************************************************************
;
; SHEILA
;
; ***************************************************************************************
.sheilaPage                                 = $FE00     ;
.crtcAddressRegister                        = $FE00     ;
.crtcAddressWrite                           = $FE01     ;

; ***************************************************************************************
;
; ACIA 6850, Control Register ($FE08)
;
; This is used for writing values. By convention (for clarity) we use the Status Register
; (See .acia6850StatusRegister below) for reading values. Even though they both refer to
; the same memory location, they have different meanings depending on whether it's being
; read or written.
;
;     bits 0,1 - the counter divide select bits (CR0/CR1)
;          %00 - divide counter by 1
;          %01 - divide counter by 16                     (used for 1200 baud tape)
;          %10 - divide counter by 64 (default for RS-423) (used for 300 baud tape)
;          %11 - master reset
;     bit 2 - set means odd parity; otherwise even parity
;     bit 3 - set means 1 stop bit; otherwise 2 stop bits
;     bit 4 - set means 8 bit word; otherwise 7 bit word
;     bits 5,6:
;          %00 - 'Request To Send' ('RTS') low, transmit interrupt disabled
;          %01 - RTS low, transmit interrupt enabled
;          %10 - RTS high, transmit interrupt disabled
;          %11 - RTS low, break level on data output, transmit interrupt disabled
;     bit 7 - enable receive data register full, overrun, DCD transition interrupts
;
;         DCD = Data Carrier Detect interrupt occurs when the tone at the end of a cassette
;               block is discontinued
;
;     RTS low is the active state ('Request To Send')
;
; ***************************************************************************************
.acia6850ControlRegister                    = $FE08     ;

; ***************************************************************************************
;
; ACIA 6850, Status Register ($FE08)
;
; This is used for reading values. By convention (for clarity) we use the Control Register
; (See .acia6850ControlRegister above) for writing values. Even though they both refer to
; the same memory location, they have different meanings depending on whether it's being
; read or written.
;
;     bit 0 - set when a receiver interrupt is generated
;     bit 1 - set when a transmit interrupt is generated
;     bit 2 - set when a Data Carrier Detect ('DCD') interrupt is generated
;     bit 3 - set if the 6850 is not clear to send ('CTS')
;     bit 4 - framing error     } only valid if bit 0 set
;     bit 5 - receiver over run } only valid if bit 0 set
;     bit 6 - parity error      } only valid if bit 0 set
;     bit 7 - set if the 6850 generated the current interrupt
;
; ***************************************************************************************
.acia6850StatusRegister                     = $FE08     ;

.acia6850DataRegister                       = $FE09     ; ACIA 6850, transmit / receive data register ('TDR'/'RDR')

; ***************************************************************************************
;
; Serial ULA, Control Register ($FE10)
;
; See ula.png
;
;     bits 0-2 - transmit rate
;     bits 3-5 - receive rate
;                   %000    19200 baud
;                   %001     9600 baud
;                   %010     4800 baud
;                   %011     2400 baud
;                   %100     1200 baud
;                   %101      300 baud
;                   %110      150 baud
;                   %111       75 baud
;     bit 6 - if set, the RS-423 system has control of the serial system; otherwise the cassette system has control
;     bit 7 - if set, switch on the cassette motor and relay
;
; ***************************************************************************************
.serialULAControlRegister                   = $FE10     ; Serial ULA control register

; ***************************************************************************************
;
; Video ULA Control Register ($FE20)
;
; See vula.png
; https://github.com/YazanMehyar/FPGA-BBC-micro/blob/master/docs/VULA.txt
;
; bit 0   = flash on/off
; bit 1   = teletext / normal
; bit 2/3 = number of characters per line
;           %00=10 characters
;           %01=20 characters
;           %10=40 characters
;           %11=80 characters
; bit 4   = 0 means low clock frequency,  used in MODES 4-7
;           1 means high clock frequency, used in MODES 0-3
; bit 5-7 = cursor width
;           %000  hide cursor
;           %100  MODE 0,3,4,6
;           %110  MODE 1,5
;           %111  MODE 2
;           %010  MODE 7
;
; ***************************************************************************************
.videoULAControlRegister                    = $FE20     ; Video ULA control register

; ***************************************************************************************
;
; Video ULA Palette Register ($FE21)
;
; Write to this register to change the palette. The top four bits define the logical colour
; field, and the bottom four bits are the physical colour EOR 7. Changing the palette is a
; little more work than you might expect however:
;
; 16 colour MODEs (MODE 2)
; ------------------------
; This is straightforward. Write the logical colour to the top four bits, and the physical
; colour EOR 7 in the bottom four bits.
;
; 2 colour MODEs (MODE 0,3,4,6)
; -----------------------------
; Bit 7 defines the logical colour, but ALL combinations of bits 4-6 must be set individually
; in order to make the change properly. e.g. to change logical colour 1 to physical colour 2:
;
;     LDA #$85
;     STA .videoULAPaletteRegister
;     LDA #$95
;     STA .videoULAPaletteRegister
;     LDA #$A5
;     STA .videoULAPaletteRegister
;     LDA #$B5
;     STA .videoULAPaletteRegister
;     LDA #$C5
;     STA .videoULAPaletteRegister
;     LDA #$D5
;     STA .videoULAPaletteRegister
;     LDA #$E5
;     STA .videoULAPaletteRegister
;     LDA #$F5
;     STA .videoULAPaletteRegister
;
; 4 colour MODEs (MODE 1,5)
; -------------------------
; Bits 5 and 7 define the logical colour. But ALL combinations of bits 4 and 6 must also be
; set to make the change properly. e.g. to change logical colour 1 to physical colour 2:
;
;     LDA #$25
;     STA .videoULAPaletteRegister
;     LDA #$35
;     STA .videoULAPaletteRegister
;     LDA #$65
;     STA .videoULAPaletteRegister
;     LDA #$75
;     STA .videoULAPaletteRegister
;
; More OS friendly ways to set the palette are VDU 19; OSWORD 12 (which is faster than the
; VDU 19 sequence of calls and can be used in interrupts); or OSBYTE 155 (but this only writes
; to the ULA register once, so multiple calls are still needed as above).
;
; If using one of the OS friendly ways above to change the palette then the physical colours
; are:
;                 0 = black             8 = flashing black-white
;                 1 = red               9 = flashing red-cyan
;                 2 = green            10 = flashing green-magenta
;                 3 = yellow           11 = flashing yellow-blue
;                 4 = blue             12 = flashing blue-yellow
;                 5 = magenta          13 = flashing magenta-green
;                 6 = cyan             14 = flashing cyan-red
;                 7 = white            15 = flashing white-black
;
; If writing directly to .videoULAPaletteRegister ($FE21) then the values for the physical
; colour are different:
;
;      value to write = physical colour from table above EOR 7.
;
; ***************************************************************************************
.videoULAPaletteRegister                    = $FE21     ; Video ULA palette register

.romSelectRegister                          = $FE30     ;


; ***************************************************************************************
;
; System VIA, Register B ($FE40)
;
; Notes:
;     The bottom four bits are used for writing, and the top four bits are used for reading.
;     (See .systemVIADataDirectionRegisterB)
;
;     Values 0-15 can be written to System VIA Register B (Output):
;
;         Value   Effect
;         -------------------------
;         0       Enable sound chip
;         1       Enable Read Speech
;         2       Enable Write Speech
;         3       Disable Keyboard auto scanning
;         4       Hardware scrolling - set C0=0 (See below)
;         5       Hardware scrolling - set C1=0 (See below)
;         6       Turn on CAPS LOCK LED
;         7       Turn on SHIFT LOCK LED
;         8       Disable sound chip
;         9       Disable Read Speech
;         10      Disable Write Speech
;         11      Enable Keyboard auto scanning
;         12      Hardware scrolling - set C0=1 (See below)
;         13      Hardware scrolling - set C1=1 (See below)
;         14      Turn off CAPS LOCK LED
;         15      Turn off SHIFT LOCK LED
;
;  The values of C0 and C1 together determine the start scroll address for the screen:
;
;         C0   C1      Screen       Used in
;                      Address   Regular MODEs
;         ------------------------------------
;          0    0      $4000           3
;          0    1      $5800          4,5
;          1    0      $6000           6
;          1    1      $3000         0,1,2
;
; When reading from this address the top four bits are read:
;
; bit 7:    Speech processor 'ready' signal
; bit 6:    Speech processor 'interrupt' signal
; bit 4-5:  joystick buttons (bit is zero when button pressed)
;
; ***************************************************************************************
.systemVIARegisterB                         = $FE40     ; System VIA Register B (Input and Output)

; ***************************************************************************************
;
; System VIA, Register A ($FE41)
;
; This register is not used. The non-handshaking variant is used instead.
; See .systemVIADataDirectionRegisterA for details.
; ***************************************************************************************
.systemVIARegisterA                         = $FE41     ; System VIA Register A (Input and Output)

; ***************************************************************************************
;
; System VIA, Data Direction Register B ($FE42) (aka 'DDRB')
;
; When writing data into Register B (.systemVIARegisterB), the bits that are set on DDRB
; indicate which bits are actually written into Register B. The bits that are clear on DDRB
; are used to read from Register B.
;
; DDRB is only written once on startup where it is initialised to %00001111
; (see .setUpSystemVIA) and the OS expects it to remain that way. Only the bottom four bits
; of .systemVIARegisterB are used when writing, and only the upper four bits are read from
; .systemVIARegisterB. See .systemVIARegisterB.
;
; ***************************************************************************************
.systemVIADataDirectionRegisterB            = $FE42     ; System VIA data direction register B (DDRB)

; ***************************************************************************************
;
; System VIA, Data Direction Register A ($FE43) (aka 'DDRA')
;
; The keyboard, sound and speech systems use Data Direction Register A. Each bit of DDRA
; indicates whether data can be written or read on that bit when data is accessed via
; .systemVIARegisterANoHandshake. This is similar to DDRB. Unlike DDRB, the OS modifies
; DDRA frequently to set the appropriate bits for accessing the device (often in the IRQ
; interrupt code). Once set, data is read or written to .systemVIARegisterANoHandshake as
; needed. See .systemVIARegisterANoHandshake.
;
; Sound:    When outputting sound, DDRA is set to %11111111 meaning all bits of data
;           that are subsequently written to .systemVIARegisterANoHandshake are output bits.
;           (See .sendToSoundChipFlagsAreadyPushed)
;
; Speech:   For speech, DDRA is set to %00000000 (for reading) or %11111111 (for writing) as
;           needed. (See .readWriteSpeechProcessorPushedFlags)
;
; Keyboard: When reading the keyboard, DDRA is set to (%011111111). The key to read is written
;           into bits 0-6 of .systemVIARegisterANoHandshake, and the 'pressed' state of that
;           key is then read from bit 7.
;           (See .interrogateKeyboard)
;           (See .scanKeyboard)
;
; ***************************************************************************************
.systemVIADataDirectionRegisterA            = $FE43     ; System VIA data direction register A (DDRA)

; ***************************************************************************************
;
; System VIA, Timer 1 registers ($FE44-7)
;
; This is a 1Mhz countdown timer. An IRQ is triggered when the timer reaches zero. The OS
; uses this timer as a 100Hz timer to update various parts of the OS. It is expected to
; remain as a 100Hz timer if the OS is to continue working properly. User VIA Timers are
; available for user programs instead.
; See .irq1CheckSystemVIA100HzTimer.
;
; Timer 1 can be configured in one of two modes by writing to the ACR
; (see .systemVIAAuxiliaryControlRegister):
;
; One-shot mode:
;   .systemVIATimer1LatchLow and .systemVIATimer1CounterHigh form a 16 bit countdown value.
;   Write to .systemVIATimer1LatchLow first then writing to .systemVIATimer1CounterHigh
;   starts the timer. When the timer is complete a timer IRQ interrupt is generated. This
;   only happens once.
;
; Free-run mode (aka 'Continuous interrupts'):
;   .systemVIATimer1LatchLow and .systemVIATimer1LatchHigh are initialised to the initial
;   timeout value for the timer. The timer starts when .systemVIATimer1CounterHigh is
;   also written. Unlike one-shot mode, once the timeout interrupt has happened the counter
;   is reset to the values in the latches and the process repeats. The process can be stopped
;   by writing .systemVIATimer1CounterHigh, by reading .systemVIATimer1CounterLow, or by
;   writing to the interrupt flag.
;   This is the mode set by the OS for Timer 1 at startup. See .setUpPage2.
;
; ***************************************************************************************
.systemVIATimer1CounterLow                  = $FE44     ;
.systemVIATimer1CounterHigh                 = $FE45     ;
.systemVIATimer1LatchLow                    = $FE46     ;
.systemVIATimer1LatchHigh                   = $FE47     ;

; ***************************************************************************************
;
; System VIA, Timer 2 registers ($FE48-9)
;
; Timer 2 (like Timer 1) is a 1MHz countdown timer with an IRQ being generated when the
; counter reaches zero. It is used by the OS to update the Speech system if present. It also
; has two modes of operation, selected by writing to the ACR. (See .systemVIAAuxiliaryControlRegister).
;
; One-shot mode:
;   This is similar to Timer 1 (above). Write the low byte of the timer first
;   .systemVIATimer2CounterLow then writing to the high byte of the counter
;   .systemVIATimer2CounterHigh starts the timer. When the timer is countdown reaches zero
;   a timer IRQ interrupt is generated. This only happens once.
;
; Pulse counting mode:
;   This is unlike Timer 1. It counts down the number of negative going pulses applied to
;   System VIA input pin PB6. Firstly write to .systemVIATimer2CounterLow, then writing to
;   .systemVIATimer2CounterHigh will start the countdown. When PB6 is pulsed low for the
;   appropriate number of times then an IRQ interrupt occurs. This only happens once. This
;   is the default mode as initialised at startup.
;
; Timer 2 is started by the Speech system (if present) as needed to time Speech. The timer
; is cleared by the OS when a Timer 2 IRQ is received (see .irq1CheckSystemVIASpeech).
; It is also cleared at startup. See .setUpPage2.
; ***************************************************************************************
.systemVIATimer2CounterLow                  = $FE48     ;
.systemVIATimer2CounterHigh                 = $FE49     ;

; ***************************************************************************************
;
; The System VIA, Shift Register ($FE4A)
;
; This is not used in this OS. It is designed to be used for serial data I/O by shifting
; bits one at a time under the control of an internal modulo-8 counter.
; See NAUG Section 22.4.9, Page 395.
;
; ***************************************************************************************
.systemVIAShiftRegister                     = $FE4A     ;

; ***************************************************************************************
;
; System VIA, Auxiliary Control Register ($FE4B) (aka 'ACR')
;
; bit 0:    PA latch enable
; bit 1:    PB latch enable
; bits 2-4: Shift register mode
; bit 5:    Timer 2 mode: 0=One-shot mode; 1=Pulse counting mode.
; bit 6:    Enable pulsing of System VIA output pin PB7. When enabled, Timer 1 will set
;           PB7 as follows:
;           In One-shot mode:
;               PB7 is cleared when Timer 1 started,
;               PB7 is set when Timer 1 one-shot mode times out.
;           In Free-run mode:
;               PB7 is inverted when Timer 1 times out.
; bit 7:    Timer 1 mode: 0=One shot mode; 1=Free-run mode.
;
; In the reset code (see .setUpPage2) this register is initialised to:
;
;   (a) disable the latches and the shift register,
;   (b) set Timer 2 as an interval timer,
;   (c) set Timer 1 as free-run mode (aka continuous interrupts).
;
; Otherwise this register is not used by the OS.
;
; See NAUG Section 22.4.8, Page 395.
;
; ***************************************************************************************
.systemVIAAuxiliaryControlRegister          = $FE4B     ;

; ***************************************************************************************
;
; System VIA, Peripheral Control Register ($FE4C) (aka 'PCR')
;
; bit 0    = CA1 interrupt control
;            Writing to CA1 means "data taken"
;            0 means negative active edge
;            1 means positive active edge
;
; bits 1-3 = CA2 control mode
;            CA2 signifies "data ready"
;
; bit 4    = CB1 interrupt control
;            Writing to CB1 means "data taken"
;            0 means negative active edge
;            1 means positive active edge
;
; bits 5-7 = CB2 control mode
;            CB2 signifies "data ready"
;
; control mode:
;   000 = negative edges active on input
;   001 = independent interrupt; input negative edge
;   010 = positive edges active on input
;   011 = independent interrupt; input positive edge
;   100 = handshake output mode
;   101 = pulse output mode
;   110 = low output
;   111 = high output
;
; The System VIA PCR initialises like so (See .setUpPage2):
;       CA1 has negative active edge       (vertical sync)
;       CA2 positive edges active on input (keyboard)
;       CB1 has negative active edge       (end of analogue conversion)
;       CB2 negative active edges on input (light pen strobe)
; ***************************************************************************************
.systemVIAPeripheralControlRegister         = $FE4C     ;

; ***************************************************************************************
;
; System VIA, Interrupt Flag Register ($FE4D) (aka 'IFR')
;
;   bit 0 = key pressed interrupt
;   bit 1 = vertical sync occurred
;   bit 2 = shift register timeout (unused)
;   bit 3 = lightpen strobe off screen
;   bit 4 = analogue conversion completed
;   bit 5 = timer 2 has timed out (used for speech)
;   bit 6 = timer 1 has timed out (100Hz signal)
;   bit 7 = (when reading) master interrupt flag (0-6 invalid if clear)
;
; Used in interrupt code:
;
; Reading
; -------
; If bit 7 is set then the System VIA caused the current interrupt. The remaining bits can
; then be checked to see the exact cause.
;
; Writing
; -------
; Clear bit 7 and set a bit 0-6 to clear that interrupt.
;
; ***************************************************************************************
.systemVIAInterruptFlagRegister             = $FE4D     ;

; ***************************************************************************************
;
; System VIA, Interrupt Enable Register ($FE4E) (aka 'IER')
;
; Each bit controls whether an interrupt is enabled or disabled.
;
; bit 0 = key pressed interrupt
; bit 1 = vertical sync occurred
; bit 2 = shift register timeout (unused)
; bit 3 = light pen strobe off screen
; bit 4 = analogue conversion completed
; bit 5 = timer 2 timed out (used for speech)
; bit 6 = timer 1 timed out (100Hz signal)
; bit 7 = enable/disable interrupt value (see below)
;
; Writing:
; --------
; To enable  an interrupt, write a byte with the top bit set   and set the desired bit(s) (0-6).
; To disable an interrupt, write a byte with the top bit clear and set the desired bit(s) (0-6).
;
; Reading:
; --------
; Bits 0-6 are read as expected.
; Bit 7 is always set when read.
;
; ***************************************************************************************
.systemVIAInterruptEnableRegister           = $FE4E     ;

; See .systemVIADataDirectionRegisterA.
.systemVIARegisterANoHandshake              = $FE4F     ; System VIA Register A without handshaking

; ***************************************************************************************
;
; User VIA
;
; Port A is the (Centronics) parallel printer port (output only)
; Port B is the user port (input and output) (unused by the OS)
;
; See .openPrinterChannel for details of how to write to the printer.
;
; The data direction registers work as they do on the System VIA
; (see .systemVIADataDirectionRegisterB)
;
; The User VIA has Timer 1 and Timer 2. They work in the same way as the timers on the
; System VIA. These are not used by the OS so are available for user programs.
; See .systemVIATimer1CounterLow.
; See .systemVIATimer2CounterLow.
;
; The auxiliary control register works the same way as on the System VIA.
; See .systemVIAAuxiliaryControlRegister.
;
; The shift register is unused.
;
; ***************************************************************************************
.userVIARegisterB                           = $FE60     ; Register B (input/output)
.userVIARegisterA                           = $FE61     ; Register A (output)
.userVIADataDirectionRegisterB              = $FE62     ; data direction register B
.userVIADataDirectionRegisterA              = $FE63     ; data direction register A

.userVIATimer1CounterLow                    = $FE64     ; Timer 1 counter (low)
.userVIATimer1CounterHigh                   = $FE65     ; Timer 1 counter (high)
.userVIATimer1LatchLow                      = $FE66     ; Timer 1 latch (low)
.userVIATimer1LatchHigh                     = $FE67     ; Timer 1 latch (high)
.userVIATimer2CounterLow                    = $FE68     ; Timer 2 counter (low)
.userVIATimer2CounterHigh                   = $FE69     ; Timer 2 counter (high)

.userVIAShiftRegister                       = $FE6A     ; shift register
.userVIAAuxiliaryControlRegister            = $FE6B     ; auxiliary control register

; ***************************************************************************************
;
; User VIA, peripheral control register ($FE6C)
;
; This works the same as on the System VIA (See .systemVIAPeripheralControlRegister).
;
; The User VIA PCR initialises like so (See .setUpPage2):
;           CA1 interrupt on -ve edge     (usually printer Acknowledge)
;           CA2 high output               (usually printer strobe)
;           CB1 interrupt on -ve edge     (user port)
;           CB2 negative edge             (user port)
; ***************************************************************************************
.userVIAPeripheralControlRegister           = $FE6C     ; Peripheral control register

; ***************************************************************************************
;
; User VIA, interrupt flag register ($FE6D)
;
; Writing:
; To clear printer interrupts, clear bit 7 and set bit 1
;
; Reading:
; bit 7 set means the current interrupt is from the User VIA
; bit 1 set signifies a parallel printer interrupt.
; (See .irq1CheckUserVIA)
;
; ***************************************************************************************
.userVIAInterruptFlagRegister               = $FE6D     ; Interrupt flag register

; ***************************************************************************************
;
; User VIA, interrupt enable register ($FE6E)
;
; Writing:
; To disable printer interrupts, clear bit 7 and set bit 1
; To  enable printer interrupts,   set bit 7 and set bit 1
;
; Reading:
; bit 1 set signifies the printer interrupt is enabled.
; bit 7 is always set when reading.
; (See .irq1CheckUserVIA)
; ***************************************************************************************
.userVIAInterruptEnableRegister             = $FE6E     ; Interrupt enable register

; ***************************************************************************************
;
; User VIA, Register B no handshake ($FE6F)
;
; ***************************************************************************************
.userVIARegisterBNoHandshake                = $FE6F     ; Register B but no handshake

; ***************************************************************************************
;
; ADC 7002 - Analogue to digital conversion
;
; See .osbyte17EntryPoint
;
; ***************************************************************************************
.adcDataStatusRegister                      = $FEC0     ; For reading the current ADC
                                                        ; conversion state
.adcStartConversionRegister                 = $FEC0     ; For writing when we want to start
                                                        ; an ADC conversion
.adcDataHighByte                            = $FEC1     ; ADC (7002) high data byte
.adcDataLowByte                             = $FEC2     ; ADC (7002) low data byte

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 4: Character definitions and VDU tables
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Character definitions
;
; See font.png
;
; This is the start of the OS, located at $C000.
;
; The shape of each printable character (ASCII codes 32-126) is defined below. They are used
; to draw text in all non-teletext MODEs 0-6 (see .displayACharacter). Character 127 (DELETE)
; is not a printable character, but is given a definition here anyway as a solid block of set
; pixels. It's drawn in the background colour to erase the character at the graphics cursor.
;
; Characters already drawn can be read from the screen, to retrieve the ASCII code from the
; pattern of pixels on screen. The OS itself uses this when in cursor editing mode (the two
; cursor editing with READ and WRITE cursors, as seen in the BASIC line editor and user text
; input in general). See .osbyte135EntryPoint.
;
; Historical note: The BBC Micro was Acorn's first computer to contain a character set in
; ROM, unless you count the seven-segment LED settings for the hex digits 0 to F in the
; tiny Acorn System 1. The System 2 used teletext graphics akin to the BBC's Mode 7, and
; the Atom's rather smaller set of symbols (which lacked lower-case letters) were similarly
; generated directly in the video circuitry rather than being plotted from symbols in ROM.
;
; ***************************************************************************************
* = $C000

.characterDefinitions
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %........

    !byte %.##.##..
    !byte %.##.##..
    !byte %.##.##..
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %..##.##.
    !byte %..##.##.
    !byte %.#######
    !byte %..##.##.
    !byte %.#######
    !byte %..##.##.
    !byte %..##.##.
    !byte %........

    !byte %....##..
    !byte %..######
    !byte %.##.#...
    !byte %..#####.
    !byte %....#.##
    !byte %.######.
    !byte %...##...
    !byte %........

    !byte %.##.....
    !byte %.##..##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##..##.
    !byte %.....##.
    !byte %........

    !byte %..###...
    !byte %.##.##..
    !byte %.##.##..
    !byte %..###...
    !byte %.##.##.#
    !byte %.##..##.
    !byte %..###.##
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %........
    !byte %...##...
    !byte %.######.
    !byte %..####..
    !byte %.######.
    !byte %...##...
    !byte %........
    !byte %........

    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %..##....

    !byte %........
    !byte %........
    !byte %........
    !byte %.######.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %........
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %........
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.###.
    !byte %.######.
    !byte %.###.##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %...##...
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.....##.
    !byte %...###..
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %....##..
    !byte %...###..
    !byte %..####..
    !byte %.##.##..
    !byte %.######.
    !byte %....##..
    !byte %....##..
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.#####..
    !byte %.....##.
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %...###..
    !byte %..##....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.######.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %....##..
    !byte %..###...
    !byte %........

    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %..##....

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %........
    !byte %........
    !byte %.######.
    !byte %........
    !byte %.######.
    !byte %........
    !byte %........
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %....##..
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.###.
    !byte %.##.#.#.
    !byte %.##.###.
    !byte %.##.....
    !byte %..####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.######.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##.###.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.######.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %........

    !byte %..#####.
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %.##.##..
    !byte %..###...
    !byte %........

    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %.###....
    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %........

    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.##...##
    !byte %.###.###
    !byte %.#######
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.##...##
    !byte %.##...##
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.###.##.
    !byte %.######.
    !byte %.##.###.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##.#.#.
    !byte %.##.##..
    !byte %..##.##.
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.##..
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %..####..
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %........

    !byte %.##...##
    !byte %.##...##
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.#######
    !byte %.###.###
    !byte %.##...##
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %.######.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %........

    !byte %........
    !byte %.##.....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %.....##.
    !byte %........
    !byte %........

    !byte %..#####.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %..#####.
    !byte %........

    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %.#....#.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %########

    !byte %...###..
    !byte %..##.##.
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.....##.
    !byte %..#####.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.....##.
    !byte %.....##.
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.######.
    !byte %.##.....
    !byte %..####..
    !byte %........

    !byte %...###..
    !byte %..##....
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %........

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %..####..

    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %...##...
    !byte %........
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %..####..
    !byte %........

    !byte %...##...
    !byte %........
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.###....

    !byte %.##.....
    !byte %.##.....
    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %........

    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %..####..
    !byte %........

    !byte %........
    !byte %........
    !byte %..##.##.
    !byte %.#######
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.##...##
    !byte %........

    !byte %........
    !byte %........
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %........
    !byte %........
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %.....###

    !byte %........
    !byte %........
    !byte %.##.##..
    !byte %.###.##.
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##.....
    !byte %..####..
    !byte %.....##.
    !byte %.#####..
    !byte %........

    !byte %..##....
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %...###..
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %........

    !byte %........
    !byte %........
    !byte %.##...##
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.#######
    !byte %..##.##.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %..####..

    !byte %........
    !byte %........
    !byte %.######.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %...##...
    !byte %.###....
    !byte %...##...
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %...##...
    !byte %....###.
    !byte %...##...
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %..##...#
    !byte %.##.#.##
    !byte %.#...##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########

; ***************************************************************************************
;
; Screen initialisation on reset
;
; ***************************************************************************************
.vduBaseAddress
.initialiseScreenOnReset
    JMP .initialiseVDUVariablesAndSetMODE               ;

.vduChrEntryPointInternalJumper
    JMP .vduChrEntryPointInternal                       ;

.splitIntoTwoCursorsJumper
    JMP .splitIntoTwoCursors                            ;

.readCharacterFromScreenAndCursorRightJumper
    JMP .readCharacterFromScreenAndCursorRight          ;

.specialOSTableLookupJumper
    JMP .specialOSTableLookup                           ;

.getOrClearNumberOfBytesInVDUQueueJumper
    JMP .getOrClearNumberOfBytesInVDUQueue              ;


; ***************************************************************************************
;
; Table of addresses (low byte) to handle VDU N
;
; This table stores the low byte of the address of the routine to handle VDU n.
; It holds values for VDU 0-31 and 127.
;
; ***************************************************************************************
.vduEntryPointTableLow
    !byte <.vdu0EntryPoint                              ; Does nothing
    !byte <.vdu1EntryPoint                              ; Send next character to printer only
    !byte <.vdu2EntryPoint                              ; Enable printer
    !byte <.vdu3EntryPoint                              ; Disable printer
    !byte <.vdu4EntryPoint                              ; Write text at text cursor
    !byte <.vdu5EntryPoint                              ; Write text at graphics cursor
    !byte <.vdu6EntryPoint                              ; Enable VDU drivers
    !byte <.vdu7EntryPoint                              ; Make a short beep
    !byte <.vdu8EntryPoint                              ; Move cursor left
    !byte <.vdu9EntryPoint                              ; Move cursor right
    !byte <.vdu10EntryPoint                             ; Move cursor down
    !byte <.vdu11EntryPoint                             ; Move cursor up
    !byte <.vdu12EntryPoint                             ; Clear text window
    !byte <.vdu13EntryPoint                             ; Move cursor to start of current line
    !byte <.vdu14EntryPoint                             ; Paged mode on
    !byte <.vdu15EntryPoint                             ; Paged mode off
    !byte <.vdu16EntryPoint                             ; Clear graphics window
    !byte <.vdu17EntryPoint                             ; Define text colour
    !byte <.vdu18EntryPoint                             ; Define graphics colour
    !byte <.vdu19EntryPoint                             ; Change palette colour
    !byte <.vdu20EntryPoint                             ; Restore default palette
    !byte <.vdu21EntryPoint                             ; Disable VDU drivers / delete line
    !byte <.vdu22EntryPoint                             ; Select screen MODE
    !byte <.vdu23EntryPoint                             ; Define character shape (etc)
    !byte <.vdu24EntryPoint                             ; Define graphics window
    !byte <.vdu25EntryPoint                             ; PLOT
    !byte <.vdu26EntryPoint                             ; Restore default windows
    !byte <.vdu27EntryPoint                             ; Does nothing
    !byte <.vdu28EntryPoint                             ; Define text window
    !byte <.vdu29EntryPoint                             ; Define graphics origin
    !byte <.vdu30EntryPoint                             ; Move text cursor to top left
    !byte <.vdu31EntryPoint                             ; Move text cursor to X,Y
.vduEntryPointTableDelete
    !byte <.vdu127EntryPoint                            ; Delete

; ***************************************************************************************
;
; Table of addresses (high byte) to handle VDU N
;
; The previous table holds the lower byte.
; This table holds values for VDU 0-31 and 127.
;
; If parameters are required then the top bit is clear, (16 - number of parameters) is stored
; in the lower 4 bits, and the remaining three of the top four bits holds the high byte of
; the offset from .vduBaseAddress. We only have three bits to store the offset's high byte,
; so the offset must be less than $800. For this reason, VDU calls with parameters are stored
; near the start of the ROM.
;
; The top bit set indicates that no parameters are required, so the entry just holds the high
; byte of the address directly.
;
; ***************************************************************************************
.vduEntryPointTableHigh
    !byte >.vdu0EntryPoint                                      ; Does nothing
    !byte (>(.vdu1EntryPoint - .vduBaseAddress))*16 + 1         ; Send next character to
                                                                ; printer only (1 parameter)
    !byte >.vdu2EntryPoint                                      ; Enable printer
    !byte >.vdu3EntryPoint                                      ; Disable printer
    !byte >.vdu4EntryPoint                                      ; Write text at text cursor
    !byte >.vdu5EntryPoint                                      ; Write text at graphics cursor
    !byte >.vdu6EntryPoint                                      ; Enable VDU drivers
    !byte >.vdu7EntryPoint                                      ; Make a short beep
    !byte >.vdu8EntryPoint                                      ; Move cursor left
    !byte >.vdu9EntryPoint                                      ; Move cursor right
    !byte >.vdu10EntryPoint                                     ; Move cursor down
    !byte >.vdu11EntryPoint                                     ; Move cursor up
    !byte >.vdu12EntryPoint                                     ; Clear text area
    !byte >.vdu13EntryPoint                                     ; Move cursor to start of
                                                                ; current line
    !byte >.vdu14EntryPoint                                     ; Paged mode on
    !byte >.vdu15EntryPoint                                     ; Paged mode off
    !byte >.vdu16EntryPoint                                     ; Clear graphics window
    !byte (>(.vdu17EntryPoint - .vduBaseAddress))*16 + 1        ; Define text colour
                                                                ; (1 parameter)
    !byte (>(.vdu18EntryPoint - .vduBaseAddress))*16 + 2        ; Define graphics colour
                                                                ; (2 parameters)
    !byte (>(.vdu19EntryPoint - .vduBaseAddress))*16 + 5        ; Define palette colour
                                                                ; (5 parameters)
    !byte >.vdu20EntryPoint                                     ; Restore default palette
    !byte >.vdu21EntryPoint                                     ; Disable VDU drivers /
                                                                ; delete current line
    !byte (>(.vdu22EntryPoint - .vduBaseAddress))*16 + 1        ; Select screen MODE
                                                                ; (1 parameter)
    !byte (>(.vdu23EntryPoint - .vduBaseAddress))*16 + 9        ; Define character shape (etc)
                                                                ; (9 parameters)
    !byte (>(.vdu24EntryPoint - .vduBaseAddress))*16 + 8        ; Define graphics window
                                                                ; (8 parameters)
    !byte (>(.vdu25EntryPoint - .vduBaseAddress))*16 + 5        ; PLOT (5 parameters)
    !byte >.vdu26EntryPoint                                     ; Restore default windows
    !byte >.vdu27EntryPoint                                     ; Does nothing
    !byte (>(.vdu28EntryPoint - .vduBaseAddress))*16 + 4        ; Define text window
                                                                ; (4 parameters)
    !byte (>(.vdu29EntryPoint - .vduBaseAddress))*16 + 4        ; Define graphics origin
                                                                ; (4 parameters)
    !byte >.vdu30EntryPoint                                     ; Move text cursor to top left
    !byte (>(.vdu31EntryPoint - .vduBaseAddress))*16 + 2        ; Move text cursor to X,Y
                                                                ; (2 parameters)
    !byte >.vdu127EntryPoint                                    ; Delete

; ***************************************************************************************
;
; Multiplication tables
;
; Used for calculating screen addresses
;
; ***************************************************************************************
.multiplyBy640Table
    !word 0 * 640
    !word 1 * 640
    !word 2 * 640
    !word 3 * 640
    !word 4 * 640
    !word 5 * 640
    !word 6 * 640
    !word 7 * 640
    !word 8 * 640
    !word 9 * 640
    !word 10 * 640
    !word 11 * 640
    !word 12 * 640
    !word 13 * 640
    !word 14 * 640
    !word 15 * 640
    !word 16 * 640
    !word 17 * 640
    !word 18 * 640
    !word 19 * 640
    !word 20 * 640
    !word 21 * 640
    !word 22 * 640
    !word 23 * 640
    !word 24 * 640
    !word 25 * 640
    !word 26 * 640
    !word 27 * 640
    !word 28 * 640
    !word 29 * 640
    !word 30 * 640
    !word 31 * 640

.multiplyBy320Table
    !word 0 * 320
    !word 1 * 320
    !word 2 * 320
    !word 3 * 320
    !word 4 * 320
    !word 5 * 320
    !word 6 * 320
    !word 7 * 320
    !word 8 * 320
    !word 9 * 320
    !word 10 * 320
    !word 11 * 320
    !word 12 * 320
    !word 13 * 320
    !word 14 * 320
    !word 15 * 320
    !word 16 * 320
    !word 17 * 320
    !word 18 * 320
    !word 19 * 320
    !word 20 * 320
    !word 21 * 320
    !word 22 * 320
    !word 23 * 320
    !word 24 * 320
    !word 25 * 320
    !word 26 * 320
    !word 27 * 320
    !word 28 * 320
    !word 29 * 320
    !word 30 * 320
    !word 31 * 320

.multiplyBy40Table
    !word 0 * 40
    !word 1 * 40
    !word 2 * 40
    !word 3 * 40
    !word 4 * 40
    !word 5 * 40
    !word 6 * 40
    !word 7 * 40
    !word 8 * 40
    !word 9 * 40
    !word 10 * 40
    !word 11 * 40
    !word 12 * 40
    !word 13 * 40
    !word 14 * 40
    !word 15 * 40
    !word 16 * 40
    !word 17 * 40
    !word 18 * 40
    !word 19 * 40
    !word 20 * 40
    !word 21 * 40
    !word 22 * 40
    !word 23 * 40
    !word 24 * 40

; ***************************************************************************************
;
; Screen MODE dimensions
;
; The maximum text row and column number in each MODE.
;
; ***************************************************************************************
.textWindowBottomRowTable                               ; Maximum text row number
    !byte 31                                            ; MODE 0 (32 rows)
    !byte 31                                            ; MODE 1 (32 rows)
    !byte 31                                            ; MODE 2 (32 rows)
    !byte 24                                            ; MODE 3 (25 rows)
    !byte 31                                            ; MODE 4 (32 rows)
    !byte 31                                            ; MODE 5 (32 rows)
    !byte 24                                            ; MODE 6 (25 rows)
    !byte 24                                            ; MODE 7 (25 rows)

.textWindowRightColumnTable                             ; Maximum text column number
    !byte 79                                            ; MODE 0 (80 columns)
    !byte 39                                            ; MODE 1 (40 columns)
    !byte 19                                            ; MODE 2 (20 columns)
    !byte 79                                            ; MODE 3 (80 columns)
    !byte 39                                            ; MODE 4 (40 columns)
    !byte 19                                            ; MODE 5 (20 columns)
    !byte 39                                            ; MODE 6 (40 columns)
    !byte 39                                            ; MODE 7 (40 columns)

; ***************************************************************************************
;
; Video Control Register of the VideoULA
;
; bit
;   0 - Flash colour select (which of the flashing colours is displayed)
;   1 - Teletext select
;   2 - } These two bits determine the number of characters per row
;   3 - } from this table:
;       %00 = 10 characters per row
;       %01 = 20 characters per row
;       %10 = 40 characters per row
;       %11 = 80 characters per row
;   4 - CRTC clock rate select:
;        %0 = low frequency clock for MODEs 4-7
;        %1 = high frequency clock for MODEs 0-3
;   5 - } These two bits determine the width of cursor in bytes
;   6 - } from this table:
;       %00 = 1 (MODEs 0,3,4,6)
;       %01 = - undefined
;       %10 = 2 (MODEs 1,5,7)
;       %11 = 4 (MODE 2)
;   7 - Master cursor width. If set, causes a larger cursor to be displayed
;
; ***************************************************************************************
.videoULAVideoControlRegisterDefaultValuesPerMODE
    !byte %10011100                                     ; MODE 0
    !byte %11011000                                     ; MODE 1
    !byte %11110100                                     ; MODE 2
    !byte %10011100                                     ; MODE 3
    !byte %10001000                                     ; MODE 4
    !byte %11000100                                     ; MODE 5
    !byte %10001000                                     ; MODE 6
    !byte %01001011                                     ; MODE 7

.numberOfColoursMinusOneInMODETable
    !byte 1                                             ; MODE 0
    !byte 3                                             ; MODE 1
    !byte 15                                            ; MODE 2
    !byte 1                                             ; MODE 3
    !byte 1                                             ; MODE 4
    !byte 3                                             ; MODE 5
    !byte 1                                             ; MODE 6
    !byte 0                                             ; MODE 7

.pixelsPerByteMinusOneInMODETable
    !byte 7                                             ; MODE 0
    !byte 3                                             ; MODE 1
    !byte 1                                             ; MODE 2
    !byte 0                                             ; MODE 3
    !byte 7                                             ; MODE 4
    !byte 3                                             ; MODE 5
    !byte 0                                             ; MODE 6
    !byte 0                                             ; MODE 7

.bytesPerCharacter
    !byte 8                                             ; MODE 0
    !byte 16                                            ; MODE 1
    !byte 32                                            ; MODE 2
    !byte 8                                             ; MODE 3
    !byte 8                                             ; MODE 4
    !byte 16                                            ; MODE 5
    !byte 8                                             ; MODE 6
    !byte 1                                             ; MODE 7

; This table describes how much memory each MODE takes
.screenDisplayMemoryIndexTable
    !byte 0                                             ; MODE 0
    !byte 0                                             ; MODE 1
    !byte 0                                             ; MODE 2
    !byte 1                                             ; MODE 3
    !byte 2                                             ; MODE 4
    !byte 2                                             ; MODE 5
    !byte 3                                             ; MODE 6
    !byte 4                                             ; MODE 7

; ***************************************************************************************
;
; Hardware scroll tables
;
; Stores which System VIA Register B registers to write, see .systemVIARegisterB
;
; ***************************************************************************************
.systemVIAHardwareScrollTable2
; Which System VIA register to write to set the hardware scrolling, for each MODE group.
    !byte 4                                             ; 20k (MODE 0,1,2)
    !byte 4                                             ; 16k (MODE 3)
    !byte 12                                            ; 10k (MODE 4,5)
    !byte 12                                            ; 8k  (MODE 6)
    !byte 4                                             ; 1k  (MODE 7)

; Which System VIA register to write to set the hardware scrolling, for each MODE group.
.systemVIAHardwareScrollTable1                          ;
    !byte 13                                            ; 20k (MODE 0,1,2)
    !byte 5                                             ; 16k (MODE 3)
    !byte 13                                            ; 10k (MODE 4,5)
    !byte 5                                             ; 8k  (MODE 6)
    !byte 4                                             ; 1k  (MODE 7)

; Low byte of the address to clear the screen in each MODE group
.clearScreenRoutineEntryPointLow
    !byte <.clearScreenRoutineEntryPointMODE012         ; MODE 0,1,2
    !byte <.clearScreenRoutineEntryPointMODE3           ; MODE 3
    !byte <.clearScreenRoutineEntryPointMODE45          ; MODE 4,5
    !byte <.clearScreenRoutineEntryPointMODE6           ; MODE 6
    !byte <.clearScreenRoutineEntryPointMODE7           ; MODE 7

; High byte of the address to clear the screen in each MODE group
.clearScreenRoutineEntryPointHigh
    !byte >.clearScreenRoutineEntryPointMODE012         ; MODE 0,1,2
    !byte >.clearScreenRoutineEntryPointMODE3           ; MODE 3
    !byte >.clearScreenRoutineEntryPointMODE45          ; MODE 4,5
    !byte >.clearScreenRoutineEntryPointMODE6           ; MODE 6
    !byte >.clearScreenRoutineEntryPointMODE7           ; MODE 7

; screen size (high byte) for each MODE group
.screenMemorySizeInBytesHigh
    !byte $50                                           ; MODEs 0,1,2 ($5000 = 20k)
    !byte $40                                           ; MODE  3     ($4000 = 16k)
    !byte $28                                           ; MODEs 4,5   ($2800 = 10k)
    !byte $20                                           ; MODE  6     ($2000 = 8k)
    !byte $04                                           ; MODE  7     ($0400 = 1k)

; screen start address (high byte) for each MODE group
.screenMemoryStartHigh
    !byte $30                                           ; MODEs 0,1,2 ($3000)   %00110000
    !byte $40                                           ; MODE  3     ($4000)   %01000000
    !byte $58                                           ; MODEs 4,5   ($5800)   %01011000
    !byte $60                                           ; MODE  6     ($6000)   %01100000
    !byte $7C                                           ; MODE  7     ($7C00)   %01111100

.multiplyTableIndex
    !byte 0,0,1,1,2                 ; given a mode group, work out which multiplication table to use

; number of bytes in each row
.bytesPerRowLow
    !byte <640                                          ; MODEs 0,1,2,3
    !byte <320                                          ; MODEs 4,5,6
    !byte <40                                           ; MODE 7
.bytesPerRowHigh
    !byte >640                                          ; MODEs 0,1,2,3
    !byte >320                                          ; MODEs 4,5,6
    !byte >40                                           ; MODE 7

.multiplicationTabletoUseLow
    !byte <.multiplyBy640Table                          ; MODEs 0,1,2,3
    !byte <.multiplyBy320Table                          ; MODEs 4,5,6
    !byte <.multiplyBy40Table                           ; MODE 7

.multiplicationTabletoUseHigh
    !byte >.multiplyBy640Table                          ; MODEs 0,1,2,3
    !byte >.multiplyBy320Table                          ; MODEs 4,5,6
    !byte >.multiplyBy40Table                           ; MODE 7

; ***************************************************************************************
;
; Solid colour tables
;
; The following tables hold the byte values required to write a full solid byte of COLOUR N
; on screen (N being the offset into the table). One table for the 2 colour MODEs, one for
; 4 colour MODEs, and one for 16 colour MODEs.
; See .vdu18EntryPoint.
;
; ***************************************************************************************
.twoColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %11111111                                     ;

.fourColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %00001111                                     ;
    !byte %11110000                                     ;
    !byte %11111111                                     ;

.sixteenColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %00000011                                     ;
    !byte %00001100                                     ;
    !byte %00001111                                     ;
    !byte %00110000                                     ;
    !byte %00110011                                     ;
    !byte %00111100                                     ;
    !byte %00111111                                     ;
    !byte %11000000                                     ;
    !byte %11000011                                     ;
    !byte %11001100                                     ;
    !byte %11001111                                     ;
    !byte %11110000                                     ;
    !byte %11110011                                     ;
    !byte %11111100                                     ;
    !byte %11111111                                     ;


; ***************************************************************************************
;
; Four colour conversion table
;
; Used when drawing characters to the screen. The index into the table is a pattern of four
; bits (%0000-%1111) representing half of the eight bit text character row definition. The
; value of the array entry is the byte value required to write that pattern of white pixels
; on screen.
;
; ***************************************************************************************
.fourColourMODEByteMaskTable
    !byte $00, $11, $22, $33, $44, $55, $66, $77
    !byte $88, $99, $AA, $BB, $CC, $DD, $EE, $FF

; ***************************************************************************************
;
; Sixteen colour conversion table
;
; Used when drawing characters to the screen. The index into the table is a pattern of two
; bits (%00-%11) representing a quarter of the eight bit text character row definition. The
; value of the array entry is the byte value required to write that pattern of white pixels
; on screen.
;
; ***************************************************************************************
.sixteenColourMODEByteMaskTable
    !byte $00, $55, $AA, $FF

; Offset to CRTC cursor end register in each MODE group
.crtcCursorEndRegisterTable
    !byte .crtcMODEs012CursorEndRegister - .crtcRegisters0to11ForMODEs012   ; MODEs 0,1,2
    !byte .crtcMODE3CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  3
    !byte .crtcMODE45CursorEndRegister   - .crtcRegisters0to11ForMODEs012   ; MODEs 4,5
    !byte .crtcMODE6CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  6
    !byte .crtcMODE7CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  7

; default CRTC register values
.crtcRegisters0to11ForMODEs012
    !byte 127                                           ; R0 = Horizontal total register
    !byte 80                                            ; R1 = Horizontal displayed register
    !byte 98                                            ; R2 = Horizontal sync position register
    !byte $88                                           ; R3 = The sync width register
    !byte 38                                            ; R4 = Vertical total register
    !byte 0                                             ; R5 = Vertical total adjust register
    !byte 32                                            ; R6 = Vertical displayed register (number of visible character rows)
    !byte 35                                            ; R7 = Vertical sync position
    !byte %00000001                                     ; R8 = Interlace and delay register
    !byte 7                                             ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODEs012CursorEndRegister
    !byte 8                                             ; R11 = The cursor end register

.crtcRegisters0to11ForMODE3
    !byte 127                                           ; R0 = Horizontal total register
    !byte 80                                            ; R1 = Horizontal displayed register
    !byte 98                                            ; R2 = Horizontal sync position register
    !byte $88                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1C                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $09                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE3CursorEndRegister
    !byte $09                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODEs45
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $31                                           ; R2 = Horizontal sync position register
    !byte $44                                           ; R3 = The sync width register
    !byte $26                                           ; R4 = Vertical total register
    !byte $00                                           ; R5 = Vertical total adjust register
    !byte $20                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $23                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $07                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE45CursorEndRegister
    !byte $08                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODE6
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $31                                           ; R2 = Horizontal sync position register
    !byte $44                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1C                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $09                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE6CursorEndRegister
    !byte $09                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODE7
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $33                                           ; R2 = Horizontal sync position register
    !byte $44                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1C                                           ; R7 = Vertical sync position
    !byte $93                                           ; R8 = Interlace and delay register
    !byte $12                                           ; R9 = Scan lines per character
    !byte $72                                           ; R10 = Cursor start register
.crtcMODE7CursorEndRegister
    !byte $13                                           ; R11 = The cursor end register

; ***************************************************************************************
;
; Pixel tables
;
; A 16 colour MODE (MODE 2) has two pixels per byte. The first table gives the byte
; values required to set each pixel in a byte to white (leaving the remainder black).
; The second table is the equivalent for four colour MODEs (four pixels per byte).
; The third table is the equivalent for two colour MODEs (eight pixels per byte, dual use
; with .fontMaskTable)
;
; ***************************************************************************************
.sixteenColourMODEMaskTable
    !byte %10101010, %01010101                          ; 2 pixels per byte (MODE 2)

.fourColourMODEMaskTable
    !byte %10001000, %01000100, %00100010, %00010001    ; 4 pixels per byte (MODE 1 or 5)

.fontMaskTable                                          ; 8 pixels per byte (MODE 0 or 4)
     ; This array is dual purpose - used both as the 8 pixels per byte MODE mask table and
     ; also to interrogate a particular bit in the vduFontByte.
     !byte $80, $40, $20, $10, $08, $04, $02, $01

; ***************************************************************************************
;
; VDU Line Plotting
;
; ***************************************************************************************
.vduPlotLineRoutineAddressesLow
    !byte <.plotLineMoveToNextRowUp                     ; if Y axis is dominant, move up
    !byte <.plotLineMoveToNextRowDown                   ; if Y axis is dominant, move down
    !byte <.plotLineMoveToNextColumnRight               ; if X axis is dominant, move right
    !byte <.plotLineMoveToNextColumnLeft                ; if X axis is dominant, move left

.vduPlotLineRoutineAddressesHigh
    !byte >.plotLineMoveToNextRowUp                     ; if Y axis is dominant, move up
    !byte >.plotLineMoveToNextRowDown                   ; if Y axis is dominant, move down
    !byte >.plotLineMoveToNextColumnRight               ; if X axis is dominant, move right
    !byte >.plotLineMoveToNextColumnLeft                ; if X axis is dominant, move left

.vduRoutineBranchVectorAddressesLow
    !byte <.plotLineDominantXAxisSameSign               ;
    !byte <.plotLineDominantXAxisDifferentSign          ;
    !byte <.plotLineDominantYAxisSameSign               ;
    !byte <.plotLineDominantYAxisDifferentSign          ;

.vduRoutineBranchVectorAddressesHigh
    !byte >.plotLineDominantXAxisSameSign               ;
    !byte >.plotLineDominantXAxisDifferentSign          ;
    !byte >.plotLineDominantYAxisSameSign               ;
    !byte >.plotLineDominantYAxisDifferentSign          ;


; Table of offsets into the VDU variables, used when line plotting
.vduGraphicsWindowBoundariesTable
    !byte .vduGraphicsWindowPixelsTopHigh - .vduVariablesStart3     ; } graphics window edges
    !byte .vduGraphicsWindowPixelsBottomHigh - .vduVariablesStart3  ; } variables of the
    !byte .vduGraphicsWindowPixelsRightHigh - .vduVariablesStart3   ; } offsets into the VDU
    !byte .vduGraphicsWindowPixelsLeftHigh - .vduVariablesStart3    ; }

; ***************************************************************************************
; This table is used when setting .vduGraphicsColourByteOR and .vduGraphicsColourByteEOR
; in .setGraphicsColourMaskXY. This table is used to help implement the GCOL Mode.
;
; GCOL Mode: 0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert
;
; See .setGraphicsColourMaskXY
.gcolPlotOptionsTable
    !byte $FF                                           ; 0=Normal
    !byte $00                                           ; 1=OR
    !byte $00                                           ; 2=AND
    !byte $FF                                           ; 3=EOR
    !byte $FF                                           ; 4=Invert

    !byte $00                                           ; 0=Normal
    !byte $00                                           ; 1=OR
    !byte $FF                                           ; 2=AND
    !byte $FF                                           ; 3=EOR
    !byte $FF                                           ; 4=Invert

    !byte $00                                           ; 0=Normal
    !byte $FF                                           ; 1=OR
    !byte $00                                           ; 2=AND
    !byte $00                                           ; 3=EOR
    !byte $FF                                           ; 4=Invert

    !byte $FF                                           ; 0=Normal
    !byte $FF                                           ; 1=OR
    !byte $FF                                           ; 2=AND
    !byte $00                                           ; 3=EOR
    !byte $00                                           ; 4=Invert

; ***************************************************************************************
;
; Converting characters in Teletext
;
; See teletext.png
;
; Writing printable characters (32-126) directly to the display memory in MODE 7
; gives different results in three cases to printing via OSWRCH. In particular:
;
; Value     Write to Screen     Write to screen
;           Memory Directly       via OSWRCH
; ----------------------------------------------
;   $23           £                   #
;   $5F           #                   long dash
;   $60           long dash           £
; ----------------------------------------------
;
; ***************************************************************************************
.teletextCharacterConversionTable
    !byte $23                                           ; when writing a character in MODE 7,
                                                        ; replace each byte here with the next
                                                        ; in the table
    !byte $5F                                           ; when reading the character from the
                                                        ; screen, replace each byte with the
                                                        ; previous in the table
    !byte $60                                           ;
    !byte $23                                           ;

; ***************************************************************************************
; Page numbers for storing ranges of soft character definitions
.defaultFontZones
    !byte $15                                           ;
    !byte $14                                           ;
    !byte $13                                           ;
    !byte $12                                           ;
    !byte $11                                           ;
    !byte $10                                           ;
    !byte $0C                                           ;

; ***************************************************************************************
    !byte $01                                           ; [unused]
    !byte $03                                           ; [unused]
    !byte $07                                           ; [unused]
    !byte $00                                           ; [unused]
    !byte $03                                           ; [unused]
    !byte $07                                           ; [unused]

; ***************************************************************************************
.specialOSTableLow
    !byte <.osbyte132EntryPoint                         ;
    !byte <.osbyte133EntryPoint                         ;
    !byte <.osbyte134EntryPoint                         ;
    !byte <.osbyte135EntryPoint                         ;
    !byte <.osbyte136EntryPoint                         ;
    !byte <.osword9EntryPoint                           ;
    !byte <.osword10EntryPoint                          ;
    !byte <.osword11EntryPoint                          ;
    !byte <.osword12EntryPoint                          ;

; ***************************************************************************************
.specialOSTableHigh
    !byte >.osbyte132EntryPoint                         ;
    !byte >.osbyte133EntryPoint                         ;
    !byte >.osbyte134EntryPoint                         ;
    !byte >.osbyte135EntryPoint                         ;
    !byte >.osbyte136EntryPoint                         ;
    !byte >.osword9EntryPoint                           ;
    !byte >.osword10EntryPoint                          ;
    !byte >.osword11EntryPoint                          ;
    !byte >.osword12EntryPoint                          ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 5: VDU and OSWORD routines
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Note about the BBC Micro Character Set (it's almost, but not quite 7-bit ASCII)
;
; ***************************************************************************************
; One of the main tasks for OSWRCH is to draw characters to the screen. The VDUCHR routine
; performs this job. In particular, with A in the range 32-126 these are the 'printable'
; characters. They result in a visual character appearing on screen. They almost match the
; standard 7-bit ASCII character set. The exception being ASCII CODE 96 '`' (GRAVE ACCENT)
; which is not available. When this code is used with OSWRCH, a pound sign '£' is displayed
; instead. For character definitions, see Chapter 4.
;
; Additionally, MODE 7 (the TELETEXT mode) has a different character set from ASCII, which
; means 10 of the ASCII printable characters can't be displayed. Substitutions are made
; as follows:
;
;     ASCII CODE 91  '[' is displayed as an arrow pointing left
;     ASCII CODE 92  '\' is displayed as the fraction 1/2
;     ASCII CODE 93  ']' is displayed as an arrow pointing right
;     ASCII CODE 94  '^' is displayed as an arrow pointing up
;     ASCII CODE 95  '_' is displayed as a dash
;     ASCII CODE 96  '`' is displayed as a pound sign
;     ASCII CODE 123 '{' is displayed as the fraction 1/4
;     ASCII CODE 124 '|' is displayed as a double vertical bar
;     ASCII CODE 125 '}' is displayed as the fraction 3/4
;     ASCII CODE 126 '~' is displayed as the divide symbol
;
; Note that when writing directly to the display memory in MODE 7 this gives different
; results in three cases to printing via OSWRCH. See .teletextCharacterConversionTable
;
; The character being output is interpreted as below:
;
; Character Range   Description
;   0-31            Control characters, which are interpreted as a whole range of special
;                   commands. Multiple bytes may need to be output to complete the
;                   command. Each VDU command is described at it's own entry point
;                   which are listed in a table (See .vduEntryPointTableLow).
;   32-126          Printable ASCII(-ish) characters as described above.
;   127             Delete character. Attempts to remove the previous printed character
;                   from the screen at the text or graphics cursor (whichever is active).
;   128-255         Available for users programs as soft characters (see .osbyte20EntryPoint).
;                   In MODE 7 these control the appearance of Teletext characters.
;
; ***************************************************************************************
;
; VDUCHR entry point
;
; This is a limited version of OSWRCH that assumes output is to the display only, not to
; Econet, the printer, RS-423, nor SPOOLed to a file. It assumes the VDU drivers are enabled.
;
; ***************************************************************************************
.vduChrEntryPointInternal
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ; get the number of items in the VDU queue
    BNE .vduParametersAreOutstanding                    ; if (parameters are still needed) then branch
    BIT .vduStatusByte                                  ; test VDU status byte
    BVC +                                               ; if (cursor editing mode is NOT active) then branch forward

    ; handle cursor editing mode...
    JSR .exchangeTextCursorAndInputCursorValues         ; temporarily swap the text cursor and input cursor coordinates
    JSR .setUpWriteCursor                               ; set up write cursor
    BMI +                                               ; if (display is disabled) then branch forward
    CMP .endTextEntryCharacter                          ; Normally RETURN?
    BNE +                                               ; if (character is not RETURN) then branch forward
    JSR .terminateEdit                                  ; terminate editing

+
    JSR .checkForNonPrintableCharacter                  ;
    BCS ++                                              ;
    CMP #.charDELETE                                    ;
    BNE +                                               ; if (character is not DELETE) then branch
    LDA #.charSPACE                                     ;
+
    TAY                                                 ; store the VDU number in Y
    LDA .vduEntryPointTableLow,Y                        ; get low byte of entry point address
    STA .vduJumpVectorLow                               ; store it in jump vector
    LDA .vduEntryPointTableHigh,Y                       ; get high byte of entry point address
    BMI .explicitAddressNoParameters                    ; if (a direct access with no parameters) then branch
    TAX                                                 ; X=A
    AND #%00001111                                      ; set up negated parameter count (set bits in top nybble)
    STA .twosComplimentOfNumberOfBytesInVDUQueue        ; store it back as number of items in VDU queue
    TXA                                                 ; get back A
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } get high nybble into low nybble
    LSR                                                 ; }
    CLC                                                 ; clear carry
    ADC #>.vduBaseAddress                               ; add base address (high byte) to get high byte of VDU entry point address
    STA .vduJumpVectorHigh                              ;
    BIT .vduStatusByte                                  ; check for cursor editing mode enabled
    BVC +
    JSR .restoreWriteCursor                             ;
    JSR .exchangeTextCursorAndInputCursorValues         ;
+
.clearCarryAndExit3
    CLC                                                 ;
    ; fall through...

; ***************************************************************************************
;
;   VDU 0 / 6 / 27      Empty handlers
;
;   VDU 0  - Does nothing
;   VDU 6  - Enable VDU drivers (re-enabling is handled prior to here, see .checkForVDUReenable)
;   VDU 27 - ESCAPE code, does nothing
;
; ***************************************************************************************
.vdu0EntryPoint
.vdu6EntryPoint
.vdu27EntryPoint
.exit
    RTS                                                 ;

++
    BIT .vduStatusByte                                  ; test VDU status byte again
    BMI .exitVDUCHR                                     ; if (screen disabled) then branch forward
    JSR .displayACharacter                              ; display a character
    JSR .vdu9EntryPoint                                 ; and cursor right
+
    JMP .exitVDUCHR                                     ;

; ***************************************************************************************
.vduParametersAreOutstanding
    DEX
    STA .vduQueueStartByte,X                            ; store parameter in vdu queue
                                                        ; (X = number of parameters - 1)
    STX .twosComplimentOfNumberOfBytesInVDUQueue        ; store it as number of bytes in VDU queue (2's complement)
    BNE .clearCarryAndExit                              ; if (more parameters are needed) then branch
    BIT .vduStatusByte                                  ; test VDU status byte
    BMI .preVDU1                                        ; if (VDU disabled) then branch to VDU 1 code
    BVS .handleCursorEditing                            ; if (cursor editing mode) then branch
    JSR .executeRequiredVDUFunction                     ; execute required function for VDU command
    CLC                                                 ; clear carry
    RTS                                                 ;

.handleCursorEditing
    JSR .exchangeTextCursorAndInputCursorValues         ; swap values of cursors
    JSR .setUpWriteCursor                               ; set up write cursor
    JSR .executeRequiredVDUFunction                     ; execute required function for VDU command
.reexchangeCursorsAndExit
    JSR .restoreWriteCursor                             ;
    JSR .exchangeTextCursorAndInputCursorValues         ;
.clearCarryAndExit
    CLC                                                 ; carry clear
    RTS                                                 ;

.preVDU1
    LDY .vduJumpVectorHigh                              ; check the upper byte of entry point address
    CPY #>.vdu1EntryPoint                               ; check for the default handler
    BNE .clearCarryAndExit                              ; if (not the default handler) then branch (exit)

; ***************************************************************************************
;
;   VDU 1       Send next byte to printer only
;
; ***************************************************************************************
.vdu1EntryPoint
    LDA .vduQueueStartByte                              ;
    JMP .sendValidByteToPrinterJumper                   ;


; ***************************************************************************************
.explicitAddressNoParameters
    BIT .vduStatusByte                                  ; test VDU status byte
    BMI .checkForVDUReenable                            ; if (VDU disabled) then branch
    STA .vduJumpVectorHigh                              ; upper byte of link address
    TYA                                                 ; restore A (the VDU number)

    ; set carry if VDU number is within range 8-13 (cursor movement)
    CMP #8                                              ;
    BCC +                                               ; if (VDU number < 8) then branch (carry clear)
    EOR #$FF                                            ; invert value
    CMP #$F2                                            ; if (VDU number > 13) then clear carry
    EOR #$FF                                            ; re-invert value back again

+
    PHP                                                 ; push flags
    JSR .executeRequiredVDUFunction                     ; execute required function
    PLP                                                 ; pull flags back
    BCC +                                               ; if (not VDU 8-13 cursor movement) then branch (skip 'printer enabled' check)
    ; fall through...

; ***************************************************************************************
.exitVDUCHR
    LDA .vduStatusByte                                  ; read VDU status byte
    LSR                                                 ; carry is set if printer is enabled
+
    BIT .vduStatusByte                                  ; test VDU status byte
    BVC .exit                                           ; if (no cursor editing mode) then branch
    ; fall through...

; ***************************************************************************************
.reswapCursorsBack
    JSR .restoreWriteCursor                             ; restore normal write cursor
    JMP .exchangeTextCursorAndInputCursorValues         ;

; ***************************************************************************************
.checkForVDUReenable
    CPY #6                                              ; check for VDU 6 (to reenable output to the display)
    BNE .clearCarryAndExit3                             ; if (not VDU 6) then branch (exit)
    LDA #%01111111                                      ; set A to clear the top bit of the VDU status byte
    CLC                                                 ;
    BCC .clearVDUStatusByteFlags                        ; ALWAYS branch, clearing the top bit (enabling output to the display again)
    ; fall through...

; ***************************************************************************************
.executeRequiredVDUFunction
    JMP (.vduJumpVectorLow)                             ;

; ***************************************************************************************
.checkForNonPrintableCharacter
    CMP #.charDELETE                                    ;
    BNE +                                               ; if (not DELETE) then branch
    CLC                                                 ; DELETE is non printable, clear carry
    RTS                                                 ;

+
    CMP #.charSPACE                                     ; clear carry for any character below SPACE
    RTS                                                 ; these are control codes, non printable.

; ***************************************************************************************
;
; Check whether the text or graphics cursor is active
;
; On Exit:
;    A = 0   if text cursor is active           (Z flag set)
;    A = $20 otherwise (graphics cursor active) (Z flag clear)
;
; ***************************************************************************************
.isTextCursorActive
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00100000                                      ; test bit 5 of status byte
.exit1
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 2     Printer On
;
; ***************************************************************************************
.vdu2EntryPoint
    LDA #%00000001                                      ;
.setVDUStatusByteFlags
    ORA .vduStatusByte                                  ;
    STA .vduStatusByte                                  ; set bit 0 of the status byte
-
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 3     Printer off
;
; ***************************************************************************************
.vdu3EntryPoint
    LDA #%11111110                                      ; clear bit 1
.clearVDUStatusByteFlags
    AND .vduStatusByte                                  ; AND with VDU status byte
.storeVDUStatusByteAndReturn
    STA .vduStatusByte                                  ; store VDU status byte
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 4       Select text cursor
;
; At all times either the text cursor is active or the graphics cursor is active
; Characters are either drawn normally in text cells (at the text cursor) or at any pixel
; position (the graphics cursor)
;
; ***************************************************************************************
.vdu4EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte
    BEQ -                                               ; if (not in graphics MODE) then branch (return)
    LDA #%11011111                                      ; clear bit 5 (graphics cursor bit)
    JSR .clearVDUStatusByteFlags                        ; ALWAYS branch - clear bit 5 and exit
    LDY #.crtcCursorStartRegister                       ;
    LDA .vduLastCursorStartRegisterValue                ;
    JMP .setCRTCRegisterDirect                          ; turn off cursor

; ***************************************************************************************
;
;   VDU 5       Select graphics cursor
;
; ***************************************************************************************
.vdu5EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte minus one
    BEQ -                                               ; if (not in graphics MODE) then branch (return)
    LDY #.crtcCursorStartRegister                       ;
    LDA #32                                             ; cursor setting
    JSR .setCRTCRegisterDirect                          ; turn off cursor
    JMP .setVDUStatusByteFlags                          ; ALWAYS branch - set bit 5 of VDU status byte and exit


; ***************************************************************************************
;
;   VDU 8       Cursor left (.charBACKSPACE)
;
; ***************************************************************************************
.vdu8EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active
                                                        ;  or A=$20 if graphics cursor
    BNE +                                               ; if (currently in graphics cursor
                                                        ; mode) then branch (to move cursor
                                                        ; left 8 pixels)
    JMP .moveTextCursorLeft                             ;

+
    LDX #2                                              ; set X = 2 for moving graphics cursor left
    JMP .moveGraphicsCursorDownOrLeftEightPixels        ; ALWAYS branch

; ***************************************************************************************
;
;   VDU 9        Cursor right
;
; ***************************************************************************************
.vdu9EntryPoint
    LDA .vduStatusByte                                  ; get VDU status byte
    AND #%00100000                                      ; check bit 5 (graphics cursor)
    BNE +                                               ;
    JMP .moveTextCursorRight                            ;

+
    LDX #2                                              ; set X = 2 for moving graphics cursor right
    JMP .moveGraphicsCursorUpOrRightEightPixels         ; ALWAYS branch

; ***************************************************************************************
;
;   VDU 10       Cursor down
;
; ***************************************************************************************
.vdu10EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active
                                                        ;  or A=$20 if graphics cursor
    BNE .moveGraphicsCursorLeftEightPixels              ; if (currently in graphics cursor
                                                        ; mode) then branch (to move cursor
                                                        ; left 8 pixels)
    JMP .moveTextCursorDown

; ***************************************************************************************
.moveGraphicsCursorLeftEightPixels
    LDX #0                                              ; X = 0 to select horizontal movement (move left)
    JMP .moveGraphicsCursorDownOrLeftEightPixels        ;

; ***************************************************************************************
;
;   VDU 11       Cursor up
;
; ***************************************************************************************
.vdu11EntryPoint
    JSR .isTextCursorActive                             ;
    BNE .moveGraphicsCursorRightEightPixels             ;
    JMP .moveTextCursorUp                               ;

; ***************************************************************************************
.moveGraphicsCursorRightEightPixels
    LDX #0                                              ; X=0 for move cursor right
    JMP .moveGraphicsCursorUpOrRightEightPixels         ;

; ***************************************************************************************
;
;   VDU 12       Clear text window
;
; ***************************************************************************************
.vdu12EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BNE .clearGraphicsWindowAndHomeGraphicsCursor       ; if (graphics cursor active) then branch (clear graphics area)
    LDA .vduStatusByte                                  ; get VDU status byte
    AND #%00001000                                      ; check if software scrolling (text window set)
    BNE +                                               ; if (software scrolling) then branch
    JMP .initializeDisplayAndHomeCursor                 ; initialise screen display and home cursor
+
    LDX .vduTextWindowTop                               ; top of text window
-
    STX .vduTextCursorYPosition                         ; current text line
    JSR .clearOneLine                                   ; clear a line

    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowBottom                            ; bottom edge
    INX                                                 ; X=X+1
    BCC -                                               ; if (not reached bottom edge yet)
                                                        ; then branch (loop back and clear the next row)
    JMP .vdu30EntryPoint                                ; home cursor


; ***************************************************************************************
;
;   VDU 13       Move cursor to start of current line
;
; ***************************************************************************************
.vdu13EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ +                                               ; if (text cursor active) then branch
    JMP .setGraphicsCursorToLeftHandColumn              ; set graphics cursor to left hand columm
+
    LDA .vduTextWindowLeft                              ;
    STA .vduTextCursorXPosition                         ;
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
;
;   VDU 14    Set paged mode
;
; ***************************************************************************************
.vdu14EntryPoint
    LDA #0                                              ;
    STA .pagedModeCounter                               ; reset page mode counter
    LDA #%00000100                                      ; set bit 2 of .vduStatusByte
    JMP .setVDUStatusByteFlags                          ;

; ***************************************************************************************
;
;   VDU 15    Paged mode off
;
; ***************************************************************************************
.vdu15EntryPoint
    LDA #%11111011                                      ; }
    JMP .clearVDUStatusByteFlags                        ; } clear bit 2 of .vduStatusByte

; ***************************************************************************************
.clearGraphicsWindowAndHomeGraphicsCursor
    JSR .graphicsCursorHome                             ;
    JMP +                                               ; clear graphics window

; ***************************************************************************************
;
;   VDU 16      Clear graphics window
;
; ***************************************************************************************
.vdu16EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte
    BEQ .exitNoGraphics                                 ; if (current MODE has no graphics) then branch (exit)
    LDX #7                                              ; loop counter
    LDA #0                                              ;
-
    STA .vduGraphicsCursorPositionXHigh,X               ;
    DEX                                                 ; reset graphics cursor position
    BPL -                                               ;

+
    LDX .vduBackgroundGraphicsColour                    ; background graphics colour
    LDY .vduBackgroundGCOLMode                          ; background graphics plot mode (GCOL n)
    JSR .setGraphicsColourMaskXY                        ; set graphics byte mask in .vduGraphicsColourByteOR/EOR
    LDX #.vduGraphicsWindowPixelsTopHigh - .vduVariablesStart3  ;
                                                        ; source      = graphics window
    LDA #8                                              ;
    LDY #.vduQueueStartByte - .vduVariablesStart3       ; destination
    JSR .copyABytesWithinVDUVariables                   ; copy graphics window coordinates to workspace

    SEC                                                 ; set carry
    LDA .vduGraphicsWindowPixelsTopLow                  ; graphics window top low
    SBC .vduGraphicsWindowPixelsBottomLow               ; graphics window bottom low
    TAY                                                 ; Y=difference
    INY                                                 ; increment
    STY .vduClearGraphicsWindowLineCount                ; and store in workspace (this is line count)

-
    LDX #.vduWorkspaceA - .vduVariablesStart3           ; graphics window right column
    LDY #.vduWorkspaceE - .vduVariablesStart3           ; graphics window left column
    JSR .fillRow                                        ; fillRow
    LDA .vduWorkspaceB                                  ; decrement window height in pixels
    BNE +                                               ;
    DEC .vduWorkspaceA                                  ;
+
    DEC .vduWorkspaceB                                  ;
    DEC .vduClearGraphicsWindowLineCount                ; decrement line count
    BNE -                                               ; if (not zero) then branch (do it again)
.exitNoGraphics
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 17      Define text colour
;
; The parameter is the logical colour to use as the current text foreground colour. If the
; top bit is set, then the current text background is changed. This is the equivalent of
; BASIC's COLOUR command.
;
; ***************************************************************************************
.vdu17EntryPoint
    LDY #0                                              ; Y = 0 (to set text foreground colour)
    BEQ .defineTextOrGraphicsColour                     ; ALWAYS branch

; ***************************************************************************************
;
;   VDU 18      Define graphics colour
;
; This sets the current graphics foreground or background colour. It is the equivalent of
; BASIC's GCOL command.
;
; The first parameter is the GCOL mode: 0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert
;
; This signifies how to modify the colour of pixels that will be drawn in the future. This
; can depend on both the current graphics colour and the colour of the current pixel already
; on screen.
;
; The second parameter:
;
;   bits 0-6 is the logical colour to use.
;   bit 7    set indicates that the current background colour should be set, otherwise
;            the current foreground colour is set.
;
; ***************************************************************************************
.vdu18ParameterGCOLNumber           = .vduQueueStartByte + 1
.vdu18ParameterLogicalColour        = .vduQueueStartByte

.vdu18EntryPoint
    LDY #2                                              ; Y = 2 (to set graphics foreground colour)
.defineTextOrGraphicsColour
    LDA .vdu18ParameterLogicalColour                    ; get last parameter
    BPL +                                               ; if (not negative, it's a foreground colour) then branch
    INY                                                 ; increment y (to set text/graphics background colour)
+
    AND .vduNumberOfLogicalColoursMinusOne              ; ensure colour is at most 'number of logical colours less 1'
    STA .vduTempStoreC4                                 ; store it
    LDA .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .exit3                                          ; if (not in a graphics MODE) then branch (exit)
    AND #7                                              ; limit to an available colour (and clear M)
    CLC                                                 ; clear carry
    ADC .vduTempStoreC4                                 ; add last parameter to get pointer to table.
    TAX                                                 ; X is the offset into the tables of colours.
                                                        ; X = (number of logical colours - 1 + logicalColour)
    LDA .twoColourMODEParameterTable-1,X                ; get plot options from table
    STA .vduForegroundTextColour,Y                      ; store current colour:
                                                        ;
                                                        ;       Y=0 means text foreground
                                                        ;       Y=1 means text background
                                                        ;       Y=2 means graphics foreground
                                                        ;       Y=3 means graphics background
    CPY #2                                              ;
    BCS .setGraphicsGCOLColour                          ; if (graphics colour changed) then branch (set graphics colour)
    LDA .vduForegroundTextColour                        ; foreground text colour
    EOR #$FF                                            ; invert
    STA .vduTextColourByteEOR                           ; text colour byte to EOR-ed into memory
    EOR .vduBackgroundTextColour                        ; background text colour
    STA .vduTextColourByteOR                            ; text colour byte to OR-ed into memory
.exit3
    RTS                                                 ;

; ***************************************************************************************
.setGraphicsGCOLColour
    LDA .vdu18ParameterGCOLNumber                       ; get first parameter
    STA .vduForegroundGraphicsColour,Y                  ; text colour Y=0=foreground; 1=background etc.
    RTS                                                 ;

; ***************************************************************************************
.restoreMODE7TextBackgroundColour
    LDA #32                                             ;
    STA .vduBackgroundTextColour                        ; background text colour
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 19      Write palette
;
; Map a logical colour to a physical colour
;
;               VDU 19,logical colour,physics colour,0,0,0
;
; Logical colours are numbers stored in memory to represent a colour. Logical colours are
; in the range 0-15.
;
; Physical colours are numbers that represent actual colours:
;
;                 0 = black             8 = flashing black-white
;                 1 = red               9 = flashing red-cyan
;                 2 = green            10 = flashing green-magenta
;                 3 = yellow           11 = flashing yellow-blue
;                 4 = blue             12 = flashing blue-yellow
;                 5 = magenta          13 = flashing magenta-green
;                 6 = cyan             14 = flashing cyan-red
;                 7 = white            15 = flashing white-black
;
; The palette defines which physical colour is displayed for each logical colour.
; The Video ULA hardware stores and manages this palette information.
;
; Flashing colours
; ----------------
; The OS (in the vertical sync interrupt) updates timers to know when to change the current
; appearance of flashing colours. When it's time, the OS signals the VideoULA to flip the
; flashing bit, thereby changing the current appearance.
;
; ***************************************************************************************
.vdu19ParameterLogicalColour  = $0348
.vdu19ParameterPhysicalColour = $0347

.vdu19EntryPoint
    LDA .vduNumberOfLogicalColoursMinusOne              ;
    BEQ .restoreMODE7TextBackgroundColour               ;
    STA .vduTempStoreC8                                 ;
    AND .vdu19ParameterLogicalColour                    ;
    TAX                                                 ;
    LDA .vdu19ParameterPhysicalColour                   ;
    STA .vduColourPaletteStart,X                        ; store physical in colour palette
    TXA                                                 ;
-
    ROR                                                 ; rotate the logical colour (A) into
                                                        ; the top bits of .tempStoreFA
    ROR .vduTempStoreC8                                 ; rotate the (number of colours
                                                        ; in the MODE-1) down by one bit
    BCS -                                               ; if (there are more set bits) then
                                                        ; branch (loop back)
    ASL .vduTempStoreC8                                 ; the final rotate wasn't needed,
                                                        ; so shift left to rectify
                                                        ; at this point .tempStoreFA holds
                                                        ; the logical colour in the top N bits
                                                        ; where N is the number of bits
                                                        ; required to store a colour in
                                                        ; the current MODE.
    LDA .vdu19ParameterPhysicalColour                   ;
    ORA .vduTempStoreC8                                 ; OR in the physical colour into
                                                        ; the bottom bits
    TAX                                                 ; store value in X. This is working
                                                        ; towards being the value to send to
                                                        ; the palette register on the Video ULA.
    LDA #0                                              ; Y=0
-
    PHA                                                 ;
    TXA                                                 ;
    LDY .vduNumberOfLogicalColoursMinusOne              ;
    CPY #3                                              ;
    BNE .notFourColourMODE                              ; if (not a four colour MODE) then branch

    ; deal with four colour MODEs
    AND #%01100000                                      ; Test bits 5 and 6
    BEQ +                                               ; if (both bit are clear) then branch
    CMP #%01100000                                      ;
    BEQ +                                               ; if (both bits are set) then branch
    TXA                                                 ; recall X value.
    EOR #%01100000                                      ; invert bits 5 and 6 (one of which
                                                        ; is set and the other clear).
    BNE .notFourColourMODE                              ; ALWAYS branch. A = value to send
                                                        ; to palette register of the Video ULA.
+
    TXA                                                 ; X=A
.notFourColourMODE
    JSR .osbyte155Jumper                                ; pass data to palette register
    TXA                                                 ;
    CLC                                                 ;
    ADC #16                                             ;
    TAX                                                 ; X = X + 16
    PLA                                                 ;
    SEC                                                 ;
    ADC .vduNumberOfLogicalColoursMinusOne              ;
    CMP #16                                             ;
    BCC -                                               ; if (Y < 16) then branch (loop back)
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 20      Restore default colours
;
; ***************************************************************************************
.vdu20EntryPoint
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    LDA #$FF                                            ; A=$FF
    CPX #15                                             ;
    BNE +                                               ; if (not 16 colours; ie. not MODE 2) then branch
    LDA #$3F                                            ; A=$3F
+
    STA .vduForegroundTextColour                        ; foreground text colour
    STA .vduForegroundGraphicsColour                    ; foreground graphics colour
    EOR #$FF                                            ; invert A
    STA .vduTextColourByteOR                            ; text colour byte to be OR-ed into memory
    STA .vduTextColourByteEOR                           ; text colour byte to be EOR-ed into memory

    LDA #0                                              ;
    STA .vduForegroundGCOLMode                          ; }
    STA .vduBackgroundGCOLMode                          ; } reset colour variables
    STA .vduBackgroundTextColour                        ; }
    STA .vduBackgroundGraphicsColour                    ; }
    CPX #3                                              ;
    BEQ .restore4Colours                                ; if (there are 4 colours) then branch
    DEX                                                 ;
    BNE +                                               ;
    STX .vdu19ParameterPhysicalColour                   ; set second parameter
    STX .vdu19ParameterLogicalColour                    ; set first parameter
    JSR .vdu19EntryPoint                                ;
    INC .vdu19ParameterLogicalColour                    ;
    LDX #7                                              ;
    STX .vdu19ParameterPhysicalColour                   ;
    JMP .vdu19EntryPoint                                ;

+
    INX                                                 ;
    STX .vdu19ParameterPhysicalColour                   ; set second parameter
    STX .vdu19ParameterLogicalColour                    ; set first parameter
-
    JSR .vdu19EntryPoint                                ; VDU 19 - define logical colour
    DEC .vdu19ParameterPhysicalColour                   ; decrement first parameter
    DEC .vdu19ParameterLogicalColour                    ; and last parameter
    BPL -                                               ;
    RTS                                                 ;

.restore4Colours
    STX .vdu19ParameterLogicalColour                    ; set first parameter
    LDX #7                                              ; X = 7
    STX .vdu19ParameterPhysicalColour                   ; set second parameter
-
    JSR .vdu19EntryPoint                                ; and do VDU 19
    LSR .vdu19ParameterPhysicalColour                   ;
    DEC .vdu19ParameterLogicalColour                    ;
    BPL -                                               ;
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 21    Disable VDU drivers
;
; Output to the VDU is disabled (until a VDU 6 is used to re-enable output).
;
; ***************************************************************************************
.vdu21EntryPoint
    LDA #%10000000                                      ;
    JMP .setVDUStatusByteFlags                          ;


; ***************************************************************************************
;
;   VDU 22      Select MODE
;
; ***************************************************************************************
.vdu22Parameter = .vduQueueStartByte

.vdu22EntryPoint
    LDA .vdu22Parameter                                 ; get parameter
    JMP .setMODE                                        ; change MODE


; ***************************************************************************************
;
;   VDU 23      Define Character
;
; See guide.png
;
; On Entry:
;   A = 0 sets CRTC 6845 register:
;       VDU 23,0,R,X,0,0,0,0,0,0 - program CRTC register R with value V
;       See Chapter 3 section 'CRTC registers'
;   A = 1 turns the cursor on or off:
;       VDU 23,1,0,0,0,0,0,0,0,0 - turn cursor off
;       VDU 23,1,1,0,0,0,0,0,0,0 - turn cursor on
;   A = 32-255 means define character
;
; ***************************************************************************************
.vdu23Parameter0 = .vduQueueStartByte + 8
.vdu23Parameter1 = .vduQueueStartByte + 7
.vdu23Parameter2 = .vduQueueStartByte + 6
.vdu23Parameter3 = .vduQueueStartByte + 5
.vdu23Parameter4 = .vduQueueStartByte + 4
.vdu23Parameter5 = .vduQueueStartByte + 3
.vdu23Parameter6 = .vduQueueStartByte + 2
.vdu23Parameter7 = .vduQueueStartByte + 1
.vdu23Parameter8 = .vduQueueStartByte

.vdu23EntryPoint
    LDA .vdu23Parameter0                                ; get character to define
    CMP #.charSPACE                                     ;
    BCC .vdu23SetCRTCRegisterOrCursorVisibility         ; if (less then SPACE) then branch
                                                        ; (it is an instruction to set a CRT
                                                        ; register or cursor visibility)
    PHA                                                 ; save parameter
    LSR                                                 ; A = A / 32
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    TAX                                                 ; store font zone (1-7) in X
    LDA .fontMaskTable,X                                ; look up single bit representing
                                                        ; the font zone (character / 32)
    BIT .vduFontFlags                                   ; font flag
    BNE +                                               ; if (not zero) then branch (storage
                                                        ; area is established already)
    ORA .vduFontFlags                                   ; OR with font flag to set bit
                                                        ; found to be 0
    STA .vduFontFlags                                   ; font flag
    TXA                                                 ; get back font zone (1-7)
    AND #3                                              ; AND with 3 to clear all but bits
                                                        ; 0 and 1 (A = 1, 2, 3)
    CLC                                                 ;
    ADC #>.characterDefinitions - 1                     ; A=$C0, $C1, $C2 to select a
                                                        ; character page in ROM
    STA .vduTempStoreC9                                 ; store it in the high byte
    LDA .vduFontZoneAddressesHigh1 - 1,X                ; get font address (high byte)
    STA .vduTempStoreC7                                 ; store it in the high byte
    LDY #0                                              ;
    STY .vduTempStoreC6                                 ; store zero in the low bytes
    STY .vduTempStoreC8                                 ;
-
    LDA (.vduTempStoreC8),Y                             ; copy character definition
    STA (.vduTempStoreC6),Y                             ;
    DEY                                                 ;
    BNE -                                               ;
+
    PLA                                                 ; get back A
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDY #7                                              ; Y=loop counter
    LDX #0                                              ;
-
    LDA .vduQueueStartByte,X                            ; transfer definition parameters
    STA (.vduTempStoreC8),Y                             ; to RAM definition
    INX
    DEY                                                 ;
    BPL -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; VDU 23 with 0-31 as the next byte
;
; VDU 23,r,v,0,0,0,0,0        - set CRTC Register
; VDU 23,1,0,0,0,0,v,l        - set VDU variable
; VDU 23,2-31,a,b,c,d,e,f,g,h - implode some soft characters, i.e. clear VDU font flags
;                               (which ranges of characters don't have definitions,
;                                each parameter value is in the range 0-7)
;
; ***************************************************************************************
.vdu23SetCRTCRegisterOrCursorVisibility
    CMP #1                                              ;
    BNE +                                               ;
    LDA .vduQueueStartByte + 6                          ; value to store
    LDX .vduQueueStartByte + 7                          ; location to store
    STA .vduVariablesStart2,X                           ;
    RTS                                                 ;

+
    BCC .vdu23CommaZeroSetCRTCRegister                  ;

    LDY #7                                              ; Y=loop counter
    LDA #0                                              ;
-
    LDX .vduQueueStartByte,Y                            ; X = parameter value (starting at the end and working backwards)
    BEQ +                                               ; a zero parameter terminates the sequence
    ORA .fontMaskTable,X                                ; add a single set bit to the result
    DEY                                                 ;
    BPL -                                               ; if (not done yet) then loop back
+
    EOR #$ff                                            ; invert every bit of A
    AND .vduFontFlags                                   ; clear the bits that were originally set
    STA .vduFontFlags                                   ; store the result
    RTS                                                 ;

; ***************************************************************************************
.vdu23CommaZeroSetCRTCRegister
    LDA .vdu23Parameter2                                ; get third parameter (value to write)
    LDY .vdu23Parameter1                                ; get second parameter (CRTC register to set)
.setCRTCRegisterAY
    CPY #.crtcVerticalSyncPositionRegister              ;
    BCC .setCRTCRegisterDirect                          ; if (Y < 7) then set register Y with value A directly
    BNE ++                                              ; if (Y > 7) branch

    ; deal with vertical sync position register
    CLC                                                 ;
    ADC .vduVerticalAdjust                              ; add screen vertical display
                                                        ; adjustment + 1 (carry set)
    BNE .setCRTCRegisterDirect                          ;
++
    CPY #.crtcInterlaceAndDelayRegister                 ;
    BNE +                                               ; if (Y != 8) then branch
    PHA                                                 ;
    PLA                                                 ;
    BMI +                                               ; if (bit 7 set) then branch
    EOR .vduInterlaceValue                              ; set interlace value (0 or 1)
+
    CPY #.crtcCursorStartRegister                       ;
    BNE .setCRTCRegisterDirect                          ; if (Y != 10) then branch - set register Y with value A directly

    ; deal with cursor start register
    STA .vduLastCursorStartRegisterValue                ; last setting of CRTC register
    TAY                                                 ; Y=A
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00100000                                      ; check bit 5 (print at graphics cursor)
    PHP                                                 ; push flags
    TYA                                                 ; A = value to set
    LDY #.crtcCursorStartRegister                       ; Y=10
    PLP                                                 ; pull flags
    BNE .exit4a                                         ; if (graphics cursor is active) then branch (return)
    ; fall through...

; ***************************************************************************************
.setCRTCRegisterDirect
    STY .crtcAddressRegister                            ; Y is which CRTC register to write to
    STA .crtcAddressWrite                               ; write value A into register Y
.exit4a
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 25      Plot
;
; ***************************************************************************************
.vdu25EntryPoint
    LDX .vduPixelsPerByteMinusOne                       ; get pixels per byte
    BEQ .exit4a                                         ; if (zero, i.e. no graphics available) then branch (plot extension)
    JMP .vdu25Plot                                      ; jump to main plot routine

; ***************************************************************************************
;
;   VDU 26      Reset to default windows
;
; ***************************************************************************************
.vdu26EntryPoint
    LDA #0                                              ; A=0
    LDX #.vduWorkspaceI - .vduTextWindowTop             ; X=loop counter
-
    STA .vduTextWindowTop,X                             ; zero a whole bunch of vdu variables,
    DEX                                                 ; including the text and graphics
    BPL -                                               ; windows

    ; use data for current screen mode
    LDX .vduCurrentScreenMODE                           ; screen MODE

    ; reset text window
    LDY .textWindowRightColumnTable,X                   ; text window right edge maximum
    STY .vduTextWindowRight                             ; store in the text window right
    JSR .calculateBytesPerTextWindowRow                 ; calculate number of bytes in a text
                                                        ; window row
    LDY .textWindowBottomRowTable,X                     ; text window bottom edge maximum
    STY .vduTextWindowBottom                            ; bottom edge

    ; reset graphics window
    LDY #3                                              ;
    STY .vdu24ParameterTopEdgeHigh                      ; top edge high byte    = 3
    INY                                                 ; Y = 4
    STY .vdu24ParameterRightEdgeHigh                    ; right edge high byte  = 4
    DEC .vdu24ParameterTopEdgeLow                       ; top edge low          = $FF
    DEC .vdu24ParameterRightEdgeLow                     ; right edge low        = $FF
                                                        ;
                                                        ; so now top edge = $03FF = 1023
                                                        ; and right edge  = $04FF = 1279
                                                        ;
    JSR .vdu24EntryPoint                                ; do VDU 24 (define graphics
                                                        ; window)

    ; reset scrolling
    LDA #%11110111                                      ; }
    JSR .clearVDUStatusByteFlags                        ; } clear bit 3 of .vduStatusByte

    LDA .vduScreenTopLeftAddressHigh                    ; screen start address high
    LDX .vduScreenTopLeftAddressLow                     ; screen start address low
    STX .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address
    STA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address
    ; fall through...

; ***************************************************************************************
;
; Set cursor screen address
;
; On Entry:
;       AX holds the screen address
;
; ***************************************************************************************
.setHardwareCursorAddress
    STX .vduWriteCursorScreenAddressLow                 ; set screen address of cursor from AX
    STA .vduWriteCursorScreenAddressHigh                ;
    LDX .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address
    LDA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address
    LDY #.crtcCursorPositionHighRegister                ; Y=14
    ; fall through...

; ***************************************************************************************
;
; Set hardware screen or cursor address
;
; On Entry:
;       The screen address or cursor position address is in AX
;       Y holds either .crtcCursorPositionHighRegister to change the cursor position
;                   or .crtcStartScreenAddressHighRegister to change the screen address
; ***************************************************************************************
.setHardwareScreenOrCursorAddress
    PHA                                                 ; store A
    LDA .vduCurrentScreenMODE                           ; screen MODE
    CMP #7                                              ; is it MODE 7?
    PLA                                                 ; restore A
    BCS .setCursorPositionMODE7                         ; if (MODE 7 selected) then branch
    STX .vduTempStoreC4                                 ; store X
    LSR                                                 ; divide X/A by 8
    ROR .vduTempStoreC4                                 ;
    LSR                                                 ;
    ROR .vduTempStoreC4                                 ;
    LSR                                                 ;
    ROR .vduTempStoreC4                                 ;
    LDX .vduTempStoreC4                                 ;
    JMP .setTwoCRTCRegisters                            ; set cursor position AX

.setCursorPositionMODE7
    SEC                                                 ;
    SBC #$74                                            ; MODE 7 subtract $74
    EOR #$20                                            ; EOR with $20 (See NAUG Section
                                                        ; 13.3.11 - MODE 7 scrolling,
                                                        ; Page 200)
    ; fall through...

; ***************************************************************************************
;
; Write to two sequential registers on the CRTC
;
; On Entry:
;       Y = register number
;       A = First value to write (to register Y)
;       X = Second value to write (to register Y+1)
;
; ***************************************************************************************
.setTwoCRTCRegisters
    STY .crtcAddressRegister                            ; set which CRTC register to write into
    STA .crtcAddressWrite                               ; write A into CRTC register
    INY                                                 ; increment Y to the next CRTC register
    STY .crtcAddressRegister                            ; set which CRTC register to write into
    STX .crtcAddressWrite                               ; write X into CRTC register
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 24      Define graphics window
;
; ***************************************************************************************
.vdu24ParameterLeftEdgeLow      = .vduQueueStartByte + 7
.vdu24ParameterLeftEdgeHigh     = .vduQueueStartByte + 6
.vdu24ParameterBottomEdgeLow    = .vduQueueStartByte + 5
.vdu24ParameterBottomEdgeHigh   = .vduQueueStartByte + 4
.vdu24ParameterRightEdgeLow     = .vduQueueStartByte + 3
.vdu24ParameterRightEdgeHigh    = .vduQueueStartByte + 2
.vdu24ParameterTopEdgeLow       = .vduQueueStartByte + 1
.vdu24ParameterTopEdgeHigh      = .vduQueueStartByte

.vdu24EntryPoint
    LDX #4                                                  ;
    STX .vduPlotType                                        ; plot type = 4
    LDY #.vduPlotLineCurrentPointXHigh - .vduGraphicsCursorPixelsYHigh;
    JSR .coordinateSubtraction                              ;
    AND .vduPlotTriMinorLineDeltaXHigh                      ;
    BPL .exit2                                              ;
    LDX #.vduWorkspaceA - .vduVariablesStart3               ;
    JSR .plotConvertExternalRelativeCoordinatesToPixels     ;
    LDX #.vduWorkspaceE - .vduVariablesStart3               ;
    JSR .plotConvertExternalRelativeCoordinatesToPixels     ;
    LDA .vduWorkspaceE                                      ; get high byte of height
    ORA .vduWorkspaceG                                      ; OR with high byte of width
    BMI .exit2                                              ; if (negative) then branch (exit)
    LDA .vdu24ParameterTopEdgeHigh                          ;
    BNE .exit2                                              ; if (non zero) then branch (exit)
    LDX .vduCurrentScreenMODE                               ; get screen MODE
    LDA .vdu24ParameterRightEdgeHigh                        ; right edge high
    STA .vduTempStoreC4                                     ; store it
    LDA .vdu24ParameterRightEdgeLow                         ; right edge low
    LSR .vduTempStoreC4                                     ;
    ROR                                                     ;
    LSR .vduTempStoreC4                                     ;
    BNE .exit2                                              ; if (negative) then branch (to exchange back and exit)
    ROR                                                     ;
    LSR                                                     ;
    CMP .textWindowRightColumnTable,X                       ; compare with text window right hand edge maximum
    BEQ +                                                   ; if (equal) then branch
    BPL .exit2                                              ; if (non-negative) then branch (to exchange back and exit)
+
    LDY #.vduGraphicsWindowPixelsTopHigh - .vduVariablesStart3 ; destination = graphics window extents
    LDX #.vdu24ParameterTopEdgeHigh - .vduVariablesStart3      ; source = parameters
    LDA #8                                                  ;
    JMP .copyABytesWithinVDUVariables                       ;

; ***************************************************************************************
.calculateBytesPerTextWindowRow
    INY                                                 ; }
    TYA                                                 ; } A = Y + 1
.calculateBytesPerTextWindowRowInternal
    LDY #0                                              ; Y=0
    STY .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    STA .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    LDA .vduBytesPerCharacter                           ; bytes per character
    LSR                                                 ; divide by 2
    BEQ .exit2                                          ; if (zero) then branch (exit)
-
    ASL .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    ROL .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    LSR                                                 ; divide by 2
    BCC -                                               ; if (carry clear) then branch (loop back)
.exit2
    RTS

; ***************************************************************************************
;
;   VDU 28       Define Text Window
;
; A sub-rectangle on screen can be defined that limits where text can be drawn.
;
; ***************************************************************************************
.vdu28ParamLeftEdge   = .vduQueueStartByte + 3
.vdu28ParamBottomEdge = .vduQueueStartByte + 2
.vdu28ParamRightEdge  = .vduQueueStartByte + 1
.vdu28ParamTopEdge    = .vduQueueStartByte

.vdu28EntryPoint
    LDX .vduCurrentScreenMODE                           ; get current screen MODE
    LDA .vdu28ParamBottomEdge                           ; get bottom edge
    CMP .vdu28ParamTopEdge                              ; compare with top edge
    BCC .exit2                                          ; if (bottom edge exceeds top edge) then branch (return)
    CMP .textWindowBottomRowTable,X                     ; check against text window bottom edge maximum
    BEQ +                                               ; if (on the edge) then branch (it's OK)
    BCS .exit2                                          ; if (outside bounds) then branch (exit)
+
    LDY .vdu28ParamRightEdge                            ; get right edge
    TYA                                                 ; put it in Y
    CMP .textWindowRightColumnTable,X                   ; text window right hand edge maximum
    BEQ +                                               ; if (on the edge) then branch (it's OK)
    BCS .exit2                                          ; if (outside bounds) then branch (exit)
+
    INY
    TYA
    SEC                                                 ; set carry to subtract
    SBC .vdu28ParamLeftEdge                             ; left edge
    BMI .exit2                                          ; if (left edge greater than right) then branch (exit)
    JSR .calculateBytesPerTextWindowRowInternal         ; calculate number of bytes in a text window row
    LDA #%00001000                                      ; set bit 3 of .vduStatusByte
    JSR .setVDUStatusByteFlags                          ; indicating that text window is defined
    LDX #3                                              ;
-
    LDA .vduQueueStartByte,X                            ;
    STA .vduTextWindowTop,X                             ;
    DEX                                                 ;
    BPL -                                               ;

    JSR .validatePositionAndSetupScreenAddress          ; check ok and set up screen address
    BCS .vdu30EntryPoint                                ; home cursor within window
.setHardwareCursorAddressLocal
    JMP .setHardwareCursorAddress                       ; set cursor position

; ***************************************************************************************
;
;   VDU 29      Set graphics origin
;
; ***************************************************************************************
.vdu29ParameterStart = .vduQueueStartByte

.vdu29EntryPoint
    LDX #.vdu29ParameterStart - .vduVariablesStart3             ; } copy the four bytes from the
    LDY #.vduGraphicsWindowOriginXHigh - .vduVariablesStart3    ; } vdu queue parameters to the
    JSR .copyFourBytesWithinVDUVariables                        ; } current graphics origin

    LDX #.vduGraphicsCursorPositionXHigh - .vduVariablesStart3  ;
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
    JSR .copyFourBytesWithinVDUVariables                        ;

    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
    JMP .plotConvertExternalRelativeCoordinatesToPixels         ;

; ***************************************************************************************
;
;   VDU 30      Home Cursor
;
; Moves the current cursor (text or graphics) to the top left of the defined text or
; graphics window.
;
; ***************************************************************************************
.vdu30EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ .homeTextCursor                                 ; if (text cursor active) then branch
    JMP .graphicsCursorHome                             ; home graphic cursor

.homeTextCursor
    LDA #0                                              ;
    STA .vdu31ParamYCoordinate                          ; store 0 in last two parameters
    STA .vdu31ParamXCoordinate                          ;
    ; fall through...

; ***************************************************************************************
;
;   VDU 31      Position text cursor
;
; ***************************************************************************************
.vdu31ParamXCoordinate = .vduQueueStartByte + 1
.vdu31ParamYCoordinate = .vduQueueStartByte
.vdu31EntryPoint
    LDA .vduTextCursorXPosition                         ; }
    PHA                                                 ; }
    LDA .vduTextCursorYPosition                         ; } push current text position
    PHA                                                 ; }
    CLC                                                 ; clear carry
    LDA .vdu31ParamXCoordinate                          ; get X coordinate
    ADC .vduTextWindowLeft                              ; add to text window left
    STA .vduTextCursorXPosition                         ; store as text column
    LDA .vdu31ParamYCoordinate                          ; get Y coordinate
    CLC                                                 ;
    ADC .vduTextWindowTop                               ; add top of text window
    STA .vduTextCursorYPosition                         ; current text line
    JSR .isTextCursorActive                             ;
    BNE .vdu31GraphicsCursorActive                      ;
    JSR .validatePositionAndSetupScreenAddress          ;
    BCS ++                                              ;
    JSR .setHardwareCursorAddress                       ;
    PLA                                                 ;
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.vdu31GraphicsCursorActive
    JSR +                                               ;
    JSR .convertPixelGraphicsCoordinatesToExternal      ;
++
    PLA                                                 ; }
    STA .vduTextCursorYPosition                         ; }
    PLA                                                 ; } pull (restore) the original text cursor position
    STA .vduTextCursorXPosition                         ; }
    RTS                                                 ; }

+
    LDY .vduTextCursorXPosition                         ; Use the text position to set
    LDX #2                                              ; the graphics cursor position
    JSR +                                               ; first the X coordinate
    LDY .vduTextCursorYPosition                         ; then the Y coordinate
    LDX #0                                              ;
+
    LDA #0                                              ;
    STA .vduGraphicsCursorPixelsYHigh,X                 ;
    TYA                                                 ;
    ASL                                                 ;
    ASL                                                 ;
    ROL .vduGraphicsCursorPixelsYHigh,X                 ;
    ASL                                                 ;
    ROL .vduGraphicsCursorPixelsYHigh,X                 ;
    CPX #0                                              ;
    BNE +                                               ; if (X coordinate) then branch
    EOR #$ff                                            ; invert the Y coordinate
+
    STA .vduGraphicsCursorPixelsYLow,X                  ;
    RTS                                                 ;

; ***************************************************************************************
;
;   VDU 127     Delete
;
; ***************************************************************************************
.vdu127EntryPoint
    JSR .vdu8EntryPoint                                 ; cursor left
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active
                                                        ;  or A=$20 if graphics cursor
    BNE .deleteCharacterAtGraphicsCursor                ; if (graphics cursor active) then branch
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .deleteCharacterInMODE7                         ; if (MODE 7) then branch
    LDA #<.characterDefinitions                         ;
    STA .vduTempStoreC8                                 ;
    LDA #>.characterDefinitions                         ; A=high byte of characters in ROM
    STA .vduTempStoreC9                                 ; store. .vduTempStoreC8/9
                                                        ; now points to the first character
                                                        ; definition: the 'space' pattern
    JMP .displayACharacterAtAddress                     ; display a space

; ***************************************************************************************
.deleteCharacterInMODE7
    LDA #.charSPACE                                     ; }
    JMP .displayCharacterMODE7                          ; } display a space

; ***************************************************************************************
.deleteCharacterAtGraphicsCursor
    LDA #.charDELETE                                    ; ASCII code for delete
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDX .vduBackgroundGraphicsColour                    ; background graphics colour
    LDY #0                                              ; normal GCOL mode
    JMP .plotACharacterWithXYAsGraphicsColourAndGCOLMode ; plot character in background colour


; ***************************************************************************************
.initialiseVDUVariablesAndSetMODE
    PHA                                                 ; save A (screen mode number)

    ; Clear 106 VDU variables ($0320-$038A)
    LDX #106                                            ; loop counter
    LDA #0                                              ; A=0
-
    STA .vduVariablesStart2,X                           ; zero VDU variables (0-126)
    DEX                                                 ; with this loop
    BPL -                                               ;

    LDX #<.exit                                         ;
    STX .vectorVDUV                                     ;
    LDX #>.exit                                         ;
    STX .vectorVDUV + 1                                 ;

    LDX #6                                              ;
-
    LDA .defaultFontZones,X                             ; read default font zones
    STA .vduFontZoneAddressesHigh1,X                    ; store font zones
    DEX                                                 ;
    BPL -                                               ;

    LDX #$0f                                            ;
    STX .vduFontFlags                                   ;
    PLA                                                 ;
    LDX #.charRETURN                                    ;
    STX .endTextEntryCharacter                          ;
    LDX #$7f                                            ;
    STX .vduTeletextCharacterForCursor                  ;
    ; fall through...

; ***************************************************************************************
;
; Set MODE
;
; On Entry:
;       A = screen MODE number
;
; ***************************************************************************************
.setMODE
    BIT .systemAvailableRAM                             ; test available RAM pages ($40 = 16k; $80 = 32k)
    BMI +                                               ; if (32k available) then branch
    ORA #4                                              ; ensure only modes 4-7 are available
+
    AND #7                                              ; X = A AND 7 (to ensure a legal mode)
    TAX                                                 ; X = mode

    ; Set characteristic vdu variables for the new mode
    STX .vduCurrentScreenMODE                           ; set screen mode
    LDA .numberOfColoursMinusOneInMODETable,X           ; get number of colours -1 in mode from table
    STA .vduNumberOfLogicalColoursMinusOne              ; set number of logical colours less 1
    LDA .bytesPerCharacter,X                            ; get number of bytes /character from table
    STA .vduBytesPerCharacter                           ; set bytes per character
    LDA .pixelsPerByteMinusOneInMODETable,X             ; get display mode pixels/byte from table
    STA .vduPixelsPerByteMinusOne                       ; set pixels per byte-1
    BNE +                                               ; if (in a graphics mode) then branch
    LDA #7                                              ; this is a text mode; set A = 7
+
    ASL                                                 ; A = A * 2
    TAY                                                 ; Y = 2 * (pixels per byte-1), index into a table of colour masks
    LDA .sixteenColourMODEMaskTable - 1,Y               ; mask table
    STA .vduColourMaskRight                             ; store as colour mask right
-
    ASL                                                 ; shift A left
    BPL -                                               ; until the top bit becomes set
    STA .vduColourMaskLeft                              ; store as colour mask left

    LDY .screenDisplayMemoryIndexTable,X                ; screen display memory index table
    STY .vduCurrentScreenMODEGroup                      ; MODE group = screen memory size:
                                                        ;       0 = 20k (MODE 0,1,2)
                                                        ;       1 = 16k (MODE 3)
                                                        ;       2 = 10k (MODE 4,5)
                                                        ;       3 = 8k (MODE 6)
                                                        ;       4 = 1k (MODE 7)

    LDA .systemVIAHardwareScrollTable2,Y                ; get system VIA parameter for setting hardware scrolling value
    JSR .writeAToSystemVIARegisterB                     ; write hardware scrolling value to System VIA
    LDA .systemVIAHardwareScrollTable1,Y                ; get system VIA parameter for setting hardware scrolling value
    JSR .writeAToSystemVIARegisterB                     ; write hardware scrolling value to System VIA
    LDA .screenMemorySizeInBytesHigh,Y                  ;
    LDX #0                                              ; }
    STX .vduScreenSizeLowByte                           ; } store size of screen memory
    STA .vduScreenSizeHighByte                          ; }
    LDA .screenMemoryStartHigh,Y                        ;
    STA .vduStartScreenAddressHighByte                  ;
    STX .vduStartScreenAddressLowByte                   ;
    LDX .multiplyTableIndex,Y                           ; get which multiplication table to use

    LDA .multiplicationTabletoUseLow,X                  ; }
    STA .vduMultiplicationTableLow                      ; } store multiplication table to use
    LDA .multiplicationTabletoUseHigh,X                 ; }
    STA .vduMultiplicationTableHigh                     ; }

    LDA .bytesPerRowLow,X                               ; }
    STA .vduBytesPerCharacterRowLow                     ; } store number of bytes per character row
    LDA .bytesPerRowHigh,X                              ; }
    STA .vduBytesPerCharacterRowHigh                    ; }

    LDA #%01000011                                      ;
    JSR .clearVDUStatusByteFlags                        ; clear bits 2,3,4,5,7 in .vduStatusByteFlags:
                                                        ; bit 2 = paged scrolling selected
                                                        ; bit 3 = software scrolling (text window)
                                                        ; bit 4 = not used
                                                        ; bit 5 = graphics cursor enabled (VDU 5)
                                                        ; bit 7 = VDU disabled


    LDX .vduCurrentScreenMODE                           ; screen mode
    LDA .videoULAVideoControlRegisterDefaultValuesPerMODE,X ; get video ULA control setting
    JSR .setVideoULA                                    ; set video ULA using OSBYTE 154

    ; Set CRTC registers for the current mode
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDX .crtcCursorEndRegisterTable,Y                   ; get cursor end register data from table
    LDY #11                                             ; Y = 11
-
    LDA .crtcRegisters0to11ForMODEs012,X                ; get entry from CRTC table
    JSR .setCRTCRegisterAY                              ; set CRTC Register Y to A
    DEX                                                 ; reduce pointers
    DEY                                                 ;
    BPL -                                               ; if (still >=0) then branch (loop back)
    PLP                                                 ; pull flags
    JSR .vdu20EntryPoint                                ; set default colours
    JSR .vdu26EntryPoint                                ; set default windows

.initializeDisplayAndHomeCursor
    LDX .vduStartScreenAddressLowByte                   ;
    LDA .vduStartScreenAddressHighByte                  ;
    STX .vduScreenTopLeftAddressLow                     ;
    STA .vduScreenTopLeftAddressHigh                    ;
    STX .vduTextCursorCRTCAddressLow                    ;
    STA .vduTextCursorCRTCAddressHigh                   ;
    JSR .setHardwareCursorAddress                       ;

    LDY #.crtcStartScreenAddressHighRegister            ;
    JSR .setTwoCRTCRegisters                            ; set registers 12 and 13 in CRTC
    LDA .vduBackgroundTextColour                        ; background text colour
    LDX .vduCurrentScreenMODEGroup                      ; MODE group = screen memory size
                                                        ; 0=20k (MODE 0,1,2)
                                                        ; 1=16k (MODE 3)
                                                        ; 2=10k (MODE 4,5)
                                                        ; 3=8k (MODE 6)
                                                        ; 4=1k (MODE 7)
    LDY .clearScreenRoutineEntryPointLow,X              ; get section control number
    STY .vduJumpVectorLow                               ; set it in jump vector low
    LDY .clearScreenRoutineEntryPointHigh,X             ;
    STY .vduJumpVectorHigh                              ; upper byte of link address
    LDX #0                                              ; X = 0
    STX .pagedModeCounter                               ; paged mode counter
    STX .vduTextCursorXPosition                         ; text column
    STX .vduTextCursorYPosition                         ; current text line
    JMP (.vduJumpVectorLow)                             ; jump indirect - this calls the screen clearing routine


; ***************************************************************************************
;
; Screen clear routine
;
; On Entry:
;       A contains byte for the background colour which is set in every byte of the screen
;
; To visualise the pattern of bytes that are cleared see cls.ssd
;
; ***************************************************************************************
.clearScreenRoutineEntryPointMODE012
    STA $3000,X                                         ;
    STA $3100,X                                         ;
    STA $3200,X                                         ;
    STA $3300,X                                         ;
    STA $3400,X                                         ;
    STA $3500,X                                         ;
    STA $3600,X                                         ;
    STA $3700,X                                         ;
    STA $3800,X                                         ;
    STA $3900,X                                         ;
    STA $3A00,X                                         ;
    STA $3B00,X                                         ;
    STA $3C00,X                                         ;
    STA $3D00,X                                         ;
    STA $3E00,X                                         ;
    STA $3F00,X                                         ;

.clearScreenRoutineEntryPointMODE3
    STA $4000,X                                         ;
    STA $4100,X                                         ;
    STA $4200,X                                         ;
    STA $4300,X                                         ;
    STA $4400,X                                         ;
    STA $4500,X                                         ;
    STA $4600,X                                         ;
    STA $4700,X                                         ;
    STA $4800,X                                         ;
    STA $4900,X                                         ;
    STA $4A00,X                                         ;
    STA $4B00,X                                         ;
    STA $4C00,X                                         ;
    STA $4D00,X                                         ;
    STA $4E00,X                                         ;
    STA $4F00,X                                         ;
    STA $5000,X                                         ;
    STA $5100,X                                         ;
    STA $5200,X                                         ;
    STA $5300,X                                         ;
    STA $5400,X                                         ;
    STA $5500,X                                         ;
    STA $5600,X                                         ;
    STA $5700,X                                         ;

.clearScreenRoutineEntryPointMODE45
    STA $5800,X                                         ;
    STA $5900,X                                         ;
    STA $5A00,X                                         ;
    STA $5B00,X                                         ;
    STA $5C00,X                                         ;
    STA $5D00,X                                         ;
    STA $5E00,X                                         ;
    STA $5F00,X                                         ;

.clearScreenRoutineEntryPointMODE6
    STA $6000,X                                         ;
    STA $6100,X                                         ;
    STA $6200,X                                         ;
    STA $6300,X                                         ;
    STA $6400,X                                         ;
    STA $6500,X                                         ;
    STA $6600,X                                         ;
    STA $6700,X                                         ;
    STA $6800,X                                         ;
    STA $6900,X                                         ;
    STA $6A00,X                                         ;
    STA $6B00,X                                         ;
    STA $6C00,X                                         ;
    STA $6D00,X                                         ;
    STA $6E00,X                                         ;
    STA $6F00,X                                         ;
    STA $7000,X                                         ;
    STA $7100,X                                         ;
    STA $7200,X                                         ;
    STA $7300,X                                         ;
    STA $7400,X                                         ;
    STA $7500,X                                         ;
    STA $7600,X                                         ;
    STA $7700,X                                         ;
    STA $7800,X                                         ;
    STA $7900,X                                         ;
    STA $7A00,X                                         ;
    STA $7B00,X                                         ;

.clearScreenRoutineEntryPointMODE7
    STA $7C00,X                                         ;
    STA $7D00,X                                         ;
    STA $7E00,X                                         ;
    STA $7F00,X                                         ;
    INX                                                 ;
    BEQ .exit7                                          ; if (all done) then branch (exit)
    ; fall through...

    JMP (.vduJumpVectorLow)                             ; loop back (using the jump vector
                                                        ; set up previously) to the
                                                        ; appropriate address for the current
                                                        ; MODE.

.exit7
    RTS                                                 ;

; ***************************************************************************************
.moveTextCursorRight
    LDX .vduTextCursorXPosition                         ; text column
    CPX .vduTextWindowRight                             ; text window right
    BCS .moveTextCursorToLeftEdgeAndDown                ; if (X exceeds window right) then branch
    INC .vduTextCursorXPosition                         ; text column
    LDA .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address low
    ADC .vduBytesPerCharacter                           ; add bytes per character
    TAX                                                 ; X = new low byte of CRTC address
    LDA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address high
    ADC #0                                              ; add carry. A = new high byte of CRTC address
-
    STA .vduTextCursorCRTCAddressHigh                   ;
    STX .vduTextCursorCRTCAddressLow                    ;
    BPL +                                               ;
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
    BMI -                                               ;
+
    JMP .setHardwareCursorAddress                       ;

; ***************************************************************************************
.moveTextCursorToLeftEdgeAndDown
    LDA .vduTextWindowLeft                              ; text window left
    STA .vduTextCursorXPosition                         ; text column
    ; fall through...

; ***************************************************************************************
.moveTextCursorDown
    CLC                                                 ; clear carry
    JSR .handleScrollingInPagedModeInternal             ; check text window bottom edge, X=line count
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowBottom                            ; bottom edge
    BCS +                                               ; if (current text Y position => bottom edge) then branch
    INC .vduTextCursorYPosition                         ; increment current text line
    JMP .setCursorSoftwareAndHardwarePosition           ;

+
    JSR .moveTextCursorToNextLine                       ; move cursor to next line
    LDA #%00001000                                      ; check bit 3 (software scrolling)
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (software scrolling enabled) then branch
    JSR .hardwareScrollUp                               ; perform hardware scroll
    JMP .clearOneLineAndPositionCursor                  ;
+
    JSR .scrollTextWindowUpwards                        ; execute upward software scroll
    ; fall through...

; ***************************************************************************************
.clearOneLineAndPositionCursor
    JSR .clearOneLine                                   ; clear a line
    ; fall through...

; ***************************************************************************************
;
; Set cursor address
;
; Calculates cursor screen addresses and sets the hardware
;
; ***************************************************************************************
.setCursorSoftwareAndHardwarePosition
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
    JMP .setHardwareCursorAddress                       ;

.moveTextCursorLeft
    DEC .vduTextCursorXPosition                         ; decrement text column
    LDX .vduTextCursorXPosition                         ; get new text column
    CPX .vduTextWindowLeft                              ; check against left of text window
    BMI .wrapFromLeftEdgeToRightEdgeOfTextWindow        ; if (less than left edge of text
                                                        ; window) then branch (wrap to right
                                                        ; edge and one line up)
    LDA .vduTextCursorCRTCAddressLow                    ; get text cursor CRTC address (low)
    SEC                                                 ;
    SBC .vduBytesPerCharacter                           ; subtract bytes per character
    TAX                                                 ; put in X
    LDA .vduTextCursorCRTCAddressHigh                   ; get text cursor CRTC address (high)
    SBC #0                                              ; subtract 0 + carry
    CMP .vduStartScreenAddressHighByte                  ; compare with high byte of screen
                                                        ; RAM address
    BCS +                                               ; if (text cursor is not below the
                                                        ; start of the screen address) then
                                                        ; branch forward
    JSR .addNumberOfBytesInACharacterRowToAX2           ;
+
    STA .vduTextCursorCRTCAddressHigh                   ;
    STX .vduTextCursorCRTCAddressLow                    ;
    TAY                                                 ;
    BPL +                                               ;
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
+
    JMP .setHardwareCursorAddress                       ;

; ***************************************************************************************
.wrapFromLeftEdgeToRightEdgeOfTextWindow
    LDA .vduTextWindowRight                             ; load text window right edge
    STA .vduTextCursorXPosition                         ; set current text column

.moveTextCursorUp
    DEC .pagedModeCounter                               ; paged mode counter
    BPL +                                               ; if (not less than zero) then branch (skip next instruction)
    INC .pagedModeCounter                               ; paged mode counter to restore X=0
+
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowTop                               ; top of text window

    BCC .cursorAtTopOfTextWindow                        ;
    BEQ .cursorAtTopOfTextWindow                        ; if (it's at the top of the text window) then branch
    DEC .vduTextCursorYPosition                         ; decrement current text line
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
.cursorAtTopOfTextWindow
    CLC                                                 ; clear carry
    JSR .moveTextCursorToNextLine                       ; move cursor
    LDA #%00001000                                      ; A=8 to check for software scrolling
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (software scrolling enabled) then branch forward
    JSR .hardwareScrollDown                             ; scroll down
    JMP .clearOneLineAndPositionCursor                  ;

+
    JSR .scrollTextWindowDownwards                      ; soft scroll 1 line
.skipScrolling
    JMP .clearOneLineAndPositionCursor                  ; clear one line and exit

; ***************************************************************************************
;
; Paged mode scrolling
;
; When paged mode is enabled, listing lots of text stops scrolling when the screen is full
; until the user presses SHIFT to display the next page of text.
;
; Even without paged mode enabled, holding SHIFT and CTRL will inhibit scrolling (pauses)
; until at least one of the keys is released.
;
; ***************************************************************************************
.handleScrollingInPagedMode
    JSR .clearPagedModeCounter                          ; clear paged mode line counter
.handleScrollingInPagedModeInternal
    ; first check for SHIFT and CTRL pressed together - this loops until at least one key is released
    JSR .osbyte118EntryPoint                            ; OSBYTE 118 - set keyboard LEDs based on current keyboard state
    BCC +                                               ; if (CTRL not pressed) then branch
    BMI .handleScrollingInPagedMode                     ; if (SHIFT pressed) then branch back
+

    ; check flags for relevant state
    LDA .vduStatusByte                                  ; VDU status byte
    ASL                                                 ;
    ASL                                                 ;
    BCS .exit5                                          ;
    AND #%00010000                                      ;
    BEQ .incrementPagedModeAndExit                      ;

    ; check the paged mode counter to see if it has run out of lines
    LDA .pagedModeCounter                               ; paged mode counter
    BMI .storePagedModeCounter                          ; if (negative) then branch (store paged mode counter and exit)

    ; check if we are at the bottom of the screen (exit if not)
    LDA .vduTextCursorYPosition                         ; current text line
    CMP .vduTextWindowBottom                            ; bottom edge
    BCC .incrementPagedModeAndExit                      ; increment line counter and exit

    ; check if we have shown enough lines to fill the text window vertically
    LSR                                                 ; }
    LSR                                                 ; } A = A / 4
    SEC                                                 ; set carry
    ADC .pagedModeCounter                               ; paged mode counter
    ADC .vduTextWindowTop                               ; top of text window
    CMP .vduTextWindowBottom                            ; bottom edge
    BCC .incrementPagedModeAndExit                      ; increment line counter and exit

    CLC                                                 ; clear carry
-
    JSR .osbyte118EntryPoint                            ; OSBYTE 118 - set keyboard LEDs based on current keyboard state
    SEC                                                 ; set carry
    BPL -                                               ; if (SHIFT not pressed) then branch (loop back)
    ; fall through...

.clearPagedModeCounter
    LDA #255                                            ;
.storePagedModeCounter
    STA .pagedModeCounter                               ; set paged mode counter
.incrementPagedModeAndExit
    INC .pagedModeCounter                               ; increment paged mode counter
.exit5
    RTS                                                 ;

; ***************************************************************************************
.moveTextCursorToNextLine
    LDA #2                                              ; A=2 to check if scrolling disabled
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (scrolling is disabled) then branch
    BVS +                                               ; if (cursor editing mode is enabled) then branch
    RTS

+
    LDA .vduTextWindowBottom                            ; bottom edge of text window
    BCC +                                               ; if (carry clear on entry) then branch
    LDA .vduTextWindowTop                               ; get top of text window
+
    BVS .moveTextCursorToNextLineCursorEditing          ; if (cursor editing mode enabled) then branch
    STA .vduTextCursorYPosition                         ; set current text line
    PLA                                                 ; pull return link from stack
    PLA                                                 ;
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
.moveTextCursorToNextLineCursorEditing
    PHP                                                 ; push flags
    CMP .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
    BEQ .pullAndExit2                                   ; if (A = line count) then branch (exit)
    PLP                                                 ; get back flags
    BCC .incYCoordinate                                 ;
    DEC .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
    RTS                                                 ;

; ***************************************************************************************
.incYCoordinate
    INC .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
    RTS                                                 ;

; ***************************************************************************************
.pullAndExit2
    PLP                                                 ;
    RTS                                                 ;

; ***************************************************************************************
; On Entry:
;       A = High byte of 16 bit value
;       X = Low byte of 16 bit value
.addNumberOfBytesInACharacterRowToAX2
    PHA                                                 ; store A
    TXA                                                 ; A=X
    CLC                                                 ;
    ADC .vduBytesPerCharacterRowLow2                    ; add bytes per character row
    TAX                                                 ; put low byte back into X
    PLA                                                 ; recall A
    ADC .vduBytesPerCharacterRowHigh2                   ; add bytes per character row high byte (and carry)
    RTS                                                 ;

; ***************************************************************************************
.subtractNumberOfBytesInACharacterRowToAX
    PHA                                                 ; store A
    TXA                                                 ; A=X
    SEC                                                 ;
    SBC .vduBytesPerCharacterRowLow2                    ; subtract bytes per character row
    TAX                                                 ; put low byte back into X
    PLA                                                 ; recall A
    SBC .vduBytesPerCharacterRowHigh2                   ; subtract bytes per character row high byte (and carry)
    RTS                                                 ;

; ***************************************************************************************
;
; Hardware screen scroll up/down
;
; Changes the start address of the display
;
; ***************************************************************************************
.hardwareScrollDown
    SEC                                                 ;
    LDA .vduScreenTopLeftAddressLow                     ;
    SBC .vduBytesPerCharacterRowLow                     ;
    TAX                                                 ;
    LDA .vduScreenTopLeftAddressHigh                    ;
    SBC .vduBytesPerCharacterRowHigh                    ;
    CMP .vduStartScreenAddressHighByte                  ;
    BCS +                                               ;
    JSR .addNumberOfBytesInACharacterRowToAX2           ;
    JMP +                                               ;

.hardwareScrollUp
    CLC                                                 ;
    LDA .vduScreenTopLeftAddressLow                     ;
    ADC .vduBytesPerCharacterRowLow                     ;
    TAX                                                 ;
    LDA .vduScreenTopLeftAddressHigh                    ;
    ADC .vduBytesPerCharacterRowHigh                    ;
    BPL +                                               ;
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
+
    STA .vduScreenTopLeftAddressHigh                    ; screen top left address high
    STX .vduScreenTopLeftAddressLow                     ; screen top left address low

    LDY #.crtcStartScreenAddressHighRegister            ; Y = value to change screen address
    JMP .setHardwareScreenOrCursorAddress               ;

; ***************************************************************************************
;
; Software scroll text window downwards
;
; ***************************************************************************************
.scrollTextWindowDownwards
    JSR .checkVerticalTextWindowBoundsAndMoveToLeftColumn   ;
    LDA .vduTextWindowBottom                            ; bottom edge
    STA .vduTextCursorYPosition                         ; current text line
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
.loopBackScrollDown
    JSR .subtractNumberOfBytesInARowFromAX              ; subtract bytes per character row
    BCS ++                                              ;

    JSR .addNumberOfBytesInACharacterRowToAX2
    STA .vduTempStoreC5                                 ; store A
    STX .vduTempStoreC4                                 ; X
    STA .vduTempStoreC6                                 ; A again
-
    JSR .copyCharacterLineOfTextWindow                  ; copy line to new position
                                                        ; using (.vduTempStoreDA) for read and
                                                        ; (.vduWriteCursorScreenAddressLow)
                                                        ; for write
    JMP +                                               ;

++
    STA .vduTempStoreC6                                 ; store A
    STX .vduTempStoreC4                                 ; X
    STA .vduTempStoreC5                                 ; A again
    JSR .subtractNumberOfBytesInARowFromAX              ; subtract bytes per character row
    BCC -                                               ; if (outside screen RAM) then branch
    JSR .copyCharacterRow                               ; copy a character row of the text window
+
    LDA .vduTempStoreC6                                 ; set write pointer from read pointer
    LDX .vduTempStoreC4                                 ;
    STA .vduWriteCursorScreenAddressHigh                ;
    STX .vduWriteCursorScreenAddressLow                 ;

    LDX .vduTempStoreC4                                 ;
    DEC .vduTempStoreC8                                 ; decrement window height
    BNE .loopBackScrollDown                             ; if (not zero) then branch (loop back)
.exchangeTextCursorPositionWithWorkspaceAB
    LDA .vduWorkspaceA                                  ;
    STA .vduTextCursorXPosition                         ;
    LDA .vduWorkspaceB                                  ;
    STA .vduTextCursorYPosition                         ; current text line
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 7: Graphics cursor and soft character definitions
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Subtract the number of bytes in a row from AX
;
; On Entry:
;       A = High byte of 16 bit value
;       X = Low byte of 16 bit value
;
; ***************************************************************************************
.subtractNumberOfBytesInARowFromAX
    PHA                                                 ; store A
    TXA                                                 ; A=X
    SEC                                                 ; set carry for subtraction
    SBC .vduBytesPerCharacterRowLow                     ; bytes per character row
    TAX                                                 ; result goes into X
    PLA                                                 ; recall A
    SBC .vduBytesPerCharacterRowHigh                    ; bytes per character row
    CMP .vduStartScreenAddressHighByte                  ; high byte of screen RAM address
    RTS

; ***************************************************************************************
;
; Software scroll text window upwards
;
; ***************************************************************************************
.scrollTextWindowUpwards
    JSR .checkVerticalTextWindowBoundsAndMoveToLeftColumn   ;
    LDY .vduTextWindowTop                               ; top of text window
    STY .vduTextCursorYPosition                         ; current text line
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
.loopBackScrollUp
    JSR .addNumberOfBytesInACharacterRowToAX            ; add bytes per character row
    BPL +                                               ;
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
    STA .vduTempStoreC5                                 ; store A
    STX .vduTempStoreC4                                 ; X
    STA .vduTempStoreC6                                 ; A again
-
    JSR .copyCharacterLineOfTextWindow                  ;
    JMP .finishScroll                                   ;

+
    STA .vduTempStoreC5                                 ; store A
    STX .vduTempStoreC4                                 ; X
    STA .vduTempStoreC6                                 ; A again
    JSR .addNumberOfBytesInACharacterRowToAX            ; add bytes per char. row
    BMI -                                               ; if (outside screen RAM) then branch
    JSR .copyCharacterRow                               ; copy a character row of the text window
.finishScroll
    LDA .vduTempStoreC6                                 ;
    LDX .vduTempStoreC4                                 ;
    STA .vduWriteCursorScreenAddressHigh                ;
    STX .vduWriteCursorScreenAddressLow                 ;
    DEC .vduTempStoreC8                                 ; decrement window height
    BNE .loopBackScrollUp                               ; if (not zero) then branch (loop back)
    JMP .exchangeTextCursorPositionWithWorkspaceAB      ;

; ***************************************************************************************
; On Entry:
;       A = High byte of 16 bit value
;       X = Low byte of 16 bit value
.addNumberOfBytesInACharacterRowToAX
    PHA                                                 ; store A
    TXA                                                 ; A=X
    CLC                                                 ;
    ADC .vduBytesPerCharacterRowLow                     ; add bytes per character row
    TAX                                                 ; put low byte back into X
    PLA                                                 ; recall A
    ADC .vduBytesPerCharacterRowHigh                    ; add bytes per character row high byte (and carry)
    RTS                                                 ;

; ***************************************************************************************
;
; Copy bytes of one character row of the text window
;
; On Entry:
;       .vduTempStoreDA/DB                   is address to copy from
;       .vduWriteCursorScreenAddressLow/High is the destination address
;       .vduTextWindowWidthInBytesLow/High   is number of bytes to copy
; ***************************************************************************************
.copyCharacterRow
    LDX .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    BEQ +                                               ; if (no more than 256 bytes to copy) then branch

    LDY #0                                              ; Y=0 to set loop counter
-
    LDA (.vduTempStoreC4),Y                             ; } copy 256 bytes
    STA (.vduWriteCursorScreenAddressLow),Y             ; }
    INY                                                 ; }
    BNE -                                               ; } loop till Y=0 again
    INC .vduWriteCursorScreenAddressHigh                ; increment high bytes
    INC .vduTempStoreC5                                 ;
    DEX                                                 ; decrement window width
    BNE -                                               ; if (not done yet) then branch (loop back)
+
    LDY .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    BEQ .exit5a                                         ; if (text window is zero bytes wide) then branch (return)
-
    DEY                                                 ; Y=Y-1
    BEQ +                                               ;
-
    LDA (.vduTempStoreC4),Y                             ; copy Y bytes
    STA (.vduWriteCursorScreenAddressLow),Y             ;
    DEY                                                 ;
    BNE -                                               ; if (not done yet) then branch (loop back)
+
    LDA (.vduTempStoreC4),Y                             ; copy last byte
    STA (.vduWriteCursorScreenAddressLow),Y             ;
.exit5a
    RTS                                                 ;

.checkVerticalTextWindowBoundsAndMoveToLeftColumn
    LDA .vduTextCursorXPosition                         ; }
    STA .vduWorkspaceA                                  ; }
    LDA .vduTextCursorYPosition                         ; } workspaceAB = text cursor position
    STA .vduWorkspaceB                                  ; }

    LDA .vduTextWindowLeft                              ;
    STA .vduTextCursorXPosition                         ; left coordinate
    SEC                                                 ;
    LDA .vduTextWindowBottom                            ;
    SBC .vduTextWindowTop                               ;
    STA .vduTempStoreC8                                 ; height
    BNE .exit5a                                         ; if (height not zero) then return
    PLA                                                 ; get back return address (to exit caller routine early)
    PLA                                                 ;
    JMP .exchangeTextCursorPositionWithWorkspaceAB      ; exchange text cursor position with workspaceAB

; ***************************************************************************************
.copyCharacterLineOfTextWindow
    LDA .vduTempStoreC4                                 ; get back A
    PHA                                                 ; push A
    SEC                                                 ; set carry
    LDA .vduTextWindowRight                             ; text window right
    SBC .vduTextWindowLeft                              ; text window left
    TAY                                                 ;
    INY                                                 ;
    TYA                                                 ;
--
    PHA                                                 ;
    LDY .vduBytesPerCharacter                           ;
    DEY                                                 ;
-
    LDA (.vduTempStoreC4),Y                             ; source: copy from .vduTempStoreDA/DB
    STA (.vduWriteCursorScreenAddressLow),Y             ; destination: store to screen
    DEY                                                 ;
    BPL -                                               ; keep copying for one character
    LDX #2                                              ; X=2 loop counter
-
    CLC                                                 ; clear carry
    LDA .vduWriteCursorScreenAddressLow,X               ;
    ADC .vduBytesPerCharacter                           ; move screen pointer on by bytes per character
    TAY
    LDA .vduWriteCursorScreenAddressHigh,X              ;
    ADC #0                                              ;
    BPL +                                               ; if (this remains in screen RAM OK) then branch
    PHA                                                 ;
    TYA                                                 ;
    SEC                                                 ;
    SBC .vduScreenSizeLowByte                           ;
    TAY                                                 ;
    PLA                                                 ;
    SBC .vduScreenSizeHighByte                          ; take off screen RAM size high byte
+
    STA .vduWriteCursorScreenAddressHigh,X              ;
    STY .vduWriteCursorScreenAddressLow,X               ;
    DEX                                                 ; X = X - 2
    DEX                                                 ;
    BEQ -                                               ; if (X = 0) then branch (loop back
                                                        ; to adjust second set of pointers)
    PLA                                                 ;
    SEC                                                 ;
    SBC #1                                              ;
    BNE --                                              ; if (still +ve) then branch (loop
                                                        ; back and do it all again)
    PLA                                                 ; get back A
    STA .vduTempStoreC4                                 ; and store it
    RTS                                                 ;

; ***************************************************************************************
.clearOneLine
    LDA .vduTextCursorXPosition                         ; text column
    PHA                                                 ; save it
    LDA .vduTextWindowLeft                              ;
    STA .vduTextCursorXPosition                         ;
    JSR .validatePositionAndSetupScreenAddress          ;
    SEC                                                 ; set carry
    LDA .vduTextWindowRight                             ; text window right
    SBC .vduTextWindowLeft                              ; text window left
    STA .vduTempStoreC6                                 ; as window width
--
    LDA .vduBackgroundTextColour                        ; background text colour
    LDY .vduBytesPerCharacter                           ; bytes per character
-
    DEY                                                 ; Y=Y-1 decrementing loop counter
    STA (.vduWriteCursorScreenAddressLow),Y             ; store background colour at this
                                                        ; point on screen
    BNE -                                               ; if (Y is not zero) then branch
                                                        ; (loop back)
    TXA                                                 ; A=X
    CLC                                                 ; clear carry to add
    ADC .vduBytesPerCharacter                           ; bytes per character
    TAX                                                 ; X=A restoring it
    LDA .vduWriteCursorScreenAddressHigh                ; get high byte
    ADC #0                                              ; add carry if any
    BPL +                                               ; if (+ve) then branch
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
+
    STX .vduWriteCursorScreenAddressLow                 ; restore values
    STA .vduWriteCursorScreenAddressHigh                ;
    DEC .vduTempStoreC6                                 ; decrement window width
    BPL --                                              ; and if not 0 do it all again
    PLA                                                 ; get back A
    STA .vduTextCursorXPosition                         ; restore text column
    RTS                                                 ;

; ***************************************************************************************
.validatePositionAndSetupScreenAddress
    LDX .vduTextCursorXPosition                         ; get text cursor X position
    CPX .vduTextWindowLeft                              ; test against left edge of text window
    BMI .setCarryAndReturn                              ; if (less than left edge) then branch (return with carry set)
    CPX .vduTextWindowRight                             ; test against right edge of text window
    BEQ +                                               ; if (equal to right edge) then branch (thats OK)
    BPL .setCarryAndReturn                              ; if (greater than right edge) then branch (return with carry set)
+
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowTop                               ; test against top edge of text window
    BMI .setCarryAndReturn                              ; if (less than top edge) then branch (return with carry set)
    CPX .vduTextWindowBottom                            ; test against bottom edge of text window
    BEQ .setTextCursorScreenAddresses                   ; if (equal to bottom edge) then branch (ok to set cursor screen addresses)
    BPL .setCarryAndReturn                              ; if (greater than bottom edge) then branch (return with carry set)
    ; fall through...

; ***************************************************************************************
;
; Set text cursor screen addresses from X,Y position
;
; Let X,Y be the text cursor position (in absolute character cells from top left corner)
;
;     MODE 0: address = screen_start + Y*640 + X* 8
;     MODE 1: address = screen_start + Y*640 + X*16
;     MODE 2: address = screen_start + Y*640 + X*32
;     MODE 3: address = screen_start + Y*640 + X* 8
;     MODE 4: address = screen_start + Y*320 + X* 8
;     MODE 5: address = screen_start + Y*320 + X*16
;     MODE 6: address = screen_start + Y*320 + X* 8
;     MODE 7: address = screen_start + Y* 40 + X
;
; Given the text cursor X,Y position, use the multiplication table and other characteristic
; values for the current MODE to calculate the address on screen.
;
; On Entry:
;       .vduTextCursorX/YPosition stores the X,Y coordinates of the text cursor
;
; On Exit:
;       Carry clear
;       Stores the result in .vduTextCursorCRTCAddressLow/High, then wraps the address back on
;       screen if beyond the bottom of the screen. Store the new wrapped result in
;       .vduWriteCursorScreenAddressLow/High.
;
; ***************************************************************************************
.setTextCursorScreenAddresses
    LDA .vduTextCursorYPosition                         ; current text line
    ASL                                                 ; multiply by two to get table offset
    TAY                                                 ; Y=A
    LDA .vduScreenTopLeftAddressLow                     ;
    ADC (.vduMultiplicationTableLow),Y                  ; get low byte
    STA .vduWriteCursorScreenAddressLow                 ;
    LDA .vduScreenTopLeftAddressHigh                    ;
    INY                                                 ;
    ADC (.vduMultiplicationTableLow),Y                  ; get high byte
    TAY                                                 ; store in Y
    LDA .vduTextCursorXPosition                         ; text column
    LDX .vduBytesPerCharacter                           ; bytes per character
    DEX                                                 ; X=X-1
    BEQ .mode7Cursor                                    ; if (in MODE 7) then branch
    CPX #15                                             ; is it mode 1 or mode 5? (four colour modes = 16 bytes per character)
    BEQ .mode1or5Cursor                                 ; if (mode 1 or 5) then branch (with carry set)
    BCC .mode0346Cursor                                 ; if (mode 0,3,4, or 6) then branch (with carry clear)
    ASL                                                 ; A=A*16 if entered here (MODE 2)
.mode1or5Cursor
    ASL                                                 ; A=A*8 if entered here
.mode0346Cursor
    ASL                                                 ; A=A*4 if entered here
    ASL                                                 ;
    BCC .skipIncs                                       ; if (carry clear) then branch
    INY                                                 ; Y=Y+2
    INY                                                 ; Y is the high byte of the address
.skipIncs
    ASL                                                 ; A=A*2
    BCC .skipInc                                        ; if (carry clear) branch (to add to .vduWriteCursorScreenAddressLow)
    INY                                                 ; Y=Y+1
.mode7Cursor
    CLC                                                 ; clear carry
.skipInc
    ADC .vduWriteCursorScreenAddressLow                 ; add to .vduWriteCursorScreenAddressLow

    TAX                                                 ; X=A
    TYA                                                 ; A=Y
    ADC #0                                              ; add carry if set
    STA .vduTextCursorCRTCAddressHigh                   ; store the text cursor CRTC address (before any wraparound)
    STX .vduTextCursorCRTCAddressLow                    ;
    BPL +                                               ; if (not negative) then branch
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
+
    STA .vduWriteCursorScreenAddressHigh                ; store in high byte
    STX .vduWriteCursorScreenAddressLow                 ;
    CLC                                                 ; clear carry
    RTS                                                 ;

.setCarryAndReturn
    SEC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.displayACharacter
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .displayCharacterMODE7                          ; if (MODE 7) then branch
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    ; fall through...

; ***************************************************************************************
.displayACharacterAtAddress
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00100000                                      ; and check bit 5 (printing at graphics cursor)
    BEQ +                                               ;
    JMP .plotACharacterAtGraphicsCursor                 ;
+
    LDY #7                                              ; Y=7
    CPX #3                                              ;
    BEQ .displayACharacter4ColourMODE                   ; if (X = 3) then branch to handle 4 colour MODEs
    BCS .displayACharacter16ColourMODE                  ; if (X > 3) then branch to deal with 16 colours

    ; display a character in a 2 colour MODE
-
    LDA (.vduTempStoreC8),Y                             ; get pattern byte
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    DEY                                                 ; Y=Y-1
    BPL -                                               ; if (still +ve) then branch (loop back)
    RTS                                                 ;

; ***************************************************************************************
.displayCharacterMODE7
    LDY #2                                              ; Y=2, loop counter/index into the teletext conversion table
-
    CMP .teletextCharacterConversionTable,Y             ; compare with teletext conversion table
    BEQ .convertMODE7Character                          ; if (found character to convert) then branch
    DEY                                                 ; Y=Y-1
    BPL -                                               ; loop back until done
.writeByteToMODE7Screen
    STA (.vduWriteCursorScreenAddressLow,X)             ; write byte to screen
    RTS                                                 ;

; ***************************************************************************************
.convertMODE7Character
    LDA .teletextCharacterConversionTable + 1,Y         ; convert with teletext conversion table
    BNE .writeByteToMODE7Screen                         ; ALWAYS branch back to write it

; ***************************************************************************************
.displayACharacter4ColourMODE
    LDA (.vduTempStoreC8),Y                             ; get pattern byte
    PHA                                                 ; save it
    LSR                                                 ; move high nybble to low
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    TAX                                                 ; X=A
    LDA .fourColourMODEByteMaskTable,X                  ; convert 4 bits of the character
                                                        ; definition into bytes to write
                                                        ; to the screen
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    TYA                                                 ; A=Y
    CLC                                                 ; clear carry
    ADC #8                                              ; add 8 to move screen RAM pointer 8 bytes
    TAY                                                 ; Y=A
    PLA                                                 ; get back A
    AND #%00001111                                      ; clear high nybble
    TAX                                                 ; X=A
    LDA .fourColourMODEByteMaskTable,X                  ; 4 colour MODE byte mask look up table
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    TYA                                                 ; A=Y
    SBC #8                                              ; A=A-9
    TAY                                                 ; Y=A
    BPL .displayACharacter4ColourMODE                   ; if (not negative) then branch (loop back)
.exit9
    RTS                                                 ;

; ***************************************************************************************
.nextPatternByte
    TYA                                                 ; Y=Y-$21
    SBC #$21                                            ;
    BMI .exit9                                          ; if (Y is negative) then branch (return)
    TAY                                                 ; A=Y
    ; fall through...

; ***************************************************************************************
.displayACharacter16ColourMODE
    LDA (.vduTempStoreC8),Y                             ; get pattern byte
    STA .vduTempStoreC6                                 ; store it
    SEC                                                 ; set carry
.iloop
    LDA #0                                              ; A=0
    ROL .vduTempStoreC6                                 ; carry now occupies bit 0 of DC
    BEQ .nextPatternByte                                ; when DC=0 again branch to deal
                                                        ; with next pattern byte
    ROL                                                 ; get bit 7 from .vduTempStoreC6 into A bit 0
    ASL .vduTempStoreC6                                 ; rotate again to get second
    ROL                                                 ; bit into A
    TAX                                                 ; and store result in X
    LDA .sixteenColourMODEByteMaskTable,X               ; convert two bits of the character
                                                        ; definition into bytes to write
                                                        ; to the screen
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; and store result
    CLC                                                 ; }
    TYA                                                 ; }
    ADC #8                                              ; } Y=Y+8 moving screen RAM pointer on 8 bytes
    TAY                                                 ; }
    BCC .iloop                                          ; branch back to deal with next bit pair
    ; fall through...

; ***************************************************************************************
;
; Get character definition address
;
; On Entry:
;       A is the ascii code for a printable character 32-255 (bit pattern abcdefgh)
; On Exit:
;       .vduTempStoreC8/F is the address of the character definition either from the default
;                      ROM characters or the soft character definitions
; ***************************************************************************************
.getCharacterDefinitionAddress
    ASL                                                 ; bcdefgh0  C=a
    ROL                                                 ; cdefgh0a  C=b
    ROL                                                 ; defgh0ab  C=c
    STA .vduTempStoreC8                                 ; save this pattern (defgh0ab)
    AND #%00000011                                      ; 000000ab
    ROL                                                 ; 00000abc  C=0
    TAX                                                 ; X = soft font zone (1 - 7)
    AND #%00000011                                      ; A = 000000bc (1 - 3)
    ADC #>.characterDefinitions - 1                     ; A = high byte of character definitions ($C0, $C1, $C2)
    TAY                                                 ; Y = high byte of ROM address of character
    LDA .fontMaskTable,X                                ; get single bit set depending on X (1-7)
    BIT .vduFontFlags                                   ; test font flags to see if there are soft character definitions
    BEQ +                                               ; if (hard character definitions) then branch
    LDY .vduFontZoneAddressesHigh1 - 1,X                ; get high byte from table for soft character definitions
+
    STY .vduTempStoreC9                                 ; store Y in high byte of address
    LDA .vduTempStoreC8                                 ; get back pattern (defgh0ab)
    AND #%11111000                                      ; defgh000
    STA .vduTempStoreC8                                 ; and store it. This is 8 times the
                                                        ; ASCII character giving the low
                                                        ; byte of the address
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 8: PLOT
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Plot routine
;
; See plot.png
; The plot routine is a multi-purpose tool for drawing graphics. It renders points,
; lines, dotted lines, filled triangles, and single horizontal line fills. It can also just
; move the current graphics cursor position. The lower three bits of the plot type hold plot
; options:
;
; Plot Options:
;   0         Move relative to last point
;   1         Draw relative to last point in foreground colour
;   2         Draw relative to last point in inverse colour
;   3         Draw relative to last point in background colour
;   4         Move absolute
;   5         Draw absolute in foreground colour
;   6         Draw absolute in inverse colour
;   7         Draw absolute in background colour
;
; ---------------------------------------------------------------------------------------
; PLOT TYPE   RANGE IN BINARY      BITS3-6    DESCRIPTION
; RANGE       abcdefgh-abcdefgh    bcde
; ---------------------------------------------------------------------------------------
; 0-7         00000000-00000111    0000       Move/Draw line with standard options 0-7
; 8-15        00001000-00001111    0001       As 0-7 but with the last point in a line omitted
;                                             when plotting with GCOL mode 3 (EOR) or 4
;                                             (INVERT)
; 16-23       00010000-00010111    0010       As 0-7 but with a dotted line
; 24-31       00011000-00011111    0011       As 0-7 but with a dotted line and the last point
;                                             in a line omitted when plotting with GCOL mode 3
;                                             (EOR) or 4 (INVERT)
; 32-39       00100000-00100111    0100       RESERVED for future expansion
; 40-47       00101000-00101111    0101       RESERVED for future expansion
; 48-55       00110000-00110111    0110       RESERVED for future expansion
; 56-63       00111000-00111111    0111       RESERVED for future expansion
; 64-71       01000000-01000111    1000       As 0-7 but only a single point is plotted
; 72-79       01001000-01001111    1001       As 0-7 but fill one line horizontally left and
;                                             right
; 80-87       01010000-01010111    1010       As 0-7 but fill a triangle
; 88-95       01011000-01011111    1011       As 0-7 but fill one line horizontally right
; 96-103      01100000-01100111    1100       RESERVED for future expansion
; 104-111     01101000-01101111    1101       RESERVED for future expansion
; 112-119     01110000-01110111    1110       RESERVED for future expansion
; 120-127     01111000-01111111    1111       RESERVED for future expansion
; 128-255     10000000-11111111    xxxx       RESERVED for future expansion
; ---------------------------------------------------------------------------------------
;
; Coordinate Systems
;
; The standard graphics coordinate system ranges from (0,0) at the bottom left of the screen
; to (1280 x 1024) at the top right. This coordinate range represents the entire screen
; regardless of the actual number of pixels available on screen.
;
; The graphics window origin can be changed to specify where a pixel drawn at (0,0) actually
; appears on the screen. This is a translation of the coordinate system.
;
; These resolution independent coordinates are called 'external' coordinates in this document.
;
; When calling the OS, external coordinates can optionally be specified 'relative' to the last
; point plotted. Coordinates are also always specified relative to the current graphics window
; origin. When translated into full screen coordinates these are known here as 'absolute'
; coordinates.
;
; Within OS routines absolute coordinates are scaled down to a pixel based scale. These are
; called 'pixel' coordinates. Pixel coordinates are never 'relative' coordinates in the sense
; above, but that doesn't stop OS routines temporarily storing the difference between two
; pixel based coordinates as part of its calculations of course.
;
; Conversions between the coordinate systems are done via:
;
;       .plotConvertExternalAbsoluteCoordinatesToPixels
;       .plotConvertExternalRelativeCoordinatesToPixels
;       .convertPixelGraphicsCoordinatesToExternal
;
; ***************************************************************************************
.vdu25ParameterPlotType = .vduQueueStartByte + 4
.vdu25ParameterXLow     = .vduQueueStartByte + 3
.vdu25ParameterXHigh    = .vduQueueStartByte + 2
.vdu25ParameterYLow     = .vduQueueStartByte + 1
.vdu25ParameterYHigh    = .vduQueueStartByte

.vdu25Plot
    LDA .vdu25ParameterPlotType                         ;
    STA .vduPlotType                                    ; set plot type from parameter

    LDX #.vduQueueStartByte - .vduVariablesStart3       ; X is offset to X Coordinate (low)
    JSR .plotConvertExternalRelativeCoordinatesToPixels ; translate coordinates

    LDA .vduPlotType                                    ; get plot type

    AND #3                                              ; mask only bits 0 and 1
    BEQ .plotMoveGraphicsCursorInAbsolutePixels         ; if (result is 0) then branch (it's a move operation)
    ROR                                                 ;
    BCS .plotWithGraphicsColour                         ; if (plot option needs foreground or background graphics colour) then branch
    LDY #4                                              ;
    BNE +                                               ; ALWAYS branch. The logic inverse colour must be wanted

; ***************************************************************************************
;
; Plot with graphics character
;
; On Entry:
;       A=0 it's a foreground colour
;       A=1 it's a background colour
;
; ***************************************************************************************
.plotWithGraphicsColour
    LDY .vduBackgroundGCOLMode                          ;
    LDX .vduBackgroundGraphicsColour                    ;
    ROR                                                 ;
    BCS +                                               ;
    LDX .vduForegroundGraphicsColour                    ;
    LDY .vduForegroundGCOLMode                          ;
+
    JSR .setGraphicsColourMaskXY                        ;
    LDA .vduPlotType                                    ;
    BMI .plotExtensionLocal                             ; if (128-255) then branch (it's RESERVED for future expansion)

    ; deal with plot 0-127
    ASL                                                 ; bcdefgh0
    BPL .plotType0to63                                  ; if (bit 7 is now 0, i.e. plot type is 0-63) then branch

    ; deal with plot 64-127
    AND #%11110000                                      ; bcde0000
    ASL                                                 ; cde00000
    BEQ .plotPointAndMove                               ; if (zero) then branch (plot type 64-71 was called, single point plot)
    CMP #$40                                            ;
    BNE .plotExtensionLocal                             ;
    JMP .plotFillTriangle                               ;

; ***************************************************************************************
.plotExtensionLocal
    LDX #>.vduVariablesStart3                           ;
    LDY #<.vduVariablesStart3                           ;
    JMP (.vectorVDUV)                                   ;

; ***************************************************************************************
;
; Set graphics colour and GCOL mode bytes
;
; When writing graphics pixels to the screen, two bytes are used to adjust the byte to write
; based on the current colour and GCOL mode.
; This routine sets these two bytes .vduGraphicsColourByteOR and .vduGraphicsColourByteEOR
;
; GCOL Mode
; ---------
; 0 = Normal Mode: Sets the pixel to the current colour
; 1 =     OR Mode: Sets the pixel to the current colour  OR-ed with the colour on screen
; 2 =    AND Mode: Sets the pixel to the current colour AND-ed with the colour on screen
; 3 =    EOR Mode: Sets the pixel to the current colour EOR-ed with the colour on screen
; 4 = Invert Mode: Inverts the colour already on screen
;
; Suppose 'C' is the byte that when written to the screen sets each pixel of the byte to
; the current graphics colour.
;
; Then the two bytes are set as follows:
;       ------------------------------------------------------------------------
;       0=Normal Mode  | .vduGraphicsColourByteOR  = (C OR $FF) EOR $00 = $FF
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $FF = C EOR $FF
;       ------------------------------------------------------------------------
;       1=OR Mode      | .vduGraphicsColourByteOR  = (C OR $00) EOR $00 = C
;                      | .vduGraphicsColourByteEOR = (C OR $FF) EOR $FF = 0
;       ------------------------------------------------------------------------
;       2=AND Mode     | .vduGraphicsColourByteOR  = (C OR $00) EOR $FF = C EOR $FF
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $FF = C EOR $FF
;       ------------------------------------------------------------------------
;       3=EOR Mode     | .vduGraphicsColourByteOR  = (C OR $FF) EOR $FF = 0
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $00 = C
;       ------------------------------------------------------------------------
;       4=Invert Mode  | .vduGraphicsColourByteOR  = (C OR $FF) EOR $FF = 0
;                      | .vduGraphicsColourByteEOR = (C OR $FF) EOR $00 = $FF
;       ------------------------------------------------------------------------
;
; When writing a pixel, start with a byte 'B', just the bits required to set one pixel to
; white. Then the pixel is written like so:
;
;            temp = (B AND .vduGraphicsColourByteOR) OR (current screen byte)
; new screen byte = (.vduGraphicsColourByteEOR AND B) EOR temp
;
; [A quirk: This routine is called with Y=5 for a relative move PLOT operation, but as
;           there's nothing to draw, the results are unused in this case.]
;
; On Entry:
;       X = colour byte to set
;       Y = GCOL Mode (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
;
; On Exit:
;       .vduGraphicsColourByteOR / EOR hold the appropriate mask values
;
; ***************************************************************************************
.setGraphicsColourMaskXY
    TXA                                                 ; A=X
    ORA .gcolPlotOptionsTable,Y                         ; OR with GCOL plot options table byte
    EOR .gcolPlotOptionsTable + 5,Y                     ; EOR with following byte
    STA .vduGraphicsColourByteOR                        ; and store it
    TXA                                                 ; A=X
    ORA .gcolPlotOptionsTable + 10,Y                    ;
    EOR .gcolPlotOptionsTable + 15,Y                    ;
    STA .vduGraphicsColourByteEOR                       ; masks are stored in .vduGraphicsColourByteOR/EOR
    RTS                                                 ;

; ***************************************************************************************
; Continue processing of a PLOT command, where the plot type is in the range 0-63
.plotType0to63
    ASL                                                 ; cdefgh00
    BMI .plotExtensionLocal                             ; if (options are in range 32-63) then branch (not implemented)
    ASL                                                 ; defgh000
    ASL                                                 ; efgh0000
    TAY                                                 ;
    TYA                                                 ;
    BCC +                                               ;
    JSR .plotPoint                                      ; type is 8-15 or 24-31. We want to
                                                        ; omit the last point when drawing
                                                        ; in invert mode, so we do this by
                                                        ; displaying a point, which will get
                                                        ; inverted (erased) again in the
                                                        ; normal course of drawing the line.
+
    JSR .plotLine                                       ; draw a line or dotted line
    JMP .plotMoveGraphicsCursorInAbsolutePixels         ; move the graphics cursor

.plotPointAndMove
    JSR .plotPointInternal                              ;

.plotMoveGraphicsCursorInAbsolutePixels
    LDX #.vduGraphicsCursorPixelsYHigh    - .vduVariablesStart3 ;
    LDY #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart3 ;
    JSR .copyFourBytesWithinVDUVariables                        ;
    LDX #.vdu25ParameterYHigh - .vduVariablesStart3             ;
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
    JMP .copyFourBytesWithinVDUVariables                        ;

; ***************************************************************************************
.plotPoint
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3  ;
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; calculate position
    BEQ .plotPointWithinBounds                          ; if (within bounds) then branch
    RTS                                                 ;

; ***************************************************************************************
;
; Plots a single point
;
; This checks the point against the graphics window, gets the screen address details, then
; renders the pixel by writing to the screen address, applying the colour masks and plot type.
;
; On Entry:
;       X holds the offset into the VDU variables for four bytes holding the position to plot
;       at.
;
; ***************************************************************************************
.plotPointInternal
    JSR .checkParameterInBoundsAndSetScreenAddresses    ; check in bounds and set up screen addresses
    BNE +                                               ; if (A is not zero) then branch (return)
.plotPointWithinBounds
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; get current graphics scan line
.plotPointWithinBoundsAtY
    LDA .vduCurrentPlotByteMask                         ;
    AND .vduGraphicsColourByteOR                        ;
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    STA .vduTempStoreC4                                 ;
    LDA .vduGraphicsColourByteEOR                       ;
    AND .vduCurrentPlotByteMask                         ;
    EOR .vduTempStoreC4                                 ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; put it back again
+
    RTS

; ***************************************************************************************
;
; Check that the graphics cursor is within the graphics window
;
; On Exit:
;   .vduTempStoreC4 is zero if the point is within the graphics window, or the four low bits
;                indicate which regions failed:
;
;       %0000   success (point is within window)
;       %0001   graphics cursor X is left of  the left   edge of the graphics window
;       %0010   graphics cursor X is right of the right  edge of the graphics window
;       %0100   graphics cursor Y is below    the bottom edge of the graphics window
;       %1000   graphics cursor Y is above    the top    edge of the graphics window
;
; ***************************************************************************************
.checkPointXIsWithinGraphicsWindow
    LDY #0                                              ;
    STY .vduTempStoreC4                                 ; .vduTempStoreC4 is initialised to zero (stores the error code)
    JSR .checkPointIsWithinWindowHorizontalOrVertical   ;
    ASL .vduTempStoreC4                                 ; } Shift up error results two bits to make room for the next horizontal test results
    ASL .vduTempStoreC4                                 ; }
    INX                                                 ;
    INX                                                 ;
    LDY #2                                              ; Y is the index to check the vertical bounds of the graphics window
    JSR .checkPointIsWithinWindowHorizontalOrVertical   ;
    DEX                                                 ; }
    DEX                                                 ; } Restore X to initial value
    LDA .vduTempStoreC4                                 ; A = error code (0,1,2,4,5,6,8,9,10) depending on which bounds are exceeded
    RTS                                                 ;

; ***************************************************************************************
;
; Check coordinate of a point is in the window bounds (horizontal or vertical)
;
; On Entry:
;       X is the offset to the coordinate to check minus two bytes
;       Y is the offset to the second variable to check (0 for horizontal or 2 for vertical)
; On Exit:
;       .vduTempStoreC4 is the error code (0 = no error, 1 = first check failed, 2 = second check
;       failed)
;       Zero flag set if no error
; ***************************************************************************************
.checkPointIsWithinWindowHorizontalOrVertical
    LDA .vduVariablesStart3 + 1,X                       ; } Subtract two sixteen bit variables, compare the results.
    CMP .vduVariablesStart3 + 5,Y                       ; }
    LDA .vduVariablesStart3 + 0,X                       ; }
    SBC .vduVariablesStart3 + 4,Y                       ; }
    BMI .oneError                                       ; branch if error

    LDA .vduVariablesStart3 + 1,Y                       ; } Subtract two sixteen bit variables, compare the results.
    CMP .vduVariablesStart3 + 1,X                       ; }
    LDA .vduVariablesStart3 + 0,Y                       ; }
    SBC .vduVariablesStart3 + 0,X                       ; }
    BPL .exit9a                                         ; if (no violation) then branch (exit)
    INC .vduTempStoreC4                                 ; increment error code
.oneError
    INC .vduTempStoreC4                                 ; increment error code
.exit9a
    RTS                                                 ;

; ***************************************************************************************
;
; Convert external relative coordinates to pixels
;
; Convert pair of external coordinates to pixels (horizontal and vertical)
;
; On Entry:
;       X is the offset in vdu variables to the coordinate to convert
;
; ***************************************************************************************
.plotConvertExternalRelativeCoordinatesToPixels
    LDY #0                                              ;
    JSR .convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo  ; convert
    JSR .signedDivideCoordinateByTwo                                ; divide by 2 again to
                                                                    ; convert 1023 to 0-255
                                                                    ; for pixels
    LDY #2                                                          ; Y=2 (for horizontal
                                                                    ; coordinate)
    INX                                                             ;
    INX                                                             ; X+=2
    JSR .convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo  ; convert
    LDY .vduPixelsPerByteMinusOne                       ; get number of pixels per byte (-1)
                                                        ;     7 for MODE 0
                                                        ;     3 for MODE 1
                                                        ;     1 for MODE 2
                                                        ;     0 for MODE 3
                                                        ;     7 for MODE 4
                                                        ;     3 for MODE 5
                                                        ;     0 for MODE 6
                                                        ;     0 for MODE 7

    CPY #3                                              ;
    BEQ +                                               ; if (MODE 1 or 5) then branch (divide by 2)
    BCS .doneDividing                                   ; if (MODE 0 or 4) then branch (no division needed)
    JSR .signedDivideCoordinateByTwo

+
    JSR .signedDivideCoordinateByTwo                    ; divide by 2
.doneDividing
    LDA .vduBytesPerCharacterRowHigh                    ; MODE 0-3 = 2; MODE 4-6 = 1; MODE 7 = 0
    ROR                                                 ; Carry set for MODEs 0-3
    BCC .exit9a                                         ;
    JMP .signedDivideCoordinateByTwo                    ;

; ***************************************************************************************
;
; Converts the vdu queue parameter to absolute coordinates and divides by two
;
; On Entry:
;       X               is the offset to the vdu queue parameter coordinate to convert
;       Y               is 0 or 2 for the vertical or horizontal cursor coordinates
;       .vduPlotType    is the plot type (to check for relative coordinate conversion)
;
; ***************************************************************************************
.convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo
    CLC                                                 ; clear carry
    LDA .vduPlotType                                    ;
    AND #4                                              ; }
    BEQ .addPreviousCoordinate                          ; } if (relative coordinates) then branch (add previous coordinate)
    LDA .vduGraphicsWindowPixelsTopLow,X                ; get coordinate
    PHA                                                 ;
    LDA .vduGraphicsWindowPixelsTopHigh,X               ;
    BCC .addGraphicsOrigin                              ; ALWAYS branch

.addPreviousCoordinate
    LDA .vduGraphicsWindowPixelsTopLow,X                ; get coordinate
    ADC .vduGraphicsCursorPositionXLow,Y                ; add cursor position
    PHA                                                 ; save it
    LDA .vduGraphicsWindowPixelsTopHigh,X               ;
    ADC .vduGraphicsCursorPositionXHigh,Y               ; add cursor
    CLC                                                 ; clear carry

.addGraphicsOrigin
    STA .vduGraphicsCursorPositionXHigh,Y               ; save new cursor
    ADC .vduGraphicsWindowOriginXHigh,Y                 ; add graphics origin
    STA .vduGraphicsWindowPixelsTopHigh,X               ; store it
    PLA                                                 ; get back low byte
    STA .vduGraphicsCursorPositionXLow,Y                ; save it in new cursor low
    CLC                                                 ; clear carry
    ADC .vduGraphicsWindowOriginXLow,Y                  ; add to graphics orgin
    STA .vduGraphicsWindowPixelsTopLow,X                ; store it
    BCC .signedDivideCoordinateByTwo                    ; if (carry clear) then branch (skip over next statement)
    INC .vduGraphicsWindowPixelsTopHigh,X               ; increment high byte
    ; fall through...

; ***************************************************************************************
;
; Divides the signed 16 bit coordinate value by two
;
; On Entry:
;       X is the offset to the coordinate from .vduGraphicsWindowPixelsTopHigh
;
; ***************************************************************************************
.signedDivideCoordinateByTwo
    LDA .vduGraphicsWindowPixelsTopHigh,X               ; get high byte
    ASL                                                 ;
    ROR .vduGraphicsWindowPixelsTopHigh,X               ; divide by 2
    ROR .vduGraphicsWindowPixelsTopLow,X                ;
    RTS                                                 ;

; ***************************************************************************************
;
; Convert pixel coordinates to external absolute coordinates
;
; ***************************************************************************************
.convertPixelGraphicsCoordinatesToExternal
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
    LDY #.vduGraphicsCursorPositionXHigh - .vduVariablesStart3  ;
    JSR .copyFourBytesWithinVDUVariables                ;
    LDX #0                                              ; X=0 (offset to update the vertical coordinate)
    LDY #2                                              ; Y=2 (shift twice to multiply by four)
    JSR +                                               ; multiply .vduGraphicsCursorPositionY by 4 and subtract graphics origin
                                                        ; this is the external Y coordinate.
    LDX #2                                              ; X=2 (offset to update the horizontal coordinate)
    LDY #4                                              ; Y=4
    LDA .vduPixelsPerByteMinusOne                       ; get number of pixels/byte
-
    DEY                                                 ; Y=Y-1
    LSR                                                 ; divide by 2
    BNE -                                               ; if (result not 0) then branch (loop back)

    ; Pixels                                     Number of
    ; per byte   Screen     Y       MODE       multiplication
    ; minus one   MODE     Now      group      steps (#shifts)
    ; --------------------------------------------------------
    ;    7       MODE 0     1         0              1  (x1)
    ;    3       MODE 1     2         0              2  (x2)
    ;    1       MODE 2     3         0              3  (x4)
    ;    0       MODE 3     -         1              -
    ;    7       MODE 4     1         2              2  (x2)
    ;    3       MODE 5     2         2              3  (x4)
    ;    0       MODE 6     -         3              -
    ;    0       MODE 7     -         4              -
    ; --------------------------------------------------------

    LDA .vduBytesPerCharacterRowHigh                    ; MODE 0-3 = 2; MODE 4-6 = 1; MODE 7 = 0
    ROR                                                 ; Carry set for MODEs 0-3
    BCC +                                               ;
    INY                                                 ;
+
-
    ASL .vduGraphicsCursorPositionXLow,X                ; } multiply coordinate by 2
    ROL .vduGraphicsCursorPositionXHigh,X               ; }
    DEY                                                 ; Y-Y-1
    BNE -                                               ; if (Y != 0) then branch (do it again)
    LDY #2                                              ;
    INX                                                 ;
    SEC                                                 ;
-
    LDA .vduGraphicsCursorPositionXHigh,X               ; get current graphics position in external coordinates
    SBC .vduGraphicsWindowOriginXHigh,X                 ; subtract origin
    STA .vduGraphicsCursorPositionXHigh,X               ; store in graphics cursor position
    DEX                                                 ;
    DEY                                                 ;
    BNE -                                               ;
    RTS                                                 ;


; ***************************************************************************************
;
; Check the graphics point on the VDU queue is within the graphics window
;
; ***************************************************************************************
.checkParameterInBoundsAndSetScreenAddresses
    LDX #.vdu25ParameterYHigh - .vduVariablesStart3     ; X is the offset to the desired parameter for the point in graphics coordinates
    ; fall through...

; ***************************************************************************************
;
; Check the given point is within the graphics window
;
; Takes the graphics coordinates pointed to by X, checks whether they are in the bounds of
; the graphics window, and if so sets up screen addresses.
;
; On Entry:
;       X is the vdu variables offset to the graphics point to check
; On Exit:
;       .vduScreenAddressOfGraphicsCursorCellLow/High is the screen address
;       Y is the vertical offset within the character cell (0-7)
;       Z is clear (i.e. BNE will branch) if coordinates are outside the graphics area
; ***************************************************************************************
.checkPointXInBoundsAndSetScreenAddresses
    JSR .checkPointXIsWithinGraphicsWindow              ;
    BNE .exitN                                          ;
.setScreenAddress
    LDA .vduGraphicsWindowPixelsRightHigh - 1,X         ; read low byte of Y coordinate
    EOR #$FF                                            ; Flip the coordinates to be from the top of the screen
    TAY                                                 ; Remember in Y
    AND #7                                              ; A = row within a character cell
    STA .vduGraphicsCursorVerticalOffsetInCell          ; store row (0-7)
    TYA                                                 ; A=Y
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } divide by 8
    ASL                                                 ; Multiply by two to give the offset in the multiplication table
    TAY                                                 ; Y = offset into multiplication table
    LDA (.vduMultiplicationTableLow),Y                  ; Get high byte of offset from screen RAM start
    ADC .vduScreenTopLeftAddressLow                     ;
    STA .vduScreenAddressOfGraphicsCursorCellLow        ;
    INY                                                 ; Y=Y+1
    LDA (.vduMultiplicationTableLow),Y                  ; get low byte
    ADC .vduScreenTopLeftAddressHigh                    ;
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ;
    LDA .vduGraphicsWindowPixelsRightHigh,X             ;
    STA .vduTempStoreC4                                 ; store x coordinate of point (high)
    LDA .vduGraphicsWindowPixelsBottomHigh - 1,X        ; get x coordinate of point (low)
    PHA                                                 ; remember it
    AND .vduPixelsPerByteMinusOne                       ; get the horizontal X offset within the range of pixelsPerByte
    ADC .vduPixelsPerByteMinusOne                       ; add the pixels per byte minus one,
                                                        ; which offsets to (one more than) the
                                                        ; start of the MODE mask table for the
                                                        ; current MODE
    TAY                                                 ; Y=A
    LDA .sixteenColourMODEMaskTable - 1,Y               ; read byte mask
    STA .vduCurrentPlotByteMask                         ; store it
    PLA                                                 ; get back A
    LDY .vduPixelsPerByteMinusOne                       ; Y=number of pixels per byte minus one
    CPY #3                                              ; compare with 3
    BEQ +                                               ; if (MODE 1 or 5) then branch forward
    BCS ++                                              ; if (MODE 0 or 4) then branch forward
    ASL                                                 ; }
    ROL .vduTempStoreC4                                 ; } (A,.vduTempStoreC4) *= 2
+
    ASL                                                 ; }
    ROL .vduTempStoreC4                                 ; } (A,.vduTempStoreC4) *= 2
++
    AND #%11111000                                      ; clear bits 0-2
    CLC                                                 ; clear carry
    ADC .vduScreenAddressOfGraphicsCursorCellLow        ; add A/.vduTempStoreC4 to screen address
    TAX                                                 ;
    LDA .vduTempStoreC4                                 ;
    ADC .vduScreenAddressOfGraphicsCursorCellHigh       ;
    BPL +                                               ; if (result +ve) then branch
    JSR .subtractNumberOfBytesInACharacterRowToAX       ;
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store it
    STX .vduScreenAddressOfGraphicsCursorCellLow        ; store it
    LDA #0                                              ; A=0 to set Z flag (valid result)
.exitN
    RTS                                                 ;

; ***************************************************************************************
;
; Plot a line or a dotted line
;
; Bresenham's line drawing algorithm is used.
; See https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
;
; In the enclosed BASIC program, we sketch out the ideas behind the assembly that follows.
; The code plots a bunch of random lines on the screen using standard OS line drawing, then
; undraws the same set of lines using a BASIC routine that mimics the OS code. The process
; is slow (it's written in unoptimised BASIC) but it unplots the exact same pixels
; as the OS routine. See lines.ssd.
;
; ***************************************************************************************
.plotLine
    LDA #0                                              ;
    STA .vduPlotLineTemp365                             ;
    LDX #.vdu25ParameterYHigh - .vduVariablesStart3     ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    STA .vduTempStoreC5                                 ;
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
    JSR .checkPointXIsWithinGraphicsWindow              ;
    AND .vduTempStoreC5                                 ;
    BNE .exitN                                          ;
    LDA .vduTempStoreC4                                 ;
    ORA .vduTempStoreC5                                 ;
    PHA                                                 ;
    JSR .plotLineInitialiseDeltaValues                  ;
    JSR .calculateDominantAxis                          ;
    BMI ++                                              ;

    LDA .vduTempStoreC4                                 ;
    AND #3                                              ;
    STA .vduTempStoreC4                                 ;
    LDA .vduTempStoreC5                                 ;
    AND #3                                              ;
    STA .vduTempStoreC5                                 ;
    LDX #2                                              ; dominant axis
    BNE +                                               ; ALWAYS branch

++
    LSR .vduTempStoreC4                                 ;
    LSR .vduTempStoreC4                                 ;
    LSR .vduTempStoreC5                                 ;
    LSR .vduTempStoreC5                                 ;
    LDX #0                                              ; dominant axis
+
    STX .vduTempStoreC6                                 ;
    STX .vduTempStoreC8                                 ;
    TXA                                                 ;
    EOR #2                                              ; flip value (0 or 2) to non-dominant axis (2 or 0)
    STA .vduTempStoreC7                                 ;
    STA .vduTempStoreC9                                 ;
    JSR .calculateMaskAndPlotRoutines                   ;
    PLA                                                 ;
    JSR .calculateLineDrawingFlags                      ;
    JSR .plotLineInitializeVariables                    ;
    LDX #.vduPlotLineCurrentPointXLow - .vduGraphicsWindowPixelsTopLow  ;
    JSR .setScreenAddress                               ;
    LDA #%00010000                                      ; }
    AND .vduPlotType                                    ; } check bit 5 of plot type
    BEQ +                                               ; if (not a dotted line) then branch
    LDA #127                                            ; } set dotted line flag.
+
    STA .vduPlotLinePlotDottedPixelFlag                 ; } 127 = draw a dot; 128 is skip.
    ORA .vduPlotLineTemp365                             ;
    STA .vduTempStoreC5                                 ;
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;
    LDX .vduTempStoreC6                                 ; }
    BNE +                                               ; }
    DEC .vduTempStoreC7                                 ; } Decrement C6/C7
+                                                       ; }
    DEX                                                 ; } (we will store X later)

.plotLineLoop
    LDA .vduTempStoreC5                                 ; bit 7 set if dotted line; bit 6 set if out of bounds
    BEQ .writePointToScreen                             ; if (solid line in bounds) then branch (write to screen)
    LDA .vduPlotLinePlotDottedPixelFlag                 ;
    BEQ .plotLineCheckNowInBounds                       ; if (dotted line flag is ok) then branch (to draw point)
    BPL .worthPlottingLine                              ;
    DEC .vduPlotLinePlotDottedPixelFlag                 ; decrement to 127
    BNE .postWritePointToScreen                         ; ALWAYs branch

.worthPlottingLine
    INC .vduPlotLinePlotDottedPixelFlag                 ; increment to 128
    LDA .vduTempStoreC5                                 ;
    BPL .writePointToScreen                             ; if (not out of bounds) then branch
.plotLineCheckNowInBounds
    STX .vduTempStoreC6                                 ; store/remember X
    STY .vduGraphicsCursorVerticalOffsetInCell          ;
    LDX #.vduPlotLineCurrentPointXHigh - .vduVariablesStart3  ;
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; check in bounds (and if so calculate screen addresses)
    LDX .vduTempStoreC6                                 ; recall X
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;
    ORA #0                                              ; recall flags for A
    BNE .postWritePointToScreen                         ; if (not in bounds) then branch

    ; At last, we get to actually draw a point
.writePointToScreen
    LDA .vduCurrentPlotByteMask                         ; byte mask for current graphics point
    AND .vduGraphicsColourByteOR                        ; and with graphics colour OR byte
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; or  with curent graphics cell line
    STA .vduTempStoreC4                                 ; store result
    LDA .vduGraphicsColourByteEOR                       ; same again with colour EOR byte
    AND .vduCurrentPlotByteMask                         ;
    EOR .vduTempStoreC4                                 ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; then store it in current graphics row

.postWritePointToScreen
    SEC                                                 ; }
    LDA .vduPlotLineErrorTermLow                        ; }
    SBC .vduPlotLineAbsNonDominantAxisDeltaLow          ; }
    STA .vduPlotLineErrorTermLow                        ; } error_term = error_term - non-dominant axis delta
    LDA .vduPlotLineErrorTermHigh                       ; }
    SBC .vduPlotLineAbsNonDominantAxisDeltaHigh         ; }

    BCS +                                               ; if (error_term >= 0, i.e. error still ok) then branch (forwards)

    STA .vduTempStoreC4                                 ; }
    LDA .vduPlotLineErrorTermLow                        ; }
    ADC .vduPlotLineAbsDominantAxisDeltaLow             ; }
    STA .vduPlotLineErrorTermLow                        ; } error_term = error_term + dominant axis delta
    LDA .vduTempStoreC4                                 ; }
    ADC .vduPlotLineAbsDominantAxisDeltaHigh            ; }
    CLC                                                 ; }
+                                                       ; }
    STA .vduPlotLineErrorTermHigh                       ; }

    PHP                                                 ; store flags (carry clear if we will move in both axes)
    BCS .jumpVectorMoveOnePixelInDominantAxis           ; if (error term still ok) then branch
                                                        ; (indirectly
                                                        ;  to .plotLineMoveToNextColumnRight
                                                        ;  or .plotLineMoveToNextRowUp
                                                        ;  which moves along the dominant axis
                                                        ;  right or up one pixel)

    JMP (.vduPlotLineRoutineLow)                        ; jump to one of the next four line
                                                        ; routines below, which move the
                                                        ; sub-dominant axis one pixel in the
                                                        ; appropriate direction, and then
                                                        ; updates in the dominant axis: move
                                                        ; up or right one pixel.

; ***************************************************************************************
;
; Move up one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantXAxisSameSign
    DEY                                                 ; Y=Y-1 (moving one row up the screen)
    BPL .jumpVectorMoveOnePixelInDominantAxis           ; if (still in same character cell) then branch
    JSR .moveGraphicsCursorAddressUpOneCharacterCell    ; call subroutine to advance cursor address to the next cell up

.jumpVectorMoveOnePixelInDominantAxis
    JMP (.vduJumpVectorLow)                             ; jump to update dominant axis

; ***************************************************************************************
;
; Move down one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantXAxisDifferentSign
    INY                                                 ; Y=Y+1 (moving down one row in the character cell)
    CPY #8                                              ; }
    BNE .jumpVectorMoveOnePixelInDominantAxis           ; } if (still in the same character cell) then branch
    JSR .moveGraphicsCursorAddressDownOneCharacterCell
    JMP (.vduJumpVectorLow)                             ; jump to update dominant axis


; ***************************************************************************************
;
; Move right one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantYAxisSameSign
    LSR .vduCurrentPlotByteMask                             ; shift byte mask right
    BCC .jumpVectorMoveOnePixelInDominantAxis               ; if (still in the same byte) then branch
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask   ; update address and mask
    JMP (.vduJumpVectorLow)                                 ; jump to update dominant axis


; ***************************************************************************************
;
; Move left one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantYAxisDifferentSign
    ASL .vduCurrentPlotByteMask                             ; shift byte mask left
    BCC .jumpVectorMoveOnePixelInDominantAxis               ; if (still in the same byte) then branch
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask    ; move graphics cursor address left and update mask value
    JMP (.vduJumpVectorLow)                                 ; jump to update dominant axis


; ***************************************************************************************
;
; Move up one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextRowUp
    DEY                                                 ; decrement row within character cell
    BPL .plotLineCheckForTermination                    ; if (still in cell) then branch
    JSR .moveGraphicsCursorAddressUpOneCharacterCell    ; move up one cell
    JMP .plotLineCheckForTermination                    ;

; ***************************************************************************************
;
; Move down one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextRowDown
    INY                                                 ;
    CPY #8                                              ;
    BNE .plotLineCheckForTermination                    ;
    JSR .moveGraphicsCursorAddressDownOneCharacterCell  ;
    JMP .plotLineCheckForTermination                    ;

; ***************************************************************************************
;
; Move right one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextColumnRight
    LSR .vduCurrentPlotByteMask                         ;
    BCC .plotLineCheckForTermination                    ;
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask   ;
    JMP .plotLineCheckForTermination                    ;

; ***************************************************************************************
;
; Move left one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextColumnLeft
    ASL .vduCurrentPlotByteMask                         ;
    BCC .plotLineCheckForTermination                    ;
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask;

.plotLineCheckForTermination
    PLP                                                 ; pull flags (carry clear if we moved in both axes)
+
    INX                                                 ; X (also in .vduTempStoreC6) holds the
                                                        ; low byte of the loop counter
    BNE +                                               ; if (X > 0) then branch
    INC .vduTempStoreC7                                 ; .vduTempStoreC7 holds the high byte
                                                        ; of the loop counter
    BEQ .plotLineFinished                               ; if (loop counter is zero) then branch (finished)
+
    LDA .vduTempStoreC5                                 ;
    BMI .plotLineContinuesOutOfBounds                   ;
    BCS +                                               ;
    DEC .vduTempStoreC9                                 ;
    BEQ .plotLineFinished                               ;
+
    JMP .plotLineLoop                                   ;

.plotLineFinished
    RTS                                                 ;

.plotLineContinuesOutOfBounds
    ; increment the actual pixel coordinate along then loop back
    LDA .vduTempStoreC8                                 ; A=.vduTempStoreC8
    STX .vduTempStoreC6                                 ; Remember X
    AND #2                                              ; clear all but bit 1
    TAX                                                 ; X=2 if X axis is dominant; 0 otherwise
    BCS ++                                              ; if (moved in dominant axis only) then branch
    LDA .vduTempStoreC8                                 ;
    BMI +                                               ; if (signs of dx,dy differ) then branch (decrement value)
    INC .vduPlotLineCurrentPointXLow,X                  ; }
    BNE ++                                              ; } Increment .vduPlotLineCurrentPointX (Y axis dominant)
    INC .vduPlotLineCurrentPointXHigh,X                 ; }        or .vduPlotLineCurrentPointY (X axis dominant)
    JMP ++                                              ;

+
    LDA .vduPlotLineCurrentPointXLow,X                  ; }
    BNE +                                               ; }
    DEC .vduPlotLineCurrentPointXHigh,X                 ; } Decrement .vduPlotLineCurrentPointX (Y axis dominant)
+                                                       ; }        or .vduPlotLineCurrentPointY (X axis dominant)
    DEC .vduPlotLineCurrentPointXLow,X                  ; }
++
    TXA                                                 ; }
    EOR #2                                              ; } invert bit 2 of X
    TAX                                                 ; } X=0 if X axis dominant; 2 if Y axis dominant
    LDA .vduTempStoreC8                                 ;
    LSR                                                 ;
    BCS +                                               ;
    INC .vduPlotLineCurrentPointXLow,X                  ; }
    BNE ++                                              ; } increment .vduPlotLineCurrentPointX (X axis dominant)
    INC .vduPlotLineCurrentPointXHigh,X                 ; }        or .vduPlotLineCurrentPointY (Y axis dominant)
    BCC ++                                              ;
+
    LDA .vduPlotLineCurrentPointXLow,X                  ; }
    BNE +                                               ; }
    DEC .vduPlotLineCurrentPointXHigh,X                 ; } Decrement .vduPlotLineCurrentPointX (Y axis dominant)
+                                                       ; }        or .vduPlotLineCurrentPointY (X axis dominant)
    DEC .vduPlotLineCurrentPointXLow,X                  ; }
++
    LDX .vduTempStoreC6                                 ; Restore X
    JMP .plotLineLoop                                   ; jump back to continue plotting the line

; ***************************************************************************************
.moveGraphicsCursorAddressUpOneCharacterCell
    SEC                                                 ;
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    SBC .vduBytesPerCharacterRowLow                     ; }
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; } subtract number of bytes per line
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ; } from address
    SBC .vduBytesPerCharacterRowHigh                    ; }
    CMP .vduStartScreenAddressHighByte                  ; compare with bottom of screen memory
    BCS +                                               ; if (inside screen RAM) then branch
    ADC .vduScreenSizeHighByte                          ; add screen memory size to wrap it
                                                        ; around
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store in current address of graphics
                                                        ; cell top line
    LDY #7                                              ; Y=7
    RTS                                                 ;

; ***************************************************************************************
.moveGraphicsCursorAddressDownOneCharacterCell
    CLC                                                 ; }
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    ADC .vduBytesPerCharacterRowLow                     ; } add a row onto the graphic cursor address
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ; }
    ADC .vduBytesPerCharacterRowHigh                    ; }
    BPL +                                               ; if (result +ve) then branch (we are within screen RAM)
    SEC                                                 ; we are above screen RAM
    SBC .vduScreenSizeHighByte                          ; subtract screen memory size high
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store it (this wraps around point to screen RAM)
    LDY #0                                              ; Y=0
    RTS

; ***************************************************************************************
;
; Update the mask value, and move graphics cursor address on to next cell to the right
;
; On Entry:
;       Carry always SET
;
; ***************************************************************************************
.moveGraphicsCursorAddressTotheRightAndUpdateMask
    LDA .vduColourMaskLeft                              ; get current left colour mask
    STA .vduCurrentPlotByteMask                         ; store it
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    ADC #7                                              ; } get current graphics cursor
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; } address and add 8 to move to
    BCC +                                               ; } next cell to the right
    INC .vduScreenAddressOfGraphicsCursorCellHigh       ; }
+
    RTS                                                 ;

; ***************************************************************************************
;
; Update the mask value, and move graphics cursor address on to previous cell to the left
;
; On Entry:
;       Carry always SET
;
; ***************************************************************************************
.moveGraphicsCursorAddressTotheLeftAndUpdateMask
    LDA .vduColourMaskRight                             ; get right colour mask
    STA .vduCurrentPlotByteMask                         ; store it
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; A=top line graphics cell low
    BNE +                                               ; if (not zero) then branch
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement high byte
+
    SBC #8                                              ; subtract 8 (carry is always SET)
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; and store in low byte
    RTS                                                 ;


; ***************************************************************************************
;
; Initialise delta values to (current cursor - params position)
;
; Called at the start of the line drawing, this function takes the current graphics cursor
; position, subtracts the desired graphics cursor position (two 16 bit values on the VDU
; queue), and stores the result in workspace A/B/C/D.
;
; ***************************************************************************************
.plotLineInitialiseDeltaValues
    LDY #.vduPlotLineDeltaYHigh - .vduVariablesStart4         ; destination: .vduPlotLineDeltaX/Y
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart4  ; source: four parameters on the VDU queue
                                                        ; and the graphics cursor position
    ; fall through...

; ***************************************************************************************
;
; Coordinate subtraction
;
; On Entry:
;       X = source offset into vdu variables      (we read offsets 0-7)
;       Y = destination offset into vdu variables (we write offsets 0-3)
;
; On Exit:
;   Stores 16 bit width and height based on the difference of four
;   16 bit source coordinates (left, bottom, right, top)
;       width  = right - left
;       height = top - bottom
;   i.e.
;       let src  = .vduVariablesStart + X
;       let dest = .vduVariablesStart + Y
;       dest[0,1] = src[4,5] - src[0,1] = width
;       dest[2,3] = src[6,7] - src[2,3] = height
;
;   A = height (high byte)
;
; ***************************************************************************************
.coordinateSubtraction
    JSR +                                               ; first calculate width
    INX                                                 ; }
    INX                                                 ; } add 2 to X and Y
    INY                                                 ; } i.e. move offsets on for Y values
    INY                                                 ; }
                                                        ; finally calculate height
+
    SEC                                                 ; set carry
    LDA .vduVariablesStart4 + 5,X                       ; subtract coordinates
    SBC .vduVariablesStart4 + 1,X                       ;
    STA .vduVariablesStart4 + 1,Y                       ;
    LDA .vduVariablesStart4 + 4,X                       ;
    SBC .vduVariablesStart4 + 0,X                       ;
    STA .vduVariablesStart4 + 0,Y                       ;
    RTS                                                 ;

; ***************************************************************************************
.calculateDominantAxis
    LDA .vduPlotLineDeltaYHigh                          ;
    EOR .vduPlotLineDeltaXHigh                          ; check high bytes for different sign bit in dX/dY
    BMI .sectionB                                       ; if (result -ve; then deltas are different in sign) then branch later

; -------------SECTION A-------------
; dX and dY have the same sign
    LDA .vduPlotLineDeltaYHigh                          ; }
    CMP .vduPlotLineDeltaXHigh                          ; } if (dY >= dX) then A = dY - dX

    BNE .plotLineGotDeltas                              ;
    LDA .vduPlotLineDeltaYLow                           ;
    CMP .vduPlotLineDeltaXLow                           ;
    JMP .plotLineGotDeltas                              ;

.sectionB
; -------------SECTION B-------------
; dX and dY have different signs
    LDA .vduPlotLineDeltaYLow                           ; } A = (dX + dY) (high byte)
    CLC                                                 ; } (where deltas are different in sign, so really a subtraction)
    ADC .vduPlotLineDeltaXLow                           ; }
    LDA .vduPlotLineDeltaYHigh                          ; } Result: A is positive if (dX > -dY), A is negative if dX < -dY, otherwise A = 0
    ADC .vduPlotLineDeltaXHigh                          ; }    i.e. A is SIGN(dX - dY), C = carry of difference
; ----------SECTION B ENDS-----------

; Table of examples (Part 1)
;         A=   B=  C=  D=           --------SECTION A---------- ----------SECTION B----------
;         dX   dX  dY  dY   signs   Carry= Result                Carry=   Result
;  dX dY  Low  Hi Low  Hi  differ?  (C>=A) D-B-(1-Carry)       (A+C)>255  (B+D+Carry)
; -------------------------------------------------------------------------------------------
;  3   1  $03 $00 $01 $00     no      0    $FF (Result Carry=0)     -     -
;  1   3  $01 $00 $03 $00     no      1    $00 (Result Carry=1)     -     -
; -3   1  $FD $FF $01 $00     yes     -     -                       0     $FF (Result Carry=0)
; -1   3  $FF $FF $03 $00     yes     -     -                       1     $00 (Result Carry=1)
;  3  -1  $03 $00 $FF $FF     yes     -     -                       1     $00 (Result Carry=1)
;  1  -3  $01 $00 $FD $FF     yes     -     -                       0     $FF (Result Carry=0)
; -3  -1  $FD $FF $FF $FF     no      1    $00 (Result Carry=1)     -     -
; -1  -3  $FF $FF $FD $FF     no      0    $FF (Result Carry=0)     -     -
; --------------------------------------------------------------------------------------------

.plotLineGotDeltas
    ; based on the calculations just done, we work out the dominant axis, X=0 for the X-axis
    ; being dominant (dX being at least as large in magnitude as dY), X=2 for the Y-axis
    ; (dY being larger).
    ROR                                                 ; make top bit of A = 'result carry'
                                                        ; from above
    EOR .vduPlotLineDeltaYHigh                          ; check if carry from result above has
                                                        ; same sign as workspaceD
    RTS

; ***************************************************************************************
.calculateMaskAndPlotRoutines
    LDA .vduTempStoreC4                                 ;
    ORA .vduTempStoreC5                                 ;
    STA .vduCurrentPlotByteMask                         ;
    BEQ .testDY                                         ;
    LDA .vduTempStoreC5                                 ;
    BEQ +                                               ;
    JSR .copyGraphicsCursorPositionToCurrentPoint       ;
    JMP ++                                              ;
+
    JSR .copyParameterCoordinateToCurrentPoint          ;
++
    ; calculate mask
    LDA .vduCurrentPlotByteMask                         ;
    CMP #2                                              ;
    PHP                                                 ;
    LDA #$ff                                            ;
    ADC #0                                              ; add carry
    EOR .vduPlotLineDeltaYHigh,X                        ;
    STA .vduCurrentPlotByteMask                         ;
    PLP                                                 ;
    BEQ .copyToTerminationCoordinate                    ;
    BCC .incrementAndCopyToTerminationCoordinate        ;
    DEC .vduPlotLineTemp365                             ;
    LDA #0                                              ;
    STA .vduCurrentPlotByteMask                         ;

.testDY
    LDY .vduPlotLineDeltaYHigh,X                        ;
    BPL +                                               ; if (dy >= 0) then branch

    ; handle dy < 0
    JSR .copyParameterCoordinateToCurrentPoint          ;
    DEC .vduCurrentPlotByteMask                         ;
    LDA .vduGraphicsCursorPixelsYHigh,X                 ;
    STA .vduPlotLineTerminationValueHigh                ;
    LDA .vduGraphicsCursorPixelsYLow,X                  ; copy final coordinate to termination value
    LDY .vduTempStoreC8                                 ;
    JMP .storeTerminationLow                            ;

+
    ; handle dy >= 0
    JSR .copyGraphicsCursorPositionToCurrentPoint       ;
    LDA .vduWorkspaceA,X                                ;
    STA .vduPlotLineTerminationValueHigh                ;
    LDA .vduWorkspaceA + 1,X                            ;
    LDY .vduTempStoreC8                                 ;
    JMP .storeTerminationLow                            ;

.incrementAndCopyToTerminationCoordinate
    INC .vduTempStoreC8                                 ;
.copyToTerminationCoordinate
    LDY .vduTempStoreC8                                 ; }
    LDX .vduGraphicsWindowBoundariesTable,Y             ; } copy final coordinate to
    LDA .vduGraphicsWindowPixelsTopHigh,X               ; } termination value. We use this later
    STA .vduPlotLineTerminationValueHigh                ; } to check for termination on plotting
    LDA .vduGraphicsWindowPixelsTopLow,X                ; } the line.
.storeTerminationLow
    STA .vduPlotLineTerminationValueLow                 ; }

    LDA .vduPlotLineRoutineAddressesLow,Y               ; } set up the address of one of two
    STA .vduJumpVectorLow                               ; } line drawing routines into
    LDA .vduPlotLineRoutineAddressesHigh,Y              ; } .vduJumpVectorLow/High (based on
    STA .vduJumpVectorHigh                              ; } X=0 or 2)
    LDX .vduTempStoreC7                                 ;
    LDA .vduPlotLineDeltaYHigh,X                        ;
    EOR .vduCurrentPlotByteMask                         ;
    ROL                                                 ;
    LDA #1                                              ;
    ROL                                                 ;
    EOR .vduTempStoreC6                                 ;
    STA .vduTempStoreC9                                 ;
    TAY                                                 ;

    ; remember the address of which routine to call
    LDA .vduRoutineBranchVectorAddressesLow,Y           ; get address and store at .vduPlotLineRoutineLow/High
    STA .vduPlotLineRoutineLow                          ; routine 0 is for a dominant Y axis, and same signs of dX/dY       (.plotLineDominantYAxisSameSign)
    LDA .vduRoutineBranchVectorAddressesHigh,Y          ; routine 1 is for a dominant Y axis, and different signs of dX/dY  (.plotLineDominantYAxisDifferentSign)
    STA .vduPlotLineRoutineHigh                         ; routine 2 is for a dominant X axis, and same signs of dX/dY       (.plotLineDominantXAxisSameSign)
                                                        ; routine 3 is for a dominant X axis, and different signs of dX/dY  (.plotLineDominantXAxisDifferentSign)
    LDA .vduPlotLineTemp365                             ;
    BNE +                                               ;
    RTS                                                 ;

+
    LDY .vduTempStoreC6                                 ;
    LDX .vduGraphicsWindowBoundariesTable,Y             ;
    LDY #.vduPlotLineTerminationValueHigh - .vduVariablesStart3 ;
    LDA #2                                              ;
    JMP .copyABytesWithinVDUVariables                   ; copy final coordinate to
                                                        ; termination value. We use this later
                                                        ; to check for termination on plotting
                                                        ; the line.

; ***************************************************************************************
.copyGraphicsCursorPositionToCurrentPoint
    LDY #3                                              ; loop counter
-
    LDA .vduGraphicsCursorPixelsYHigh,Y                 ; }
    STA .vduPlotLineCurrentPointXLow - 1,Y              ; } copy graphics cursor position
    DEY                                                 ; } to current point
    BPL -                                               ; }
    RTS                                                 ;

; ***************************************************************************************
.copyParameterCoordinateToCurrentPoint
    LDY #3                                              ; loop counter
-
    LDA .vdu25ParameterYHigh,Y                          ; }
    STA .vduPlotLineCurrentPointXLow - 1,Y              ; } loop to copy parameter coordinate to current point
    DEY                                                 ; }
    BPL -                                               ; }
    RTS                                                 ;

; ***************************************************************************************
.calculateLineDrawingFlags
    BEQ .storeAndReturn                                 ;
    LDA .vduPlotLineTemp365                             ;
    BNE ++                                              ;
    LDX #.vduPlotLineCurrentPointXHigh - .vduVariablesStart3 ; X is the offset to check the current point
    JSR .checkPointXIsWithinGraphicsWindow              ;
    LDY .vduTempStoreC7                                 ;
    BNE +                                               ;
    LSR                                                 ;
    LSR                                                 ;
+
    AND #3                                              ;
    BEQ .getAbsoluteDistanceToEdge                      ;
    DEC .vduPlotLineTemp365                             ;
++
    LDA .vduTempStoreC9                                 ;
    LSR                                                 ;
    ROR                                                 ;
    ORA .vduTempStoreC8                                 ;
    AND #%10000001                                      ;
    ORA .vduTempStoreC7                                 ;
    STA .vduTempStoreC8                                 ; line drawing flags
    LDA #0                                              ;
.storeAndReturn
    STA .vduTempStoreC9                                 ;
    RTS                                                 ;

; ***************************************************************************************
.getAbsoluteDistanceToEdge
    ; get absolute distance to the graphics window edge
    LDX .vduTempStoreC9                                 ; which edge we are measuring (0-3)
    LDY .vduGraphicsWindowBoundariesTable,X             ;
    SEC                                                 ;
    LDX .vduTempStoreC7                                 ; }
    LDA .vduGraphicsWindowPixelsTopLow,Y                ; }
    SBC .vduPlotLineCurrentPointXLow,X                  ; } get distance to edge:
    PHA                                                 ; } graphics window boundary - current point
    LDA .vduGraphicsWindowPixelsTopHigh,Y               ; }
    SBC .vduPlotLineCurrentPointXHigh,X                 ; }

    TAX                                                 ; }
    PLA                                                 ; } XY = distance to window edge
    TAY                                                 ; }
    TXA                                                 ;
    BPL +                                               ; if(distance is positive) then branch
    JSR .negateAY                                       ; negate AY: Make sure distance to edge
                                                        ; is positive (note A=X from above)
+
    INY
    TAX                                                 ; } XY = ABS(distance to window edge)
    BEQ +                                               ; if (A=0) then branch (not out of bounds)
    LDY #0                                              ; Y=0
+
    STY .vduTempStoreC9                                 ; .vduTempStoreC9 = low byte of distance,
                                                        ; or zero if high byte is non-zero.
                                                        ; In other words: if this value is
                                                        ; one, then it's the last pixel.
    RTS

; ***************************************************************************************
.pullATwiceAndExit
    PLA                                                 ;
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Initialise line drawing variables
;
; Swaps the delta coordinates to make the non-dominant axis first. Stores absolute values of
; the deltas in .vduPlotLineAbsNonDominantAxisDeltaLow/High
;        and in .vduPlotLineAbsDominantAxisDeltaLow/High
; Initialises the loop counter (-ve of the number of pixels to draw along the dominant axis)
; Initialises the error term.
;
; In steps:
;   1. Make sure the dominant axis is stored second, by swapping coordinates if needed.
;   2. Both coordinates are then made positive and stored in:
;           .vduPlotLineAbsNonDominantAxisDeltaLow/High
;           .vduPlotLineAbsDominantAxisDeltaLow/High
;   3. .vduTempStoreDC/DD stores the negative of the number of steps to take along the dominant axis.
;   4. .vduPlotLineErrorTermLow/High stores half .vduPlotLineAbsDominantAxisDelta. This is the error variable.
;
; On Entry:
;       The original signed (dX, dY) delta values are stored at:
;           (.vduPlotLineDeltaXLow/High, .vduPlotLineDeltaYLow/High)
;
; On Exit:
;       .vduPlotLineAbsNonDominantAxisDeltaLow/High initialised
;       .vduPlotLineAbsDominantAxisDeltaLow/High initialised
;       .vduPlotLineErrorTermLow/High initialised
;
; ***************************************************************************************
.plotLineInitializeVariables
    LDA .vduTempStoreC6                                 ; get the dominant axis (0 or 2)
    BEQ +                                               ; if (Y axis is dominant) then branch
    LDX #.vduPlotLineDeltaYHigh - .vduVariablesStart3   ;
    LDY #.vduPlotLineDeltaXHigh - .vduVariablesStart3   ;
    JSR .exchangeABytes                                 ; exchange the X and Y variables.
                                                        ; So the dominant axis is now the
                                                        ; first coordinate.
+
    LDX #.vduPlotLineDeltaYHigh - .vduVariablesStart3   ; source: .workspaceABCD (the start
                                                        ; coordinates)
    LDY #.vduPlotLineAbsDominantAxisDeltaHigh - .vduVariablesStart3 ; destination: absolute
                                                        ; deltas in X and Y with the
                                                        ; non-dominant axis first
    JSR .copyFourBytesWithinVDUVariables                ; copy four bytes
    SEC                                                 ; set carry
    LDX .vduTempStoreC6                                 ; get the dominant axis (0 or 2)
    LDA .vduPlotLineTerminationValueLow                 ; }
    SBC .vduPlotLineCurrentPointXLow,X                  ; }     AY = .vduPlotLineTerminationValue - .vduPlotLineCurrentPointX or Y
    TAY                                                 ; } ie. AY = finalPoint - start point (in dominant axis)
    LDA .vduPlotLineTerminationValueHigh                ; }
    SBC .vduPlotLineCurrentPointXHigh,X                 ; }
    BMI +                                               ; if (startPoint > finalPoint) then branch
    JSR .negateAY                                       ; negate value stored in A and Y
+
    STA .vduTempStoreC7                                 ; store high byte of negative value     } this is the -ve of the number of steps we
    STY .vduTempStoreC6                                 ; store low byte of negative value      } need to take when plotting the line.


    ORA .vduTempStoreC6                                 ;
    BEQ .pullATwiceAndExit                              ;
    LDX #.vduPlotLineErrorTermHigh - .vduVariablesStart4 ;
    ; fall through...

; ***************************************************************************************
;
; Line Initialisation
;
; This is used in both line drawing and triangle filling to initialise the variables needed
; to track along the edge. Sets the deltas to absolute values, and initialises an error
; term to half the absolute delta in Y.
;
;   Let src  = .vduVariablesStart + X
;   src[2,3] = ABS(src[2,3])
;   src[4,5] = ABS(src[4,5])
;   src[0,1] = src[2,3] / 2
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;
; On Exit:
;       AY = absolute value of src[4,5]
;
; ***************************************************************************************
.lineInitialisation
    JSR .absoluteValue                                  ; make src[2,3] positive
    LSR                                                 ; }
    STA .vduVariablesStart4,X                           ; }
    TYA                                                 ; } src[0,1] = src[2,3] / 2
    ROR                                                 ; }
    STA .vduVariablesStart4 + 1,X                       ; }
    INX                                                 ; point to src[0,1]
    INX                                                 ; and fall through to make src[4,5] positive
    ; fall through...

; ***************************************************************************************
;
; Absolute value
;
; Make sure that the 16 bit coordinate at (.vduVariablesStart4 + 2 + X)
; is not negative, by negating it if necessary.
;
; On Entry:
;       X is offset to vdu variable i.e.:
;       (vduVariablesStart + 2 + X) has the low byte of the coordinate
;       (vduVariablesStart + 3 + X) has the high byte of the coordinate
;
; On Exit:
;       A is the high byte of the result (also stored in .vduVariablesStart + 2 + X)
;       Y is the low byte of the result  (also stored in .vduVariablesStart + 3 + X)
;       X is preserved
;
; ***************************************************************************************
.absoluteValue
    LDY .vduVariablesStart4 + 3,X                       ;
    LDA .vduVariablesStart4 + 2,X                       ;
    BPL +                                               ; if (A is +ve) then branch (return)
    JSR .negateAY                                       ; negate AY
    STA .vduVariablesStart4 + 2,X                       ; store back again
    PHA                                                 ;
    TYA                                                 ;
    STA .vduVariablesStart4 + 3,X                       ;
    PLA                                                 ; get back A
+
    RTS                                                 ;

; ***************************************************************************************
.exchangeFourBytes
    LDA #4                                              ; A = 4
    ; fall through...

; ***************************************************************************************
.exchangeABytes
    STA .vduTempStoreC4                                 ; store it as loop counter
-
    LDA .vduVariablesStart3,X                           ; get byte
    PHA                                                 ; store it
    LDA .vduVariablesStart3,Y                           ; get byte pointed to by Y
    STA .vduVariablesStart3,X                           ; put it in 330+X
    PLA                                                 ; get back A
    STA .vduVariablesStart3,Y                           ; put it in 330+Y
    INX                                                 ; increment pointers
    INY                                                 ;
    DEC .vduTempStoreC4                                 ; decrement loop counter
    BNE -                                               ; if (not zero) then branch (loop back and do it again)
    RTS                                                 ;

; ***************************************************************************************
;
; Copy four bytes (e.g. one pair of coordinates) of VDU variables
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyFourBytesWithinVDUVariables
    LDA #4                                              ; number of bytes to copy
    ; fall through...

; ***************************************************************************************
;
; Copy a number of bytes in VDU variables
;
; On Entry:
;       A = number of bytes to copy
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyABytesWithinVDUVariables
    STA .vduTempStoreC4                                 ; store A as a loop counter
-
    LDA .vduVariablesStart3,X                           ; load value from source address
    STA .vduVariablesStart3,Y                           ; store value in destination address
    INX                                                 ; move index forwards
    INY                                                 ; move index forwards
    DEC .vduTempStoreC4                                 ; decrement loop counter
    BNE -                                               ; loop back until done
    RTS                                                 ;


; ***************************************************************************************
;
; Negate the sixteen bit value in A and Y
;
; On Entry:
;       A = high byte
;       Y = low byte
;
; On Exit:
;       A = high byte of negated value
;       Y = low byte of negated value
;       Preserves X
;
; ***************************************************************************************
.negateAY
    PHA                                                 ; save A
    TYA                                                 ;
    EOR #$FF                                            ;
    TAY                                                 ; Y=255 - Y
    PLA                                                 ; restore A
    EOR #$FF                                            ; A=255 - A
    INY                                                 ; Y=Y+1 (effectively making Y = 256 - initialY)
    BNE +                                               ; if (Y != 0) then branch (exit)
    CLC                                                 ;
    ADC #1                                              ; A+=1
+
    RTS                                                 ;

; ***************************************************************************************
;
; Display a character at the current graphics cursor
;
; ***************************************************************************************
.plotACharacterAtGraphicsCursor
    LDX .vduForegroundGraphicsColour                    ; foreground graphics colour
    LDY .vduForegroundGCOLMode                          ; foreground graphics GCOL mode
.plotACharacterWithXYAsGraphicsColourAndGCOLMode
    JSR .setGraphicsColourMaskXY
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ; point to parameters
    LDY #.vduWorkspaceR - .vduVariablesStart3           ;
    JSR .copyFourBytesWithinVDUVariables                ;
    LDY #0                                              ; Y=0
.displayNextRowOfCharacter
    STY .vduTempStoreC6                                 ; .vduTempStoreC6=Y
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ; point to parameters
    LDY #.vduWorkspaceN - .vduVariablesStart3           ;
    JSR .copyFourBytesWithinVDUVariables                ;
    LDY .vduTempStoreC6                                 ; Y=.vduTempStoreDC
    LDA (.vduTempStoreC8),Y                             ; get pattern byte
    BEQ .characterPatternZero                           ; if (A=0) then branch
    STA .vduTempStoreC7                                 ; .vduTempStoreC7 = 1 bit character pattern byte
-
    BPL +                                               ; if (pattern's top bit is clear) then branch (nothing to draw)

    JSR .plotPoint                                      ;
+
    INC .vduGraphicsCursorPixelsXLow                    ;
    BNE +                                               ;
    INC .vduGraphicsCursorPixelsXHigh                   ;
+
    ASL .vduTempStoreC7                                 ;
    BNE -                                               ;
.characterPatternZero
    LDX #.vduWorkspaceN - .vduVariablesStart3           ; source
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; destination
    JSR .copyFourBytesWithinVDUVariables
    LDY .vduGraphicsCursorPixelsYLow                    ; }
    BNE +                                               ; }
    DEC .vduGraphicsCursorPixelsYHigh                   ; } decrement graphics cursor Y pixel position
+                                                       ; }
    DEC .vduGraphicsCursorPixelsYLow                    ; }
    LDY .vduTempStoreC6                                 ; loop counter
    INY                                                 ;
    CPY #8                                              ;
    BNE .displayNextRowOfCharacter                      ; if (Y<8) then branch (loop back)
    LDX #.vduWorkspaceR - .vduVariablesStart3           ; source
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ;
                                                        ; destination: graphics cursor position
    JMP .copyFourBytesWithinVDUVariables                ; copy to graphics cursor position

; ***************************************************************************************
;
; Move graphics cursor (up or right)
;
; On Entry:
;       X = 0 means move graphics cursor up
;       X = 2 means move graphics cursor right
;
; ***************************************************************************************
.moveGraphicsCursorUpOrRightEightPixels
    STX .vduTempStoreC5                                 ; store X
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; X is the offset to check the graphics cursor
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    LDX .vduTempStoreC5                                 ; recall X
    CLC                                                 ;
    LDA .vduGraphicsCursorPixelsYLow,X                  ; get current graphics cursor (low)
    ADC #8                                              ; add 8 pixels
    STA .vduGraphicsCursorPixelsYLow,X                  ; set current graphics cursor (low)
    BCC +                                               ;
    INC .vduGraphicsCursorPixelsYHigh,X                 ; set current graphics cursor (high)
+
    LDA .vduTempStoreC4                                 ; A=0 no window violations, 1 or 2 indicates violation
    BNE .setUpExternalGraphicsCoordinatesLocal               ; if (outside graphics window) then branch
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; X is the offset to check the graphics cursor
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    BEQ .setUpExternalGraphicsCoordinatesLocal               ; if (within graphics window) then branch

    LDX .vduTempStoreC5                                 ; get back X
    LDA .vduGraphicsWindowPixelsBottomLow,X             ; get left/bottom edge of graphics
                                                        ; window (low) (X=2 means left,
                                                        ; else X=0 means bottom)
    CLC                                                 ;
    LDX .vduTempStoreC5                                 ; recall X
    BNE +                                               ;
    ADC #7                                              ;
+
    STA .vduGraphicsCursorPixelsYLow,X                  ; set current graphics cursor position (low)
    LDA .vduGraphicsWindowPixelsBottomHigh,X            ; get bottom edge (high)
    ADC #0                                              ; add carry
    STA .vduGraphicsCursorPixelsYHigh,X                 ; set current graphics cursor position (high)
    TXA                                                 ; A=X
    BEQ .setUpExternalGraphicsCoordinatesLocal          ; if (X = 0) then branch (move graphics cursor down)
    JMP .moveGraphicsCursorLeftEightPixels              ; set up external coordinates for graphics

.setUpExternalGraphicsCoordinatesLocal
    JMP .convertPixelGraphicsCoordinatesToExternal      ;

; ***************************************************************************************
;
; Move graphics cursor (left or down)
;
; On Entry:
;       X = 0 to move down or
;       X = 2 to move left
;
; ***************************************************************************************
.moveGraphicsCursorDownOrLeftEightPixels
    STX .vduTempStoreC5                                 ; store X
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; X is the offset to check the graphics cursor
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    LDX .vduTempStoreC5                                 ; restore X
    SEC                                                 ; set carry
    LDA .vduGraphicsCursorPixelsYLow,X                  ; current graphics cursor (X=2 for horizontal movement)
    SBC #8                                              ; subtract 8 to move back/down 1 character
    STA .vduGraphicsCursorPixelsYLow,X                  ; store in current graphics cursor (X=2 for horizontal movement)
    BCS +                                               ; if (carry set, no need to adjust high byte) then branch forward
    DEC .vduGraphicsCursorPixelsYHigh,X                 ; decrement high byte of graphics cursor
+
    LDA .vduTempStoreC4                                 ; check the old graphics cursor position
    BNE .setUpExternalGraphicsCoordinates               ; if (old graphics position out of the graphics window bounds) then branch
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; X is the offset to check the graphics cursor
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    BEQ .setUpExternalGraphicsCoordinates               ; if (not out of bounds now) then branch

    ; this is the case where the old coordinates were within the window, but now are not.
    ; when moving left, then move up and clamp to the right edge.
    ; when moving down, clamp to the top edge.
    LDX .vduTempStoreC5                                 ; get back X
    LDA .vduGraphicsWindowPixelsTopLow,X                ; get graphics window left (X=0) or down (X=2)


    SEC                                                 ;
    LDX .vduTempStoreC5                                 ;
    BEQ +                                               ;
    SBC #7                                              ;
+
    STA .vduGraphicsCursorPixelsYLow,X                  ;
    LDA .vduGraphicsWindowPixelsTopHigh,X               ;
    SBC #0                                              ;
    STA .vduGraphicsCursorPixelsYHigh,X                 ;
    TXA                                                 ;
    BEQ .setUpExternalGraphicsCoordinates               ;
    JMP .moveGraphicsCursorRightEightPixels             ;

.setUpExternalGraphicsCoordinates
    JMP .convertPixelGraphicsCoordinatesToExternal      ;

; ***************************************************************************************
.graphicsCursorHome
    LDA #2                                                      ;
    LDX #.vduGraphicsWindowPixelsTopHigh - .vduVariablesStart3 ; source bytes (graphics window top)
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3   ; destination bytes (graphics cursor Y)
    JSR .copyABytesWithinVDUVariables

; ***************************************************************************************
.setGraphicsCursorToLeftHandColumn
    LDA #2                                                      ;
    LDX #.vduGraphicsWindowPixelsLeftHigh - .vduVariablesStart3 ; source: left edge of graphics
                                                                ; window
    LDY #.vduGraphicsCursorPixelsXHigh - .vduVariablesStart3    ; destination: graphics cursor
                                                                ; X coordinate
    JSR .copyABytesWithinVDUVariables                           ;
    JMP .convertPixelGraphicsCoordinatesToExternal              ;

; ***************************************************************************************
;
; Fill triangle
;
; A filled triangle is drawn. It is drawn in rows from the bottom of the triangle to the top.
;
; Here we define the 'main line' as the edge of the triangle from the bottommost vertex
; to the topmost vertex. The other two edges are the lower and upper 'minor lines'.
;
; The triangle is drawn in two 'halves'. The first 'half' is for the rows of lower minor line,
; and the second 'half' is for the rows of upper minor line. See the diagram below.
;
; On Entry:
;       .vdu25ParameterLow/High             }
;       .vduGraphicsCursorPixels            } three points that define the triangle
;       .vduOldGraphicsCursorPixels         }
;
; ***************************************************************************************
.plotFillTriangle
    LDX #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart3     ; X = source: parameter
    LDY #.vduPlotTriStorageForCoordinates - .vduVariablesStart3     ; Y = destination: storage
    JSR .copyFourBytesWithinVDUVariables                ;
    LDX #$10                                            ; loop counter
-
    LDA .vduVariablesStart3,X                           ; }
    PHA                                                 ; }
    INX                                                 ; } Push $0340 - $0348
    CPX #$18                                            ; }
    BNE -                                               ; }

    ; sort the three points of the triangle into order vertically
    JSR .sortParameterPointAndOldPosition                       ; }
    LDX #.vduOldGraphicsCursorPixelsYHigh - .vduVariablesStart3 ; }
    LDY #.vdu25ParameterYHigh - .vduVariablesStart3             ; } sort positions by Y
    JSR .sortCoordinatesXY                                      ; } coordinate
    JSR .sortParameterPointAndOldPosition                       ; }

    ; The three points of the triangle (now sorted from lowest to highest) are:
    ;
    ;                                               ##  <-.vduGraphicsCursorPixels
    ;                                             ###      /|\
    ;                                           ##  #       |
    ;                     upper minor line->  ##   #        |
    ;                                       ##     #        | second 'half' of triangle
    ;                                     ##      #         | to draw
    ;                                   ##        #         |
    ;                                 ##         #         \|/
    ; .vduOldGraphicsCursorPixels->  #           #         /|\
    ;                                 #         #           |
    ;                                 #         #  <-main   |
    ;                                  #       #     line   |
    ;                                  #       #            |
    ;               lower minor line->  #     #             | first 'half' of triangle
    ;                                   #     #             | to draw
    ;                                    #   #              |
    ;                                    #   #              |
    ;                                     # #               |
    ;                                     # #               |
    ;                                      #               \|/
    ;                                      #  <-.vdu25Parameter
    ;

    ; get the dX, dY for the main line
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart4            ;
    LDY #.vduPlotLineAbsNonDominantAxisDeltaLow - .vduVariablesStart4   ;
    JSR .coordinateSubtraction                          ;
    LDA .vduPlotTriMainLineDeltaXHigh                   ;
    STA .vduPlotTriMainLineXDirectionFlag               ; store high byte of delta X to
                                                        ; use as a flag when updating our
                                                        ; position.
                                                        ; See .fillTriangleUpdateLinePosition

    ; initialise variables for the main line
    LDX #.vduPlotTriMainLineErrorTermLow - .vduVariablesStart4 ;
    JSR .lineInitialisation                             ; Initialise variables for the main
                                                        ; line. This makes the deltas positive
                                                        ; and initialises the error term.

    ; copy .vdu25Parameter to current main edge point
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3        ;
    LDY #.vduPlotTriMainLineCurrentPointXLow - .vduVariablesStart3  ;
    JSR .copyFourBytesWithinVDUVariables                            ;

    ; swap graphics cursor points
    LDX #.vdu25ParameterYHigh - .vduVariablesStart3                 ;
    LDY #.vduOldGraphicsCursorPixelsYHigh - .vduVariablesStart3     ;
    JSR .exchangeFourBytes                                          ;

    ; fill the bottom half of the triangle
    CLC                                                 ; clear carry
    JSR .plotFillTriangleHalf                           ; fill bottom 'half' of triangle

    ; swap graphics cursor points back
    LDX #.vdu25ParameterYHigh - .vduVariablesStart3                 ;
    LDY #.vduOldGraphicsCursorPixelsYHigh - .vduVariablesStart3     ;
    JSR .exchangeFourBytes                                          ;

    ; swap parameter point with old graphics cursor
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3        ;
    LDY #.vduOldGraphicsCursorPixelsYHigh - .vduVariablesStart3     ;
    JSR .exchangeFourBytes                                          ;

    ; Now our triangle looks like this:
    ;                                               ##  <-.vduGraphicsCursorPixels
    ;                                             ###      /|\
    ;                                           ##  #       |
    ;                     upper minor line->  ##   #        |
    ;                                       ##     #        | second 'half' of triangle
    ;                                     ##      #         | to draw
    ;                                   ##        #         |
    ;                                 ##         #         \|/
    ;             .vdu25Parameter->  #############         /|\
    ;                                 ###########           |
    ;                                 ###########  <-main   |
    ;                                  #########     line   |
    ;                                  #########            |
    ;               lower minor line->  #######             | first 'half' of triangle
    ;                                   #######             | is filled
    ;                                    #####              |
    ;                                    #####              |
    ;                                     ###               |
    ;                                     ###               |
    ;                                      #               \|/
    ;                                      #  <-.vduOldGraphicsCursorPixels
    ;
    ; It is now half filled, and the parameters of the vertices have been swapped ready for
    ; filling the second half.

    ; fill the top half of the triangle
    SEC                                                 ; set carry
    JSR .plotFillTriangleHalf                           ; fill top 'half' of triangle
    LDX #$18                                            ; loop counter
-
    DEX                                                 ;
    PLA                                                 ; loop to pull off eight bytes
    STA .vduVariablesStart3,X                           ; from the stack to restore
    CPX #$10                                            ; the parameter position and
    BNE -                                               ; graphics cursor position

    ; move the graphics cursor to the new parameter point, and return
    JMP .plotMoveGraphicsCursorInAbsolutePixels         ;

; ***************************************************************************************
;
; Fill half a triangle
;
; Draws rows of a triangle from bottom to top following the main line and the minor line
; as edges, until we reach the top of the minor line. See .plotFillTriangle. The minor line
; starts at the parameter point and moves up the screen to the current graphics point.
;
; On Entry:
;       Carry clear = first half of triangle is being drawn
;       Carry set = second half of triangle is being drawn
;
; ***************************************************************************************
.plotFillTriangleHalf
    PHP                                                 ; store flags

    SEC                                                 ;
    LDA .vduGraphicsCursorPixelsYLow                    ;
    SBC .vdu25ParameterYLow                             ;
    STA .vduTriangleFillHeightLow                       ;
    TAY                                                 ;
    LDA .vduGraphicsCursorPixelsYHigh                   ;
    SBC .vdu25ParameterYHigh                            ;
    STA .vduTriangleFillHeightHigh                      ;
    BNE +                                               ;
    TYA                                                 ;
    BNE +                                               ;
    PLP                                                 ;
    BCC .exit10b                                        ;
    JMP .fillRowLeftToRightBetweenMainAndMinorLines     ;

+
    ; find the dX, dY for the minor line
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart4 ; X = source (graphics cursor)
    LDY #.vduPlotTriMinorLineDeltaXLow - .vduVariablesStart4; Y = destination (minor delta)
    JSR .coordinateSubtraction                          ;

    ; Get and store the sign of the delta in X, so we know which way to update in X later.
    ; See .fillTriangleUpdateLinePosition.
    LDA .vduPlotTriMinorLineDeltaXHigh                  ; get high byte of deltaX
    STA .vduPlotTriMinorLineXDirectionFlag              ; store as flag

    ; initialise the minor line variables:
    ;       .vduPlotTriMinorLineDeltaX = ABS(.vduPlotTriMinorLineDeltaX)
    ;       .vduPlotTriMinorLineDeltaY = ABS(.vduPlotTriMinorLineDeltaY)
    ;       .vduPlotTriMinorLineErrorTerm = .vduPlotTriMinorLineDeltaY / 2
    LDX #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart4 ;
    JSR .lineInitialisation                             ;

    ; initialise current point on the minor line
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3        ;
    LDY #.vduPlotTriMinorLineCurrentPointXLow - .vduVariablesStart3 ;
    JSR .copyFourBytesWithinVDUVariables                ;

    ; loop to fill each row (.vduTriangleFillHeight is the loop counter, counting up)
.plotFillTriangleHalfLoop
    JSR .fillRowLeftToRightBetweenMainAndMinorLines     ; fill one row

    ; update the minor line position
    LDX #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart44    ;
    JSR .fillTriangleUpdateLinePosition                 ;

    ; update the main line position
    LDX #.vduPlotTriMainLineErrorTermLow - .vduVariablesStart44     ;
    JSR .fillTriangleUpdateLinePosition                 ;

    ; increment the loop counter until we hit zero
    INC .vduTriangleFillHeightLow                       ;
    BNE .plotFillTriangleHalfLoop                       ;
    INC .vduTriangleFillHeightHigh                      ;
    BNE .plotFillTriangleHalfLoop                       ;

    ; finish up
    PLP                                                 ;
    BCS .fillRowLeftToRightBetweenMainAndMinorLines     ; fill one row

.exit10b
    RTS                                                 ;

; ***************************************************************************************
;
; Sort the parameter point and the old graphics cursor point, sorting by Y coordinate
;
; if (parameter point is higher or level with old graphics cursor) then swap points in place
;
; ***************************************************************************************
.sortParameterPointAndOldPosition
    LDX #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3     ; } Sort graphics cursor
    LDY #.vduOldGraphicsCursorPixelsYHigh - .vduVariablesStart3  ; } and old graphics cursor
    ; fall through...

; ***************************************************************************************
;
; Sort one point with another, sorting by Y coordinate
;
; given two pairs of coordinates (one indexed by register X the other by register Y), sort
; them by their Y coordinates (lowest first)
;
; if (point X is higher or level with point Y) then swap points in place
;
; ***************************************************************************************
.sortCoordinatesXY
    LDA .vduVariablesStart3 + 1,X                       ; Y coordinate low byte
    CMP .vduVariablesStart3 + 1,Y                       ; Y coordinate low byte
    LDA .vduVariablesStart3,X                           ; Y coordinate high byte
    SBC .vduVariablesStart3,Y                           ; Y coordinate high byte
    BMI .exit10a                                        ; if (Y coordinates of variable indexed by Y > Y coordinate of variable indexed by X) then branch (return)
    JMP .exchangeFourBytes                              ; swap coordinates

.exit10a
    RTS

; ***************************************************************************************
.fillRowLeftToRightBetweenMainAndMinorLines
    LDX #.vduPlotTriMinorLineCurrentPointXLow - .vduVariablesStart3  ;
    LDY #.vduPlotTriMainLineCurrentPointXLow - .vduVariablesStart3   ;
    ; fall through...

; ***************************************************************************************
;
; Fill a single horizontal row
;
; Used as part of clearing the graphics window or filling a triangle.
;
; On Entry:
;       X = offset into VDU variables for one extreme graphics pixel X coordinate
;       Y = offset into VDU variables for the other extreme graphics pixel X coordinate
;
; ***************************************************************************************
.fillRow
    STX .vduTempStoreC8                                 ;
    LDA .vduGraphicsWindowPixelsRightLow,X              ; }
    CMP .vduGraphicsWindowPixelsRightLow,Y              ; }
    LDA .vduGraphicsWindowPixelsRightHigh,X             ; } if (leftmost <= rightmost) then branch
    SBC .vduGraphicsWindowPixelsRightHigh,Y             ; }
    BMI +                                               ; }

    TYA                                                 ; }
    LDY .vduTempStoreC8                                 ; }
    TAX                                                 ; } swap X and Y so (leftmost < rightmost)
    STX .vduTempStoreC8                                 ; }
+
    STY .vduTempStoreC9                                 ; .vduTempStoreDF=offset to leftmost coordinate
    LDA .vduGraphicsWindowPixelsRightLow,Y              ;
    PHA                                                 ;
    LDA .vduGraphicsWindowPixelsRightHigh,Y             ;
    PHA                                                 ; push graphics window left edge coordinate
    LDX .vduTempStoreC9                                 ; check leftmost coordinate
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    BEQ +                                               ; if (within bounds) then branch

    ; out of bounds. Work out what to do.
    CMP #2                                              ; }
    BNE .donePlottingPoints                             ; } if (reason for being out of bounds
                                                        ; } is not just that it's too far
                                                        ; } right) then branch (finish up)

    ; out of bounds (point is right of the right hand edge of the graphics window)
    LDA .vduGraphicsWindowPixelsRightHigh               ;
    STA .vduGraphicsWindowPixelsRightHigh,X             ;
    LDA .vduGraphicsWindowPixelsRightLow                ;
    STA .vduGraphicsWindowPixelsRightLow,X              ;
+
    JSR .setScreenAddress                               ; set a screen address
    LDX .vduTempStoreC8                                 ; X=offset to rightmost pixel X coordinate
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds

    LSR                                                 ; A = reason for being offscreen / 2
                                                        ; (checks for offscreen to the right / up / down)
    BNE .donePlottingPoints                             ; if (point is offscreen to the right, up or down) then branch (finish up)
    BCC +                                               ; if (not outside bounds to the left of the graphics window) then branch

    ; out of bounds (point is left of the graphics window left edge)
    LDX #.vduGraphicsWindowPixelsBottomHigh - .vduVariablesStart3 ; outside the left edge, leftmost = left edge instead.
+
    LDY .vduTempStoreC9                                 ; Y = offset to leftmost pixel coordinate
    SEC                                                 ;
    LDA .vduGraphicsWindowPixelsRightLow,Y              ; }
    SBC .vduGraphicsWindowPixelsRightLow,X              ; }
    STA .vduTempStoreC6                                 ; } tempStoreDC/DD = width of row to fill (rightmost - leftmost)
    LDA .vduGraphicsWindowPixelsRightHigh,Y             ; }
    SBC .vduGraphicsWindowPixelsRightHigh,X             ; }
    STA .vduTempStoreC7                                 ; }

    ; First calculate leftmost byte to write
    LDA #0                                              ;
-
    ASL                                                 ; shift current mask left
    ORA .vduCurrentPlotByteMask                         ; OR in the mask for a pixel
    LDY .vduTempStoreC6                                 ; } get low byte (as decremented by .calculateLeftmostByte)
    BNE .calculateLeftmostByte                          ; } check to see if we are done yet (check if width = 0)
    DEC .vduTempStoreC7                                 ; } decrement high byte if needed
    BPL .calculateLeftmostByte                          ; } if (width > 0, i.e. not done yet) then branch

    ; we get here if width is now zero, i.e. the leftmost byte is all we needed to draw
    STA .vduCurrentPlotByteMask                         ;
    JSR .plotPointWithinBounds                          ; display final byte

.donePlottingPoints
    ; we get here when we are done drawing all the pixels
    LDX .vduTempStoreC9                                 ; restore X = offset to leftmost coordinate
    PLA                                                 ; pull A
    STA .vduGraphicsWindowPixelsRightHigh,X             ; restore left edge of graphics window
    PLA                                                 ; pull A
    STA .vduGraphicsWindowPixelsRightLow,X              ; restore left edge of graphics window
    RTS                                                 ;

; ***************************************************************************************
;
; Calculate leftmost byte
;
; ***************************************************************************************
.calculateLeftmostByte
    DEC .vduTempStoreC6                                 ; decrement width
    TAX                                                 ; check the pixel mask
    BPL -                                               ; loop back until mask has bit set in bit 7

    STA .vduCurrentPlotByteMask                         ; store the full mask
    JSR .plotPointWithinBounds                          ; display a point (write leftmost byte to screen)

    LDA #$ff                                            ;
    STA .vduCurrentPlotByteMask                         ;

    LDX .vduTempStoreC6                                 ; }
    INX                                                 ; } increment width (was decremented
    BNE +                                               ; } one too many times)
    INC .vduTempStoreC7                                 ; }

    ; we are going to write a line of completely filled bytes.
    ; first calculate the number of bytes we need to fill (= width in pixels / pixels per byte)
+
    TXA                                                 ; A = X = width low byte
    PHA                                                 ; Push width (low)
    LSR .vduTempStoreC7                                 ; }
    ROR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two
    LDY .vduPixelsPerByteMinusOne                       ; get number of pixels/byte
    CPY #3                                              ; check for four colour MODEs
    BEQ +                                               ; if (four colour MODE) then branch (only divide by 2 once more)
    BCC .finishedGettingByteCount                       ; if (>four colour mode, i.e. MODE 2) then branch

    ; two colour mode
    LSR .vduTempStoreC7                                 ; }
    ROR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two

    ; four colour mode
+
    LSR .vduTempStoreC7                                 ; }
    LSR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two


    ; finished getting the number of bytes to fill. At this point the accumulator holds the
    ; number of filled bytes we need to draw
.finishedGettingByteCount
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; Y=line in current graphics cell containing current point
    TAX                                                 ; X=number of bytes to fill
    BEQ .finalByte                                      ; if (no full bytes to write) then branch (plot final byte)

    ; loop to fill all the complete bytes we can
.loopPlotBytes
    TYA                                                 ; }
    SEC                                                 ; }
    SBC #8                                              ; } Y=Y-8, move to next cell left
    TAY                                                 ; }

    BCS +                                               ;
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement high byte of current graphics cursor
+

    JSR .plotPointWithinBoundsAtY
    DEX                                                 ;
    BNE .loopPlotBytes                                  ; if (more bytes to fill) then branch (loop back)

    ; now we may need to plot some pixels into the final byte
.finalByte
    PLA                                                 ; restore pixel width
    AND .vduPixelsPerByteMinusOne                       ; check modulo pixels per byte
    BEQ .donePlottingPoints                             ; if (no remainder, i.e. no more pixels to write) then branch
    TAX                                                 ; remainder = loop counter
    LDA #0                                              ; A=0

-
    ASL                                                 ; shift A
    ORA .vduColourMaskRight                             ; OR with right colour mask
    DEX                                                 ;
    BNE -                                               ; if (not done shifting the right colour mask) then branch (loop back)

    STA .vduCurrentPlotByteMask                         ; store as byte mask
    TYA                                                 ; }
    SEC                                                 ; }
    SBC #8                                              ; } Y=Y-8
    TAY                                                 ; }
    BCS +                                               ; if (carry set) then branch
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement byte of top line off current graphics cursor cell
+
    JSR .plotPointWithinBoundsAtY                       ; display final point
    JMP .donePlottingPoints                             ; jump to next point

; ***************************************************************************************
;
; Update one edge when filling a triangle
;
; Update the variables of one edge, looping if needed to move the position up by one row.
; We update either the 'main line' or the 'minor line'. See .plotFillTriangle.
;
; On Entry:
;       X = .vduPlotTriMainLineErrorTermLow  - .vduVariablesStart    to update the main edge
;       X = .vduPlotTriMinorLineErrorTermLow - .vduVariablesStart    to update the minor edge
;
; Offsets 0-10 from X are used in the code below and refer to:
;
;       0,1 = error term
;       2,3 = delta Y
;       4,5 = delta X
;       6,7 = current point Y
;       8,9 = current point X
;       10  = X direction flag (top bit set means decrement X, otherwise increment X)
;
; See .vduPlotTriMainLineErrorTermLow for the variables.
;
; ***************************************************************************************
.fillTriangleUpdateLinePosition
    INC .vduVariablesStart44 + 7,X                      ; }
    BNE +                                               ; } Increment current Y position
    INC .vduVariablesStart44 + 6,X                      ; }
+
    SEC                                                 ; }
    LDA .vduVariablesStart44 + 1,X                      ; }
    SBC .vduVariablesStart44 + 5,X                      ; }
    STA .vduVariablesStart44 + 1,X                      ; } error -= delta X
    LDA .vduVariablesStart44,X                          ; }
    SBC .vduVariablesStart44 + 4,X                      ; }
    STA .vduVariablesStart44,X                          ; }
    BPL .exit11                                         ; if (error >=0) then branch (exit)

.fillTriangleUpdatePositionLoop
    LDA .vduVariablesStart44 + 10,X                     ;
    BMI .fillTriangleMoveLeft                           ; if (X direction flag set) then branch

.fillTriangleMoveRight
    INC .vduVariablesStart44 + 9,X                      ; }
    BNE .updateErrorTerm                                ; } increment current X
    INC .vduVariablesStart44 + 8,X                      ; }
    JMP .updateErrorTerm                                ; jump forward

.fillTriangleMoveLeft
    LDA .vduVariablesStart44 + 9,X                      ; }
    BNE +                                               ; }
    DEC .vduVariablesStart44 + 8,X                      ; } decrement current X
+                                                       ; }
    DEC .vduVariablesStart44 + 9,X                      ; }

.updateErrorTerm
    CLC                                                 ; }
    LDA .vduVariablesStart44 + 1,X                      ; }
    ADC .vduVariablesStart44 + 3,X                      ; }
    STA .vduVariablesStart44 + 1,X                      ; } error += deltaY
    LDA .vduVariablesStart44,X                          ; }
    ADC .vduVariablesStart44 + 2,X                      ; }
    STA .vduVariablesStart44,X                          ; }
    BMI .fillTriangleUpdatePositionLoop                 ; if (still on same row) then branch (loop back)

.exit11
    RTS                                                 ;

; ***************************************************************************************
.getOrClearNumberOfBytesInVDUQueue
    BCS +                                               ;
    LDX #0                                              ;
    STX .twosComplimentOfNumberOfBytesInVDUQueue        ;
+
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ;
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 9: Cursor editing mode
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE 135 - Read character at text cursor position
;
; ***************************************************************************************
.osbyte135EntryPoint
    LDX .vduNumberOfLogicalColoursMinusOne              ;
    BNE .nonMODE7ReadCharacter                          ; if (MODE is not 7) then branch
    LDA (.vduWriteCursorScreenAddressLow,X)             ; read from screen address (note X=0)
    JSR .checkForNonPrintableCharacter                  ;
    BCC .finishUpFX135                                  ; if (non-printable) then branch
    LDX #3                                              ; loop counter
    LDY .vduCurrentScreenMODE                           ; Y = screen MODE
-
    CMP .teletextCharacterConversionTable,X             ;
    BEQ +                                               ; loop to apply teletext conversion
    DEX                                                 ;
    BNE -                                               ;
    TAX                                                 ;
    RTS                                                 ;

+
    LDA .teletextCharacterConversionTable - 1,X         ;
    RTS                                                 ;

; ***************************************************************************************
.nonMODE7ReadCharacter
    JSR .readCharacterDefinitionMaskFromScreen          ; read from screen, making a one bit
                                                        ; mask of 8 bytes to match against
                                                        ; each character, in workspaceA-H
    LDX #0                                              ;
    STX .vduTempStoreC6                                 ; font zone address (low byte) = 0
    INX                                                 ;
    STX .vduTempStoreC4                                 ; font zone (=1)
    LDA .vduFontFlags                                   ;
    SEC                                                 ;
    ROL                                                 ;
    STA .vduTempStoreC5                                 ;
    LDX #.charSPACE                                     ; Start with the space character (loop counter)
.readCharLoop
    ASL .vduTempStoreC5                                 ;
    BEQ .finishUpFX135                                  ;
    BCC +                                               ;
    LDY .vduTempStoreC4                                 ;
    LDA .vduFontZoneAddressesHigh1 - 1,Y                ;
    BCS ++                                              ; ALWAYS branch

+
    LDA .vduTempStoreC4                                 ;
    AND #$03                                            ; A = 1,2 or 3
    ADC #$bf                                            ; A = $C0, $C1 or $C2, i.e. the high byte of the character definitions in ROM
++
    STA .vduTempStoreC7                                 ; font zone address (high byte)
-
    LDY #7                                              ; Y=7
--
    LDA .vduWorkspaceA,Y                                ; get byte in workspaceA-H copy
    CMP (.vduTempStoreC6),Y                             ; check against character definition
    BNE +                                               ; if (not the same) then branch (to skip to next character)
    DEY                                                 ; Y--
    BPL --                                              ; if (still non-negative) then branch (back to loop eight times, to check each row of the character)
    CPX #.charDELETE                                    ; but if it's the DELETE character then pretend we didn't match and carry on
    BEQ +                                               ;

.finishUpFX135
    LDY .vduCurrentScreenMODE                           ; Y = current screen MODE
    TXA                                                 ; X = character
    RTS                                                 ;

+
    CLC                                                 ; }
    LDA .vduTempStoreC6                                 ; } Add 8 to address of character definition to move on to the next character
    ADC #8                                              ; } Affects low byte only as we check one page of characters at a time
    STA .vduTempStoreC6                                 ; }
    INX                                                 ; no match on this character so increment to next character
    BCC -                                               ;
    INC .vduTempStoreC4                                 ;
    BCS .readCharLoop                                   ; ALWAYS branch

; ***************************************************************************************
;
; Read character from screen pixels
;
; Reads 8x8 cell of pixels from the screen. This will be compared against each of the
; character definitions to determine which character is on screen. This is for the
; cursor editing mode feature.
;
; ***************************************************************************************
.readCharacterDefinitionMaskFromScreen
    LDY #7                                              ; Y=7
.setupPatternLoop
    STY .vduTempStoreC4                                 ; .vduTempStoreC4=Y (loop counter)
    LDA #1                                              ; A=1
    STA .vduTempStoreC5                                 ; .vduTempStoreC5=A
--
    LDA .vduColourMaskLeft                              ; A=left colour mask
    STA .vduTempStoreC6                                 ; store in .vduTempStoreC6
    LDA (.vduWriteCursorScreenAddressLow),Y             ; get a byte from current text character
    EOR .vduBackgroundTextColour                        ; EOR with text background colour
    CLC                                                 ; clear carry
-
    BIT .vduTempStoreC6                                 ; and check bits of colour mask
    BEQ +                                               ; if (result = 0) then branch (this becomes a zero bit in our mask)
    SEC                                                 ; set carry. This becomes a one bit in our mask
+
    ROL .vduTempStoreC5                                 ; Rotate left and add the carry in the low bit
    BCS +                                               ; if (carry now set; bit 7 originally set) then branch (because we are done:
                                                        ;               the initial value of 1 has rotated through the 8 bits and into the carry)
    LSR .vduTempStoreC6                                 ; shift mask right one place for the next pixel
    BCC -                                               ; if (carry clear; nothing shifted off the left) then branch (loop back)
    TYA                                                 ; }
    ADC #7                                              ; } Y = Y + 8 (Carry is set, so adding 7 + carry = 8)
    TAY                                                 ; }
    BCC --                                              ; if (no overflow from the add) then branch (loop back, move on to the next cell to read from)
+
    LDY .vduTempStoreC4                                 ; read modified values into Y and A
    LDA .vduTempStoreC5                                 ;
    STA .vduWorkspaceA,Y                                ; store copy
    DEY                                                 ; and do it again
    BPL .setupPatternLoop                               ; until 8 bytes copied
    RTS                                                 ;

; ***************************************************************************************
    LDX #.vduGraphicsCursorPositionXHigh - .vduVariablesStart3  ; [unused]
    LDY #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ; [unused]
    JSR .copyFourBytesWithinVDUVariables                        ; [unused]
    LDA #.vduGraphicsCursorPixelsYHigh - .vduVariablesStart3    ; [unused]
    ; fall through...

; ***************************************************************************************
;
; Read pixel
;
; On Entry:
;       A = VDU variable offset for the graphics coordinates to use.
;
; On Exit:
;       A = current colour at the coordinate specified OR
;       A = $FF if coordinate is out of bounds
; ***************************************************************************************
.readPixel
    PHA                                                 ; store A
    TAX                                                 ; X=A
    JSR .plotConvertExternalRelativeCoordinatesToPixels ; set up positional data
    PLA                                                 ; get back A
    TAX                                                 ; X=A
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; set a screen address after checking for window bounds
    BNE ++                                              ; if (out of bounds) then branch (exit with A=$FF)
    LDY .vduGraphicsCursorVerticalOffsetInCell          ;
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get row of current graphics cell
-
    ASL                                                 ; A=A*2, Carry=bit 7
    ROL .vduTempStoreC4                                 ; .vduTempStoreC4=.vduTempStoreC4+2 +Carry,
                                                        ; Carry=bit 7 of .vduTempStoreDA
    ASL .vduCurrentPlotByteMask                         ; byte mask=byte mask*2 + Carry
    PHP                                                 ; save flags
    BCS +                                               ; if (carry set) then branch
    LSR .vduTempStoreC4                                 ; restore .vduTempStoreC4 with bit 7=0
+
    PLP                                                 ; pull flags
    BNE -                                               ; if (Z set) then branch
    LDA .vduTempStoreC4                                 ; A=.vduTempStoreC4 AND number of colours in current MODE -1
    AND .vduNumberOfLogicalColoursMinusOne              ;
-
    RTS                                                 ;

++
    LDA #$ff                                            ;
    BNE -                                               ;

; ***************************************************************************************
.splitIntoTwoCursors
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ; X=number of items in VDU queue
    BNE .exit12                                         ; if (not 0) then branch
    BIT .vduStatusByte                                  ; check VDU status byte
    BMI .exit12                                         ; if (either VDU is disabled, or plot to graphics cursor enabled) then branch (exit)
    BVS +                                               ; if (cursor editing mode enabled) then branch
    PHA                                                 ;
    JSR .setCursorOnOrOff                               ;
    LDA .vduTextCursorXPosition                         ;
    STA .vduTextInputCursorXCoordinate                  ;
    LDA .vduTextCursorYPosition                         ;
    STA .vduTextInputCursorYCoordinate                  ;
    JSR .restoreWriteCursor                             ; modify character at cursor position
    LDA #2                                              ;
    JSR .setVDUStatusByteFlags                          ; bit 1 of VDU status is set to bar scrolling
    PLA                                                 ;
+
    AND #$7f                                            ;
    PHA                                                 ;
    LDA #%10111111                                      ;
    JSR .clearVDUStatusByteFlags                        ; bit 6 of VDU status (separated cursors) is set to zero
    PLA                                                 ; Pull A
    JSR .vduChrEntryPointInternal                       ; call VDU routine
    LDA #%01000000                                      ; set bit six (separate cursors)
    JMP .setVDUStatusByteFlags                          ; set separated cursors and return

; ***************************************************************************************
.exchangeTextCursorAndInputCursorValues
    PHP                                                 ; save flags
    PHA                                                 ; save A
    LDX #.vduTextCursorYPosition - .vduVariablesStart2c ; offset within VDU variables for text cursor position
-
    LDA .vduVariablesStart2c,X                          ;
    PHA                                                 ;
    LDA .vduTextInputCursorXCoordinate,X                ;
    STA .vduVariablesStart2c,X                          ;
    PLA                                                 ;
    STA .vduTextInputCursorXCoordinate,X                ;
    DEX                                                 ;
    BPL -                                               ;
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
    JSR .setHardwareCursorAddress                       ; set cursor position
    LDA .vduStatusByte                                  ; get VDU status byte
    EOR #%00000010                                      ; invert bit 1 to allow or inhibit scrolling
    STA .vduStatusByte                                  ; store VDU status byte
    PLA                                                 ; restore flags
    PLP                                                 ; restore A
    RTS                                                 ;

; ***************************************************************************************
.readCharacterFromScreenAndCursorRight
    LDA #0                                              ; A=0
    BIT .vduStatusByte                                  ;
    BVC .exit12                                         ; if (bit 6 clear; not in cursor editing mode) then branch (exit)
    JSR .osbyte135EntryPoint                            ; read a character from the screen
    BEQ .exit12                                         ; if (A = 0, i.e. failed to read) then branch (exit)
    PHA                                                 ; store A
    JSR .vdu9EntryPoint                                 ; perform cursor right
    PLA                                                 ; restore A
.exit12
    RTS                                                 ;

; ***************************************************************************************
; When editing a line with two cursors, pressing return terminates the edit.
; This clears the VDU status flags and restores the text cursor to normal.
.terminateEdit
    LDA #%10111101                                      ; }
    JSR .clearVDUStatusByteFlags                        ; } clear bits 2 and 6 of VDU status (page scrolling; separated cursors)

.setCursorOnOrOff
    LDA .vduLastCursorStartRegisterValue                ;
    EOR #$20                                            ;
    LDY #$0a                                            ;
    JSR .setCRTCRegisterAY                              ;
    LDA .endTextEntryCharacter                          ;
    RTS                                                 ;

; ***************************************************************************************
;
; Set up a write cursor
;
; When entering a line of text, if the user presses a cursor key then two cursors are shown:
; The WRITE cursor is shown at the point of text entry (looks like a solid block character),
; and is the position at which new characters will be input.
; The READ cursor (shown as a flashing underline) is positioned by the cursor keys.
; The COPY key reads the character under the READ cursor and enters it at WRITE cursor.
;
; Editing finishes when RETURN is pressed.
;
; ***************************************************************************************
.setUpWriteCursor
    PHP                                                 ; save flags
    PHA                                                 ; save A
    LDY .vduBytesPerCharacter                           ;
    DEY                                                 ; Y = bytes per character - 1
    BNE .restoreWriteCursorNonMODE7                     ; if (not MODE 7) then branch
    LDA .vduMODE7CursorCharacter                        ; get MODE 7 write character
                                                        ; cursor character $7F
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it at top scan line of current
                                                        ; character
.pullTwiceAndExit
    PLA                                                 ; pull A
.pullAndExit
    PLP                                                 ; pull flags
.exit8
    RTS                                                 ;

; ***************************************************************************************
;
; Restore a normal cursor
;
; ***************************************************************************************
.restoreWriteCursor
    PHP                                                 ; push flags
    PHA                                                 ; push A
    LDY .vduBytesPerCharacter                           ;
    DEY                                                 ; Y = bytes per character - 1
    BNE .restoreWriteCursorNonMODE7                     ; if (not MODE 7) then branch
    LDA (.vduWriteCursorScreenAddressLow),Y             ; read from cursor screen address
    STA .vduMODE7CursorCharacter                        ; store it
    LDA .vduTeletextCharacterForCursor                  ; MODE 7 write cursor character
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it in MODE 7 screen address
    JMP .pullTwiceAndExit                               ; and exit

; ***************************************************************************************
.restoreWriteCursorNonMODE7
    LDA #$FF                                            ; A=$FF (cursor byte mask)
    CPY #31                                             ; check bytes per character
    BNE +                                               ; if (not MODE 2) then branch
    LDA #$3F                                            ; A=$3F (cursor byte mask)
+
    STA .vduTempStoreC4                                 ; store it
-
    LDA (.vduWriteCursorScreenAddressLow),Y             ; get scan line byte
    EOR .vduTempStoreC4                                 ; invert it
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it on scan line
    DEY                                                 ; decrement scan line counter
    BPL -                                               ; do it again
    JMP .pullTwiceAndExit                               ; ALWAYS branch (pull and exit)

; ***************************************************************************************
.specialOSTableLookup
    ORA #$80                                            ; Make sure top bit is set
                                                        ;(this maps OSWORD calls into being
                                                        ; adjacent to range of special OSBYTEs
                                                        ; ready for table lookup)
    STX .oswordX                                        ; }
    STY .oswordY                                        ; } store parameters

    TAY                                                 ; }
    LDA .specialOSTableHigh - 132,Y                     ; }
    STA .specialOSRoutineAddressHigh                    ; } get routine address
    LDA .specialOSTableLow - 132,Y                      ; }
    STA .specialOSRoutineAddressLow                     ; }

    LDY #0                                              ;
    LDA (.oswordX),Y                                    ; get first byte of OSWORD parameter block into A
                                                        ; [this will read from an arbitrary
                                                        ; memory address for the OSBYTE calls!]
    JMP (.specialOSRoutineAddressLow)                   ; call routine

; ***************************************************************************************
;
; OSBYTE 132 - Read HIMEM (start of screen memory)
;
; ***************************************************************************************
.osbyte132EntryPoint
    LDX .vduCurrentScreenMODE                           ;
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 133 - Read start of screen memory for given MODE
;
; ***************************************************************************************
.osbyte133EntryPoint
    TXA                                                 ; X=MODE number
    AND #7                                              ; keep it in range 0-7
    TAX                                                 ; Y=MODE number
    LDY .screenDisplayMemoryIndexTable,X                ; X = get screen RAM size index
    LDA .screenMemoryStartHigh,Y                        ; A = high byte of start address
    BIT .systemAvailableRAM                             ; get available RAM
    BMI .returnTheScreenAddress                         ; if (32k available) then branch
    AND #$3F                                            ; AND A with $3F to bring into memory range for a 16K BBC Micro
    CPX #4                                              ;
    BCS .returnTheScreenAddress                         ; if (MODE number >= 4) then branch (to return the value)
    LDA #0                                              ;
.returnTheScreenAddress
    TAY                                                 ; Y = high byte of screen address
    LDX #0                                              ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 134 - Read text cursor position
;
; ***************************************************************************************
.osbyte134EntryPoint
    LDA .vduTextCursorXPosition                         ; read current text cursor X position
    SEC                                                 ; }
    SBC .vduTextWindowLeft                              ; } subtract text window left position
    TAX                                                 ; X = text cursor X - text window left
    LDA .vduTextCursorYPosition                         ; get current text cursor Y position
    SEC                                                 ; }
    SBC .vduTextWindowTop                               ; } subtract text window top position
    TAY                                                 ; Y = text cursor Y - text window top

.exit10
.osbyte136EntryPoint
    RTS                                                 ;

; ***************************************************************************************
;
;   OSWORD 9 - Read a pixel
;
; On Entry:
;       .oswordA = 9
;       .oswordX = low byte of parameter block address
;       .oswordY = high byte of parameter block address
;
;   .oswordX/Y is the address of the four bytes of parameters:
;       byte 0-1: X coordinate
;       byte 2-3: Y coordinate
;
; On Exit:
;       Result stored in byte 4 of parameter block:
;           $FF if point was off screen, or logical colour of point if on screen
;
; ***************************************************************************************
.osword9EntryPoint
    LDY #3                                              ; Y is loop counter
    LDX #0                                              ;
-
    LDA (.oswordX),Y                                    ; get it
    STA .vduWorkspaceR,X                                ;
    INX                                                 ;
    DEY                                                 ; decrement counter
    BPL -                                               ; loop back until done
    LDA #.vduWorkspaceR - .vduVariablesStart3           ;
    JSR .readPixel                                      ;
    LDY #4                                              ; Y=4
    STA (.oswordX),Y                                    ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 10 - Read character definition
;
; On Entry:
;       A          = character to read
;       .oswordX/Y = address of buffer to store the eight bytes of results
; ***************************************************************************************
.osword10EntryPoint
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDY #0                                              ; Y=0
-
    LDA (.vduTempStoreC8),Y                             ; get first byte
    INY                                                 ; Y=Y+1
    STA (.oswordX),Y                                    ; store it in YX
    CPY #8                                              ; until Y=8
    BNE -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
;   OSWORD 11 - Read palette
;
; On Entry:
;       Y = 0
;       .oswordA = 11
;       .osWordX = low byte of parameter block address
;       .osWordY = high byte of parameter block address
;
;   .oswordX/Y is the address of the four byte parameter block:
;       byte 0: logical colour to read
;
; On Exit:
;       byte 0: logical colour
;       byte 1: physical colour
;       byte 2: zero
;       byte 3: zero
;
; ***************************************************************************************
.osword11EntryPoint
    AND .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    TAX                                                 ; put it in X
    LDA .vduColourPaletteStart,X                        ; get value from colour palette
    INY                                                 ; increment Y to point to byte 1
    STA (.oswordX),Y                                    ; store data
    LDA #0                                              ; issue 0s
-
    INY                                                 ; increment Y
    STA (.oswordX),Y                                    ; store data
    CPY #4                                              ; to next bytes until Y=4
    BNE -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 12 - read 8 bytes of VDU variables into the XY parameter block
;
; ***************************************************************************************
.osword12EntryPoint
    TAX                                                 ;
-
    LDA .vduVariablesStart2,X                           ; read from VDU variables
    INY                                                 ;
    STA (.oswordX),Y                                    ; store in parameter block (offsets 1-8)
    INX                                                 ;
    CPY #8                                              ;
    BNE -                                               ;
    RTS                                                 ;

    !byte $73                                           ; [unused]

; ***************************************************************************************
;
; VDU 7 (.charBELL)
;
; See beep.mp3
; Generates a short tone.
;
; By default this plays a Treble C as a square wave for 0.3 seconds on channel 3. The
; frequency is as close as the sound chip can get to Treble C. It produces a 523.013Hz tone
; compared to the theoretical ideal 523.251Hz, and so is very close to the ideal pitch.
;
; The 523.013Hz figure for the frequency achieved takes into account that the OS changes the
; pitch slightly depending on the channel number (see .soundPitchOffsetByChannelTable). If
; it were played on channel 1 or 2, the frequency would not be as close to Treble C.
;
; ***************************************************************************************
.vdu7EntryPoint
    JMP .vdu7EntryPointInternal                         ;

.osbyte118EntryPoint
    JMP .osbyte118EntryPointInternal                    ;

.writeAToSystemVIARegisterB
    JMP .writeAToSystemVIARegisterBInternal             ;

.setVideoULA
    JMP .setVideoULAInternal                            ;

.osbyte155Jumper
    JMP .osbyte155EntryPoint                            ;

.sendValidByteToPrinterJumper
    JMP .sendValidByteToPrinter                         ;

; ***************************************************************************************
;
; The boot message
;
; See Boot.png
; See startup.mp3
; Here a BBC Micro Model B has booted up, displaying the 32K version of its welcome message.
; The Acorn Disk Filing System, installed on this machine as a sideways ROM, also identifies
; itself, after which the MOS enters the language ROM, BBC BASIC. It's BASIC, not the MOS,
; which displays the ">" prompt and receives commands. The screen is in MODE 7, so the
; text uses Teletext characters rather than being rendered in the raster font above.
;
; The startup sound has random variation in the first tone(s) as the sound chip starts
; playing random data on reset until the audio is silenced (See .resetClearAllSounds), and
; the second tone is the familiar .charBELL sound from the boot message below.
;
; Teletext characters look smoother than the regular raster font, thanks to the hardware's
; diagonal smoothing algorithm, giving them an effective resolution of 10x18 pixels instead
; of 8x8 in other MODEs.
; See https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms#SAA5050_'diagonal_smoothing'.
;
; Historical note: All of Acorn's early computers booted up with brief identifications
; like this, then a skipped line, then a prompt. For the System 2, it was "Acorn Cos",
; referring to its "cassette operating system"; for the Atom, which had only upper case
; characters, the ident was "ACORN ATOM". What is perhaps most notable about the ident on
; the original BBC Micro is that it mentions the BBC, but not Acorn (unless additional
; ROMs such as the disc filing system are also plugged in). Subsequent models did
; not follow this pattern: the BBC Master ident is "Acorn MOS", and the B+ is "Acorn OS"
; plus a RAM size.
;
; See 5050.png
;
; ***************************************************************************************
.bootMessage
    !text .charRETURN, "BBC Computer ", 0               ;

.bootMessageMemory16
    !text "16K", .charBELL, 0                           ;

.bootMessageMemory32
    !text "32K", .charBELL, 0                           ;

.bootMessageEnding
    !text .charBACKSPACE, .charRETURN, .charRETURN, 0   ;

    !text .charRETURN, "Bad IRQ",0                      ;
    !text "System/3 loader", .charRETURN, 0             ;

.starDDot
    !text "*D.", .charRETURN                            ; [unused]
    !text "*E.*", .charRETURN                           ; [unused]

.initialVariableValues
    !byte $a0, $20, $32, $07      ;

.defaultVectorTable
    !word .badEventError          ; USERV          $0200-1      .vectorUSERV
    !word .displayMessageAndHang  ; BRKV           $0202-3      .vectorBRKV
    !word .restoreAndReturnFromInterrupt ; IRQ1V   $0204-5      .vectorIRQ1V
    !word .badEventError          ; IRQ2V          $0206-7      .vectorIRQ2V
    !word .oscliEntryPoint        ; CLIV           $0208-9      .vectorCLIV
    !word .osbyteEntryPoint       ; BYTEV          $020A-B      .vectorBYTEV
    !word .oswordEntryPoint       ; WORDV          $020C-D      .vectorWORDV
    !word .oswrchEntryPoint       ; WRCHV          $020E-F      .vectorWRCHV
    !word .osrdchEntryPoint       ; RDCHV          $0210-1      .vectorRDCHV

.defaultFileSystemVectors
    !word .noFilingSystemError    ; FILEV          $0212-3      .vectorFILEV
    !word .noFilingSystemError    ; ARGSV          $0214-5      .vectorARGSV
    !word .noFilingSystemError    ; BGETV          $0216-7      .vectorBGETV
    !word .noFilingSystemError    ; BPUTV          $0218-9      .vectorBPUTV
    !word .noFilingSystemError    ; GBPBV          $021A-B      .vectorGBPBV
    !word .noFilingSystemError    ; FINDV          $021C-D      .vectorFINDV
    !word .badCommandError        ; FSCV           $021E-F      .vectorFSCV

    !byte $ff, $ff, $19, $19, $19                       ; [unused]
    !byte $00, $00, $00, $00, $00                       ; [unused]
    !byte $00, $90, $9f, $03, $b0                       ; [unused]
    !byte $64, $06, $10, $04, $04                       ; [unused]

.allBitsSet
    !byte $ff                                           ;

    !byte $ff, $ff, $ff, $ff, $ff                       ; [unused]
    !byte $ff, $ff, $ff, $ff, $ff                       ; [unused]
    !byte $ff, $ff, $ff, $ff, $ff                       ; [unused]
    !byte $6c, $00, $00, $00, $00                       ; [unused]

.noFilingSystemError
    BRK                                                 ;
    !byte $f8                                           ;
    !text "No filing system", 0                         ;

.badEventError
    BRK                                                 ;
    !byte $f7                                           ;
    !text "Bad event", 0                                ;

.resetEntryPoint
    SEI                                                 ; disable interrupts just in case
    CLD                                                 ; clear decimal flag
    LDX #$FF                                            ; reset stack to where it should be
    STX .unknownInterruptDisableFlag                    ; Initialise to $FF (disable unknown interrupt handling)
    TXS                                                 ; ($01FF)
    STX .userVIADataDirectionRegisterA                  ;
    JSR .resetACIA1                                     ;
    LDA .systemVIAInterruptEnableRegister               ;
    ROR                                                 ;
    AND #1                                              ;
    AND $f0                                             ;
    PHA                                                 ;
    LDA #$7f                                            ;
    STA .systemVIAInterruptFlagRegister                 ; clear all interrupts
    STA .userVIAInterruptFlagRegister                   ;
    STA .systemVIAInterruptEnableRegister               ;
    STA .userVIAInterruptEnableRegister                 ;
    CLI                                                 ; }
    NOP                                                 ; } give interrupts a chance to fire
    SEI                                                 ; }
    LDX #$d3                                            ;
    STX .systemVIAInterruptEnableRegister               ;
    LDA #$40                                            ;
    STA .systemVIAAuxiliaryControlRegister              ;

    LDA #$0e                                            ; }
    STA .systemVIATimer1LatchLow                        ; }
    STA .userVIAPeripheralControlRegister               ; } set timer 1 to $270e (=9998 uS)
    LDA #$27                                            ; }
    STA .systemVIATimer1LatchHigh                       ; }
    STA .systemVIATimer1CounterHigh                     ; }
-
    BIT .systemVIAInterruptFlagRegister                 ; wait for timer 1 interrupt to finish?
    BVC -                                               ;

    ; set variables $D7-$DA to initial values
    LDX #4                                              ;
-
    LDA .initialVariableValues - 1,X                    ;
    STA .lastKeyPressedInternal - 1,X                   ; initialise keyboard variables
    DEX                                                 ;
    BNE -                                               ;

    STX .unknownInterruptDisableFlag                    ; reset variables
    STX .systemVIAPeripheralControlRegister             ;
    ; fall through...

; ***************************************************************************************
;
; Copy the default vectors and MOS variables
;
; X is the loop counter
; ***************************************************************************************
    LDX #$49                                            ; loop counter
-
    LDA .defaultVectorTable - 1,X                       ; read from default vectors
    STA .page2Start - 1,X                               ; write to current vectors
    DEX                                                 ;
    BNE -                                               ; if not done yet then branch (loop back)

    ; Reset memory locations $00DB-$00FF
    TXA                                                 ; A = X = 0
    LDX #$DB                                            ; loop counter
-
    STA $00,X                                           ; }
    INX                                                 ; } this loop stores zero in zero-page memory locations $DB to $FF
    BNE -                                               ; }

    LDA $3fff                                           ; }
    EOR #$ff                                            ; } on a 16K machine $3fff and $7fff are the
    STA $7fff                                           ; } same memory location, resulting in a zero
    EOR $3fff                                           ; } result in A. Otherwise all bits are set.
    AND #$80                                            ; N flag set if 32K available
    LDX #0                                              ;
    STX $7fff                                           ; clear byte to zero (on screen)
    CLV                                                 ;
    LDX #12                                             ;
    LDY #8                                              ;
    STX .romSelectRegister                              ; }
    STY .romSelectRegister                              ; } switch to ROM 12 then 8
    BVC +                                               ;

    ORA #$40                                            ;
    CLV                                                 ;
+
    LDY #4                                              ; }
    STX .romSelectRegister                              ; } switch to ROM 12 then 4
    STY .romSelectRegister                              ; }
    BVC +                                               ;

    ORA #$20                                            ;
+
    STA .systemAvailableRAM                             ; $E0 for 32K, or $60 for 16K?
    LDX #%00001111                                      ; set System VIA PORT B to output on bits 0-3; input on bits 4-7
    STX .systemVIADataDirectionRegisterB                ;

; The next loop writes 13, 12, 11, 10, 9, 8 in turn to System VIA Register B which:
;       - sets the hardware scroll address to $3000;
;       - enables keyboard auto scanning;
;       - enable read/write speech;
;       - disable sound;
;
; (See .systemVIARegisterB)
    LDX #13                                             ; loop counter
-
    STX .systemVIARegisterB                             ; write system VIA register B
    DEX                                                 ;
    CPX #8                                              ;
    BCS -                                               ; if (X>=8) then branch (loop back and do it again)

    LDX #$58                                            ;
    LDY #10                                             ;
    STY .adcStartConversionRegister                     ;
    INC $f8                                             ;
    PLA                                                 ;
    BNE +                                               ;
    DEC $f8                                             ;
    STY .timeClockSwitch                                ;
    JSR .resetSoftKeys                                  ;
    LDA #0                                              ; value to store
    LDY #$40                                            ; loop counter
-
    STA .envelopeBuffer - 1,Y                           ; }
    DEY                                                 ; } loop to clear the envelope workspace $0800-$083F
    BNE -                                               ; }

    LDA #%01100100                                      ;
    STA .serialULARegisterCopy                          ; RS-423 has control. 1200 baud for transmit and receive.
    LDA #1                                              ;
    STA .printerDestination                             ; default to parallel printer
    LDA #10                                             ;
    STA .printerIgnoreCharacter                         ; set printer to ignore linefeeds

    ; clear MOS variables
    LDX #$4b                                            ; loop counter
+
    LDY .serialULARegisterCopy                          ;

    LDA #0                                              ; value to store
-
    STA .page2Start,X                                   ; }
    INX                                                 ; } loop to clear $024B-$2FF MOS variables
    BNE -                                               ; }

    TYA                                                 ;
    AND #$7f                                            ; clear top bit
    STA .serialULARegisterCopy                          ; this switches off the cassette motor and relay
    STA .serialULAControlRegister                       ;
    JSR .resetACIA1                                     ;
    LDX #3                                              ;
    ; fall through

; ***************************************************************************************
;
; Read ROM Types
;
; Check each sideways ROM (aka Paged ROM) and make a catalogue of their types X = 0...3
;
; Note that the OS itself is not a Paged ROM. As originally shipped, BASIC is the only
; Paged ROM present. The OS supports 4 Paged ROMS (0-3).
;
; ROM Header
; ----------
; $8000 = language entry point      (.romLanguageEntry)
; $8003 = service entry point       (.romServiceEntry)
; $8006 = ROM Type byte (see below) (.romTypeByte)
; $8007 = copyright message         (.romCopyrightOffsetPointer)
; $8009 = offset to title string    (.romTitleString)
;
; ROM Type Byte
; -------------
; bits 0-3  Processor Type (see below)
; bit 4     not used (Electron only)
; bit 5     Language ROM has a relocation address provided. The ROM can only run on the second
;           processor when located at that address.
; bit 6     If set, this is a language ROM (and can be chosen on RESET). Otherwise this is
;           a utility or Filing System ROM.
; bit 7     ROM has a service entry. All ROMs should have this bit set. (The BASIC ROM is the
;           exception, it does not have this bit set).
;
; Processor Type
; --------------
; Language ROMs can be copied across to a second processor and run there. Processor codes
; have been assigned:
;
;  0 = 6502 BASIC
;  1 = 6502 Turbo code
;  2 = 6502 machine code
;  3 = 68000 code
;  4 = -
;  5 = -
;  6 = -
;  7 = PDP-11 code
;  8 = Z80 code
;  9 = 32016 code
; 10 = -
; 11 = 80186 code
; 12 = 80286 code
; 13 = ARM code
; 14 = -
; 15 = -
;
; ***************************************************************************************
.selectROMLoop
    STX .currentlySelectedROM                           ; RAM copy of current ROM
    STX .romSelectRegister                              ; switch the ROM into the memory map
    LDX #3                                              ; set X to point to offset in table
    LDY .romCopyrightOffsetPointer                      ; get copyright offset from ROM
-
    LDA .romStartAddress,Y                              ; get first byte
    CMP .copyrightString,X                              ; compare it with table byte
    BNE .noCopyright                                    ; if (no copyright) then branch
    INY                                                 ; point to next byte in ROM
    DEX                                                 ; point to previous byte in ")C(",0 string
    BPL -                                               ; if (still +ve) then branch (go back to check next byte)
                                                        ; this point is reached if 4 bytes indicate valid ROM

    ; Check the first 2K of each ROM against higher priority ROMs to ensure that
    ; there are no matches. If a match is found, ignore the lower priority ROM
    LDX .currentlySelectedROM                           ; get RAM copy of ROM number in X
    TXA                                                 ; }
    TAY                                                 ; } and Y

.nextROM
    DEY                                                 ;
    BMI .romComparisonDone                              ; if (ROM number is 16 or more) then branch (done checking each ROM, store catalogue byte)
    TYA                                                 ; put Y in A
    EOR #$FF                                            ; invert it
    STA .tempStoreDB                                    ; and store at .tempStoreFA
    LDA #$7F                                            ; }
    STA .tempStoreDC                                    ; } store $7F at .tempStoreFB to get address $7FFF-Y

.nextByteInROM
    STY .romSelectRegister                              ; switch the ROM into the memory map
    LDA (.tempStoreDB),Y                                ; get byte
    STX .romSelectRegister                              ; switch the original ROM into the memory map
    CMP (.tempStoreDB),Y                                ; and compare with previous byte called
    BNE .nextROM                                        ; if (not the same) then branch (go back and do it again with next ROM)
    INC .tempStoreDB                                    ; increment .tempStoreFA to point to new location
    BNE .nextByteInROM                                  ; if (.tempStoreFA is not zero) then branch (check next byte)
    INC .tempStoreDC                                    ; increment tempStoreFB (high byte of address)
    LDA .tempStoreDC                                    ; load it
    CMP #$88                                            ; check if high byte has reached $88 = $80 + (8*256 bytes), i.e. 2k checked
    BCC .nextByteInROM                                  ; if (not checked 2k yet) then branch (check next 256 bytes)

.noCopyright
    LDX .currentlySelectedROM                           ; X=current ROM
    BPL +                                               ; if (+ve) then branch

.romComparisonDone
    LDA .romTypeByte                                    ; get rom type byte
    STA .romTypeTable,X                                 ; store it in catalogue
+
    DEX                                                 ;
    BPL .selectROMLoop                                  ;
    ; fall through...

; ***************************************************************************************
;
; Check for speech system
;
; ***************************************************************************************
    BIT .systemVIARegisterB                             ; check for speech system
    BVS +                                               ; if (bit 7 set) then branch (no speech system fitted)
    INC .speechSystemPresentFlag                        ; .speechSystemPresentFlag set to $01 to indicate speech present
+
    JSR .readKeyboardCtrlAndLinks                       ;
    ROR                                                 ;
    JMP .skipAddToKeyboardBuffer                        ;

; ***************************************************************************************
; [unused startup code]
    BCC .skipAddToKeyboardBuffer                        ; if (carry clear) then branch (skip forward)   [unused]
    LDX #$F6                                            ; loop counter                                  [unused]
    STX $0234                                           ; [not needed, value is written but never read] [unused]
-
    LDA .starDDot - $F6,X                               ; Read from string                              [unused]
    STA .vduVariablesStart,X                            ; Write to buffer                               [unused]
    INX                                                 ; increment counter                             [unused]
    BNE -                                               ; if (not done) then branch (loop back)         [unused]

; ***************************************************************************************
.skipAddToKeyboardBuffer
    LDA .keyboardLinks                                  ;
    EOR #$ff                                            ;
    JSR .initialiseScreenOnReset                        ;
    JSR .silenceAllChannels                             ;
    LDA #.charKEY10                                     ;
    JSR .insertByteIntoKeyboardBuffer                   ;
    LDY #<(.bootMessage - 1)                            ;
    JSR .displayString                                  ; output 'BBC Computer ' message
    LDA .lastResetType                                  ; 0=soft reset, anything else continue
    ROR                                                 ;
    BCS .outputTwoNewlines                              ; if (soft reset) then branch (skip
                                                        ; forward)
    LDY #<(.bootMessageMemory32 - 1)                    ;
    BIT .systemAvailableRAM                             ; read available RAM ($40 = 16k
                                                        ; $80 = 32k)
    BMI +                                               ; if (32k RAM available) then branch
    LDY #<(.bootMessageMemory16 - 1)                    ; set to point to 16K message
+
    JSR .displayString                                  ; write message with '16K' or '32K'

.outputTwoNewlines
    LDY #<(.bootMessageEnding - 1)                      ; and two newlines
    JSR .displayString                                  ;
    LDA #$ff                                            ;
    JSR .setupTapeBaudRateJumper2                       ;
    LDA #$80                                            ; }
    STA .tapeFilingSystemEnableFlag                     ; } activate tape filing system

    LDX #3                                              ; loop counter
-
    LDA .romTypeTable,X                                 ;
    BPL +                                               ; look for ROM type being negative
    STX .currentlySelectedROM                           ; if so we have a language.
    STX .romSelectRegister                              ;
    JSR .romLanguageEntry                               ;
+
    DEX                                                 ;
    BPL -                                               ;

    ; no rom has a negative type. Look for a rom with bit 6 set. Reset and enter that ROM.
    LDX #3                                              ; loop counter
-
    LDA .romTypeTable,X                                 ; get ROM type from map
    ROL                                                 ; put bit 6 into bit 7
    BMI .resetAndEnterLanguageROM                       ; if (bit 7 set then ROM has a language entry) then branch (initialise and enter ROM)

    DEX                                                 ;
    BPL -                                               ; search for language until X=255

    ; If no ROM found, then error
.noLanguageROMError
    BRK                                                 ;
    !byte $f9                                           ;
    !text "No language ROM", 0                          ;

.resetAndEnterLanguageROM
    STX .languageROMNumber                              ;
    STX .currentlySelectedROM                           ; RAM copy of current ROM
    STX .romSelectRegister                              ; switch the ROM into the memory map
    LDA #<(.romTitleString - 1)                         ; }
    STA .displayStringAddressLow                        ; }
    LDA #>(.romTitleString - 1)                         ; } set address of ROM title string
    STA .displayStringAddressHigh                       ; }
    JSR .displayStringWithAddressSet                    ;
    JSR .OSNEWL                                         ; two line feeds
    JSR .OSNEWL                                         ; are output
    LDA .romTypeByte                                    ;
    ROR                                                 ;
    AND $f8                                             ;
    ROR                                                 ;
    BCS +                                               ;
    JMP .romLanguageEntry                               ; enter language at $8000

+
    JMP .romServiceEntry                                ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 11: Interrupt processing
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; IRQ entry point
;
; On Entry:
;       The stack contains status register (flags); high and low bytes of previous program
;       counter.
;
; IRQ and BRK causes execution here. If it was a BRK instruction we branch (see .brkRoutine)
; otherwise we call (indirectly via IRQ1V) the default IRQ1 handler (see .irq1Handler)
;
; ***************************************************************************************
.irqEntryPoint
    STA .interruptAccumulator                           ; save A
    PLA                                                 ; read flags
    PHA                                                 ; store flags again
    AND #%00010000                                      ; check BRK flag
    BNE .brkRoutine                                     ; if (BRK flag set) then branch (to BRK handler)
    LDA .interruptAccumulator                           ;
    PHA                                                 ;
    TXA                                                 ;
    PHA                                                 ;
    TYA                                                 ;
    PHA                                                 ;
    JMP .processIRQ                                     ;

; ***************************************************************************************
.brkRoutine
    PLA                                                 ;
    CLD                                                 ;
    PLA                                                 ;
    SEC                                                 ; set carry
    SBC #1                                              ; subtract 1
    STA .brkAddressLow                                  ; and store
    PLA
    SBC #0                                              ; subtract 1 if necessary
    STA .brkAddressHigh                                 ; and store
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 123 - Generate BRK
;
; ***************************************************************************************
.osbyte123EntryPoint
    LDA .currentlySelectedROM                           ; get currently active ROM
    STA .romNumberActiveLastBRK                         ; and store it
    LDA .languageROMNumber                              ; get current language
    STA .currentlySelectedROM                           ; RAM copy of current ROM
    STA .romSelectRegister                              ; switch the ROM into the memory map
    CLI                                                 ; allow interrupts
    JMP (.vectorBRKV)                                   ; and JUMP via BRKV (normally into current language)

; ***************************************************************************************
.displayMessageAndHang
    JSR .OSNEWL                                         ; output a newline
    JSR .displayStringWithAddressSet                    ; display message
    LDA #.charQUESTIONMARK                              ;
    JSR .OSASCI                                         ; display question mark
    SEI                                                 ;
-
    JMP -                                               ; Hang machine!

.restoreAndReturnFromInterrupt
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
.processIRQ
    BIT .unknownInterruptDisableFlag                    ;
    BPL .irq1CheckACIA                                  ;
    JMP (.jimPagedEntryPoint)                           ;

; ***************************************************************************************
    STA .userVIAInterruptFlagRegister                   ; [unused]

.localRestoreRegistersAndReturnFromInterrupt
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
.readFromRS423
    LDY .acia6850DataRegister                           ; read serial data from ACIA
    CMP #2                                              ;
    BCS .rs423ErrorDetected                             ; if (not zero) then branch
    LDX #1                                              ; X=1
    TYA
    JSR .insertByteIntoBuffer                           ; put byte in RS-423 input buffer
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
.rs423ErrorDetected
    AND #8                                              ;
    BEQ +                                               ;
    JSR .generateESCAPECondition                        ;
+
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
.writeToACIA
    LDX #.bufferNumberPrinter                           ;
    JSR .osbyte152EntryPoint                            ;
    BCS +                                               ;
    PHA                                                 ;

    LDY #0                                              ; loop counter
-
    NOP                                                 ; }
    NOP                                                 ; }
    DEY                                                 ; } delay loop
    BNE -                                               ; }

    LDA .acia6850StatusRegister                         ;
    AND #8                                              ;
    CMP #8                                              ;
    PLA                                                 ;
    BCS .localRestoreRegistersAndReturnFromInterrupt    ;
    STA .acia6850DataRegister                           ;
    JSR .osbyte145EntryPoint                            ;
    ROR .printerBufferEmptyFlag                         ;
    BPL .localRestoreRegistersAndReturnFromInterrupt    ;
+
    ROR .printerBufferEmptyFlag                         ;
    LDX #0                                              ;
    JSR .writeToACIARequestToSend                       ;
    LDA #$E7                                            ; } reset timeout counter to
    STA .rs423TimeoutCounter                            ; } count up 25 vsyncs (0.5 seconds)
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
    STA .acia6850DataRegister                           ; [unused]
    JMP .restoreRegistersAndReturnFromInterrupt         ; [unused]

; ***************************************************************************************
;
; Check for ACIA Interrupt or Update ACIA
;
; Two modes of operation (V CLEAR and V SET)
;
; On Entry:
;       V CLEAR means check that the ACIA generated the interrupt, and if so then update
;               the RS-423 or cassette as needed
;       V  SET  means just update the RS-423
.irq1CheckACIA
    LDA .acia6850StatusRegister                         ;
    STA $02a5                                           ;
    BPL .irq1CheckSystemVIA                             ;
    LDX .rs423TimeoutCounter                            ;
    DEX                                                 ;
    BPL ++                                              ;
    ; fall through...

; ***************************************************************************************
;
; Service RS-423 interrupt
;
; See NAUG Section 8.4 - Serial system interrupts, Page 126
;
; On Entry:
;       A = ACIA status byte
;
;       Two modes of operation:
;       V CLEAR - read from RS-423; handle DCD (Data Carrier Detect); write to RS-423;
;                 handle unrecognised interrupt
;       V SET   - handle DCD; write to RS-423
; ***************************************************************************************
.rs423HasControl
    AND #$7f                                            ; clear top bit
    LSR                                                 ; shift right to put bit 0 of ACIA status (receive interrupt) in carry
    BIT .acia6850ControlRegisterCopy                    ;
    BPL +                                               ;
    BCS .readFromRS423                                  ;
+
    LSR                                                 ; shift,  put bit 1 of ACIA status into carry
    BCS .writeToACIA                                    ; if (ACIA status bit 1 is set) then branch (transmit interrupt)
    JMP .restoreRegistersAndReturnFromInterrupt         ;

++
    JSR .updateACIATapeJumper                           ;
    JMP .restoreRegistersAndReturnFromInterrupt         ;

.unrecognisedInterruptCheck
    JMP (.vectorIRQ1V)                                  ;

; ***************************************************************************************
;
; Check for User VIA interrupt
;
; Check if the User VIA triggered the interrupt and deal with it (check for parallel
; printer in particular).
; ***************************************************************************************
.irq1CheckUserVIA
    LDA .userVIAInterruptFlagRegister                   ; check User VIA interrupt flags register
    BPL .unrecognisedInterruptCheck                     ; if (User VIA did not call interrupt) then branch

    AND .userVIAInterruptEnableRegister                 ; }
    ROR                                                 ; }
    ROR                                                 ; } check for User IRQ bit 1 set (printer interrupt)
    BCC .unrecognisedInterruptCheck                     ;

    ; deal with parallel printer
    LDA #%00000010                                      ; interrupt bit 1 (printer interrupt)
    STA .userVIAInterruptFlagRegister                   ; clear interrupt bit 1
    STA .userVIAInterruptEnableRegister                 ; enable interrupt bit 1
    LDX #.bufferNumberPrinter                           ; }
    JSR .openPrinterChannel                             ; } output data to parallel printer
    JMP .restoreRegistersAndReturnFromInterrupt         ;

; ***************************************************************************************
;
; Check for System VIA interrupt
;
; Check if the System VIA triggered the interrupt and deal with it.
; ***************************************************************************************
.irq1CheckSystemVIA
    LDA .systemVIAInterruptFlagRegister                 ; read system VIA interrupt flag register
    BPL .irq1CheckUserVIA                               ; if (the System VIA has not caused interrupt) then branch (try the next thing)

    AND .systemVIAInterruptEnableRegister               ; and interrupt enable register
    ROL                                                 ;
    BPL .irq1CheckSystemVIAKeyboard                     ;
    LDA #$40                                            ;
    STA .systemVIAInterruptFlagRegister                 ; timer 1 clear interrupt
    LDA .lastKeyPressedInternal                         ;
    ORA .firstKeyPressedInternal                        ;
    BEQ +                                               ;
    JSR .keyboardTimerInterrupt                         ;
+
    ; Update the 5 byte clock in timerClockA/B
    LDA .timeClockSwitch                                ; get current system clock pointer (5 or 10)
    TAX                                                 ; put old system clock pointer in X
    EOR #$0F                                            ; invert bits so it toggles between 5 and 10
    PHA                                                 ; remember A
    TAY                                                 ; put new system clock pointer in Y
    SEC                                                 ;
-
    LDA .timeClockA-1,X                                 ; get current system clock value
    ADC #0                                              ; increment it (carry is set on the first iteration of the loop,
                                                        ;     thereafter carry is set as needed based on this increment)
    STA .timeClockA-1,Y                                 ; store result in new copy
    DEX                                                 ; decrement X
    BEQ +                                               ; if (finished) then branch (loop ends)
    DEY                                                 ; decrement Y
    BNE -                                               ; and go back and do next byte

+
    PLA                                                 ; get back new clock pointer
    STA .timeClockSwitch                                ; and store back in clock pointer
    LDX .timeClockSwitch                                ;
    LDY #5                                              ;
-
    LDA .timeClockB - 1,Y                               ;
    CMP .timeClockA - 1,X                               ;
    BNE +                                               ; check if timeClockA has reached timeClockB
    DEX                                                 ;
    DEY                                                 ;
    BNE -                                               ;

    LDY #.eventClockTimeReached                         ;
    JSR .eventEntryPoint                                ; send event if timers match
+
    ; Update countdown interval timer. An EVENT is generated when it times out.
    LDX #5                                              ; set loop counter
-
    INC .countdownIntervalTimer - 1,X                   ; increment byte for countdown timer
    BNE +                                               ; if (done updating timer bytes) then branch
    DEX                                                 ; decrement loop counter
    BNE -                                               ; if (not finished looping) do it again

    LDY #.eventIntervalTimerCrossingZero                ; at this point all the interval timer bytes are zero
    JSR .eventEntryPoint                                ; call EVENT 5 interval timer

    ; Update INKEY timeout. Used when reading a key within a time limit.
+
    LDA .inkeyTimeoutCounterLow                         ; get low byte of inkey countdown timer
    BNE +                                               ; if (inkey timer is non-zero) then branch forward
    LDA .inkeyTimeoutCounterHigh                        ; get high byte of inkey countdown timer
    BEQ ++                                              ; if (inkey timer is zero) then branch forward
    DEC .inkeyTimeoutCounterHigh                        ; decrement high byte
+
    DEC .inkeyTimeoutCounterLow                         ; and decrement low byte

    ; Update sound.
++
    BIT .soundIsUpdatingFlag                            ; check bit 7 of sound flag
                                                        ; (this bit is set while processing
                                                        ; sound interrupt. check so we don't
                                                        ; try to process a second sound
                                                        ; interrupt while still processing
                                                        ; the first)
    BMI +                                               ;
+
    JSR .processSoundInterrupt                          ;

    ; Update ADC conversion.
    BIT .adcDataStatusRegister                          ; check ADC status register
    BVS .handleADCConversionEnds                        ; if (bit 6 is set, i.e. ADC not
                                                        ; busy) then branch

    BVC .restoreRegistersAndReturnFromInterrupt         ; ALWAYS branch

; ***************************************************************************************
.irq1CheckSystemVIAKeyboard
    ROR                                                 ;
    ROR                                                 ;
    BCC .irq1CheckSystemVIAVSYNC                        ;
    JSR .keyEntryPoint                                  ;
    LDA #1                                              ;
    BNE +                                               ; [redundant!]
+
.storeToSystemVIAIFR
    STA .systemVIAInterruptFlagRegister                 ; cancel keyboard interrupts

.restoreRegistersAndReturnFromInterrupt
    PLA                                                 ;
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    PLA                                                 ;
    RTI                                                 ;

; ***************************************************************************************
.irq1CheckSystemVIAVSYNC
    ROR                                                 ;
    BCC ++                                              ;
    ROR $f0                                             ;

    ; vsync interrupt
    DEC .verticalSyncCounter                            ; decrement vertical sync counter
    LDA .rs423TimeoutCounter                            ; A = RS-423 Timeout counter
    BPL +                                               ; if (positive) then branch
    INC .rs423TimeoutCounter                            ; increment counter
+
    LDA .videoULAFlashingColourIntervalCount            ; load flash counter
    BEQ .doneFlashingColours                            ; if (flashing system is not in use) then branch
    DEC .videoULAFlashingColourIntervalCount            ; decrement counter
    BNE .doneFlashingColours                            ; if (not time for a colour to flash) then branch (to continue processing)

    ; ready to flash colour
    LDX .videoULAFirstFlashingColourInterval            ; get mark period count in X
    LDA .videoULAVideoControlRegisterCopy               ; current Video ULA control setting in A
    LSR                                                 ; shift bit 0 into C
    BCC .restoreAndFlipBit                              ; if (first colour is in effect) then branch

    LDX .videoULASecondFlashingColourInterval           ; get second colour period count in X
.restoreAndFlipBit
    ROL                                                 ; restore bit
    EOR #1                                              ; and invert it
    JSR .setVideoULAInternal                            ; then set colour
    STX .videoULAFlashingColourIntervalCount            ; reset the count until the next flash

.doneFlashingColours
    LDY #.eventStartOfVSync                             ;
    JSR .eventEntryPoint                                ; call the event
    LDA #%00000010                                      ; A=bit set to clear the vsync interrupt flag
    BNE .storeToSystemVIAIFR                            ; ALWAYS branch, clear interrupt and exit

++
    ROR                                                 ;
    ROR                                                 ;
    BCC +                                               ;
    LDA #%00001000                                      ;
    BNE .storeToSystemVIAIFR                            ; clear interrupt 3

+
    ROR                                                 ;
    BCC ++                                              ;

.handleADCConversionEnds
    LDX .adcCurrentChannel                              ; get current ADC channel
    BEQ .clearInterrupt4                                ; if (zero) then branch (clear interrupt and exit)

    LDA .adcDataLowByte                                 ; read low data byte
    STA .lowByteLastByteFromADCChannel1 - 1,X           ; store it in memory
    LDA .adcDataHighByte                                ; get high data byte
    STA .highByteLastByteFromADCChannel1 - 1,X          ; and store it in high byte

    LDY #.eventADCConversionComplete                    ; handle event 3 conversion complete
    JSR .eventEntryPoint                                ;

    DEC .adcCurrentChannel                              ;
    BNE +                                               ;
    LDY .maximumADCChannelNumber                        ;
    STY .adcCurrentChannel                              ;
+
    LDY .adcCurrentChannel                              ;
    DEY                                                 ; decrement
    TYA                                                 ; A=Y
    AND #3                                              ;
    ORA #8                                              ;
    STA .adcStartConversionRegister                     ; store value to start ADC conversion

.clearInterrupt4
    LDA #%00010000                                      ;
    BNE .storeToSystemVIAIFR                            ;
++
    JMP .unrecognisedInterruptCheck                     ;

; ***************************************************************************************
;
; Display string on screen
;
; Display the boot message (e.g. 'BBC Computer 32K') and language ROM title (e.g. 'BASIC')
;
; On Entry:
;       Y = offset from page of .displayStringArea to start of string -1
;
; ***************************************************************************************
.displayString
    LDA #>.displayStringArea                            ; Start of string area (high byte)
    STA .displayStringAddressHigh                       ; store it
    STY .displayStringAddressLow                        ; store low byte
.displayStringWithAddressSet
    LDY #0                                              ; loop counter
-
    INC .displayStringAddressLow                        ; }
    BNE +                                               ; } move to next character
    INC .displayStringAddressHigh                       ; }
+
    LDA (.displayStringAddressLow),Y                    ; print character in string
    JSR .OSASCI                                         ; print it expanding Carriage returns
    BNE -                                               ; and loop again if not zero
    RTS                                                 ;

; ***************************************************************************************
; On Entry:
;       X/Y holds the time limit
.osbyte129Timed
    STX .inkeyTimeoutCounterLow                         ; store time in INKEY countdown timer
    STY .inkeyTimeoutCounterHigh                        ; which is decremented every 10ms
    LDA #255                                            ;
    STA .readCharacterTimedFlag                         ;
    BNE .readCharacterTimed                             ; ALWAYS branch

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 12: Command Line Interpreter (star commands)
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Introduction
;
; The Command Line Interpreter is responsible for executing star commands. There are a number
; built in to the system (see .starCommandTable), and more can be added via paged ROMs.
;
; The commands can have parameters as integer decimal, hexadecimal values, and strings.
; These commands have characters in the range 32-126, but can encode control codes and other
; non-printable characters. It uses GSINIT and GSREAD to convert the set of ASCII printable
; string characters into a full 8-bit ASCII converted values. See .gsinitEntryPoint .
;
; This chapter contains integer (in string form) to byte conversion,
; see .parseDecimalNumberFromString. A conversion for a hex digit in string form to a byte,
; see .readHexDigit, which is used to read a wole 32 bit address, see .readOSFILEAddress .
;
; Historical note: Every Acorn computer from the System 2 onwards has a CLI, and the
; asterisk probably derives from the System 2's use of it as a prompt character.
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSRDCH - Read a character
;       This reads from an EXEC file if open, or the current input buffer otherwise
;
; On Entry:
;       A = 0 for reading a key instantly
;       A = 255 for reading a key with a time limit
;
; ***************************************************************************************
.osrdchEntryPoint
    LDA #0                                              ;
    STA .inkeyTimeoutCounterLow                         ;
    STA .inkeyTimeoutCounterHigh                        ;
    STA .readCharacterTimedFlag                         ;

.readCharacterTimed
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } store X and Y
    PHA                                                 ; }
    LDY .execFileHandle                                 ; get *EXEC file handle
    BEQ .readCharacterFromCurrentInputBufferLoop        ; if (zero, i.e. no EXEC file open) then branch

    JSR .OSBGET                                         ; get a byte from the file
    BCC .pullAndReturn                                  ; if (character found) then branch (recall values and exit)
    LDA #0                                              ; error reading from file, so close the file
    STA .execFileHandle                                 ; store it in exec file handle
    JSR .OSFIND                                         ; and close file via OSFIND

.readCharacterFromCurrentInputBufferLoop
    BIT .escapeFlag                                     ; check ESCAPE flag
    BMI .setEscapeConditionAndExit                      ; if (ESCAPE flag set) then branch (set escape condition and exit)
    LDX .currentInputBuffer                             ; get current input buffer number
    JSR .readFromSoftKeyOrInputBufferA                  ; get a byte from current input buffer
    BCC .pullAndReturn                                  ; if (valid character found) then branch (exit)

    LDA .inkeyTimeoutCounterLow                         ;
    ORA .inkeyTimeoutCounterHigh                        ;
    BIT .readCharacterTimedFlag                         ;
    BVC .readCharacterFromCurrentInputBufferLoop        ;
    BNE .readCharacterFromCurrentInputBufferLoop        ;
    SEC                                                 ;
    BCS +                                               ;

.setEscapeConditionAndExit
    SEC                                                 ;
    LDA #.charESCAPE                                    ; ESCAPE character read

.pullAndReturn
    STA .readCharacterTimedFlag                         ; remember character read
+
    PLA                                                 ; }
    TAY                                                 ; } restore X,Y
    PLA                                                 ; }
    TAX                                                 ; }
    LDA .readCharacterTimedFlag                         ; recall character read
    RTS                                                 ;

; ***************************************************************************************
;
; Copyright string
; Only used as part of the check for valid Paged ROM, never printed
;
; ***************************************************************************************
.copyrightString
    !text ")C(", 0

; ***************************************************************************************
;
; Star command table
;
; *. <directory>                Synonym of *CAT
; *FX <a>,<x>,<y>               Calls OSBYTE
; *BASIC                        Start BASIC
; *CAT <directory>              Show catalogue from filing system
; *CODE <x>,<y>                 Execute code via USERV with A=0
; *EXEC <filename>              Execute a script file
; *HELP <string>                Get help
; *KEY <n> <string>             Define a soft key definition
; *LINE <string>                Execute code via USERV with A=1
; *LOAD <filename> <addr>       Load file
; *MOTOR <n>                    Turn on/off cassette motor
; *OPT <x>,<y>                  Set filing system options (Equivalent to OSBYTE 139)
; *RUN <filename>               Load and execute a file from the current filing system
; *ROM                          Set ROM filing system
; *SAVE <filename> <start> <end> <exec> <load> Save memory to the current filing system
; *SPOOL <filename>             Save keystrokes to the current filing system
; *TAPE <n>                     Set the TAPE filing system
; *TV <x>,<y>                   Adjust the TV display
;
; Commands can be abbreviated, e.g. *M. for *MOTOR.
;
; This list is not quite alphabetical, so that short abbreviations yield the more common
; commands, so *LOAD comes before *LINE so that *L. becomes *LOAD; and *R. becomes *RUN,
; not *ROM.
;
; The last entry is empty to catch anything else.
;
; After the name and address of each command is a single byte parameter that is passed in
; the accumulator before calling the routine's address. If the parameter has the top bit
; clear (*.; *BASIC; *CAT; *EXEC; *LOAD; *LINE; *RUN; *SAVE; *SPOOL), then the next part of
; the command line is decoded into a string (usually a pathname).
;
; A group of commands (*CODE; *MOTOR; *OPT; *TAPE; *ROM; *TV) are synonyms for *FX calls
; with the parameter being the OSBYTE number.
;
; Historical note: The Acorn System 2 star commands were *BASIC, *CAT, *LOAD, *SAVE, *GO,
; *RUN, *MEM, *MON, *NOMON, *DRIVE, *USE, and *FLOAD, while the Atom provided *CAT, *LOAD,
; *SAVE, *RUN, *MON, *NOMON, *FLOAD, and *DOS. Their CLIs each provide the dot abbreviation
; and have similar command-parsing code. But the System 2 and Atom monitors lack the ability
; to EXEC scripts, and have no comment notation. *FLOAD, "finish loading", allowed part of
; a file to be loaded into memory by ignoring its block numbers -- an ability which was,
; perhaps wisely, dropped from the BBC.
;
; ***************************************************************************************
.starCommandTable
    !text "CAT"                                         ;
    !be16 .starCommandsForSpecificOSBYTEs               ; *CAT
    !byte $8A                                           ;

    !be16 .passCommandToROMs                            ; *.
    !byte $01                                           ;

    !text "DISC"                                        ; *DISC
    !be16 .noFilingSystemError                          ;
    !byte $04                                           ;

    !text "DISK"                                        ;
    !be16 .noFilingSystemError                          ; *DISK
    !byte $04                                           ;

    !text "DEBUG"                                       ;
    !be16 .OSDBUG                                       ; *DEBUG
    !byte 0                                             ;

    !text "EXEC"                                        ;
    !be16 .starExec                                     ; *EXEC
    !byte 0                                             ;

    !text "FX"                                          ;
    !be16 .fxEntryPoint                                 ; *FX
    !byte $FF                                           ;

    !text "KEY"                                         ;
    !be16 .starKey                                      ; *KEY
    !byte $FF                                           ;

    !text "LOAD"                                        ;
    !be16 .starLoadSave                                 ; *LOAD
    !byte 1                                             ;

    !text "MOTOR"                                       ;
    !be16 .starCommandsForSpecificOSBYTEs               ; *MOTOR
    !byte $89                                           ;

    !text "NET"                                         ;
    !be16 .noFilingSystemError                          ; *NET
    !byte 3                                             ;

    !text "NOTAPE"                                      ;
    !be16 .starNoTape                                   ; *NOTAPE
    !byte 0                                             ;

    !text "OPT"                                         ;
    !be16 .starCommandsForSpecificOSBYTEs               ; *OPT
    !byte $8b                                           ;

    !text "RUN"                                         ;
    !be16 .passToCurrentFilingSystem                    ; *RUN
    !byte 0                                             ;

    !text "SAVE"                                        ;
    !be16 .starLoadSave                                 ; *SAVE
    !byte 0                                             ;

    !text "SPOOL"                                       ;
    !be16 .starSpool                                    ; *SPOOL
    !byte 0                                             ;

    !text "TAPE"                                        ;
    !be16 .starCommandsForSpecificOSBYTEs               ; *TAPE
    !byte $8c                                           ;

    !text "TV"                                          ;
    !be16 .starCommandsForSpecificOSBYTEs               ; *TV
    !byte $90                                           ;

    !byte 0                                             ;

; ***************************************************************************************
;
; OSCLI - Command Line Interpreter
;       the default handler for CLIV vector
;
; On Entry:
;       XY is the address of the command line (terminated with a carriage return)
;
; On Exit:
;       A,X,Y,Flags undefined
;
; ***************************************************************************************
.oscliEntryPoint
    STX .stringInputBufferAddressLow                    ;
    STY .stringInputBufferAddressHigh                   ;
    LDY #0                                              ; loop counter
-
    LDA (.stringInputBufferAddressLow),Y                ; Check the line is correctly terminated
    CMP #.charRETURN                                    ; loop until CR is found
    BEQ .stringOK                                       ;
    INY                                                 ; move to next character
    BNE -                                               ; loop back if less than 256 bytes long
    BEQ .exit15                                         ; ALWAYS branch

    ; String is terminated ok - now skip prepended spaces and '*'s
.stringOK
    LDY #$FF                                            ; Y = offset into string (which is about to be incremented so it will start at zero)
-
    JSR .incAndSkipSpaces                               ; Skip any spaces
    BEQ .exit15                                         ; if (CR found) then branch (return)
    CMP #.charSTAR                                      ; check for '*'
    BEQ -                                               ; if ('*' found) then branch (Loop back to skip it and skip spaces again)

    JSR .skipSpacesAndCheckForCRInStringInput           ; doesn't need to move forward, but checks if the current character is CR
    BEQ .exit15                                         ; if (CR found) then branch (exit)
    CMP #.charBAR                                       ; check for '|' (a comment)
    BEQ .exit15                                         ; if ('|' found) then branch (exit)
    STY .currentStringPointer                           ;
    LDX #0                                              ;
    ; fall through...

; ***************************************************************************************
;
; Compare character in A in a star command
;
; ***************************************************************************************
.compareCharacterInCommand
    AND #%11011111                                      ; ignore case (zero the bit that distinguishes between upper and lower case)
    BEQ .namesDontMatch                                 ;
    BMI .namesDontMatch                                 ;
    CMP .starCommandTable,X                             ;
    BNE .namesDontMatch                                 ; if (no match) then branch
    INY                                                 ; increment offset in command line
    CLC                                                 ; test next character

.atEndOfCommandName
    BCS .foundMatchForCommand                           ;
    INX                                                 ; increment offset in star command table
    LDA (.stringInputBufferAddressLow),Y                ; read next character in command line
    JSR .isLetter                                       ; carry clear if letter in A
    BCC .compareCharacterInCommand                      ;

    CMP #.charDOT                                       ; check for '.'
    BEQ .foundDot                                       ; if (dot character found) then branch
    LDA .starCommandTable,X                             ;
    BPL .namesDontMatch                                 ;
    INX                                                 ;
    INX                                                 ;

.foundMatchForCommand
    DEX                                                 ;
    DEX                                                 ;
    STA .tempStore285                                   ;
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip over the following spaces
    PHP                                                 ;
    LDA .starCommandTable + 1,X                         ;
    STA .tempStore284                                   ;
    JSR .prepareRegistersForStarCommand                 ; prepare the A,X,Y registers for the call to star command routine
    PLP                                                 ;
    CLC                                                 ;
    JMP (.tempStore284)                                 ;

.namesDontMatch
    CLC                                                 ;
    LDY .currentStringPointer                           ;
    DEY                                                 ;

.foundDot
    INY                                                 ;
    INX                                                 ;

-
    INX                                                 ;
    LDA .starCommandTable-2,X                           ;

    BEQ .passCommandToROMs                              ; reached end of table; unrecognised star command
    BPL -                                               ; if (top bit clear, i.e. not yet end of command name) then branch back (move to next character)
    BMI .atEndOfCommandName                             ; ALWAYS branch (loop back)

.prepareRegistersForStarCommand
    LDA .starCommandTable+2,X                           ; Get A parameter from table
    BMI .exit15                                         ; if (top bit set, this implies the
                                                        ; command has no string parameter, but
                                                        ; there may be numeric parameters)
                                                        ; then branch (exit, we are done)
                                                        ; otherwise we set XY to be the rest
                                                        ; of the command line (i.e. string
                                                        ; based)
    ; fall through...

; ***************************************************************************************
;
; Convert string input pointer to XY
;
; On Entry:
;       X is the offset into the starCommandTable at the end of the string
;       Y is the offset into the string at .stringInputBufferAddressLow/High
;
; On Exit:
;       XY = (.stringInputBufferAddressLow/High + A)
;       A = parameter from star command table
;
; ***************************************************************************************
.convertStringInputPointerToXY
    TYA                                                 ; Pass Y line offset to A for later
    LDY .starCommandTable+2,X                           ; Get A parameter from table
    ; fall through...

; ***************************************************************************************
;
; Convert string address to XY
;
; On Entry:
;       A = is offset into string at .stringInputBufferAddressLow/High
;
; On Exit:
;       XY = .stringInputBufferAddressLow/High + A
;       A = original value of Y on entry
;
; ***************************************************************************************
.convertStringAddressToXY
    CLC                                                 ;
    ADC .stringInputBufferAddressLow                    ;
    TAX                                                 ; low byte in X
    TYA                                                 ; remember original Y into A
    LDY .stringInputBufferAddressHigh                   ; }
    BCC .exit15                                         ; } put high byte in Y, increment as needed
    INY                                                 ; }
.exit15
    RTS                                                 ;

; ***************************************************************************************
;
; Pass command on to filing system
;
; ***************************************************************************************
.passCommandToROMs
    BIT .tapeFilingSystemEnableFlag                     ;
    BPL +                                               ; if (tape filing system NOT active) then branch
    JMP .badCommandError                                ;

+
    ROR                                                 ;
    BCS .passToCurrentFilingSystem                      ;
    JSR .convertStringInputPointerToXY                  ;

.passToCurrentFilingSystem
    JMP (.vectorFSCV)                                   ; call into current filing system
                                                        ; handler (for default handler,
                                                        ; see .fscEntryPoint)


; ***************************************************************************************
;
; Close EXEC file and optionally open a new EXEC file
;
; On Entry:
;       A = 0
;       Z = 0 means close any open EXEC file.
;       Z = 1 means open the exec file whose filename is in address XY.
;
; ***************************************************************************************
.starExec
    PHP                                                 ; save flags on stack
    STY .tempStorage27C                                 ; .tempWorkspace27C = Y
    LDY .execFileHandle                                 ; file handle of EXEC file to be closed
    STA .execFileHandle                                 ; record EXEC file closed (A=0)
    BEQ +                                               ; if (closing an exec file) then branch
    JSR .OSFIND                                         ; close EXEC file (A=0; Y=file handle)
+
    LDY .tempStorage27C                                 ; Y = original Y
    PLP                                                 ; get back flags
    BEQ .exit19                                         ; if (zero flag set on entry) then branch (exit)

    LDA #$c0                                            ; A is value for opening an input file
    JSR .OSFIND                                         ; open an EXEC file
    TAY                                                 ; Y=A
    BNE +                                               ;
-
    JMP .badCommandError                                ;

+
    STA .execFileHandle                                 ;
.exit19
    RTS                                                 ;

; ***************************************************************************************
;
;   *SPOOL
;
; On Entry:
;       A = 0 (and carry clear) to close the currently SPOOLed file, OR
;       A = file handle to start SPOOLing
; On Exit:
;       if closing a spooled file:
;           A, X and Y are preserved
;       if opening a spooled file:
;          A = Y = file handle for spooled file
;
; ***************************************************************************************
.starSpool
    PHP                                                 ; push flags
    STY .tempStorage27C                                 ; remember Y
    LDY .spoolFileHandle                                ; get file handle
    STA .spoolFileHandle                                ; store A as file handle
    BEQ +                                               ; if (Y is zero) then branch (skip forward)
    JSR .OSFIND                                         ; close the file using OSFIND
+
    LDY .tempStorage27C                                 ; recall Y
    PLP                                                 ; pull flags
    BEQ .exit19a                                        ; if (A = 0 on entry) then branch (exit, we are done)
    LDA #$80                                            ; A is value for 'open file for output'
    JSR .OSFIND                                         ; open file XY for output using OSFIND
    TAY                                                 ; Y=A=file handle for *SPOOLed file
    BEQ -                                               ;
    STA .spoolFileHandle                                ; store new file handle
.exit19a
    RTS                                                 ;

; ***************************************************************************************
;
;   *NOTAPE
;
; ***************************************************************************************
.starNoTape
    PHP                                                 ; remember flags
    SEI                                                 ; disable interrupts
    LDX #14                                             ; loop counter
-
    LDA .defaultFileSystemVectors - 1,X                 ; read addresses for filing system errors
    STA .vectorFILEV - 1,X                              ; store in current filing system vectors
    DEX                                                 ;
    BNE -                                               ; loop back until done
    STX .tapeFilingSystemEnableFlag                     ; clear flag (X=0)
    PLP                                                 ; restore flags
    RTS                                                 ;

; ***************************************************************************************
;
; Skip spaces
;
; On Entry:
;       .stringInputBufferAddressLow/High is address of string to test
;       Y is the current offset within the string
;
; On Exit:
;       Y is incremented to the next non-space character
;       Z set if RETURN found (end of string)
;
; ***************************************************************************************
.incAndSkipSpaces
    INY                                                 ; move to next character in string
.skipSpacesAndCheckForCRInStringInput
    LDA (.stringInputBufferAddressLow),Y                ; read character from string
    CMP #.charSPACE                                     ; check for SPACE character
    BEQ .incAndSkipSpaces                               ; if (SPACE) then branch (loop back)
.compareWithReturnAndExit
    CMP #.charRETURN                                    ; set Z flag if charRETURN found
    RTS                                                 ;

; ***************************************************************************************
;
; Skip spaces and comma
;
; Skip past any spaces, and check for CR
;
; On Entry:
;     if carry is clear, then skip SPACEs then look for RETURN
;     if carry is set, then skip SPACEs then skip a comma or look for a RETURN
;
; On Exit:
;       Y incremented past any spaces and comma
;       Z set if RETURN found
;
; ***************************************************************************************
.skipSpacesAndComma
    BCC .skipSpacesAndCheckForCRInStringInput           ;
.skipSpacesAndCommaValid
    JSR .skipSpacesAndCheckForCRInStringInput           ;
    CMP #.charCOMMA                                     ;
    BNE .compareWithReturnAndExit                       ;
    INY                                                 ; move to next character. Y is not
                                                        ; zero so Z is set.
    RTS                                                 ;

; ***************************************************************************************
;
; Read a number (0-255) from string
;
; On Entry:
;       stringInputBufferAddressLow/High + Y is address of string holding a number
; On Exit:
;       X = result (value 0-255) also stored in .tempWorkspaceE6
;       Carry clear on error
;       Zero set if RETURN found
;
; ***************************************************************************************
.parseDecimalNumberFromString
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip spaces
    JSR .readDigitFromString                            ; read digit
    BCC .errorReadingString                             ; if (error found) then branch (clear carry and exit)

.readingDigits
    STA .tempWorkspaceE0                                ; store temporary result
    JSR .readNextDigitFromString                        ; read next digit 0-9
    BCC .finishedParsingDigits                          ; if (not a digit) then branch (we have finished)
    TAX                                                 ; remember best valid result so far
    LDA .tempWorkspaceE0                                ; recall previous digit P
    ASL                                                 ; A=P*2
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ASL                                                 ; A=P*4
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ADC .tempWorkspaceE0                                ; A=(P*4)+P =P*5
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ASL                                                 ; A=P*10
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    STA .tempWorkspaceE0                                ; Store temporary result
    TXA                                                 ; recall current digit
    ADC .tempWorkspaceE0                                ; Add previous digit times ten
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    BCC .readingDigits                                  ; ALWAYS branch back

; ***************************************************************************************
.finishedParsingDigits
    LDX .tempWorkspaceE0                                ; get best valid result
    CMP #.charRETURN                                    ; set Z flag if RETURN found
    SEC                                                 ; set carry (success flag)
    RTS                                                 ;

; ***************************************************************************************
.readNextDigitFromString
    INY                                                 ;
.readDigitFromString
    LDA (.stringInputBufferAddressLow),Y                ; get digit from string
    CMP #.charNINE + 1                                  ; }
    BCS .errorReadingString                             ; } check if digit is in range '0' to '9'
    CMP #.charZERO                                      ; }
    BCC .errorReadingString                             ; }
    AND #$0F                                            ; mask off bits to leave binary value 0-9
    RTS                                                 ;

; ***************************************************************************************
.notAHexByte
    JSR .skipSpacesAndCommaValid                        ;

.errorReadingString
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Read hex digit
;
; On Exit:
;       on success, carry is set, A = 0-15, based on ascii digit in string (0-9,A-F)
;       on error, carry clear
;
; ***************************************************************************************
.readHexDigit
    JSR .readDigitFromString                            ; read digit 0-9
    BCS +                                               ; if (digit not in 0-9 range) then branch
    AND #%11011111                                      ; clear bit 5 (converts lower case letters to upper case)
    CMP #.charF + 1                                     ;
    BCS .notAHexByte                                    ; if (higher than 'F') then branch (exit with error)
    CMP #.charA                                         ;
    BCC .notAHexByte                                    ; if (lower than 'A') then branch (exit with error)
    PHP                                                 ; carry set, push flags
    SBC #.charA - 10                                    ; Convert to range 10-15
    PLP                                                 ; restore flags (carry set, for successful result)
+
    INY                                                 ; move on to next byte
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 13: Writing characters; printer; buffers
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSWRCH - write character
;
; This is the main entry point for writing characters to the display and/or to other devices
; such as ECONET, a printer, RS-423 or to a file.
;
; Note: the .characterDestinationsAvailableFlags has the following bits:
;
;   bit 0 - enable RS-423 driver
;   bit 1 - disable VDU driver
;   bit 2 - disable printer driver
;   bit 3 - enable printer, independent of VDU 2/3 (=CTRL B/C)
;   bit 4 - disable SPOOLed output
;   bit 5 - not used, zero
;   bit 6 - disable printer driver (unless preceded by VDU 1)
;   bit 7 - not used, zero
;
; On Entry:
;       A = character to write
; On Exit:
;       A, X, Y are preserved
;
; ***************************************************************************************
.oswrchEntryPoint
    PHA                                                 ; }
    TXA                                                 ; }
    PHA                                                 ; } store A,X,Y registers
    TYA                                                 ; }
    PHA                                                 ; }
    TSX                                                 ; X = stack pointer
    LDA .stackPage + 3,X                                ; peek into stack to get A value back
    PHA                                                 ; push A again
    LDA .characterDestinationsAvailableFlags            ;
    ROR                                                 ;
    BCS +                                               ;
    PLA                                                 ;
    PHA                                                 ;
    JSR .vduChrEntryPointInternalJumper                 ;
    BCC .skipVDUOutput                                  ;
+
    LDA #4                                              ;
    BIT .characterDestinationsAvailableFlags            ;
    BNE .skipVDUOutput                                  ; yes, skip past VDU driver
    PLA                                                 ; pull character
    PHA                                                 ; push character
    JSR .sendCharacterToPrinter                         ; call VDU driver
.skipVDUOutput

    LDA #2                                              ; check output destination
    BIT .characterDestinationsAvailableFlags            ; is VDU driver disabled?
    BEQ +                                               ;
    PLA                                                 ; pull character
    PHA                                                 ; push character
+
    LDA #8                                              ; check output destination
    BIT .characterDestinationsAvailableFlags            ; is printer separately enabled?
    BNE .oswrchFinishUp                                 ; yes, jump to call printer driver
    PLA                                                 ;
    PHA                                                 ;
    LDY .spoolFileHandle                                ;
    BEQ .oswrchFinishUp                                 ;
    JSR .OSBPUT                                         ;

.oswrchFinishUp
    PLA                                                 ;
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } restore A,X,Y registers
    TAX                                                 ; }
    PLA                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
;
; On Entry:
;       A=character to print
;
; ***************************************************************************************
.sendCharacterToPrinter
    CMP .printerIgnoreCharacter                         ; compare character against printer ignore character
    BEQ .exit16                                         ; if (the same) then branch (exit)

.sendValidByteToPrinter
    PHP                                                 ; save flags (including IRQ flag)
    SEI                                                 ; disable interrupts

    LDX .printerDestination                             ;
    BEQ .pullAndExit14                                  ; if (no printer destination) then branch (exit)
    LDX #.bufferNumberPrinter                           ; X=printer buffer number
    CLC
-
    SEI                                                 ;
    JSR .setKeyboardLEDSOnAndTestEscapeFlag             ; Note; carry is clear on the first
                                                        ; time around the loop, set otherwise
                                                        ; This call sets the keyboard LEDs
                                                        ; ON when carry is set, then always
                                                        ; tests the escape flag.
    BMI ++                                              ;
    JSR .insEntryPoint                                  ;
    BCC +                                               ; if (carry clear, i.e. successful) then branch
    CLI                                                 ; enable interrupts (to allow ESCAPE?)
    BCS -                                               ; ALWAYS branch (loop back)
+
    BIT .printerBufferEmptyFlag                         ; check buffer empty flag
    BPL ++                                              ; if (printer buffer is not empty) then branch (pull flags and exit)
    JSR .openPrinterChannel                             ; open printer channel

++
    JSR .keyboardIndicators                             ;
.pullAndExit14
    PLP                                                 ;
.exit16
    RTS                                                 ;

; ***************************************************************************************
.openPrinterChannel
    LDA .printerDestination                             ;
    ROR                                                 ;
    BCC .serialPrinter                                  ;

    ; deal with parallel printer
    JSR .osbyte145EntryPoint                            ; read a byte from the printer buffer
    ROR .printerBufferEmptyFlag                         ; rotate carry into bit 7 of the printer buffer empty flag
    BMI .exit17                                         ; if (printer buffer empty) then branch (return)

    ; To send data to the parallel printer:
    ;
    ; 1. Enable the User VIA interrupt '1'. The printer will trigger an IRQ when it is ready
    ;    for another character.
    ; 2. Write the byte to send to .userVIARegisterA
    ; 3. Set bits 1-3 of the userVIAPeripheralControlRegister to %110
    ; 4. Set bits 1-3 of the userVIAPeripheralControlRegister to %111
    ; This sends a 'STROBE' signal to advise the printer that valid data is waiting.

    LDY #%10000010                                      ; enable interrupt 1 of the user VIA
    STY .userVIAInterruptEnableRegister                 ; this is triggered by the printer
                                                        ; when it is ready to receive a new
                                                        ; character
    STA .userVIARegisterA                               ; pass byte to the Centronics port
    LDA .userVIAPeripheralControlRegister               ; }
    AND #%11110001                                      ; }
    ORA #%00001100                                      ; } pulse CA2 line to generate
    STA .userVIAPeripheralControlRegister               ; } STROBE signal to advise printer
    ORA #%00001110                                      ; } that valid data is waiting
    STA .userVIAPeripheralControlRegister               ; }
    BNE .exit17                                         ; ALWAYS branch (return)
                                                        ; [this could just be an RTS, saving one byte]

; ***************************************************************************************
.serialPrinter
    ROR                                                 ;
    BCC .exit17                                         ;
    LDY .rs423TimeoutCounter                            ;
    DEY                                                 ;
    BPL +                                               ;
    CLC                                                 ;
    ROR .printerBufferEmptyFlag                         ;
    LDX #%00100000                                      ; set bit 5 on ACIA control register
                                                        ; set 'Request To Send' low (meaning Active)

.writeToACIARequestToSend
    LDA #%10011111                                      ; Mask for setting bits 5 and 6
                                                        ; This writes the 'Request To Send'
                                                        ; value.
    STX .tempStoreDB                                    ; .tempStoreFB=X
    AND .acia6850ControlRegisterCopy                    ; A=old value AND Y EOR X
    ORA .tempStoreDB                                    ;
    STA .acia6850ControlRegister                        ; }
    STA .acia6850ControlRegisterCopy                    ; } store new value
    RTS                                                 ;

.exit17
    RTS                                                 ;

+
    JMP .flushBufferX                                   ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 14: Star commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Clear four consecutive bytes in the OSFILE block
;
; The data required by the OSFILE call is stored at .osfileBlockStart, is 18 bytes long, and
; is as follows:
;
;       byte      description
;       0-1       address of filename
;       2-5       load address
;       6-9       execution address
;       10-13     start address (or length)
;       14-17     end address (or file attributes)
;
; This call clears one of these 4 byte addresses.
;
; On Entry:
;       X is the start offset within the OSFILE block
; On Exit:
;       Preserves A,X,Y
; ***************************************************************************************
.clearOSFILEAddress
    PHA                                                 ; push A
    LDA #0                                              ; A=0
    STA .osfileBlockStart + 0,X                         ; clear osfile control block workspace
    STA .osfileBlockStart + 1,X                         ;
    STA .osfileBlockStart + 2,X                         ;
    STA .osfileBlockStart + 3,X                         ;
    PLA                                                 ; get back A
    RTS                                                 ;

; ***************************************************************************************
;
; Shift one hex digit into an OSFILE address
;
; Used as part of .readOSFILEAddress
;
; On Entry:
;       A contains hex digit 0-15
;       X contains the offset into the .osfileBlockStart for the address to be updated
; On Exit:
;       The four byte address at .osfileBlockStart+X is shifted four binary bits and the new
;       digit is inserted at the least significant end.
;       Preserves Y
; ***************************************************************************************
.shiftDigitIntoAddress
    STY .tempStorage27C                                 ; remember Y
    ROL                                                 ; A=A*2
    ROL                                                 ; *4
    ROL                                                 ; *8
    ROL                                                 ; *16
    LDY #4                                              ; Y=loop counter
-
    ROL                                                 ; A=A*32
    ROL .osfileBlockStart + 0,X                         ; shift bit 7 of A into shift register
    ROL .osfileBlockStart + 1,X                         ; and
    ROL .osfileBlockStart + 2,X                         ; shift
    ROL .osfileBlockStart + 3,X                         ; along
    BCS .brkBadAddress                                  ; if (carry set on exit, i.e. register has overflowed) then branch ('Bad address' error)
    DEY                                                 ; decrement Y
    BNE -                                               ; if (Y > 0) then branch (do another shift)

    LDY .tempStorage27C                                 ; recall original Y
    RTS                                                 ;

; ***************************************************************************************
.brkBadAddress
    BRK                                                 ;
    !byte $fc                                           ;
    !text "Bad address", 0                              ;

; ***************************************************************************************
;
;   *SAVE Entry (and *LOAD continued)
;
; On Entry:
;       A=0         for *SAVE
;       A=non-zero  for *LOAD
;       XY = address of rest of command line
;
; ***************************************************************************************
.starLoadSave
    STX .stringInputBufferAddressLow                    ; store address of rest of command line
    STY .stringInputBufferAddressHigh                   ;
    STX .osfileFilenameAddressLow                       ; X and Y are stored in OSfile control block
    STY .osfileFilenameAddressHigh                      ;
    PHA                                                 ; Push A
    LDX #.osfileLoadAddressLow - .osfileBlockStart      ; X=2
    JSR .clearOSFILEAddress                             ; clear the load address

    LDA #$FF                                            ; Y=255
    STA .osfileExecAddressLow                           ; store $FF in exec address low byte

    ; For a *LOAD (A=$FF) this byte (.osfileExecAddressLow) is used as a flag (it's available
    ; since we don't need the executable address when just loading a file). Zero means use the
    ; specified load address. Non-zero means use the load address from the file. This is
    ; OSFILE behaviour.

    LDY #0                                              ;
    JSR .gsinitEntryPoint                               ;
-
    JSR .gsreadEntryPoint                               ; read a byte from text line
    BCC -                                               ; until end of line reached
    PLA                                                 ; recall original A
    PHA                                                 ;
    BEQ .starSave                                       ; if (A=0, i.e. *SAVE) then branch

    ; loading
    JSR .readOSFILEAddress                              ; read hex byte into start address
    BCS .checkForErrorAndLoadFile                       ; if (success) then branch (load using OSFILE)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line found) then branch
    BNE .brkBadAddress                                  ;

; ***************************************************************************************
.checkForErrorAndLoadFile
    BNE .localBadCommandError                           ; if (not end of command line) then branch (show 'Bad command' error)
    INC .osfileExecAddressLow                           ; increment execution address low
                                                        ; byte to zero (when A=255 as OSFILE
                                                        ; parameter, zero means use specified
                                                        ; address)

.callOSFILEWithParameterBlockForLoadSave
    LDX #<.osfileBlockStart                             ; }
    LDY #>.osfileBlockStart                             ; } XY = address of OSFILE parameter block
    PLA                                                 ; get back A
    JMP .OSFILE                                         ; and JUMP to OSFILE

; ***************************************************************************************
;
; Read hex bytes into OSFILE address (start / end / load / exec address)
;
; On Entry:
;       X is the offset to the address to write to
;
; On Exit:
;       C set on success
;       Z set if end of line found
; ***************************************************************************************
.readOSFILEAddress
    JSR .skipSpacesAndCheckForCRInStringInput           ; look for NEWline
    JSR .readHexDigit                                   ; carry is set if it finds hex digit
    BCC .exit20                                         ; so exit
    JSR .clearOSFILEAddress                             ; clear start address in OSFILE block
-
    JSR .shiftDigitIntoAddress                          ; shift lower nybble of A into shift register
    JSR .readHexDigit                                   ; then check for Hex digit
    BCS -                                               ; if (found digit) then branch (do it again)
    SEC                                                 ; set carry
.exit20
    RTS                                                 ;


; ***************************************************************************************
.starSave
    LDX #.osfileStartAddressLow - .osfileBlockStart     ; X=offset into OSFILE block to clear start address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (no start address found) then branch (exit via 'Bad command' error)
    CLV                                                 ; clear bit 6

    ;
    ; check for '+' to indicate a length rather than the end address
    ;
    LDA (.stringInputBufferAddressLow),Y                ; read next byte from text line
    CMP #.charPLUS                                      ; is it '+'
    BNE +                                               ; if (not '+') then branch (it's the end address)
    BIT .allBitsSet                                     ; set V flag (it's the length)
    INY                                                 ; increment Y to point to hex group
+

    ;
    ; read file length/end address from command line string
    ;
    LDX #.osfileEndAddressLow - .osfileBlockStart       ; X=offset into OSFILE block for end address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (carry clear, i.e. no hex byte found) then branch ('Bad command' error)
    PHP                                                 ; save flags
    BVC .explicitEndAddressFound                        ; if (V clear; i.e. explicit end address found; i.e. no '+') then branch

    ; add start address and length, and store as end address
    LDX #$FC                                            ; X=loop counter, from $FC incrementing to $00 (4 bytes copied)
    CLC                                                 ; clear carry
-
    LDA .osfileStartAddressLow - $FC,X                  ; Get start address
    ADC .page2Start - $84,X                             ; add length
    STA .page2Start - $84,X                             ; store as end address
    INX                                                 ;
    BNE -                                               ; loop until X=0

.explicitEndAddressFound
    LDX #3                                              ; X=loop counter
-
    LDA .osfileStartAddressLow,X                        ; }
    STA .osfileExecAddressLow,X                         ; }
    STA .osfileLoadAddressLow,X                         ; } copy start adddress to load and execution addresses
    DEX                                                 ; }
    BPL -                                               ; }

    PLP                                                 ; get back flag
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of command line reached) then branch to do OSFILE

    ;
    ; read command line for execution address
    ;
    LDX #.osfileExecAddressLow - .osfileBlockStart      ; X=offset into OSFILE block for execution address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line reached) then branch (do OSFILE)

    ;
    ; read command line for load address
    ;
    LDX #.osfileLoadAddressLow - .osfileBlockStart      ; X=offset into OSFILE block for load address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line) then branch (do OSFILE)
.localBadCommandError
    BNE .badCommandError                                ; ALWAYS branch

; ***************************************************************************************
;
; *KEY
;
; The *KEY <number> <string> command defines one of 16 strings. These strings are associated
; with keys on the keyboard. When the key is pressed, the contents of the string are entered
; into the input buffer ('expanded'). These are also known as 'soft key' definitions.
;
;       *KEY number     Definition
;           0-9         Function keys f0-f9
;            10         When BREAK is pressed, the contents of the string are played
;            11         COPY key
;            12         LEFT key
;            13         RIGHT key
;            14         DOWN key
;            15         UP key
;
; Whether the soft keys are expanded is controlled by OSBYTE 225 (See .functionAndCursorKeyCodes)
; For the COPY key and cursor keys to be expanded, they must also be enabled using OSBYTE 4
; with X = 2 (see .osbyte4EntryPoint) which is translated into a call to OSBYTE 237, which
; updates memory location .cursorEditingType. (See .cursorEditingType)
;
; Memory
; Soft key definitions are stored in $0B00-$0BFF (See .softKeyPage). The first 16 bytes
; ($0B00-$0B0F) are a table of byte offsets from $0B01 to the start of the string definition
; for that soft key.
;
; The seventeenth byte (at $0B10) is the offset from $0B01 to the first free byte after all
; soft key definitions (See .softKeysCurrentEndOffset). If a key has no definition, it's
; offset also points to the first free byte.
;
; The string definitions follow (with no terminators).
;
; When a new key is defined (or undefined using *KEY <number>) the existing strings are
; compacted (shuffled down in memory to leave no gaps) with the old definition removed so the
; new definition can be added on the end. (See .compactStarKeyStrings). Thus the string
; definitions always appear in memory in the order they are defined, with the latest *KEY
; definition showing last.
;
; On Entry:
;   Y = offset to source string of command line
;
; ***************************************************************************************
.starKey
    JSR .parseDecimalNumberFromString                   ; set up key number in A
    BCC .badKeyError                                    ; if (not valid number) then branch ('Bad key' error)
    CPX .numberOfSoftKeyDefinitions                     ;
    BCS .badKeyError                                    ; if (key number is 16 or more) then branch ('Bad key' error)
    ROR .stringInputPlingFlag                           ;
    STX $e7                                             ;
    LDX .softKeysCurrentEndOffset                       ;
    STX .softKeysCurrentEndOffset + 1                   ;
    JSR .skipSpacesAndCommaValid                        ; skip commas, and check for CR
    BNE .addStarKeyString                               ;
    TXA                                                 ;
    TAY                                                 ;
    JMP .compactStarKeyStrings                          ; compact soft key definitions

.badCommandError
    BRK                                                 ;
    !byte $fe                                           ;
    !text "Bad command"                                 ;

.badKeyError
    BRK                                                 ;
    !byte $fb                                           ;
    !text "Bad key", 0                                  ;

; ***************************************************************************************
;
; *FX
;
; This is the entry point for the OSCLI call to execute "*FX <A>,<X>,<Y>". We parse the first
; numeric parameter ('A') then fall through to the version that parses a range of other star
; commands with 'X' and 'Y' parameters, each implemented with an OSBYTE call.
;
; ***************************************************************************************
.fxEntryPoint
    JSR .parseDecimalNumberFromString                   ; convert the number to binary
    BCC .badCommandError                                ; if (bad number) then branch ('Bad command' error)
    TXA                                                 ; put the parsed first parameter in A
    ; fall through...

; ***************************************************************************************
;
; Handle a range of star commands
;
; On Entry:
;       A = $88     *CODE
;       A = $89     *MOTOR
;       A = $8B     *OPT
;       A = $8C     *TAPE
;       A = $8D     *ROM
;       A = $90     *TV
;       A = any     *FX     (when falling through from .fxEntryPoint above)
;
; Parses star commands with one or two numeric (0-255) parameters 'X' and 'Y' (space and/or
; comma separated) then calls OSBYTE with A as above.
;
; ***************************************************************************************
.starCommandsForSpecificOSBYTEs
    PHA                                                 ; save A
    LDA #0                                              ; }
    STA .starCommandXParameter                          ; } clear the X/Y parameters for the upcoming OSBYTE call
    STA .starCommandYParameter                          ; }
    JSR .skipSpacesAndComma                             ; skip commas and check for newline (CR)
    BEQ .parsedParameters                               ; if (CR found) then branch (to call appropriate OSBYTE)

    JSR .parseDecimalNumberFromString                   ; parse first parameter (X Parameter for OSBYTE)
    BCC .badCommandError                                ; if (bad character) then branch (to give bad command error)
    STX .starCommandXParameter                          ; store as X parameter for OSBYTE
    JSR .skipSpacesAndCommaValid                        ; skip comma and check CR
    BEQ .parsedParameters                               ; if (CR found) then branch (to call appropriate OSBYTE)

    JSR .parseDecimalNumberFromString                   ; parse second parameter (Y Parameter for OSBYTE)
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    STX .starCommandYParameter                          ; store as Y parameter for OSBYTE
    JSR .skipSpacesAndCheckForCRInStringInput           ; now we must have a CR
    BNE .badCommandError                                ; if (no CR) then branch ('Bad command' error)

.parsedParameters
    LDY .starCommandYParameter                          ; Y = OSBYTE parameter
    LDX .starCommandXParameter                          ; X = OSBYTE parameter
    PLA                                                 ; A = OSBYTE parameter
    JMP .OSBYTE                                         ; call OSBYTE

; ***************************************************************************************
;
; Add a new *KEY string
; See .starKey.
;
; ***************************************************************************************
.addStarKeyString
    SEC                                                 ; set carry (meaning: check for '"' marks around string)
    JSR .gsinitEntryPointInternal                       ; start reading string

    ; copy string into *KEY buffer
-
    JSR .gsreadEntryPoint                               ; read string
    BCS +                                               ; if (end of string reached) then branch (deal with end of string)
    INX                                                 ; point to first byte of new key definition
    BEQ .badKeyError                                    ; if (X=0, i.e. buffer overflow) then branch (exit with 'Bad Key' error)

    ROL                                                 ;
    ROL .stringInputPlingFlag                           ;
    ROR                                                 ;
    STA .softKeyPage,X                                  ; store character
    BCC -                                               ; if (not end of line) then branch (loop to copy next byte)
+
    BNE .badKeyError                                    ; if (parsing error) then branch (show 'Bad Key' error)
    STX .softKeysCurrentEndOffset + 1                   ;
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    JSR .compactStarKeyStrings                          ; compact *KEY definitions with the stored string definition

    ; Update the array of offsets that point to the start of each string
    LDX #$10                                            ; set loop counter
-
    CPX .tempWorkspaceE7                                ; check for key already being defined
    BEQ .skipRestOfLoop                                 ; if (key already being defined) then branch (skip rest of loop)
    LDA .softKeyPage,X                                  ; get start of string X
    CMP .softKeyPage,Y                                  ; compare with start of string Y
    BNE .skipRestOfLoop                                 ; if (not the same) then branch (skip rest of loop)
    LDA .softKeysCurrentEndOffset                       ; store top of string definition
    STA .softKeyPage,X                                  ; in designated key pointer
.skipRestOfLoop
    DEX                                                 ; decrement loop pointer X
    BPL -                                               ; and do it all again
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
;
; Get *KEY string length
;
; Get the length of a soft key definition. See .starKey.
;
; On Entry:
;       Y = *KEY number
;
; On Exit:
;       A = string length
;       Preserves X,Y
;
; ***************************************************************************************
.getStarKeyStringLength
    PHP                                                 ; push flags
    LDA .softKeysCurrentEndOffset                       ; get top of currently defined strings
    SEC                                                 ;
    SBC .softKeyPage,Y                                  ; subtract to get the number of bytes in strings above end of string Y

    SEI
    STA .tempStoreDB                                    ; store this
    TXA                                                 ; save X
    PHA                                                 ;
    LDX #$10                                            ; and X=16

-
    LDA .softKeyPage,X                                  ; get start offset (from .softKeyPage) of key string X
    SEC                                                 ;
    SBC .softKeyPage,Y                                  ; subtract offset of string we are working on
    BCC +                                               ; if (carry clear, i.e. .softKeyPage+Y > .softKeyPage+X) then branch (forward)
    BEQ +                                               ; if (result in A=0) then branch (forward)
    CMP .tempStoreDB                                    ; check against number of bytes above string we are working on
    BCS +                                               ; if (>= number of bytes above string we are working on) then branch
    STA .tempStoreDB                                    ; store A in .tempStoreDB
+
    DEX                                                 ; point to next lower key offset
    BPL -                                               ; if (not negative) then branch (loop back and do it again)

    PLA                                                 ; get back value of X
    TAX                                                 ;
    LDA .tempStoreDB                                    ; get back latest value of A
    PLP                                                 ; pull flags
    RTS                                                 ;

; ***************************************************************************************
;
; Compact *KEY strings
;
; Remove an existing definition, and move the remaining definitions down in memory (so that
; we can add a new definition on the end).
; See .starKey.
;
; On Entry:
;       .tempWorkspaceE7 = key number
; On Exit:
;       X is preserved
;
; ***************************************************************************************
.compactStarKeyStrings
    LDY .tempWorkspaceE7                                ; get key number
    JSR .getStarKeyStringLength                         ; and set up .tempStoreFB to length of existing string
    STA .tempWorkspaceE6                                ;
    LDA .softKeyPage,Y                                  ; get start of string Y
    TAY                                                 ; put it in Y
    CLC                                                 ; clear carry
    ADC .tempWorkspaceE6                                ; add number of bytes for existing string
    TAX                                                 ; X = new end position
    STA .tempStoreDB                                    ; and store it in .tempStoreDB
    PHP
    SEI
    LDA .softKeyStringLength                            ; check to see if we are already defining a *KEY string
    BEQ +                                               ; if (key is not already being defined) branch
.keyInUseError
    BRK                                                 ; definition expanded) so error.  This stops *KEY 1 "*key1 FRED" etc.
    !byte $FA                                           ; error number
    !text "Key in use",0                                ;

+
    LDA .softKeysCurrentEndOffset + 1                   ;
    SEC                                                 ;
    SBC .tempStoreDB                                    ; subtract .tempStoreFA
    STA .tempStoreDB                                    ; and re store it
    BEQ +                                               ; if (zero) then branch

    ; move string from offset X to offset Y
-
    LDA .softKeyPage + 1,X                              ; read byte from offset X
    STA .softKeyPage + 1,Y                              ; write character to offset Y
    INY                                                 ; increment pointer
    INX                                                 ; increment pointer
    DEC .tempStoreDB                                    ; decrement loop counter
    BNE -                                               ; if (not done yet) then branch (loop back)

+
    LDY .tempWorkspaceE7                                ; get back key number

    ; adjust the offset to each KEY now we have moved one
    LDX #$11                                            ; point at top of last string
-
    LDA .softKeyPage,X                                  ; get this value
    CMP .softKeyPage,Y                                  ; compare it with start of new or re defined key
    BCC +                                               ; if (less) then branch
    BEQ +                                               ; if (equal) then branch
    SEC
    SBC .tempWorkspaceE6                                ; shift key definitions accordingly
    STA .softKeyPage,X                                  ; store new offset to KEY X
+
    DEX                                                 ; point to next lowest string def
    BPL -                                               ; if (X=>0) then branch (loop back and do it again)

    LDA .softKeysCurrentEndOffset                       ; make top of key definitions
    STA .softKeyPage,Y                                  ; the start of our key def
    LDA .softKeysCurrentEndOffset + 1                   ;
    STA .softKeysCurrentEndOffset                       ; and store it
    PLP                                                 ; restore flags
    RTS                                                 ;

; ***************************************************************************************
.bufferAddressesHigh
    !byte >(.keyboardInputBuffer - .keyboardInputBufferOffset)       ; 0 = Keyboard
    !byte >(.tapeOrRS423InputBuffer - .tapeOrRS423InputBufferOffset) ; 1 = tape/RS-423 Input
    !byte >(.tapeOrRS423OutputBuffer - .rs423OutputBufferOffset)     ; 2 = RS-423 output
    !byte >(.printerBuffer - .printerBufferOffset)                   ; 3 = printer
    !byte >(.soundChannel0Buffer - .soundChannel0BufferOffset)       ; 4 = sound channel 0
    !byte >(.soundChannel1Buffer - .soundChannel1BufferOffset)       ; 5 = sound channel 1
    !byte >(.soundChannel2Buffer - .soundChannel2BufferOffset)       ; 6 = sound channel 2
    !byte >(.soundChannel3Buffer - .soundChannel3BufferOffset)       ; 7 = sound channel 3

; ***************************************************************************************
.bufferAddressesLow
    !byte <(.keyboardInputBuffer - .keyboardInputBufferOffset)       ; 0 = Keyboard
    !byte <(.tapeOrRS423InputBuffer - .tapeOrRS423InputBufferOffset) ; 1 = tape/RS-423 Input
    !byte <(.tapeOrRS423OutputBuffer - .rs423OutputBufferOffset)     ; 2 = RS-423 output
    !byte <(.printerBuffer - .printerBufferOffset)                   ; 3 = printer
    !byte <(.soundChannel0Buffer - .soundChannel0BufferOffset)       ; 4 = sound channel 0
    !byte <(.soundChannel1Buffer - .soundChannel1BufferOffset)       ; 5 = sound channel 1
    !byte <(.soundChannel2Buffer - .soundChannel2BufferOffset)       ; 6 = sound channel 2
    !byte <(.soundChannel3Buffer - .soundChannel3BufferOffset)       ; 7 = sound channel 3

; ***************************************************************************************
.emptyBufferStartOffset
    !byte .keyboardInputBufferOffset                    ; 0 = Keyboard
    !byte .tapeOrRS423InputBufferOffset                 ; 1 = tape/RS-423 Input
    !byte .rs423OutputBufferOffset                      ; 2 = RS-423 output
    !byte .printerBufferOffset                          ; 3 = printer
    !byte .soundChannel0BufferOffset                    ; 4 = sound channel 0
    !byte .soundChannel1BufferOffset                    ; 5 = sound channel 1
    !byte .soundChannel2BufferOffset                    ; 6 = sound channel 2
    !byte .soundChannel3BufferOffset                    ; 7 = sound channel 3


; ***************************************************************************************
;
; Get buffer address
;
; For buffer numbers, see .bufferNumberKeyboard.
;
; On Entry:
;       X=buffer number
;
; ***************************************************************************************
.getBufferAddress
    LDA .bufferAddressesLow,X                           ; get buffer base address low
    STA .tempStoreDB                                    ; store it
    LDA .bufferAddressesHigh,X                          ; get buffer base address high
    STA .tempStoreDC                                    ; store it
    RTS                                                 ;


; ***************************************************************************************
;
; Count or Purge Buffer (CNPV) - Default Entry Point
;
; On Entry:
;       X = buffer to access
;       if V set then purge buffer (else count buffer)
;       for count buffer: if C set then get bytes free
;                                  else get bytes used
;
; ***************************************************************************************
.cnpEntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    SEC                                                 ; set carry
    LDA .bufferEndIndices - 1,X                         ; get end of buffer
    SBC .bufferStartIndices - 1,X                       ; subtract start of buffer
    BCS +                                               ; if (carry set) then branch
    SEC                                                 ; set carry
    SBC .emptyBufferStartOffset,X                       ; subtract buffer start offset (i.e. add buffer length)
+
    CPX #2                                              ;
    BCC .recallAndExit                                  ; if (buffer is input; 0=keyboard or 1=RS-423 input) then branch
    CLC                                                 ; clear carry
    ADC .emptyBufferStartOffset,X                       ; adc to get bytes used
    EOR #$FF                                            ; and invert to get space left
.recallAndExit
    PLP                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; INSV - insert value into buffer - default handler
;
; On Entry:
;       A is value to write
;       X is buffer number
; On Exit:
;       A preserved
;       X preserved
;       C clear on success
;
; ***************************************************************************************
.insEntryPoint
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
.insEntryPointInternal
    PHA                                                 ; save A
    LDY .bufferEndIndices - 1,X                         ; get buffer input pointer
    INY                                                 ; increment Y to next byte
    BNE +                                               ; if (not reached the end index) then branch (skip forward)
    LDY .emptyBufferStartOffset,X                       ; set back to the start index
+
    TYA                                                 ; put it in A
    CMP .bufferStartIndices - 1,X                       ; compare it with input pointer
    BEQ .insertIntoFullBuffer                           ; if (buffer is full) then branch
    LDY .bufferEndIndices - 1,X                         ; get buffer end in Y
    STA .bufferEndIndices - 1,X                         ; set new offset
    JSR .getBufferAddress                               ; and point .tempStoreFA/B at it

    CPX #4                                              ;
    BCC +                                               ;
    ROR .bufferEmptyFlags,X                             ; set flag for buffer number >= 4
+
    PLA                                                 ; get back value to write
    STA (.tempStoreDB),Y                                ; write it in buffer
    PLP                                                 ; pull flags
.yesLetter
    CLC                                                 ; clear carry for success
    RTS                                                 ;

.insertIntoFullBuffer
    PLA                                                 ; get back byte
.pullSetCarryAndExit
    PLP                                                 ; restore flags
.noLetter
    SEC                                                 ; set carry
    RTS                                                 ;

; ***************************************************************************************
;
; Events
;
; Events are a slightly simpler way for users to use an interrupt. Events are disabled by
; default, but can be enabled via OSBYTE 14 (see .osbyte14EntryPoint). Different event types
; can be individually enabled or disabled. For the list of different event types,
; see .eventOutputBufferBecomesEmpty.
;
; Most events are generated from the default IRQ handling code. When a relevant interrupt
; happens .eventEntryPoint is called with the event type. If enabled, this calls the EVNTV
; vector with the event type in the accumulator. The default implementation of the EVNTV
; vector does nothing, but the user can intercept this vector and do their own processing.
;
; This provides a simpler (and more limited) interface to handling interrupts than
; intercepting the IRQ1 or IRQ2 vectors directly. Events can't override the default interrupt
; handling, but are executed in addition.
;
; As with regular interrupt code, event handling code must not enable interrupts, and should
; be brief (The Acorn User Guide suggests "one millisecond maximum", 2000 clock cycles,
; whereas the New Advanced User Guide suggests it should "not last for more than about 2ms").
;
; The user can generate their own events by calling .OSEVEN with A=9 (.eventUserEvent)
;
; (See NAUG Section 7, Page 119)
;
; On Entry:
;       A = parameter to pass into EVENV vector in Y
;       X = parameter to pass into EVENV vector in X
;       Y = event type
; On Exit:
;       A is preserved.
;       Flags are preserved except for carry:
;       Carry clear indicates the event was called successfully because it was enabled.
;
; ***************************************************************************************
.eventEntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    STA .tempStore294                                   ; .tempStoreFA = A
    LDA .eventEnabledFlags,Y                            ; get enable event flag
    BEQ .pullSetCarryAndExit                            ; if (event is not enabled) then branch (exit with carry set)
    TYA                                                 ; Y = event enabled flag
    LDY .tempStore294                                   ; Y = original A
    JSR .eventJumper                                    ; call the EVENV vector
    PLP                                                 ; get back flags
    CLC                                                 ; clear carry for success
    RTS                                                 ;

; ***************************************************************************************
.eventJumper
    JMP (.vectorIRQ2V)                                  ;

; ***************************************************************************************
;
; Check for a letter (A-Z or a-z)
;
; On Entry:
;       A = character to check
; On Exit:
;       Preserves A
;       Carry clear if character is an upper or lower case letter (A-Z or a-z)
;       otherwise carry set
;
; ***************************************************************************************
.isLetter
    CMP #.charA                                         ; compare with 'A'
    BCC .noLetter                                       ; if (lower than 'A') then branch (exit routine with carry set)
    CMP #.charZ + 1                                     ; compare with 'Z' + 1
    BCC .yesLetter                                      ; if (no larger than 'Z') then branch (exit with carry clear)

    CMP #.chara                                         ; compare with 'a'
    BCC .noLetter                                       ; if (lower than 'a') then branch (exit routine with carry set)
    CMP #.charz + 1                                     ; compare with 'z' + 1
    RTS                                                 ;

; [ Alternatively this would use five fewer bytes...
; .isLetter
;    PHA                                                ; Save A
;    AND #$DF                                           ; convert lower to upper case
;    SEC                                                ;
;    SBC #.charA                                        ; 'A'-'Z' maps to 0-25
;    CMP #26                                            ; check if in range 0-25
;    PLA                                                ;
;    RTS                                                ; ]

; ***************************************************************************************
;
; OSBYTE 152 - Examine buffer status
;
; On Entry:
;       X = buffer number
; On Exit:
;       X preserved
;       if buffer is empty C=1, Y is preserved
;                     else C=0, Y is offset to next character in buffer at $FA/B
;
; ***************************************************************************************
.osbyte152EntryPoint
    BIT .allBitsSet                                     ; set V flag (meaning examine buffer)
    BVS .remEntryPoint                                  ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 145 - Get byte from buffer
;
; On Entry:
;       X = buffer number
; On Exit:
;       X preserved
;       Y = character extracted
;       if buffer is empty C=1, else C=0
;
; ***************************************************************************************
.osbyte145EntryPoint
    CLV                                                 ;
    ; fall through...

; ***************************************************************************************
;
; REMV - default entry point for remove from/examine buffer vector
;
; On Entry:
;       X = buffer number
;       V = 1 if only examination is requested
; On Exit:
;       Examination Only:   A = next byte to be removed
;                           X preserved
;                           Y = offset to next character in buffer at $FA/B
;
;       Removal:            A undefined
;                           X preserved
;                           Y = value of the byte removed
;
;       if buffer was already empty C=1
;                              else C=0
;
; Used by: OSBYTE 152 - examine buffer status
;      and OSBYTE 145 - get byte from buffer
;
; ***************************************************************************************
.remEntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .bufferStartIndices - 1,X                       ; get output pointer for buffer X
    CMP .bufferEndIndices - 1,X                         ; compare to input pointer
    BEQ .pullSetCarryAndExit                            ; if (equal, i.e. buffer is empty) then branch (exit)
    TAY                                                 ; Y = buffer start position
    JSR .getBufferAddress                               ; and get buffer pointer into .tempStoreFA/B
    LDA (.tempStoreDB),Y                                ; read byte from buffer
    BVS .pullClearCarryAndExit                          ; if (V is set, i.e. only examination) then branch (exit with CARRY clear)
                                                        ; OSBYTE 152 has been done
    PHA                                                 ; must be OSBYTE 145 so save byte
    INY                                                 ; increment Y
    TYA                                                 ; A=Y
    BNE +                                               ; if (end of buffer not reached) then branch
    LDA .emptyBufferStartOffset,X                       ; get pointer start from offset table
+
    STA .bufferStartIndices - 1,X                       ; set buffer output pointer
    PLA                                                 ; get back byte from buffer
.pullClearCarryAndExit
    PLP                                                 ; get back flags
    CLC                                                 ; clear carry to indicate success
    RTS                                                 ;

.flushBufferX
    PHA                                                 ;
    PHP                                                 ;
    SEI                                                 ;
    CPX #4                                              ;
    BCC +                                               ; if (not sound buffer) then branch
    ROR .bufferEmptyFlags - 4,X                         ; sound buffer ROR flag
+
    CPX #.bufferNumberPrinter                           ;
    BNE +                                               ;
    ROR .printerBufferEmptyFlag                         ; printer buffer flag
+
    LDA .bufferStartIndices - 1,X                       ; get output pointer for buffer X
    STA .bufferEndIndices - 1, X                        ;
    PLP                                                 ;
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Put byte in keyboard buffer
;
; On Entry:
;       Y is character to be written
;
; On Exit:
;       Carry clear
;
; ***************************************************************************************
.insertByteIntoKeyboardBuffer
    LDX #0                                              ; X=0 to indicate keyboard buffer

.insertByteIntoBuffer
    CMP #.charESCAPE                                    ;
    BNE .generateEventAndPutByteIntoBuffer              ; if (not ESCAPE character) OR (ESCAPE action says ASCII) then branch (to enter byte in buffer)
    LDY .escapeAction                                   ; current ESCAPE status (0=ESC, 1=ASCII)
    BNE .generateEventAndPutByteIntoBuffer              ; if (ESCAPE action says ASCII) then branch (to enter byte in buffer)
.generateESCAPECondition
    LDY #.eventESCAPEConditionDetected                  ; signal event "Escape condition detected"
    JSR .eventEntryPoint                                ;
    BCC .exitWithCarryClear                             ;
    ROR .escapeFlag                                     ; set ESCAPE flag

.exitWithCarryClear
    CLC                                                 ;
-
    RTS                                                 ;

; ***************************************************************************************
.generateEventAndPutByteIntoBuffer
    JSR .insEntryPoint                                  ;
    BCC -                                               ;
    CPX #2                                              ;
    BCS -                                               ;
    LDY #.eventOutputBufferInsert                       ;
    JMP .eventEntryPoint                                ;

; ***************************************************************************************
;
; Read from input buffer X (0 = keyboard; 1 = RS-423)
;
; ***************************************************************************************
.readFromInputBufferX
    JSR .osbyte145EntryPoint                            ; get byte from buffer X
    BCS .exit21                                         ; if (buffer is empty) then branch (return)
    CMP .minEditingCharacter                            ;
    BCC .handleCopyAndCursorKeys                        ;
    CMP .maxEditingCharacter                            ;
    BEQ +                                               ;
    BCS .handleCopyAndCursorKeys                        ;
+
    PHA                                                 ;
    SEC                                                 ;
    SBC .minEditingCharacter                            ;
    TAY                                                 ;
    PLA                                                 ;
    CPY .numberOfSoftKeyDefinitions                     ;
    BCS .readFromSoftKeyOrInputBufferA                  ; if (Y > star key definitions) then branch
    JSR .getStarKeyStringLength                         ;
    STA .softKeyStringLength                            ;
    LDA .softKeyPage,Y                                  ;
    STA .softKeyExpansionPointer                        ;

.readFromSoftKeyOrInputBufferA
    LDA .softKeyStringLength                            ; get length of *KEY string
    BEQ .readFromInputBufferX                           ; if (no soft key) then branch (get a character from the buffer)
    LDY .softKeyExpansionPointer                        ; get soft key expansion pointer
    LDA .softKeyPage + 1,Y                              ; get character from string
    INC .softKeyExpansionPointer                        ; increment pointer
    DEC .softKeyStringLength                            ; decrement length

    CLC                                                 ;
.exit21
    RTS                                                 ;

; ***************************************************************************************
.handleCopyAndCursorKeys
    TAY                                                 ;
    LDA .characterDestinationsAvailableFlags            ;
    ROR                                                 ;
    TYA                                                 ;
    BCS +                                               ; if (RS-423 enabled) then branch (exit)
    CMP #.charUP + 1                                    ;
    BCS +                                               ; if (character read > cursor keys) then branch (exit)
    LDY .cursorEditingType                              ;
    BNE +                                               ; if (not normal editor type) then branch (exit)
    CMP #.charCOPY                                      ;
    BCC +                                               ; if (char < COPY) then branch (exit)
    BEQ .handleCOPYkeyToReadCharacterFromScreen         ; if (COPY key pressed) then branch (handle COPY key)

    TAY                                                 ; Y=A
    TXA                                                 ; A=X
    PHA                                                 ; Push X
    TYA                                                 ; get back Y
    JSR .splitIntoTwoCursorsJumper                      ; Split into the WRITE and READ cursors

    PLA                                                 ; restore X
    TAX                                                 ;
    JMP .readFromSoftKeyOrInputBufferA                  ;

; ***************************************************************************************
.handleCOPYkeyToReadCharacterFromScreen
    TXA                                                 ; A=X
    PHA                                                 ; Push A
    JSR .readCharacterFromScreenAndCursorRightJumper    ; read a character from the screen
    TAY                                                 ; Y=A
    BEQ .errorOnReadingCharacterFromScreen              ; if (A=0, i.e. not valid) then branch (beep)
    PLA                                                 ; restore X
    TAX                                                 ;
    TYA                                                 ; and Y
+
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.errorOnReadingCharacterFromScreen
    JSR .vdu7EntryPointInternal                         ; produce bell
    PLA                                                 ; get back A, buffer number
    TAX                                                 ; X=buffer number
    JMP .readFromSoftKeyOrInputBufferA                  ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 15: OSBYTE and OSWORD
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE/OSWORD lookup table
;
; Valid OSBYTEs are in the arbitrary ranges 0-21, 117-160, 166-255. The range 166-255 reads
; and writes to a contiguous range of memory locations, and are implemented by a single
; routine. Otherwise the reasoning behind these ranges is unclear. Perhaps 0-21 were
; anticipated (erroneously or otherwise) to be the more commonly used OSBYTEs?
;
; Valid OSWORDs are in the range 0-13, and OSWORDs 224-255 are sent through USERV.
;
; ***************************************************************************************
.osbyteAndOSWORDRoutineTable
    !word .osbyte0EntryPoint        ; OSBYTE   0 - Display version number
    !word .badCommandJumper         ; OSBYTE   1 - Read/Write user flag
    !word .badCommandJumper         ; OSBYTE   2 - select input stream
    !word .badCommandJumper         ; OSBYTE   3 - Select output stream
    !word .osbyte4EntryPoint        ; OSBYTE   4 - Enable / disable cursor editing
    !word .osbyte5EntryPoint        ; OSBYTE   5 - Select printer type
    !word .osbyte6EntryPoint        ; OSBYTE   6 - Set printer ignore character
    !word .osbyte7EntryPoint        ; OSBYTE   7 - Set RS-423 baud rate for receiving data
    !word .osbyte8EntryPoint        ; OSBYTE   8 - Set RS-423 baud rate for transmitting data
    !word .osbyte9EntryPoint        ; OSBYTE   9 - Duration of first colour
    !word .osbyte10EntryPoint       ; OSBYTE  10 - Duration of second colour
    !word .osbyte11EntryPoint       ; OSBYTE  11 - Set keyboard autorepeat delay
    !word .osbyte12EntryPoint       ; OSBYTE  12 - Set keyboard autorepeat rate
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .osbyte15EntryPoint       ; OSBYTE  15 - Flush selected buffer class
    !word .osbyte16EntryPoint       ; OSBYTE  16 - Select ADC channels
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;

    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .badCommandJumper         ;
    !word .osbyte120EntryPoint      ; OSBYTE 120 - Close any files being SPOOLed or EXECed [MOS 0.10 only]
    !word .badCommandJumper         ;
    !word .osbyte122EntryPoint      ; OSBYTE 122 - Set CAPS/SHIFT LOCK LED state    [MOS 0.10 only]
    !word .osbyte123EntryPoint      ; OSBYTE 123 - Generate BRK                     [MOS 0.10 only]
    !word .osbyte124EntryPoint      ; OSBYTE 124 - Clear ESCAPE condition
    !word .osbyte125EntryPoint      ; OSBYTE 125 - Set ESCAPE condition
    !word .osbyte126EntryPoint      ; OSBYTE 126 - Acknowledge detection of ESCAPE condition
    !word .osbyte127EntryPoint      ; OSBYTE 127 - Check for EOF on open file
    !word .osbyte128EntryPoint      ; OSBYTE 128 - Read ADC Channel, or get buffer status
    !word .osbyte129EntryPoint      ; OSBYTE 129 - Read key within time limit
    !word .osbyte130EntryPoint      ; OSBYTE 130 - Read 'machine high order address'
    !word .osbyte131EntryPoint      ; OSBYTE 131 - Read OSHWM (OS High Water Mark)
    !word .specialOSTableEntryPoint ; OSBYTE 132 - Read HIMEM (start of screen memory)
    !word .specialOSTableEntryPoint ; OSBYTE 133 - Read start of screen memory for given MODE
    !word .specialOSTableEntryPoint ; OSBYTE 134 - Read text cursor position
    !word .specialOSTableEntryPoint ; OSBYTE 135 - Read character at text cursor position
    !word .specialOSTableEntryPoint ; OSBYTE 136 - Do nothing
    !word .osbyte137EntryPoint      ; OSBYTE 137 - Turn on/off tape motor
    !word .osbyte138EntryPoint      ; OSBYTE 138 - Display filing system catalogue  [MOS 0.10 only]
    !word .osbyte139EntryPoint      ; OSBYTE 139 - *OPT
    !word .osbyte140EntryPoint      ; OSBYTE 140 - Enable Tape Filing System
    !word .osbyte141EntryPoint      ; OSBYTE 141 - Insert byte A into buffer X
    !word .osbyte142EntryPoint      ; OSBYTE 142 - enumerate *KEY definitions
    !word .osbyte143EntryPoint      ; OSBYTE 143 - Get number of *KEY definitions
    !word .osbyte144EntryPoint      ; OSBYTE 144 - *TV
    !word .finishOSBYTEXY           ; OSBYTE 145 - Do nothing

;
; OSWORD lookup table
;
.oswordRoutineTable
    !word .osword0EntryPoint        ; OSWORD   0 - Read line from current input into memory
    !word .osword1EntryPoint        ; OSWORD   1 - Read system clock
    !word .osword2EntryPoint        ; OSWORD   2 - Write system clock
    !word .osword3EntryPoint        ; OSWORD   3 - Read interval timer
    !word .osword4EntryPoint        ; OSWORD   4 - Write interval timer
    !word .osword5EntryPoint        ; OSWORD   5 - Read system clock B
    !word .osword6EntryPoint        ; OSWORD   6 - Write system clock B
    !word .osword7EntryPoint        ; OSWORD   7 - Make a sound
    !word .osword8EntryPoint        ; OSWORD   8 - Define an envelope
    !word .specialOSTableEntryPoint ; OSWORD   9 - Read a pixel
    !word .specialOSTableEntryPoint ; OSWORD  10 - Read character definition
    !word .specialOSTableEntryPoint ; OSWORD  11 - Read palette
    !word .specialOSTableEntryPoint ; OSWORD  12 - Write palette
    !word .badCommandJumper         ;


; ***************************************************************************************
;
; OSBYTE 126 - Acknowledge detection of ESCAPE condition
;
; If an ESCAPE condition has occurred, then this acknowledges (clears) it, informing the
; second processor of it via the Tube if present.
;
; ***************************************************************************************
.osbyte126EntryPoint
    LDX #0                                              ; X=0
    BIT .escapeFlag                                     ; check for ESCAPE flag
    BPL .osbyte124EntryPoint                            ; if (no ESCAPE flag) then branch
                                                        ; (just clear the ESCAPE condition)
    TXA                                                 ;
    JSR .osbyte15EntryPointInternal                     ;
    JSR .silenceAllChannels                             ;
    CLC                                                 ;
    JSR .getOrClearNumberOfBytesInVDUQueueJumper        ; clear # bytes in VDU queue
    LDA #3                                              ;
    JSR .OSWRCH                                         ; disable printer
    CLI                                                 ; allow interrupts
    LDA #0                                              ;
    JSR .starExec                                       ; close any open EXEC file (A=0, Z=0)
    LDX #$FF                                            ; X=$FF to indicate ESCAPE acknowledged
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 124 - Clear ESCAPE condition
;
; ***************************************************************************************
.osbyte124EntryPoint
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 125 - Set ESCAPE condition
;
; On Entry:
;       The regular OSBYTE entry sets carry (meaning set the ESCAPE condition).
;       If falling through from OSBYTE 124 above then carry is clear (meaning clear the ESCAPE
;       condition).
;
; ***************************************************************************************
.osbyte125EntryPoint
    ROR .escapeFlag                                     ; set/clear bit 7 of ESCAPE flag
    JMP .finishOSBYTEY                                  ;

; ***************************************************************************************
;
; OSBYTE 127 - Check for EOF on open file
;
; On Entry:
;       X = file handle
;
; ***************************************************************************************
.osbyte127EntryPoint
    JSR .checkForEOFJumper                              ;
    JMP .finishOSBYTEY                                  ;

; ***************************************************************************************
;
; OSBYTE 8 - Set RS-423 baud rate for transmitting data
;
; On Entry:
;       X = baud rate
;
; ***************************************************************************************
.osbyte8EntryPoint
    LDA #%00111000                                      ; Once it's EOR'd with the next instruction,
                                                        ; this value becomes %00000111 (set transmit baud rate)
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 7 - Set RS-423 baud rate for receiving data
;
; On Entry:
;       X = baud rate
;
; ***************************************************************************************
.osbyte7EntryPoint
    EOR #%00111111                                      ; converts 7 -> $38 = %00111000 (set receive baud rate)
                                                        ; converts $38 -> 7 = %00000111 (set transmit baud rate)
    STA .tempStoreDB                                    ; store result
    LDY .serialULARegisterCopy                          ; get serial ULA control register setting
    CPX #9                                              ; }
    BCS .putNewSettingYInXAndReturn                     ; } is it 9 or more then branch (exit)
    AND .bufferTypeAndSerialBaudRatesTable,X            ; and with byte from look up table
    STA .tempStoreDC                                    ; store it
    TYA                                                 ; put Y in A
    ORA .tempStoreDB                                    ; set the transmit or receive baud rate bits to 1
    EOR .tempStoreDB                                    ; zero the transmit or receive baud rate bits to 0
    ORA .tempStoreDC                                    ; set baud rate from value read from table lookup
    ORA #$40                                            ; set bit 6
    STA .serialULARegisterCopy                          ; store serial ULA flag
    STA .serialULAControlRegister                       ; and write to control register
.putNewSettingYInXAndReturn
    TYA                                                 ;
    TAX                                                 ;
    BVC .finishOSBYTEYJumper                            ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 10 - Duration of second colour
;
; On Entry:
;       X = new value (in 1/50 of a second)
;
; ***************************************************************************************
.osbyte10EntryPoint
    LDY .videoULAFirstFlashingColourInterval            ; get mark period count
    STX .videoULAFirstFlashingColourInterval            ; store it
    BCS +                                               ;

; ***************************************************************************************
;
; OSBYTE 9 - Duration of first colour
;
; On Entry:
;      Y = 0
;      X = new value (in 1/50 of a second)
;
; ***************************************************************************************
.osbyte9EntryPoint
    LDY .videoULASecondFlashingColourInterval           ;
    STX .videoULASecondFlashingColourInterval           ;
    CLC                                                 ;
+
    LDA .videoULAFlashingColourIntervalCount            ; get value of flash counter
    BNE +                                               ; if (not zero) then branch
    STX .videoULAFlashingColourIntervalCount            ; restore old value
    PHP
    ROR .videoULAVideoControlRegisterCopy               ; get current video ULA control register setting
    PLP
    ROL .videoULAVideoControlRegisterCopy               ; get current video ULA control register setting
    LDA .videoULAVideoControlRegisterCopy               ; store it in RAM copy
    STA .videoULAControlRegister                        ; and ULA control register
+
    TYA                                                 ;
    TAX                                                 ;
.finishOSBYTEYJumper
    BVC +                                               ; ALWAYS branch

; ***************************************************************************************
; [Perhaps this was going to be .osbyte13EntryPoint but was removed?]
    LDA .keyboardStatusFlags                            ; [unused]
    STX .keyboardStatusFlags                            ; [unused]
    TAX                                                 ; [unused]
+
    BVC +                                               ; ALWAYS branch [unused]

; ***************************************************************************************
; [Perhaps this was going to be .osbyte14EntryPoint but was removed?]
    TXA                                                 ; [unused]
    AND #1                                              ; [unused]
    LDX .currentInputBuffer                             ; [unused]
    STA .currentInputBuffer                             ; [unused]
    ROL .acia6850ControlRegisterCopy                    ; [unused]
    CMP #1                                              ; [unused]
    ROR .acia6850ControlRegisterCopy                    ; [unused]
    LDA .acia6850ControlRegisterCopy                    ; [unused]
    STA .acia6850ControlRegister                        ; [unused]
+
    BVC ++                                              ; ALWAYS branch [unused]

; ***************************************************************************************
; [Perhaps this was going to be .osbyte121EntryPoint but was removed?]
    JSR .resetSoftKeys                                  ; [unused]
    LDA .numberOfSoftKeyDefinitions                     ; [unused]
    CPX #17                                             ; [unused]
    BCS +                                               ; [unused]
    STX .numberOfSoftKeyDefinitions                     ; [unused]
+
    TAX                                                 ; [unused]
++
    BVC .finishOSBYTEYLocal                             ; ALWAYS branch [unused]

; ***************************************************************************************
;
; OSBYTE 137 - Turn on/off tape motor
;
; On Entry:
;       X = 0 to turn the motor off; otherwise turn the motor on
;
; ***************************************************************************************
.osbyte137EntryPoint
    LDA .serialULARegisterCopy                          ; get serial ULA control setting
    PHA                                                 ; store old serial value
    ROL                                                 ;
    CPX #1                                              ; if (X>=1, i.e. turn on motor) then set carry
    ROR                                                 ; rotate carry back in serialULA copy (bit 7)
    STA .serialULARegisterCopy                          ; store serial ULA flag
    STA .serialULAControlRegister                       ; and write to control register
    PLA                                                 ; recall old serial value
    AND #$80                                            ;
    TAX                                                 ; X=A
.finishOSBYTEYLocal
    BVC .finishOSBYTEY                                  ; ALWAYS branch

; ***************************************************************************************
    LDA #0                                              ; [unused]
    CPX #13                                             ; [unused]
    BCS +                                               ; [unused]
    LDY $0295,X                                         ; [unused]
    STA $0295,X                                         ; [unused]
    TYA                                                 ; [unused]
+
    TAX                                                 ; [unused]
    BVC .finishOSBYTEY                                  ; ALWAYS branch [unused]

; ***************************************************************************************
;
; OSBYTE 12 - Set keyboard autorepeat rate
;
; ***************************************************************************************
.osbyte12EntryPoint
    BNE +                                               ; if (.osbyteX != 0; i.e. not resetting to defaults) then branch
    LDX #50                                             ; reset default delay and rate
    STX .keyboardAutoRepeatDelay                        ; set keyboard autorepeat delay
    LDX #7                                              ;
+
    LDA .keyboardAutoRepeatRate                         ;
    STX .keyboardAutoRepeatRate                         ;
    TAX                                                 ;
    BVC .finishOSBYTEY                                  ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 11 - Set keyboard autorepeat delay
;
; ***************************************************************************************
.osbyte11EntryPoint
    LDA .keyboardAutoRepeatDelay                        ;
    STX .keyboardAutoRepeatDelay                        ;
    TAX                                                 ;
    BVC .finishOSBYTEY                                  ; ALWAYS branch

; ***************************************************************************************
    TAY                                                 ; [unused]
    LDX $0215,Y                                         ; [unused]
    LDA .tempStoreFA                                    ; [unused]
    STA $0215,Y                                         ; [unused]
    BVC .finishOSBYTEY                                  ; [unused]

; ***************************************************************************************
.osbyte4EntryPoint
.osbyte5EntryPoint
.osbyte6EntryPoint
    TAY                                                 ; Write to one of:
    LDX .cursorEditingType - 4,Y                        ;   .cursorEditingType
    LDA .tempStoreFA                                    ;   .printerDestination
    STA .cursorEditingType - 4,Y                        ;   .printerIgnoreCharacter
    BVC .finishOSBYTEY                                  ; ALWAYS branch

; ***************************************************************************************
.osbyte143EntryPoint
    LDX .numberOfSoftKeyDefinitions                     ;
    LDY #$EE                                            ;
    BVC .pullFlagsAndAThenExit                          ; ALWAYS branch

; ***************************************************************************************
.osbyte144EntryPoint
    LDA .vduVerticalAdjust                              ;
    STX .vduVerticalAdjust                              ;
    TAX                                                 ;
    TYA                                                 ;
    AND #1                                              ;
    LDY .vduInterlaceValue                              ;
    STA .vduInterlaceValue                              ;
    BVC .pullFlagsAndAThenExit                          ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 131 - Read OSHWM (OS High Water Mark)
;
; ***************************************************************************************
.osbyte131EntryPoint
    LDX #$00                                            ;
    LDY #$0e                                            ;
    BVC .pullFlagsAndAThenExit                          ; ALWAYS branch: return $0E00


; ***************************************************************************************
;
; OSBYTE 141 - Insert byte A into buffer X
;
; ***************************************************************************************
.osbyte141EntryPoint
    CPX #8                                              ;
    BCS +                                               ; if (8 or more) then branch (exit)
    TYA                                                 ;
    JSR .insEntryPoint                                  ; Insert character into buffer
    LDX .tempStoreFA                                    ;
    LDA #1                                              ; A = 1
    ROR                                                 ; A = 0, Carry set
    TAY                                                 ; Y = 0
+
    BCS .pullFlagsAndAThenExit                          ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 15 - Flush selected buffer class
;
; On Entry:
;       X = 0       flush all buffers
;       X != 0      flush input buffer
;
; ***************************************************************************************
.osbyte15EntryPoint
    JSR .osbyte15EntryPointInternal                     ;
.finishOSBYTEXY
    LDX .tempStoreFA                                    ;
.finishOSBYTEY
    LDY .tempStoreFB                                    ;
.pullFlagsAndAThenExit
    PLP                                                 ;
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 120 - Close any files being SPOOLed or EXECed
;
; ***************************************************************************************
.osbyte120EntryPoint
    LDA #0                                              ;
    JSR .starExec                                       ; close any current EXEC file
    JSR .starSpool                                      ; close any current SPOOL file
    BEQ .finishOSBYTEXY                                 ;

; ***************************************************************************************
;
; OSBYTE 122 - Set CAPS LOCK or SHIFT LOCK LED state
;
; On Entry:
;       X = 0   turn on CAPS LOCK LED
;       X = 1   turn on SHIFT LOCK LED
;       X = 8   turn off CAPS LOCK LED
;       X = 9   turn off SHIFT LOCK LED
;
; ***************************************************************************************
.osbyte122EntryPoint
    TXA                                                 ;
    ORA #$06                                            ;
    STA .systemVIARegisterB                             ;
    BVC .finishOSBYTEXY                                 ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 16 - Select ADC channels
;
; Selects the range of channels for analogue to digital conversion (0-4)
; See .osbyte17EntryPoint
;
; On Entry:
;       X contains channel number (1-4) or 0 to disable conversions
;       Y = 0
;
; ***************************************************************************************
.osbyte16EntryPoint
    BEQ ++                                              ;
    CPX #5                                              ;
    BCC +                                               ; if (channel number in range) then branch
    LDX #4                                              ; Cap at channel 4
+
    STX .adcCurrentChannel                              ; Store as ADC channel
    DEX                                                 ;
    TXA                                                 ;
    ORA #8                                              ;
    STA .adcStartConversionRegister                     ;
    INX                                                 ;
++
    LDA .maximumADCChannelNumber                        ; get current maximum ADC channel number
    STX .maximumADCChannelNumber                        ; store new value
    TAX                                                 ; put old value in X
    BVC .finishOSBYTEY                                  ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 129 - Read key within time limit
;
; On Entry:
;       X and Y contains either:
;           time limit in centi-seconds (Y=$7F max)
;       or Y=$FF and X=-ve INKEY value for an instant read of a specific key
;       or Y=$FF and X=0 to read the machine type (see NAUG Section 24.4.1 Page 428)
;
; ***************************************************************************************
.osbyte129EntryPoint
    TYA                                                 ; A=Y
    BMI .readNegativeKeyNumber                          ; if (Y negative) then branch

    ; time limited key read
    CLI                                                 ; allow interrupts
    JSR .osbyte129Timed                                 ; and go to timed routine
    BCS +                                               ; if (carry set) then branch

.setXResetYAndExit
    TAX                                                 ; then X=A
    LDY #0                                              ;
    BEQ .pullFlagsAndAThenExitLocal                     ; ALWAYS branch

+
    TAY                                                 ;
    BCS .pullFlagsAndAThenExitLocal                     ; ALWAYS branch

.readNegativeKeyNumber
    TXA                                                 ; A=X
    EOR #$FF                                            ; convert to keyboard input
    TAX                                                 ; X=A
    JSR .interrogateKeyboard                            ;
    JSR .keyboardIndicators                             ;
    ROL                                                 ; put bit 7 into carry

    ; if (carry is set) then return $FFFF else return $0000
.setXYAndExit
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 130 - Read 'machine high order address'
;
; Filing systems use 32 bit addresses, where $FF,$FF is used in the top two bytes to
; indicate the address is in the main (I/O processor) memory as opposed to the second
; processor memory. This routine returns the two values used for this purpose, namely $FF,$FF.
;
; On Entry:
;       Carry set if entry is via OSBYTE 130
;       Carry may be clear if falling through from routines above,
;       either reading a key (.readNegativeKeyNumber) or doing an ADC conversion (.setXYAndExit).
;
; ***************************************************************************************
.osbyte130EntryPoint
    LDX #$FF                                            ; X=$FF
    LDY #$FF                                            ; Y=$FF
    BCS .pullFlagsAndAThenExitLocal                     ; if (carry set, depends on entry point) then branch (exit)
    INX                                                 ; X=0
-
    INY                                                 ; Y=0
.pullFlagsAndAThenExitLocal
    JMP .pullFlagsAndAThenExit                          ;

; ***************************************************************************************
;
; OSBYTE 142 - enumerate *KEY definitions
;
; On Entry:
;       Y = current *KEY number
;       X = desired *KEY number
;
; On Exit:
;       Y = 0 if no key definition is found
;       Y = incremented (>0) if less than desired *KEY number
;
; ***************************************************************************************
.osbyte142EntryPoint
    JSR .getStarKeyStringLength                         ;
    BEQ .setXResetYAndExit                              ; if (no star key defintion) then branch
    CMP .tempStoreFA                                    ;
    BCC -                                               ; if (length < tempStoreFA) then branch
                                                        ; (increment *KEY number and exit)
    TXA                                                 ;
    ADC .softKeyPage,Y                                  ;
    TAX                                                 ;
    LDA .softKeyPage - 1,X                              ; get start offset (from .softKeyPage) of key string X
    BCC .setXResetYAndExit                              ; ALWAYS branch (since ADC above can never overflow)

; ***************************************************************************************
;
; OSBYTE 128 - Read ADC Channel, or get buffer status
;
; On Entry:              On Exit:
; X=0                    Y contains number of last channel converted (1-4); X = fire buttons
; X=channel number (1-4) X,Y contain 16 bit value read from ADC channel (See .osbyte17EntryPoint)
; X<0 Y=$FF              X returns information about various buffers
; X=$FF (keyboard)       X = number of characters in buffer
; X=$FE (RS-423 input)   X = number of characters in buffer
; X=$FD (RS-423 output)  X = number of empty spaces in buffer
; X=$FC (printer)        X = number of empty spaces in buffer
; X=$FB (sound 0)        X = number of empty spaces in buffer
; X=$FA (sound 1)        X = number of empty spaces in buffer
; X=$F9 (sound 2)        X = number of empty spaces in buffer
; X=$F8 (sound 3)        X = number of empty spaces in buffer
; X=$F7 (Speech)         X = number of empty spaces in buffer
;
; ***************************************************************************************
.osbyte128EntryPoint
    BMI .countNegativeBuffer                            ; if (X is -ve) then branch (count space free/used)
    BEQ .lastChannelConverted                           ; if (X is zero) then branch
    CPX #5                                              ; }
    BCS .setXYAndExit                                   ; } if channel is not valid then branch (set X and Y to 255 and exit)
    LDA $028f,X                                         ; [these variables seem wrong, fixed in MOS 1.20]
    TAY                                                 ;
    LDA .videoULAVideoControlRegisterCopy,X             ; [these variables seem wrong, fixed in MOS 1.20]

-
    TAX                                                 ; X=low byte
    JMP .pullFlagsAndAThenExit                          ;

.lastChannelConverted
    LDA .systemVIARegisterB                             ; read system VIA port B
    ROR                                                 ; move high nybble to low
    ROR                                                 ;
    ROR                                                 ;
    ROR                                                 ;
    EOR #$FF                                            ; and invert it
    AND #3                                              ; isolate the FIRE buttons
    BPL +                                               ; ALWAYS branch

; ***************************************************************************************
;
; Get free space from an input buffer, or used space from an output buffer
;
; For buffer numbers, see .bufferNumberKeyboard.
;
; On Entry:
;       X=255 - buffer number
;
; ***************************************************************************************
.countNegativeBuffer
    TXA                                                 ; buffer number in A
    EOR #$FF                                            ; invert it
    AND #7                                              ; ensure buffer number is in range 0-7
    TAX                                                 ; X=A
    JSR .cnpEntryPoint                                  ;
+
    LDY #0                                              ;
    BEQ -                                               ; ALWAYS branch

; ***************************************************************************************
.resetSoftKeys
    LDA #$11                                            ;
    TAY                                                 ;
-
    STA .softKeyPage,Y                                  ;
    DEY                                                 ;
    BPL -                                               ;
.exit0
    RTS                                                 ;

; ***************************************************************************************
.osbyte15EntryPointInternal
    BNE .flushCurrentInputBuffer                        ; if (X is not zero) then branch (flush input buffer only)
    LDX #.bufferNumberHighest                           ; load highest buffer number (8)
-
    JSR .osbyte21EntryPoint                             ; flush buffer
    DEX                                                 ; decrement X to point at next buffer
    BPL -                                               ; if (X >= 0) then branch (flush next buffer)

.flushCurrentInputBuffer
    DEX                                                 ;
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 21 - Flush specific buffer
;
; On Entry:
;       X=buffer number
; ***************************************************************************************
.osbyte21EntryPoint
    CPX #.bufferNumberHighest + 1                       ; test against largest buffer number
    BCS .exit0                                          ;
    CPX #2                                              ;
    BCS .skipInputBufferHandling                        ; if (X > 1) then branch (it's not an input buffer)
    JSR +                                               ;
.skipInputBufferHandling
    JMP .flushBufferX                                   ;

; ***************************************************************************************
    LDX .currentInputBuffer                             ;
+
    LDA #0                                              ;
    STA .softKeyStringLength                            ;
    JMP .flushBufferX                                   ;

; ***************************************************************************************
;
; OSBYTE 138 - Display filing system catalogue
;
; ***************************************************************************************
.osbyte138EntryPoint
    LDA .tapeFilingSystemEnableFlag                     ;
    BEQ .noFilingSystemErrorLocal                       ; if (tape filing system not enabled) then branch
    BPL .cat                                            ;
    JSR .selectTapeAndSearchForAnyFileJumper            ;
    JMP .pullFlagsAndAThenExit                          ;

.cat
    LDX #<.catCommandString                             ;
    LDY #>.catCommandString                             ; point to "CAT" command string
    JSR .passToCurrentFilingSystem                      ;
    JMP .pullFlagsAndAThenExit                          ;

.noFilingSystemErrorLocal
    JMP .noFilingSystemError                            ;

.catCommandString
    !text "CAT", .charRETURN                            ;

.osbyte139EntryPoint
    JSR .starOptEntryPointJumper                        ;
    JMP .pullFlagsAndAThenExit                          ;

; ***************************************************************************************
;
; OSBYTE 140 - Enable Tape Filing System
;
; On Entry:
;       X = 3 for 300 baud
;       otherwise 1200 baud
;
; ***************************************************************************************
.osbyte140EntryPoint
    TXA                                                 ;
    LDX #$80                                            ; 1200 buad
    SBC #3                                              ; check for (X = 3 on entry)
    BNE +                                               ; branch if not 300 baud requested

    LDX #$c0                                            ;
+
    STX .tapeFilingSystemEnableFlag                     ; bit 7 = tape enabled flag, bit 6 = set for 300 baud
    JSR .setupTapeBaudRateJumper1                       ;
    JMP .pullFlagsAndAThenExit                          ;

; ***************************************************************************************
.specialOSTableEntryPoint
    JSR .specialOSTableLookupJumper                     ;
    JMP .pullFlagsAndAThenExit                          ;

; ***************************************************************************************
;
; Table of buffer types and serial baud rates
;
; This table has dual use. It is used to set the serial baud rate (using bits 0-5), and
; also to identify a buffer as being a sound buffer (bit 7):
;
;   - bit 7 is not used (always clear)
;   - bit 6 is not used (always set)
;   - bits 3,4,5 indicate the serial receive baud rate
;   - bits 0,1,2 indicate the serial transmit baud rate
;
;       111 =    75 baud
;       011 =   150 baud
;       101 =   300 baud
;       001 =  1200 baud
;       110 =  2400 baud
;       010 =  4800 baud
;       100 =  9600 baud
;       000 = 19200 baud
;
; ***************************************************************************************
.bufferTypeAndSerialBaudRatesTable
    !byte %01100100                                     ; Keyboard           9600 baud (default)
    !byte %01111111                                     ; RS-423 Input         75 baud
    !byte %01011011                                     ; RS-423 output       150 baud
    !byte %01101101                                     ; serial printer      300 baud
    !byte %01001001                                     ; sound0             1200 baud
    !byte %01110110                                     ; sound1             2400 baud
    !byte %01010010                                     ; sound2             4800 baud
    !byte %01100100                                     ; sound3             9600 baud
    !byte %01000000                                     ; speech            19200 baud

.resetACIA1
    LDA #%00000011                                      ; reset ACIA
    STA .acia6850ControlRegister                        ;
    LDA #%00010110                                      ;
    STA .acia6850ControlRegister                        ;
    STA .acia6850ControlRegisterCopy                    ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 0 - Display version number
;
; See fx0.png
; Shows which version of the OS is installed.
;
; ***************************************************************************************
.osbyte0EntryPoint
    BRK                                                 ;
    !byte 0                                             ;
    !text "OS EPROM 0.10",0                             ;

; ***************************************************************************************
;
; OSBYTE - default entry point
;
; This entry point is executed for all OSBYTE calls. It routes the call through to one of the
; individual OSBYTE entry points by means of a table (see .osbyteAndOSWORDRoutineTable).
;
; Note: OSBYTEs 0-127 only return a value in the X register, whereas OSBYTEs 128-255 can
; return values in X,Y and carry. This fact is used to speed up access via the Tube.
;
; ***************************************************************************************
.osbyteEntryPoint
    PHA                                                 ; Push A
    PHP                                                 ; Push flags
    SEI                                                 ; disable interrupts
    PHA                                                 ;
    STX .tempStoreFA                                    ;
    STY .tempStoreFB                                    ;
    CMP #120                                            ;
    BCC .osbyte0to119                                   ; if (A < 120) then branch
    CMP #146                                            ;
    BCS .badCommandJumper                               ;
    SBC #119                                            ; }
    ADC #29                                             ; } [can be optimised to one ADC instruction]
    BCC .oswordStoreTableAddressAndCall                 ;

.osbyte0to119
    CMP #30                                             ;
    BCC .oswordStoreTableAddressAndCall                 ;

.badCommandJumper
    JMP .badCommandError                                ;

.oswordStoreTableAddressAndCall
    ASL                                                 ;
    TAX                                                 ;
    LDA .osbyteAndOSWORDRoutineTable,X                  ; get address from table (low byte)
    STA .tempStore284                                   ; store as low byte
    LDA .osbyteAndOSWORDRoutineTable+1,X                ; get address from table (high byte)
    STA .tempStore285                                   ; store as high byte
    PLA                                                 ;
    LDX .tempStoreFA                                    ;
-
    SEC                                                 ;
    CLV                                                 ;
    JMP (.tempStore284)                                 ;

; ***************************************************************************************
;
; OSWORD - Default entry point
;
; This entry point is executed for all OSWORD calls. It routes the call through to one of
; the individual OSWORD entry points by means of a table (see .osbyteAndOSWORDRoutineTable,
; at the end of which is the list of OSWORD entry points).
;
; ***************************************************************************************
.oswordEntryPoint
    PHA                                                 ; Push A
    PHP                                                 ; Push flags
    SEI                                                 ; disable interrupts
    PHA                                                 ;
    STX .tempStoreFA                                    ;
    STY .tempStoreFB                                    ;
    ASL                                                 ;
    BCS .badCommandJumper                               ;
    CMP #28                                             ;
    BCS .badCommandJumper                               ;
    TAY                                                 ;
    LDA .oswordRoutineTable,Y                           ; get address from table (low byte)
    STA .tempStore284                                   ; store as low byte
    LDA .oswordRoutineTable + 1,Y                       ; get address from table (high byte)
    STA .tempStore285                                   ; store as high byte
    PLA                                                 ;
    LDY .tempStoreFB                                    ;
    BCC -                                               ; ALWAYS branch (to call routine)

; ***************************************************************************************
;
; OSWORD 5 - Read system clock B
;
; The system clock counts in centi-seconds since boot and is 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte result
;
; ***************************************************************************************
.osword5EntryPoint
    LDX #.timeClockB - (.timeClockA - 5)                ;
    BNE .readFiveBytesIntoBlock                         ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 3 - Read interval timer
;
; The interval timer is centi-seconds and 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte result
;
; ***************************************************************************************
.osword3EntryPoint
    LDX #.countdownIntervalTimer - (.timeClockA - 5)    ;
    BNE .readFiveBytesIntoBlock                         ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 1 - Read system clock
;
; The system clock counts in centi-seconds since boot and is 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte result
;
; ***************************************************************************************
.osword1EntryPoint
    LDX .timeClockSwitch                                ; X=current system clock store pointer
.readFiveBytesIntoBlock
    LDY #4                                              ; Y = loop counter
-
    LDA .timeClockA - 5,X                               ; read byte
    STA (.tempStoreFA),Y                                ;
    INX                                                 ; X = X + 1
    DEY                                                 ; Y = Y - 1
    BPL -                                               ; if (Y >= 0) then branch (loop back and do it again)

    BVC .restoreRegistersAndExit2                       ;


; ***************************************************************************************
;
; OSWORD 5 - Write system clock B
;
; The system clock counts in centi-seconds since boot and is 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte value to set
;
; ***************************************************************************************
.osword6EntryPoint
    LDA #.timeClockB - (.timeClockA - 5)                ;
    BNE .writeFiveBytesFromBlock                        ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 4 - Write interval timer
;
; On Entry:
;       .oswordX/Y is the address of the five byte value to set
;
; ***************************************************************************************
.osword4EntryPoint
    LDA #.countdownIntervalTimer - (.timeClockA - 5)    ;
    BNE .writeFiveBytesFromBlock                        ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 2 - Write system clock
;
; On Entry:
;       .oswordX/Y is the address of the five byte value to set
;
; ***************************************************************************************
.osword2EntryPoint
    LDA .timeClockSwitch                                ; get current clock store pointer
    EOR #15                                             ; and invert to get inactive clock (toggle between 5 and 10)
    CLC                                                 ; clear carry (indicates write system clock)
    ; fall through...

; ***************************************************************************************
;
; Write system clock or interval timer
;
; On Entry:
;       carry clear indicates write system clock
;       carry set indicates write interval timer
;
; ***************************************************************************************
.writeFiveBytesFromBlock
    PHA                                                 ; store A
    TAX                                                 ; X=A
    LDY #4                                              ; Y=loop counter
.writeClockLoop
    LDA (.tempStoreFA),Y                                ; transfer 5 bytes from out parameter block
    STA .timeClockA - 5,X                               ; to the clock or timer
    INX                                                 ;
    DEY                                                 ;
    BPL .writeClockLoop                                 ; if (Y >= 0) then branch (loop)
    PLA                                                 ; restore A
    BCS .restoreRegistersAndExit2                       ;
    STA .timeClockSwitch                                ; write back current clock (5 or 10) into switch variable
    BVC .restoreRegistersAndExit2                       ;

; ***************************************************************************************
.osword7EntryPoint
    LDY #0                                              ;
    JSR .getChannelNumberAndFlush                       ; returns with carry set if flush is required, and A=channel number (0-3)
    ORA #4                                              ; convert channel number to buffer number (4-7)
    TAX                                                 ; X = buffer number
    BCC +                                               ; if (carry clear) then branch
    JSR .flushBufferX
+
    JSR .getSyncNumberAndHold                           ; get sync number (0-3) (carry set if hold is required)
    STA .tempStoreDB                                    ; .tempStoreDB = sync number
    LDA (.tempStoreFA),Y                                ;
    TAY                                                 ;
    DEY                                                 ;
    TYA                                                 ;

    ROL                                                 ; multiply amplitude by two, and add carry into bit zero = hold bit
    ASL                                                 ; }
    ASL                                                 ; } multiply by 4
    ORA .tempStoreDB                                    ; add sync value (0-3)
-
    SEI                                                 ;
    BIT .escapeFlag                                     ;
    BMI .restoreRegistersAndExit2                       ;
    JSR .insEntryPoint                                  ;
    BCC +                                               ;
    CLI                                                 ;
    BCS -                                               ;
+
    LDY #4                                              ;
    LDA (.tempStoreFA),Y                                ;
    JSR .insEntryPoint                                  ;
    LDY #6                                              ;
    LDA (.tempStoreFA),Y                                ;
    JSR .insEntryPoint                                  ;

.restoreRegistersAndExit2
    LDX .tempStoreFA                                    ;
    LDY .tempStoreFB                                    ;
    PLP                                                 ;
    PLA                                                 ;
    RTS                                                 ;

.getChannelNumberAndFlush
.getSyncNumberAndHold
    LDA (.tempStoreFA),Y                                ; get byte (channel parameter low byte or sync parameter low byte)
    CMP #$10                                            ; is it greater than 15, if so set carry
    AND #3                                              ; get hardware channel number
    INY                                                 ; increment Y to point to byte 1 of the parameters
    RTS                                                 ;

; ***************************************************************************************
.osword8EntryPoint
    LDY #0                                              ;
    LDA (.tempStoreFA),Y                                ; read first byte of XY parameter block (envelope number 1-4)
    TAX                                                 ;
    DEX                                                 ; reduce A by one and copy into X
    TXA                                                 ;
    AND #3                                              ; Restrict to envelopes 0-3
    ASL                                                 ; }
    ASL                                                 ; } set up appropriate displacement to storage area
    ASL                                                 ; } A=(A-1)*16 OR 12
    ASL                                                 ; }
    ORA #$0c                                            ; A = $0C,$1C,$2C,$3C
    TAX                                                 ; X = A

    ; loop to copy envelope data into envelope buffer
    LDY #13                                             ; loop counter
-
    LDA (.tempStoreFA),Y                                ; Read envelope bytes from offset 1-13 of the parameter block
    STA .envelopeBuffer,X                               ; store in envelope buffer
    DEX                                                 ;
    DEY                                                 ;
    BNE -                                               ;
    BVC .restoreRegistersAndExit2                       ;

; ***************************************************************************************
;
; OSWORD 0 - Read line from current input into memory
;
; On Entry:
;       .oswordX/.oswordY - address of parameter block:
;           byte 0: address of input buffer for result (low)
;           byte 1: address of input buffer for result (high)
;           byte 2: maximum line length
;           byte 3: minimum acceptable ASCII code
;           byte 4: maximum acceptable ASCII code
;
; ***************************************************************************************
.osword0EntryPoint
    LDY #4                                              ; Y=4
-
    LDA (.tempStoreFA),Y                                ; copy bytes 2,3,4 to absolute addresses .osword0MaxLineLength,+1,+2
    STA .osword0MaxLineLength-2,Y                       ;
    DEY                                                 ; decrement Y
    CPY #2                                              ; until Y=1
    BCS -                                               ;

    LDA (.tempStoreFA),Y                                ; get address of input buffer (high byte)
    STA .osword0BufferAddressHigh                       ; store it in temporary buffer
    DEY                                                 ; decrement Y


    LDA (.tempStoreFA),Y                                ; get address of input buffer (low byte)
    STA .osword0BufferAddressLow                        ; and store in temporary buffer
    CLI                                                 ; allow interrupts
    ; fall through...

; ***************************************************************************************
.readInputCharacter
    JSR .OSRDCH                                         ; read character from input stream
    BCS .exitWithNegativeAndCarryFlagsSet               ; if (error occurred) then branch (exit)
    TAX                                                 ; X=A
    LDA .characterDestinationsAvailableFlags            ; get character destination status
    ROR                                                 ; rotate the status twice to make

    TXA                                                 ; restore character read
    BCS +                                               ;
    SEC                                                 ;
    JSR .getOrClearNumberOfBytesInVDUQueueJumper        ; read number of remaining bytes in VDU queue
    BEQ +                                               ;
    JSR .OSWRCH                                         ;
    JMP .readInputCharacter                             ;

+
    CMP #.charDELETE                                    ;
    BNE +                                               ; if (character is not DELETE) then branch forward
    CPY #0                                              ;
    BEQ .readInputCharacter                             ; if (Y is zero, i.e. first character) then branch (read next character)
    JSR .OSWRCH                                         ;
    DEY                                                 ;
    JMP .readInputCharacter                             ;

+
    CMP #.charDisableVDUOrDeleteLine                    ; is it delete line (CTRL-U)
    BNE +                                               ; if (not CTRL-U) then branch forward
    TYA                                                 ; Y=A
    BEQ .readInputCharacter                             ; if (we are still reading first character) then branch back the read character
    LDA #.charDELETE                                    ;
-
    JSR .OSWRCH                                         ; }
    DEY                                                 ; } output DELETE until Y=0
    BNE -                                               ; }
    BEQ .readInputCharacter                             ; ALWAYS branch (read character again)
+
    STA (.osword0BufferAddressLow),Y                    ; store character in designated buffer
    CMP #.charRETURN                                    ;
    BEQ .outputNewlineAndExit                           ; if (carriage return entered) then branch
    CPY .osword0MaxLineLength                           ; check the line length
    BCS +                                               ; if (buffer full) then branch (loop to ring bell)
    CMP .osword0MinASCIICharacter                       ; check minimum character
    BCC .retryReadWithoutIncrementingPosition           ; if (less than minimum character) then branch (read at existing position)
    CMP .osword0MaxASCIICharacter                       ; check maximum character
    BEQ ++                                              ; if (equal to maximum character) then accept the character and move on
    BCC ++                                              ; if (less than maximum character) then accept the character and move on
    BCS .retryReadWithoutIncrementingPosition           ; ALWAYS branch (reject character and continue)
+
    LDA #.charBELL                                      ; sound the bell when the buffer is full
.retryReadWithoutIncrementingPosition
    DEY                                                 ;
++
    INY                                                 ;
    JSR .OSASCI                                         ; output character
    JMP .readInputCharacter                             ;

.outputNewlineAndExit
    JSR .OSASCI                                         ;
.exitWithNegativeAndCarryFlagsSet                       ;
    LDA .escapeFlag                                     ;
    TAX                                                 ;
    ROL                                                 ;
    PLA                                                 ;
    PLA                                                 ;
    RTS                                                 ;

.checkForEscapeFlag
    PLP                                                 ;
    BIT .escapeFlag                                     ;
    BMI .exit25a                                        ;

; wait for the RS-423 system to timeout, so that the cassette system can take over
.waitForRS423ToTimeout
    PHP                                                 ; save flags on stack (with interrupts enabled)
    SEI                                                 ; disable interrupts
    BIT .rs423ReadyFlag                                 ;
    BPL .checkForEscapeFlag                             ; if (RS-423 is busy) then branch
                                                        ; (check escape flag and try again)
    LDA .rs423TimeoutCounter                            ;
    BMI .checkForEscapeFlag                             ; if (RS-423 has NOT timed out) then
                                                        ; branch (check for escape flag and try again)

    LDA #1                                              ; } store RS-423 timeout counter with
    STA .rs423TimeoutCounter                            ; } one to indicate that cassette has
                                                        ; } control of the ACIA 6850

    JSR .resetACIA1                                     ;
    PLP                                                 ;
.exit25a
    RTS                                                 ;

.cancelTapeOperation
    PHP                                                 ; save flags on stack
    SEI                                                 ; prevent IRQ interrupts
    LDA #0                                              ; A=0
    STA .rs423TimeoutCounter                            ; zero RS-423 timeout counter
    LDA .serialULARegisterCopy                          ; get serial ULA control register setting
    STA .serialULAControlRegister                       ; write to serial ULA control register setting
    JSR .resetACIA1                                     ;
    LDA .acia6850ControlRegisterCopy                    ;
    STA .acia6850ControlRegister                        ;
    PLP                                                 ; restore flags
    RTS                                                 ;

.vdu7EntryPointInternal
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .soundBELLChannel                               ; get bell channel number in A
    AND #%00000111                                      ; clear all except bits 0-2
    ORA #%00000100                                      ; set bit 2 (=channel number + 4)
    TAX                                                 ; X=A=channel number+4=buffer number
    LDA .soundBELLAmplitudeEnvelope                     ; get bell amplitude/envelope number

    JSR .insEntryPoint                                  ; add envelope to sound buffer
    LDA .soundBELLPitch                                 ;
    JSR .insEntryPoint                                  ; add pitch to sound buffer
    LDA .soundBELLDuration                              ;
    JMP .insEntryPointInternal                          ; add duration to sound buffer

; ***************************************************************************************
;
; OSBYTE 118 - Set keyboard LEDs based on keyboard status
;
; On Exit:
;       carry is set if CTRL pressed
;       N is set if SHIFT is pressed
;
; ***************************************************************************************
.osbyte118EntryPointInternal
    PHP                                                 ; remember flags
    SEI                                                 ; disable interrupts
    LDA #$40                                            ; switch on CAPS and SHIFT LOCK lights
    JSR .setKeyboardLEDSOnAndTestEscapeFlag             ; via subroutine
    BMI .popRollAndExit                                 ; if (negative, i.e. ESCAPE condition exists) then branch
    SEC                                                 ;
    JSR .keyTestSHIFTAndCTRLOrTimerInterrupt            ; switch on lights as required
.popRollAndExit
    PLP                                                 ; recall flags
    ROL                                                 ; and rotate carry into bit 0
    RTS                                                 ;

.setKeyboardLEDSOnAndTestEscapeFlag
    BCC +                                               ; if (carry clear) then branch
    LDY #7                                              ;
    STY .systemVIARegisterB                             ; turn on SHIFT LOCK LED
    DEY                                                 ;
    STY .systemVIARegisterB                             ; turn on CAPS LOCK LED
+
    BIT .escapeFlag                                     ; test the escape flag
    RTS                                                 ;

; ***************************************************************************************
.writeAToSystemVIARegisterBInternal
    PHP                                                 ; push flags
    SEI                                                 ; disable interupts
    STA .systemVIARegisterB                             ; write register B from Accumulator
    PLP                                                 ; get back flags
    RTS                                                 ;

.setVideoULAInternal
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    STA .videoULAVideoControlRegisterCopy               ; save RAM copy of new parameter
    STA .videoULAControlRegister                        ; write to control register
    LDA .videoULASecondFlashingColourInterval           ; get second flashing colour interval
    STA .videoULAFlashingColourIntervalCount            ; set flash counter to this value
    PLP                                                 ; get back status
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 155 - Set palette value
;
; On Entry:
;       X contains value to write
;
; ***************************************************************************************
.osbyte155EntryPoint
    EOR #7                                              ; convert to palette format required for video ULA register
    STA .videoULAPaletteRegister                        ; store actual colour in register
    RTS                                                 ;

.gsinitEntryPoint
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
; GSINIT - Initialise parsing of a string
;
; Initialises the parsing of a given string (the 'input' string). Usually the string is part
; of an OSCLI command line where a string is expected (e.g. the filename in a *LOAD or the
; definition of a function key in *KEY).
;
; Leading spaces are ignored. The input string can be surrounded by double quotation marks.
; The string is terminated by a carriage return, or the second double quotation mark, or
; (optionally) a space character (useful for filename parsing).
;
; Once initialised, the parsing occurs using multiple calls to GSREAD. Each call produces one
; character result based on the input string.
;
; Control codes are disallowed in the input string. However the bar character '|' can be
; used to introduce control codes into the parsed output of GSREAD, and the '|!' combination
; is used to introduce top bit set characters.
;
; '|' followed by a character (see exceptions below) gives the ASCII value minus 64.
;       e.g. |G = control code 7  (bell)
;            |M = control code 13 (carriage return)
; '|!' adds 128 to the following character.
; '||' is parsed as a single bar character.
; '|"' is parsed as double quotes.
; '|?' is parsed as the DELETE character (character 127).
;
; These can be combined, e.g. '|!|A' results in character 129 being parsed.
;
; On Entry:
;       Address for string stored at .stringInputBufferAddressLow/High
;       Y = offset into string
;       C = 0: string is terminated by a space (used for filename parsing)
;       C = 1: otherwise (used e.g. for defining a soft key with *KEY)
;
; On Exit:
;       .stringInputOptions bit 7 = double-quote character found at start
;                           bit 6 = don't stop on space character
;       Y = offset of the first non-blank character
;       A = first non-blank character
;       Z is set if string is empty
;
; ***************************************************************************************
.gsinitEntryPointInternal
    ROR .stringInputOptions                             ; Move carry into top bit of options
    LDA (.stringInputBufferAddressLow),Y                ;
    INY                                                 ; increment Y to point at next character
    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ +                                               ; if (double quotes) then branch
    DEY                                                 ; decrement Y
    CLC                                                 ; clear carry
+
    ROR .stringInputOptions                             ; bit 7 = double quote character found
                                                        ; bit 6 = space is not a terminator
    RTS                                                 ;


; ***************************************************************************************
;
; GSREAD - Read one character by parsing the input string
;
; Parses a character from the input string previously set up by GSINIT.
; See .gsinitEntryPoint
;
; On Entry:
;       Address for string stored at .stringInputBufferAddressLow/High
;       Y = offset into string
; On Exit:
;       A = character read
;       X is preserved
;       Y = index of next character to be read
;       Carry is set if end of string reached
;       Overflow (V flag) is set if the character read was interpreted as a control code
;
; ***************************************************************************************
.gsreadEntryPoint
    CLC                                                 ;
    ROR .stringInputPlingFlag                           ;
-
    LDA (.stringInputBufferAddressLow),Y                ; read first character
    CMP #.charRETURN                                    ; check for CR
    BNE .notRETURN                                      ; if (not CR) then branch

    ; deal with RETURN character
    BIT .stringInputOptions                             ; check options
    BMI .brkBadString                                   ; if (second quotation mark needed) then branch ('Bad string' message)
    BPL .finishedString                                 ; ALWAYS branch (string ok, finished)

.notRETURN
    CMP #.charSPACE                                     ; check for SPACE
    BCC .brkBadString                                   ; if (less then space, i.e. a control character) then branch ('Bad string' message)
    BNE .notSPACE                                       ; if (it's not a space) then branch

    ; Deal with ' ' SPACE character
    BIT .stringInputOptions                             ; check bit 6 and 7 of .stringInputOptions
    BMI .finishUpReadClearV                             ; if (double-quote character found) then branch
    BVC .finishedString                                 ; if (space character is a terminator) then branch (finished string)

.notSPACE
    CMP #.charDOUBLEQUOTE                               ; check for DOUBLE QUOTE
    BNE .notDOUBLEQUOTE                                 ; if (not double quote) then branch

    ; Deal with '"' DOUBLE QUOTE character
    BIT .stringInputOptions                             ; check options
    BPL .finishUpReadClearV                             ; if (string didn't start with a double quote) then branch

    ; We have found a string surrounded by double quotes.
    ; Check the next character isn't also a double quote, as that's an error.
    INY                                                 ; point at next character
    LDA (.stringInputBufferAddressLow),Y                ; get it
    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ .finishUpReadClearV                             ; if (third double quote character found) then branch

.finishedString
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip past any final SPACEs
    SEC                                                 ; carry set
    RTS                                                 ;

.notDOUBLEQUOTE
    CMP #.charBAR                                       ; check for bar '|' character
    BNE .finishUpReadClearV                             ; if (not bar) then branch

    ; deal with '|' vertical BAR character
    INY                                                 ; increase Y to point to next character
    LDA (.stringInputBufferAddressLow),Y                ; get next character
    CMP #.charBAR                                       ; check for '|' again
    BEQ .finishUpReadClearV                             ; if (bar found) then branch

    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ .finishUpReadClearV                             ; if (double quotes) then branch

    CMP #.charEXCLAMATIONMARK                           ; check for '!' character
    BNE +                                               ; if (not '!') then branch

    ; deal with '|!' characters
    INY                                                 ; increment Y to next character
    SEC                                                 ;
    ROR .stringInputPlingFlag                           ;
    BMI -                                               ;

    ; deal with remaining possible characters after the '|' BAR character
+
    CMP #.charSPACE                                     ; check for ' '
    BCC .brkBadString                                   ; if (less than space, i.e. a control code) then branch ('Bad string' message)

    JSR .implementCTRLCodes                             ;
.finishUpReadClearV
    INY                                                 ;
    PHA                                                 ;
    PLA                                                 ;
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.brkBadString
    BRK                                                 ;
    !byte $FD                                           ; error number
    !text "Bad string"                                  ; message (with zero terminator as next BRK instruction)
    !byte 0

; ***************************************************************************************
.starDebug
    RTS                                                 ;

; ***************************************************************************************
;
; Silence all sound channels
;
; ***************************************************************************************
.silenceAllChannels
    LDX #4                                              ; loop counter
-
    DEX                                                 ;
    LDA #4                                              ;
    STA .channel0PhaseCounter,X                         ;
    STA $08a6,X                                         ;
    STA $08bc,X                                         ;
    LDA #0                                              ;
    STA .channel0Duration,X                             ;
    STA .channel0SyncFlag,X                             ;
    STA .bufferEmptyFlags,X                             ;
    JSR .setPitch                                       ;
    LDA #$c0                                            ;
    JSR .setChannelXVolume                              ;
    TXA                                                 ;
    BNE -                                               ;
    LDA #$ff                                            ;
    STA .soundSyncCount                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Set volume for channel X
;
; On Entry:
;       A = volume, where $3F (loudest) to $C0 (silent) - see table below
;       X = sound channel (0-3)
;
; ***************************************************************************************
.setChannelXVolume
    STA .channel0Volume,X                               ;

    ; we now convert the input volume into the value required to write to the sound chip
    SEC                                                 ; set carry
    SBC #$40                                            ; subtract $40
    LSR                                                 ; } divide by 8
    LSR                                                 ; }
    LSR                                                 ; }
    EOR #$0F                                            ; invert bits 0-3

;     BASIC SOUND   volume on entry     accumulator
;     volume        .channel0Volume     result now
;      -15                $3F              $10          loudest
;      -14                $37              $11
;      -13                $2F              $12
;      -12                $27              $13
;      -11                $1F              $14
;      -10                $17              $15
;       -9                $0F              $16
;       -8                $07              $17
;       -7                $FF              $18
;       -6                $F7              $19
;       -5                $EF              $1A
;       -4                $E7              $1B
;       -3                $DF              $1C
;       -2                $D7              $1D
;       -1                $CF              $1E
;        0                $C7              $1F          silent
;        -                $C0              $1F          silent

    ORA .soundParameterTable,X                          ; get encoded value for channel into top nybble
    ORA #$10                                            ; ensure bit 4 set (set volume)

.sendToSoundChip
    PHP                                                 ;
.sendToSoundChipFlagsAreadyPushed
    SEI                                                 ; disable interrupts
    LDY #$FF                                            ; }
    STY .systemVIADataDirectionRegisterA                ; } set data direction to all outputs
    STA .systemVIARegisterANoHandshake                  ; send data byte to sound chip
    INY                                                 ; Y=0
    STY .systemVIARegisterB                             ; set the write enable line low (active)
                                                        ; to let the sound chip know there
                                                        ; is data
    LDY #2                                              ; Y = loop counter
-
    DEY                                                 ; execute a short delay (this is to
    BNE -                                               ; keep the write enable line low for
                                                        ; at least 8 us, 16 cycles. This is
                                                        ; required by the sound chip hardware)
                                                        ;
                                                        ; [An alternative to this loop that
                                                        ; takes the same number of cycles, but
                                                        ; is two bytes shorter would be to JSR
                                                        ; to an (existing) RTS instruction.]

    LDY #8                                              ; }
    STY .systemVIARegisterB                             ; } pull the write enable line high (inactive)

    LDY #4                                              ; Y = loop counter
-
    DEY                                                 ; execute another short delay loop
    BNE -                                               ; [it's longer this time for some
                                                        ; reason? It seems like this loop is
                                                        ; not needed at all to me.]

    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
; Table to convert channel number to the bits required by the chip
.soundParameterTable
    !byte $E0,$C0,$A0,$80

; ***************************************************************************************
;
; Update sounds in the 100Hz timer interrupt
;
; ***************************************************************************************
.processSoundInterrupt
    LDA #0                                              ;
    STA .numberOfSoundChannelsOnHold                    ; zero number of channels on hold for sync
    LDA .soundSyncCount                                 ; get sync count
    BNE +                                               ; if (this is not zero) then branch
    INC .numberOfSoundChannelsOnHold                    ; number of channels on hold for sync = 1
    DEC .soundSyncCount                                 ; number of channels required for sync = 255
+
    LDX #4                                              ; set loop counter (X = channel number 0-3)
.processSoundChannelLoop
    DEX                                                 ; loop counter (X=3,2,1,0)
    LDA .channel0Occupancy,X                            ; get (sound queue occupancy)
    BEQ .skipToNextChannelLocal                         ; if (nothing playing on this channel) then branch (check next channel)
    LDA .bufferEmptyFlags,X                             ; get buffer empty flag

    BNE .chooseNextSound                                ; if (buffer empty) then branch (choose the next sound to play)
    LDA .channel0Duration,X                             ; get duration remaining
    BNE .continueExistingSound                          ; if (duration remaining > 0) then branch (continue processing current sound)
.chooseNextSound
    JSR .checkForNextSoundToPlay                        ; check and pick up new sound if required
.continueExistingSound
    LDA .channel0Duration,X                             ; get duration of current sound
    BEQ .skipUpdateOfCurrentSound                       ; if (duration is zero) then branch (skip update)
    CMP #$FF                                            ; check for $FF duration (infinite duration)
    BEQ .notAtEndOfCurrentSoundDuration                 ; if (infinite duration) then branch (not at end of current sound)

    ; decrement 20Hz counter
    DEC .channel0Countdown20Hz,X                        ; decrement 10 mS count
    BNE .notAtEndOfCurrentSoundDuration                 ; if (counter not reached zero) then branch (not at end of current sound)

    ; reset 20Hz counter
    LDA #5                                              ; reset to 5
    STA .channel0Countdown20Hz,X                        ; to give 50 mSec delay

    ; decrement duration at 20Hz
    DEC .channel0Duration,X                             ; and decrement main counter
    BNE .notAtEndOfCurrentSoundDuration                 ; if (duration is non-zero) then branch (not at end of current sound)

.skipUpdateOfCurrentSound
    JSR .checkForNextSoundToPlay                        ; check and get new sound

.notAtEndOfCurrentSoundDuration
    LDA .channel0StepCountdownProgress,X                ; check the step progress
    BEQ +                                               ; if (step progress counter is zero) then branch (don't decrement step progress)
    DEC .channel0StepCountdownProgress,X                ; decrement step progress
    BNE .skipToNextChannelLocal                         ; if (step progress counter is zero) then branch (check next channel)

+
    LDY .channel0EnvelopeOffset,X                       ; get envelope data offset

    BMI .skipToNextChannelLocal                         ; if (no envelope active) then branch (check next channel)

    LDA .envelopeBuffer,Y                               ; get step length (first byte of envelope data)
    AND #%01111111                                      ; clear the repeat bit
    STA .channel0StepCountdownProgress,X                ; store it
    LDA .channel0PhaseCounter,X                         ; get current phase in ADSR
    CMP #4                                              ; check for release phase complete
    BNE +                                               ; if (release phase NOT completed) then branch

.skipToNextChannelLocal
    JMP .skipToNextChannel                              ;

+
    ; set target amplitude for new phase
    LDA .channel0PhaseCounter,X                         ; start new step by getting current phase
    CLC                                                 ;
    ADC .channel0EnvelopeOffset,X                       ; add it to envelope offset
    TAY                                                 ; transfer to Y
    LDA .envelopeBuffer + 11,Y                          ; and get target value at end of current phase
    SEC                                                 ;
    SBC #$3F                                            ;
    STA .targetAmplitude                                ; store modified number as current target amplitude

    ; set amplitude step for new phase
    LDA .envelopeBuffer + 7,Y                           ; get change of amplitude for current phase
    STA .currentAmplitudeStep                           ; store as current amplitude step change

    ; calculate updated volume
    LDA .channel0Volume,X                               ; get current volume level
    PHA                                                 ; save it
    CLC                                                 ; clear carry
    ADC .currentAmplitudeStep                           ; add current amplitude step change
    BVC .skipToggleBits                                 ; if (no overflow) then branch
    ROL                                                 ; carry = bit 7. If new amplitude is negative (relatively quiet) then set the maximum volume
    LDA #$3F                                            ; A=$3F (loudest volume)
    BCS .skipToggleBits                                 ; if (carry set) then branch
    EOR #$FF                                            ; toggle bits (A=$C0, silent)

.skipToggleBits
    STA .channel0Volume,X                               ; store in current volume
    ROL                                                 ; }
    EOR .channel0Volume,X                               ; } take the EOR of bits 6 and 7
    BPL .updateAmplitude                                ; if (bits 6 and 7 of volume are equal) then branch (to update amplitude)
    LDA #$3F                                            ; }
    BCC +                                               ; } if (carry clear) then branch (A=$3F); otherwise A=$C0
    EOR #$FF                                            ; }
+
    STA .channel0Volume,X                               ; this is stored in current volume

.updateAmplitude
    DEC .currentAmplitudeStep                           ; decrement amplitude change per step
    LDA .channel0Volume,X                               ; get volume again
    SEC                                                 ; set carry
    SBC .targetAmplitude                                ; subtract target value
    EOR .currentAmplitudeStep                           ; check against step value: a negative result indicates correct trend
    BMI +                                               ; so jump to next part

    ; enter new amplitude phase
    LDA .targetAmplitude                                ;
    STA .channel0Volume,X                               ; set target amplitude
    INC .channel0PhaseCounter,X                         ; increment phase counter
+
    PLA                                                 ; get the old volume level
    EOR .channel0Volume,X                               ; and compare with the new volume
    AND #$F8                                            ; mask out lower bits
    BEQ .adjustEnvelopePitch                            ; if (they are the same) then branch (volume doesn't need changing)
    LDA .channel0Volume,X                               ; }
    JSR .setChannelXVolume                              ; } set new volume level

.adjustEnvelopePitch
    LDA .channel0Section,X                              ; get current pitch section (0-2)
    CMP #3                                              ; check if we have reached section 3
    BEQ .skipToNextChannel                              ; if (current section is 3) then branch (skip rest of loop as all sections are finished)

    DEC .channel0SectionCountdownProgress,X
    BNE .countdownTimerNotFinished                      ; if (countdown timer is not yet zero) then branch

    ; increment pitch section
    INC .channel0Section,X                              ; implement a section change
    LDA .channel0Section,X                              ; check if it's complete
    CMP #3                                              ;
    BNE +                                               ; if (not complete) then branch

    ; reached end of all three pitch sections
    LDY .channel0EnvelopeOffset,X                       ; }
    LDA .envelopeBuffer,Y                               ; } get first envelope byte (top bit = repeat pitch envelope)
    BMI .skipToNextChannel                              ; if (negative, i.e. don't repeat pitch envelope) then branch
    LDA #0                                              ; }
    STA .channel0PitchOffset,X                          ; } reset to first pitch section
    STA .channel0Section,X                              ; }

+
    LDA .channel0Section,X                              ; get number of steps in new section
    CLC                                                 ;
    ADC .channel0EnvelopeOffset,X                       ;
    TAY                                                 ;
    LDA .envelopeBuffer + 4,Y                           ; get envelope byte at offset 4 (number of steps in first pitch section)
    STA .channel0SectionCountdownProgress,X             ;

.countdownTimerNotFinished
    LDA .channel0EnvelopeOffset,X                       ; get rate of pitch change
    CLC                                                 ;
    ADC .channel0Section,X                              ; add section number
    TAY                                                 ;
    LDA .envelopeBuffer + 1,Y                           ; get envelope byte 1+section (current change of pitch)
    CLC                                                 ;
    ADC .channel0PitchOffset,X                          ; add to current pitch offset
    STA .channel0PitchOffset,X                          ; save updated pitch offset
    CLC                                                 ;
    ADC .channel0BasePitch,X                            ; add base pitch
    JSR .setPitch                                       ; set new pitch

.skipToNextChannel
    TXA                                                 ;
    BEQ +                                               ; if (X == 0) then branch
    JMP .processSoundChannelLoop                        ; jump back to process next channel

+
    RTS                                                 ;

; ***************************************************************************************
.checkForNextSoundToPlay
    LDA .channel0PhaseCounter,X                         ; get current phase counter
    CMP #4                                              ; is it 'release complete' state
    BEQ +                                               ; if (release complete) then branch
    LDA #3                                              ; mark release in progress
    STA .channel0PhaseCounter,X                         ; store it
+
    LDA .bufferEmptyFlags,X                             ; check buffer empty flag
    BEQ .skipResetAsBufferIsNotEmpty                    ; if (buffer not empty) then branch
    LDA #0                                              ; mark buffer not empty
    STA .bufferEmptyFlags,X                             ; an store it

    STA .channel0SyncFlag                               ; }
    STA .channel1SyncFlag                               ; }
    STA .channel2SyncFlag                               ; } clear all sync flags
    STA .channel3SyncFlag                               ; }
    STA .channel0Duration,X                             ; clear duration
    LDA #$ff                                            ;
    STA .soundSyncCount                                 ;

.skipResetAsBufferIsNotEmpty
    LDA .channel0SyncFlag,X                             ; get synchronising flag
    BEQ .syncSounds                                     ; if (it's zero) then branch
    LDA .numberOfSoundChannelsOnHold                    ; get number of channels on hold
    BEQ .silenceNonEnvelopeSound                        ; if (it's zero) then branch (silence sound)
    LDA #0                                              ;
    STA .channel0SyncFlag,X                             ; zero synchronising flag

.readNextSoundFromBufferAndProcessLocal
    JMP .readNextSoundFromBufferAndProcess              ;

.syncSounds
    JSR .osbyte152EntryPointAdding4                     ; examine next byte in buffer (sets carry if buffer empty)
    BCS .syncSoundBufferEmpty                           ; if (buffer empty) then branch
    AND #3                                              ; get just bits 0 and 1
    BEQ .readNextSoundFromBufferAndProcessLocal         ; if (zero) then branch
    LDA .soundSyncCount                                 ; get synchronising count
    BEQ +                                               ; if (zero, i.e. nothing to sync) then branch

    INC .channel0SyncFlag,X                             ; set sync flag
    BIT .soundSyncCount                                 ; check bit 7 is clear
    BPL ++                                              ; if (sync required) then branch
    JSR .osbyte152EntryPointAdding4                     ; get first byte from buffer
    AND #3                                              ; get just bits 0 and 1
    STA .soundSyncCount                                 ; store result
    JMP .silenceNonEnvelopeSound                        ;

++
    DEC .soundSyncCount                                 ;
+
    JMP .silenceNonEnvelopeSound                        ; silence the channel if envelope not in use

; ***************************************************************************************
.syncSoundBufferEmpty
    PHP                                                 ; save flags
    SEI                                                 ; and disable interrupts
    LDA .channel0PhaseCounter,X                         ; get ADSR phase counter
    CMP #4                                              ; check for end of release phase
    BNE +                                               ; if (not end of release phase) then branch
    JSR .osbyte152EntryPointAdding4                     ; examine buffer
    BCC +                                               ; if (not empty, i.e. there's another sound to play) then branch
    LDA #0                                              ; }
    STA .channel0Occupancy,X                            ; } mark channel as silent
+
    PLP                                                 ; get back flags
    ; fall through...

; ***************************************************************************************
.silenceNonEnvelopeSound
    LDY .channel0EnvelopeOffset,X                       ; this value is positive if an envelope is defined
    BPL .exit25                                         ; if (envelope defined) then branch
    LDA #$c0                                            ;
    JSR .setChannelXVolume                              ; silence channel
    LDA #4                                              ;
    STA .channel0PhaseCounter,X                         ; set phase counter
.exit25
    RTS                                                 ;

; ***************************************************************************************
.setPitch
    CMP .channel0Pitch,X                                ; check against pitch value
    BEQ .exit25                                         ; if (pitch is equal) then branch (exit)
.setPitchChanged
    STA .channel0Pitch,X                                ; store new pitch
    CPX #0                                              ; check for noise channel
    BNE .setPitchNotNoise                               ; if (X is not noise channel) then branch (not noise)

    ; setting noise
    AND #$0F                                            ; noise value
    ORA .soundParameterTable,X                          ; convert to chip format, by adding the value required for channel
    PHP                                                 ; save flags
    JMP .localSendToSoundChipFlagsAreadyPushed          ; and pass to chip control routine

; ***************************************************************************************
;
; Set the pitch of a sound
;
; On Entry:
;       A = pitch (0-255).
;
; ***************************************************************************************
.setPitchNotNoise
    PHA                                                 ; remember A = pitch (0-252)
    AND #3                                              ;
    STA .fractionalSemitones                            ; store the fractional amount (0-3) between semitones

    ; calculate the octave
    LDA #0                                              ;
    STA .soundPitchLow                                  ; octave
    PLA                                                 ; get back A = original pitch value
    LSR                                                 ; }
    LSR                                                 ; } divide by 4 (to get semitone count 0-63)
-
    CMP #12                                             ;
    BCC .finishedGettingOctave                          ; if (remainder is less than 12) then branch (we have found the right octave)
    INC .soundPitchLow                                  ; increment octave
    SEC
    SBC #12                                             ; subtract 12 for each octave
    BNE -                                               ; if (not zero) then branch (loop back)

    ; at this point .soundPitchLow defines the Octave (0-5)
    ; A = the semitone within the octave

    ; get the 10 bit pitch value for the note within the octave from the pitch lookup tables
.finishedGettingOctave
    TAY                                                 ; Y = semitone within octave
    LDA .soundPitchLow                                  ; get octave number into A
    PHA                                                 ; push it
    LDA .pitchLookupTableLow,Y                          ; get semitone byte from first pitch table

    ; Offset the pitch slightly depending on the channel. Perhaps to avoid
    ; phase shift effects when two or more channels play the same pitch?
    CLC                                                 ;
    ADC .soundPitchOffsetByChannelTable,X               ;
    STA .soundPitchLow                                  ; store it
    LDA .pitchLookupTableHigh,Y                         ; get semitone byte from second pitch table
    ADC #0                                              ;
    AND #3                                              ; keep two least significant bits only
    STA .soundPitchHigh                                 ; save them
    ASL .soundPitchLow                                  ;
    ROL .soundPitchHigh                                 ;
    ASL .soundPitchLow                                  ;
    ROL .soundPitchHigh                                 ;
    LDA .pitchLookupTableHigh,X                         ;
    LSR                                                 ; }
    LSR                                                 ; } shift down
    STA .soundFractional                                ; store it (amount to subtract for each fraction (0-3) between semitones)

    ; adjust for any eighth tones (0-3) between semitones
    LDY .fractionalSemitones                            ; loop counter (0-3)
    BEQ ++                                              ;

-
    LDA .soundPitchLow                                  ;
    SEC                                                 ; }
    SBC .soundFractional                                ; } soundFractional is subtracted from A each time around the loop
    STA .soundPitchLow                                  ;
    BCS +                                               ;
    DEC .soundPitchHigh                                 ; decrement high byte of pitch as needed
+
    DEY                                                 ; decrement loop counter
    BNE -                                               ; if (not done) then branch (loop back)
++
    LSR .soundPitchHigh                                 ;
    ROR .soundPitchLow                                  ;
    LSR .soundPitchHigh                                 ;
    ROR .soundPitchLow                                  ;

    ; halve the 10-bit pitch value (.soundPitchLow/High) for each octave
    PLA                                                 ; recall octave number
    TAY                                                 ; Y = loop counter = octave number
    BEQ +                                               ;
-
    LSR .soundPitchHigh                                 ; }
    ROR .soundPitchLow                                  ; } halve soundVariableA/B
    DEY                                                 ;
    BNE -                                               ; if (not done yet) then branch (loop back)

+
    LDA .soundPitchLow                                  ;
    AND #$0F                                            ; frequency value (low four bits)
    ORA .soundParameterTable,X                          ; convert to chip format, by adding
                                                        ; the value required for channel

    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    JSR .sendToSoundChip                                ; send first byte to sound chip

    LDA .soundPitchLow                                  ; calculate the second byte to send
                                                        ; to the sound chip
    LSR .soundPitchHigh                                 ; }
    ROR                                                 ; }
    LSR .soundPitchHigh                                 ; } divide by 4
    ROR                                                 ; }

    LSR                                                 ; }
    LSR                                                 ; } shift byte right twice

    ; now A holds the second byte we want to send to the sound chip
.localSendToSoundChipFlagsAreadyPushed
    JSR .sendToSoundChip                                ;
    PLP                                                 ;
    RTS                                                 ;

.readNextSoundFromBufferAndProcess
    JSR .osbyte152EntryPointAdding4                     ;
    PHP                                                 ;
    SEI                                                 ;
    AND #4                                              ; isolate the hold bit
    BEQ .playNewSound                                   ; if (hold not set) then branch
    LDY .channel0EnvelopeOffset,X                       ;
    BPL +                                               ;
    ; no envelope in use, silence channel
    LDA #$c0                                            ;
    JSR .setChannelXVolume                              ; silence channel
    LDA #$04                                            ;
    STA .channel0PhaseCounter,X                         ;
+
    JSR .osbyte145EntryPointAdding4                     ;
    JSR .osbyte145EntryPointAdding4                     ; get (and ignore) pitch byte
    JSR .osbyte145EntryPointAdding4                     ; get the duration
    PLP                                                 ; get back flags
    JMP .setDurationAndExit                             ; set duration, exit

.playNewSound
    JSR .osbyte145EntryPointAdding4                     ;
    AND #%11111000                                      ; zero bits 0-2
    ASL                                                 ; put bit 7 into carry
    BCC +                                               ; if (zero, envelope) then branch

    ; extract and set volume
    EOR #$FF                                            ; }
    LSR                                                 ; } convert volume number into
    SEC                                                 ; } an expected value for the
    SBC #$40                                            ; } volume routine
    JSR .setChannelXVolume                              ; and set volume

    ; set no envelope in use
    LDA #$FF                                            ; A=$FF
+
    ; set envelope offset = envelope number * 16 (or $FF for no envelope)
    STA .channel0EnvelopeOffset,X                       ; get envelope number-1 *16 into A

    ; restart the channel's 20Hz timer
    LDA #5                                              ; set duration sub-counter
    STA .channel0Countdown20Hz,X                        ;

    ; set phase 1, the start of the sound
    LDA #1                                              ; set phase counter
    STA .channel0StepCountdownProgress,X                ;
    STA .channel0SectionCountdownProgress,X             ;

    ; reset section countdown, phase counter, and pitch offset
    LDA #0                                              ;
    STA .channel0PhaseCounter,X                         ;
    STA .channel0PitchOffset,X                          ;

    ; set section to $FF
    LDA #$FF                                            ;
    STA .channel0Section,X                              ;

    ; store pitch
    JSR .osbyte145EntryPointAdding4                     ; read pitch
    STA .channel0BasePitch,X                            ; set it

    ; read duration
    JSR .osbyte145EntryPointAdding4                     ; read duration
    PLP                                                 ;
    PHA                                                 ; save duration

    ; set pitch
    LDA .channel0BasePitch,X                            ; get back pitch value
    JSR .setPitch                                       ; and set it
    PLA                                                 ;

.setDurationAndExit
    STA .channel0Duration,X                             ;
    RTS                                                 ;

; ***************************************************************************************
.osbyte145EntryPointAdding4
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    JSR .osbyte145EntryPoint                            ;
    DEX                                                 ;
    DEX                                                 ;
    DEX                                                 ;
    DEX                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.osbyte152EntryPointAdding4
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    JSR .osbyte152EntryPoint                            ;
    DEX                                                 ;
    DEX                                                 ;
    DEX                                                 ;
    DEX                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Pitch tables
;
; These next two tables are used to convert the 8 bit pitch (0-255) of a sound value passed
; to the OS (e.g. via OSWORD 7, see .osword7EntryPoint) into the 10-bit integer pitch value
; required by the sound chip.
;
; When given a 10 bit pitch value, the chip outputs a tone with frequency:
;
;       frequency (in Hz) = 4,000,000 / (32 * pitch)
;
; The first table provides the lower 8 bits and the second table (bits 0-1) provide the two
; high bits:
;
;        low byte      10 bit
;        +bits 0,1     chip      actual      ideal
; note   high byte     pitch     frequency   frequency
; -------------------------------------------------------------------------
;   B    $3F0       =  1008      124.01Hz    123.47Hz
;   C    $3B7       =   951      131.44Hz    130.81Hz
;   C#   $382       =   898      139.20Hz    138.59Hz
;   D    $34F       =   847      147.58Hz    146.83Hz
;   D#   $320       =   800      156.25Hz    155.56Hz
;   E    $2F3       =   755      165.56Hz    164.81Hz
;   F    $2C8       =   712      175.56Hz    174.61Hz
;   F#   $2A0       =   672      186.01Hz    185.00Hz
;   G    $27B       =   635      196.85Hz    196.00Hz
;   G#   $257       =   599      208.68Hz    207.65Hz
;   A    $235       =   565      221.24Hz    220.00Hz
;   A#   $216       =   534      234.08Hz    233.08Hz
;
; The upper nybble (bits 4-7) of the .pitchLookupTableHigh stores the amount to reduce the
; 10 bit pitch value for each quarter (0-3) between two adjacent semitones. Bits 2-3 are
; unused.
;
; ***************************************************************************************
.pitchLookupTableLow
    !byte $F0                                           ; B
    !byte $B7                                           ; C
    !byte $82                                           ; C#
    !byte $4F                                           ; D
    !byte $20                                           ; D#
    !byte $F3                                           ; E
    !byte $C8                                           ; F
    !byte $A0                                           ; F#
    !byte $7B                                           ; G
    !byte $57                                           ; G#
    !byte $35                                           ; A
    !byte $16                                           ; A#

.pitchLookupTableHigh
    !byte $E7                                           ; B
    !byte $D7                                           ; C
    !byte $CB                                           ; C#
    !byte $C3                                           ; D
    !byte $B7                                           ; D#
    !byte $AA                                           ; E
    !byte $A2                                           ; F
    !byte $9A                                           ; F#
    !byte $92                                           ; G
    !byte $8A                                           ; G#
    !byte $82                                           ; A
    !byte $7A                                           ; A#

; [ More accurate values for these two tables would be as follows:
;
; .pitchLookupTableLow
;    !byte $F3                                           ; B
;    !byte $BB                                           ; C
;    !byte $85                                           ; C#
;    !byte $52                                           ; D
;    !byte $23                                           ; D#
;    !byte $F5                                           ; E
;    !byte $CB                                           ; F
;    !byte $A3                                           ; F#
;    !byte $7D                                           ; G
;    !byte $59                                           ; G#
;    !byte $37                                           ; A
;    !byte $17                                           ; A#
;
; .pitchLookupTableHigh
;    !byte $E7                                           ; B
;    !byte $D7                                           ; C
;    !byte $DB                                           ; C#   <-- this is the only
;    !byte $C3                                           ; D        change to this table
;    !byte $B7                                           ; D#
;    !byte $AA                                           ; E
;    !byte $A2                                           ; F
;    !byte $9A                                           ; F#
;    !byte $92                                           ; G
;    !byte $8A                                           ; G#
;    !byte $82                                           ; A
;    !byte $7A                                           ; A#
; ]

    ; Sound pitch offsets table: Notes played on different sound channels are offset in pitch
    ; slightly from each other. Channel 3 in particular is slightly raised in pitch.
.soundPitchOffsetByChannelTable
    !byte $00                                           ;
    !byte $01                                           ;
    !byte $00                                           ;
    !byte $02                                           ;
    !byte $60                                           ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 17: Keyboard processing
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.tidyUpAfterKeyboardProcessing
    LDA .lastKeyPressedInternal                         ; }
    ORA .firstKeyPressedInternal                        ; } check for any key pressed
    BNE .keyboardIndicators                             ; if (anything pressed) then branch (skip forward)
    LDA #%10000001                                      ; enable keyboard interrupt (by writing bit 7 and
    STA .systemVIAInterruptEnableRegister               ; bit 0 of system VIA interrupt enable register)
    ; fall through...


; ***************************************************************************************
; write to the keyboard LEDs (SHIFT LOCK and CAPS LOCK)
;
; On Entry:
;       .keyboardStatusFlags contains the SHIFT / CAPS LOCK state to write to the LEDs
;
; On Exit:
;       A contains the value of the flags register on entry
;       Preserves N and V flags
.keyboardIndicators
    PHP                                                 ; save flags
    LDA .keyboardStatusFlags                            ; read keyboard status
                                                        ; Bit 4 = 0 means CAPS LOCK engaged (c)
                                                        ; bit 5 = 0 means SHIFT LOCK engaged (s)
                                                        ; A = %xxscxxxx
    LSR                                                 ; A = %0xxscxxx
    AND #$18                                            ; A = %000sc000
    ORA #6                                              ; A = %000sc110
    STA .systemVIARegisterB                             ; write the bottom nybble to turn on or off CAPS LOCK light
    LSR                                                 ; A = %0000sc11
    ORA #7                                              ; A = %0000s111
    STA .systemVIARegisterB                             ; write the bottom nybble to turn on or off SHIFT LOCK light
    LDA #11                                             ;
    STA .systemVIARegisterB                             ; Enable Keyboard auto scanning
    PLA                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
.keyboardTimerInterrupt
    CLC                                                 ;
    ; fall through...

; ***************************************************************************************
;
; Test SHIFT and CTRL
;
; On Entry:
;       Carry SET   if entered here for testing the SHIFT and CTRL keys
;       Carry CLEAR if entered via the keyboard timer interrupt
;
; On Exit:
;       N=1 if CTRL pressed
;       V=1 if SHIFT pressed
; ***************************************************************************************
.keyTestSHIFTAndCTRLOrTimerInterrupt
    LDA .keyboardStatusFlags                            ; read keyboard status
                                                        ; Bit 3 = 1 means SHIFT pressed
                                                        ; Bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; Bit 6 = 1 means CTRL pressed
                                                        ; Bit 7 = 1 means SHIFT enabled
    AND #%10110111                                      ; zero bits 3 and 6 (SHIFT and CTRL pressed)
    LDX #0                                              ; zero X to test for SHIFT key pressed

    STX .tempStoreDB                                    ; save X (SHIFT key status)
    JSR .interrogateKeyboard                            ; interrogate keyboard. Returns with X=$80 if SHIFT is pressed
    CLV                                                 ; clear V
    BPL .testCTRL                                       ; if (no key pressed) then branch (check for CTRL key)
    BIT .allBitsSet                                     ; set N and V flags
    ORA #%00001000                                      ; set bit 3 to indicate SHIFT was pressed
    DEC .tempStoreDB
.testCTRL
    INX                                                 ; (X=$01 or X=$81 but top bit is ignored by .interrogateKeyboard)
    JSR .interrogateKeyboard                            ; check the CTRL key (key X)
    BCS .keyboardIndicators                             ; if (entered routine just for testing SHIFT and CTRL status) then branch
                                                        ;                        (to turn on keyboard lights as required and exit)

    ; at this point we are here because of a timer interrupt
    BPL +                                               ; if (key not pressed) then branch
    ORA #%01000000                                      ; or set CTRL pressed bit in keyboard status byte in A
+

    STA .keyboardStatusFlags                            ; save the updated status byte

    LDX .lastKeyPressedInternal                         ;
    BEQ .noLastKeyPressed                               ; if (no key pressed) then branch
    JSR .interrogateKeyboard                            ; check to see if last key is still pressed
    BMI .checkForKeyAutorepeat                          ; if (key pressed) then branch (enter repeat routine)
    CPX .lastKeyPressedInternal                         ; compare X (zero) with last key pressed
.storeLastKeyPressed
    STX .lastKeyPressedInternal                         ; store X in last key pressed
    BNE .noLastKeyPressed                               ; if (no key recently pressed) then branch
    LDX #0                                              ; }
    STX .lastKeyPressedInternal                         ; } store zero as the last key pressed

.resetAutorepeatCounters
    LDX #1                                              ; set timer to 1
    STX .autorepeatCountdownTimer                       ;
    LDX .keyboardAutoRepeatDelay                        ; get next timer value
    STX .keyboardFirstAutorepeatCount                   ; and store it

.noLastKeyPressed
    JMP .keyboardRolloverChecks                         ;

; ***************************************************************************************
; This looks the see if the current key pressed is the same as the previous key pressed
; If so we handle auto-repeat.
.checkForKeyAutorepeat
    CPX .lastKeyPressedInternal                         ;
    BNE .storeLastKeyPressed                            ; if (X is not the same as the last key pressed) then branch back

    ; new key pressed is same as last key pressed, so handle auto-repeat
    LDA .autorepeatCountdownTimer                       ; get auto repeat countdown timer
    BEQ .afterModifiers                                 ; if (auto repeat countdown timer is zero) then branch
    DEC .autorepeatCountdownTimer                       ; decrement timer
    BNE .afterModifiers                                 ; if (not zero) then branch (still waiting for a repeat delay to finish)

    LDA .keyboardFirstAutorepeatCount                   ; get initial autorepeat delay (or repeat interval)
    STA .autorepeatCountdownTimer                       ; store it in countdown timer
    LDA .keyboardAutoRepeatRate                         ; get auto repeat interval
    STA .keyboardFirstAutorepeatCount                   ; store it as next value for countdown timer
    LDA .keyboardStatusFlags                            ; get keyboard status
    ROL                                                 ;
    ROR .tempStoreDB                                    ;
    CLC                                                 ;
    ROR                                                 ;
    LDX .lastKeyPressedInternal                         ; get last key pressed
    CPX #$D0                                            ; check for SHIFT LOCK key
    BNE .testCapsLock                                   ; if (not SHIFT LOCK) then branch (to test CAPS LOCK)

    ; deal with SHIFT LOCK key pressed.
    ; Update keyboard status flags.
    ORA #%00010000                                      ; sets keyboard status flags (disengage CAPS LOCK)

                                                        ; Bit 3 = 1 means SHIFT pressed
                                                        ; Bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; Bit 6 = 1 means CTRL pressed
                                                        ; Bit 7 = 1 means SHIFT enabled

    EOR #%00100000                                      ; flip SHIFT LOCK engaged

.resetKeyboardStatusAndTimer
    STA .keyboardStatusFlags                            ;
    LDA #0                                              ;
    STA .autorepeatCountdownTimer                       ; store it in countdown timer
.afterModifiers
    JMP .keyboardRolloverChecks                         ;

; ***************************************************************************************
.testCapsLock
    CPX #$C0                                            ; check for CAPS LOCK
    BNE .getASCIICode                                   ; if (not CAPS LOCK) then branch (decode key to ASCII etc)

    ; deal with CAPS LOCK key pressed.
    ; Update keyboard status flags.
    ORA #%00100000                                      ; sets keyboard status flags (disengage SHIFT LOCK)
    EOR #%00010000                                      ; flip CAPS LOCK engaged
    JMP .resetKeyboardStatusAndTimer                    ;

; ***************************************************************************************
;
; Get ASCII code
;
; Handles the conversion of the internal key number (here with the top bit set) into
; the final ASCII code. It takes into account the current state of CTRL key, SHIFT key,
; the SHIFT LOCK and CAPS LOCK engaged states.
;
; See .scanKeyboard for table of internal key numbers.
;
; On Entry:
;       X = key pressed internal number WITH THE TOP BIT SET
;           X is at least $90, since the internal key number is at least 16 ($10).
;
; ***************************************************************************************
.getASCIICode
    LDA .keyDataTable1 - $90,X                          ; get ASCII code from look up tables
    CMP #.charSPACE                                     ;
    BEQ .keyboardInsertByte                             ;
    CMP #.charRETURN                                    ;
    BEQ .keyboardInsertByte                             ;
    CMP #.charDELETE                                    ;
    BEQ .keyboardInsertByte                             ;
    LDX .keyboardStatusFlags                            ; get keyboard status
    STX .tempStoreDB                                    ; store keyboard status in temporary storage
    ROL .tempStoreDB                                    ; rotate to get CTRL pressed into bit 7
    BPL +                                               ; if (CTRL not pressed) then branch (past CTRL processing)

    ; deal with CTRL key pressed
    LDX .firstKeyPressedInternal                        ; get number of previously pressed key
.localResetAutorepeatAndContinue
    BNE .resetAutorepeatCounters                        ; if (not zero) then branch (reset autorepeat counters)
    JSR .implementCTRLCodes                             ; perform code changes for CTRL
+
    LDY #0                                              ;
    ROL .tempStoreDB                                    ; move SHIFT LOCK into bit 7
    BMI .testCapsLockEngaged                            ; if (SHIFT LOCK not engaged) then branch (skip SHIFT LOCK processing)

    ; deal with SHIFT LOCK key engaged
    LDY $0225                                           ; [unknown]
    BNE +                                               ;
    JSR .implementSHIFT                                 ; make code changes for SHIFT
+
    ROL .tempStoreDB                                    ; move CAPS LOCK into bit 7
    JMP .testShiftEnabled                               ;

; ***************************************************************************************
.testCapsLockEngaged
    ROL .tempStoreDB                                    ; move CAPS LOCK into bit 7
    BMI .testShift                                      ; if (CAPS LOCK not engaged) then branch

    ; deal with CAPS LOCK engaged
    JSR .isLetter                                       ; make changes for CAPS LOCK on, return with C clear for alphabetic codes
    BCS .testShift                                      ; if (not a letter) then branch
    JSR .implementSHIFT                                 ; transform the letter via SHIFT

.testShiftEnabled
    INY                                                 ;
    DEY                                                 ;
    BNE .testShift                                      ;
    LDX .keyboardStatusFlags                            ; check SHIFT enabled bit
    BPL .testESCAPEcode                                 ; if (SHIFT disabled) then branch

.testShift
    ROL .tempStoreDB                                    ; move SHIFT into bit 7
    BPL .testESCAPEcode                                 ; if (no SHIFT key) then branch

    ; deal with SHIFT key pressed
    LDX .firstKeyPressedInternal                        ; get previous key press
    BNE .localResetAutorepeatAndContinue                ; if (not 0) then branch (reset repeat system etc)
    JSR .implementSHIFT                                 ; make code changes for SHIFT

.testESCAPEcode
    CMP #.charESCAPE                                    ; check against ESCAPE action
    BNE +                                               ; if (A is not ESCAPE action) then branch

    ; deal with ESCAPE key
    LDX .escapeAction                                   ; get ESCAPE key action type
    BNE +                                               ; if (ESCAPE returns ASCII code) then branch
    STX .autorepeatCountdownTimer                       ; store zero in auto-repeat countdown timer
    BEQ .keyboardInsertByte                             ;

+
    INY                                                 ;
    DEY                                                 ; increment and decrement Y, to set flags
    BEQ .keyboardInsertByte                             ; if (Y = 0) then branch
    ORA #$80                                            ; set top bit

.keyboardInsertByte
    JSR .insertByteIntoKeyboardBuffer                   ;
.keyboardRolloverChecks
    LDX .firstKeyPressedInternal                        ; get first keypress
    BEQ +                                               ; if (none) then branch
    JSR .interrogateKeyboard                            ; examine to see if key still pressed
    STX .firstKeyPressedInternal                        ; store result
    BMI +                                               ; if (key pressed) then branch
    CPX .firstKeyPressedInternal                        ; } [redundant code, removed in MOS 1.20]
    BNE +                                               ; } [redundant code, removed in MOS 1.20]
    LDA #0                                              ;
    STA .firstKeyPressedInternal                        ; reset .firstKeyPressedInternal to zero
+
    LDX .firstKeyPressedInternal                        ; get .firstKeyPressedInternal
    BNE .continueKeyProcessing                          ; if (not zero) then branch
    JSR .interrogateKeyboardFrom16
-
    INC .systemVIARegisterANoHandshake                  ; increments key number (bits 0-6), then reads
                                                        ; bit 7 (sets N flag) to indicate key pressed
    BPL -                                               ; if (not pressed) then branch (try next key)
    LDA .systemVIARegisterANoHandshake                  ;
    AND #$7f                                            ; clear top bit to get just the key number
    BEQ .localTidyUpAfterKeyboardProcessing             ; if (no key pressed) then branch (finish up)
    SEC                                                 ;
    SBC #1                                              ;
    EOR .lastKeyPressedInternal                         ; check against last key pressed
    AND #$7f                                            ; clear top bit
    BEQ -                                               ; if (same as last key pressed) then branch (loop back)
    LDA .lastKeyPressedInternal                         ; make the last key the
    STA .firstKeyPressedInternal                        ; first key pressed i.e. rollover
--
    LDA .systemVIARegisterANoHandshake                  ;
    SEC                                                 ;
    SBC #1                                              ;
    AND #$7f                                            ;
    STA .lastKeyPressedInternal                         ; store last key pressed
    LDA #1                                              ;
    STA .autorepeatCountdownTimer                       ;
    LDA .keyboardAutoRepeatDelay                        ;
    STA .keyboardFirstAutorepeatCount                   ;

.localTidyUpAfterKeyboardProcessing
    JMP .tidyUpAfterKeyboardProcessing                  ;

; ***************************************************************************************
.keyEntryPoint
    JSR .interrogateKeyboardFrom16                      ;
    LDA #1                                              ; disable keyboard interrupts
    STA .systemVIAInterruptEnableRegister               ; by writing to VIA interrupt vector

.continueKeyProcessing
    LDA .lastKeyPressedInternal                         ; get previous key press
    BNE .localTidyUpAfterKeyboardProcessing             ; if (none) then branch (back to housekeeping routine)
    JSR .interrogateKeyboardFrom16                      ;
-
    INC .systemVIARegisterANoHandshake                  ; increments key number (bits 0-6), then reads
                                                        ; bit 7 (sets N flag) to indicate key pressed
    BPL -                                               ; if (not pressed) then branch (try next key)
    LDA .systemVIARegisterANoHandshake                  ;
    AND #$7f                                            ; clear top bit to get just the key number
    BEQ .localTidyUpAfterKeyboardProcessing             ;
    SEC                                                 ;
    SBC #1                                              ;
    EOR .firstKeyPressedInternal                        ;
    AND #$7f                                            ; clear top bit to get just the key number
    BEQ -                                               ;
    BNE --                                              ;

; ***************************************************************************************
.interrogateKeyboardFrom16
    LDX #16                                             ; set X to 16 (ignores the first
                                                        ; keyboard row containing SHIFT,
                                                        ; CTRL, and the hardware keyboard
                                                        ; switches)
    ; fall through...

; ***************************************************************************************
;
; Read a single key's state from the keyboard
;
; See return.png
;
; On Entry:
;       X = key to test
; On Exit:
;       A is preserved
;       Carry is preserved
;
;       X = $80 if key pressed (N set)
;           $00 otherwise      (N clear)
;
; ***************************************************************************************
.interrogateKeyboard
    LDY #3                                              ; stop keyboard scanning
    STY .systemVIARegisterB                             ; by writing to system VIA
    LDY #%01111111                                      ; input on bit 7, output on bits 0 to 6
    STY .systemVIADataDirectionRegisterA                ;
    STX .systemVIARegisterANoHandshake                  ; write X to Port A system VIA
    LDX .systemVIARegisterANoHandshake                  ; read back ($80 + internal key number) if key pressed (or zero otherwise)
    RTS                                                 ;

; ***************************************************************************************
;
; Read the keyboard 8 times with internal key numbers 9-1
;
; This reads the state of the CTRL key and the 'keyboard links', a set of DIP switches next
; to the keyboard. See .scanKeyboard for internal key numbers.
;
; These are rotated into the 8 bits of .keyboardLinks for further processing
;
; ***************************************************************************************
.readKeyboardCtrlAndLinks
    LDX #9                                              ; loop counter
-
    TXA                                                 ; Start of loop to interrogate keyboard
    JSR .interrogateKeyboard                            ; with A = 9...1 which reads keyboard links 9-2 and CTRL key
    CPX #$80                                            ; set carry if the 'key' or 'link' is 'pressed' or 'set'
    ROR .keyboardLinks                                  ; rotate carry into MSB into bit 7 of .keyboardLinks
    TAX                                                 ; get back value of X for loop
    DEX                                                 ; decrement it
    BNE -                                               ; if (not zero) then branch (do loop again)

    ; At this point Carry(C) and .keyboardLinks holds:
    ; C = }
    ; 0 = } screen MODE on startup
    ; 1 = }
    ; 2 = if clear reverse SHIFT BREAK action
    ; 3 = }
    ; 4 = } set disc drive timings
    ; 5 = not used
    ; 6 = not used
    ; 7 = CTRL key

    ROL .keyboardLinks                                  ;

    ; At this point .keyboardLinks holds keyboard links:
    ; 0 = }
    ; 1 = } screen MODE on startup
    ; 2 = }
    ; 3 = if clear reverse SHIFT BREAK action
    ; 4 = }
    ; 5 = } set disc drive timings
    ; 6 = not used
    ; 7 = not used
    ; C = CTRL key

    JMP .keyboardIndicators                             ; set LEDs. carry flag (CTRL key) is put into bit zero of A

; ***************************************************************************************
;
; Apply SHIFT to character in A
;
; Modify character in A as if the SHIFT key is being pressed
;
; ***************************************************************************************
.implementSHIFT
    CMP #.charUNDERSCORE                                ; }
    BEQ .handleUnderscore                               ; }
    CMP #.charPOUND                                     ; } Check for UNDERSCORE or POUND
    BNE +                                               ; }
.handleUnderscore
    EOR #$3f                                            ; SHIFT underscore or POUND character
    BNE .exit24                                         ; ALWAYS branch

+
    CMP #.charA                                         ; }
    BCC +                                               ; }
    CMP #.charDELETE                                    ; } Check range is between 65 and 126
    BCS +                                               ; }
    EOR #$20                                            ; SHIFT character in range 65-126
    BNE .exit24                                         ;
+
    CMP #.charZERO                                      ; }
    BEQ .exit24                                         ; }
    CMP #.charEXCLAMATIONMARK                           ; }
    BCC .exit24                                         ; } These characters have no SHIFTed version
    CMP #.charAT                                        ; }
    BCS .exit24                                         ; }
    EOR #$10                                            ; SHIFT character in range 0-64
.exit24
    RTS                                                 ;

; ***************************************************************************************
;
; Modify character in A as if the CTRL key is being pressed
;
; This is used both when the CTRL key is being pressed, and for parsing strings using
; GSINIT / GSREAD. See .gsinitEntryPoint.
;
;     Input     Output      Notes
;     ASCII      CTRL
;     Code       Code
;     ----------------------------------------------------------------------
;     32-63     32-63       VDU 32-63 (unchanged)
;     '@'         0         VDU 0
;     'A'         1         VDU 1
;           ...
;     'Z'        26         VDU 26
;     '['        27         VDU 27
;     '\'        28         VDU 28
;     ']'        29         VDU 29
;     '^'        30         VDU 30
;     '_'        31         VDU 31
;     '£'        31         VDU 31 this is treated as a special case.
;                                  it would otherwise result in VDU 0 [why the special case?]
;     'a'         1         VDU 1
;           ...
;     'z'        26         VDU 26
;     '{'        27         VDU 27
;     '|'        28         VDU 28
;     '}'        29         VDU 29
;     '~'        30         VDU 30
;     127       127         DELETE
;     128-255   flip bit 5  flip bit 5 [it's not clear why this is useful?]
;
; ***************************************************************************************
.implementCTRLCodes
    CMP #.charDELETE                                    ; check for DELETE or above
    BCS ++                                              ; if (>= 127) then branch (exit)
    CMP #.charPOUND                                     ; }
    BNE +                                               ; } if (A is not '£') then branch
    LDA #.charUNDERSCORE                                ; CTRL £ = _
+
    CMP #.charZERO                                      ;
    BNE +                                               ;
    LDA #.charSPACE                                     ; CTRL 0 = SPACE
+
    CMP #.charFORWARDSLASH                              ;
    BEQ .useDelete                                      ; CTRL / = DELETE
    CMP #.charQUESTIONMARK                              ;
    BEQ .useDelete                                      ; CTRL ? = DELETE
    CMP #.charAT                                        ; }
    BCC ++                                              ; } if (A < '@') then branch (return unchanged)
    AND #%00011111                                      ; at this point     A is between 64 to 126 inclusive
                                                        ; zero bits 5 to 7  A is between  0 to  31 inclusive
++
    RTS                                                 ;

.useDelete
    LDA #.charDELETE                                    ;
    RTS                                                 ;

; ***************************************************************************************
;
; The seven 'key data' tables
;
; What follows is 7 tables of 10 bytes each, spaced 16 bytes apart, giving the 'ASCII'
; character codes for each internal key number on the keyboard row. The six bytes between
; each table are unused.
;
; See .scanKeyboard for table of internal key numbers.
;
; ***************************************************************************************
.keyDataTable1
    ;      q , 3 , 4 , 5 , f4, 8 , f7, - , ^ ,LEFT
    !byte $71,$33,$34,$35,$94,$38,$97,$2D,$5E,$88

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable2
    ;      f0, w , e , t , 7 , i , 9 , 0 , _ ,DOWN
    !byte $90,$77,$65,$74,$37,$69,$39,$30,$5F,$8A

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable3
    ;      1 , 2 , d , r , 6 , u , o , p , [ ,UP
    !byte $31,$32,$64,$72,$36,$75,$6F,$70,$5B,$8B

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable4
    ; CAPS LOCK, a , x , f , y , j , k , @ , : ,RETURN
    !byte   $00,$61,$78,$66,$79,$6A,$6B,$40,$3A,$0D

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable5
    ; SHIFT LOCK, s , c , g , h , n , l , ; , ] ,DELETE
    !byte    $00,$73,$63,$67,$68,$6E,$6C,$3B,$5D,$7F

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable6
    ;      TAB, Z ,SPACE, V , b , m , , , . , / ,COPY
    !byte  $09,$7A,$20  ,$76,$62,$6D,$2C,$2E,$2F,$87

    !byte $00,$00,$00,$00,$00,$00                       ; [unused]

; ***************************************************************************************
.keyDataTable7
    ;      ESC, f1, f2, f3, f5, f6, f8, f9, \ ,RIGHT
    !byte  $1B,$91,$92,$93,$95,$96,$98,$99,$5C,$89

; ***************************************************************************************
; This code is unused. It reads an entry from 'unknownTable' which has three bytes per
; entry, each entry being a ROM number then an address that we call in that ROM (low byte
; first).
.unknownTable = $db9f
.callROMJMPInstruction = $0244
.callROMAddressLow = $0245
.callROMAddressHigh = $0246
.callROMRegisterA = $0266
.callROMRegisterY = $0267
startUnused
    STY .callROMRegisterY                               ; [unused]
    LDY #9                                              ; [unused]

.callROMRoutine
    STA .callROMRegisterA                               ; [unused]
    LDA .currentlySelectedROM                           ; [unused]
    PHA                                                 ; [unused]
    LDA .unknownTable,Y                                 ; [unused]
    STA .currentlySelectedROM                           ; [unused]
    STA .romSelectRegister                              ; [unused]
    LDA .unknownTable + 1,Y                             ; [unused]
    STA .callROMAddressLow                              ; [unused]
    LDA .unknownTable + 2,Y                             ; [unused]
    STA .callROMAddressHigh                             ; [unused]
    LDY .callROMRegisterY                               ; [unused]
    LDA .callROMRegisterA                               ; [unused]
    JSR .callROMJMPInstruction                          ; [unused]
    STA .callROMRegisterA                               ; [unused]
    PLA                                                 ; [unused]
    STA .currentlySelectedROM                           ; [unused]
    STA .romSelectRegister                              ; [unused]
    LDA .callROMRegisterA                               ; [unused]
    RTS                                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #0                                              ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #3                                              ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #6                                              ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #12                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #15                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #18                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #21                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #24                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #27                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #30                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

    STY .callROMRegisterY                               ; [unused]
    LDY #33                                             ; [unused]
    BNE .callROMRoutine                                 ; [unused]

!text " : OPT MOS70", .charRETURN                       ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :   (c) 1981 ACORN Computers Limited", .charRETURN ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :   BBC Microcomputer Machine Operating System (MOS)", .charRETURN ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :", .charRETURN                                 ; [unused]
!text " :   Change record:", .charRETURN                ; [unused]
!text " :   032 12-Aug-81 PB     Swop '_' (no"          ; [unused]

    !byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00   ; [unused]
    !byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00       ; [unused]
endUnused

; ***************************************************************************************
.setupTapeBaudRateJumper1
    JMP .setupTapeBaudRate                              ;

.setupTapeBaudRateJumper2
    JMP .setupTapeBaudRate                              ;

.updateACIATapeJumper
    JMP .updateACIATape                                 ;

; ***************************************************************************************
    RTS                                                 ; [unused] }
    NOP                                                 ; [unused] } This is an empty entry in the jump table
    NOP                                                 ; [unused] }

; ***************************************************************************************
.selectTapeAndSearchForAnyFileJumper
    JMP .selectTapeAndSearchForAnyFile                  ;

.starOptEntryPointJumper
    JMP .starOptEntryPoint                              ;

.checkForEOFJumper
    JMP .checkForEOF                                    ;

; ***************************************************************************************
;
; Set tape baud
;
; On Entry:
;       Z set for 300 baud
;       Z clear for 1200 baud
; ***************************************************************************************
.setupTapeBaudRate
    LDX #6                                              ;
    TAY                                                 ;
    BEQ +                                               ; if (Z set on entry) then branch
    DEX                                                 ; decrement X
+
    STX .tapeBaudRate                                   ; set current baud rate: X=5 means 1200 baud; X=6 means 300 baud


    ; Reset the file based vectors (FILEV; ARGSV; BGETV; BPUTV; GBPBV; FINDV; FSCV) to default values
    LDX #14                                             ; Loop counter
-
    LDA .tapeFileSystemVectors - 1,X                    ; }
    STA .vectorFILEV - 1,X                              ; } Reset vectors for file related operations
    DEX                                                 ; }
    BNE -                                               ; }

    STX .fsStatusByte                                   ; }
    STX .fsReadProgressState                            ; } zero variables
    STX .tapeSendingFlag                                ; }

    LDA #%10100001                                      ; set default tape OPT
    STA .tapeOptionsByte                                ; LOAD/SAVE: Retry; short messages
                                                        ; SEQUENTIAL: Abort; no messages

    LDA #25                                             ; set interblock gap (2.5 seconds)
    STA .tapeSequentialAccessInterBlockGap              ; and store it
    RTS                                                 ;

; ***************************************************************************************
.tapeFileSystemVectors
    !word .osfileEntryPoint                             ; }
    !word .osargsEntryPoint                             ; }
    !word .osbgetEntryPoint                             ; } default tape file system vector
    !word .osbputEntryPoint                             ; } routines
    !word .osgbpbEntryPoint                             ; }
    !word .osfindEntryPoint                             ; }
    !word .fscEntryPoint                                ; }

; ***************************************************************************************
;
; OSFILE
;
; default handling for OSFILE (for cassette and ROM filing system)
;
; parameter block located by XY
;   0-1     Address of Filename terminated by CR
;   2-4     Load Address of File
;   6-9     Execution Address of File
;   10-13   Start address of data for write operations or length of file for read operations
;   14-17   End address of Data (i.e. byte AFTER last byte to be written) or file attributes
;
; On Entry:
;   Action is determined by value in A
;
;   A=0     Save section of memory as named file, write catalogue information
;   A=1     Write catalogue information for named file             (not supported in this FS)
;   A=2     Write the LOAD       address (only) for the named File (not supported in this FS)
;   A=3     Write the EXECUTION  address (only) for the named File (not supported in this FS)
;   A=4     Write the ATTRIBUTES for the named File                (not supported in this FS)
;   A=5     Read the catalogue information and put file type in A  (not supported in this FS)
;   A=6     Delete the named file                                  (not supported in this FS)
;   A=$FF   Load the named file and read its catalogue information
;
;   XY = address of osfile block
;
; See .saveFileToTape for PDF showing the code path and how bytes are written to tape.
; See .loadFile for PDFs showing the code path and how bytes are read from tape and ROM.
;
; ***************************************************************************************
.osfileEntryPoint
    PHA                                                 ; save action on stack
    STX .osfileBlockAddressLow                          ; osfile block pointer low
    STY .osfileBlockAddressHigh                         ; osfile block pointer high
    LDY #0                                              ; Y=0
    LDA (.osfileBlockAddressLow),Y                      ; get address of filename (low byte)
    TAX                                                 ; store in X
    INY                                                 ; Y=1
    LDA (.osfileBlockAddressLow),Y                      ; get address of filename (high byte)
    TAY                                                 ; store in Y
    JSR .getFilenameFromXY                              ; get filename from buffer at XY
    LDY #2                                              ; Y=2
    LDX #0                                              ;
-
    LDA (.osfileBlockAddressLow),Y                      ; copy parameter block (load and exec
                                                        ; addresses)...
    STA .fsLoadAddressLow,X                             ; ...     to .fsLoadAddressLow
    STA .loadAddressLow,X                               ; ... and to .loadAddressLow
    INX                                                 ;
    INY                                                 ; increment offsets
    CPY #10                                             ; compare with limit
    BNE -                                               ; if (not done yet) then branch (loop back)

    ; get action code, and branch to save if A=0
    PLA                                                 ; get back A (action)
    BNE .loadFile                                       ;
    LDX #0                                              ; loop counter
-
    LDA (.osfileBlockAddressLow),Y                      ; read from .OSFILE parameter block
    STA .tapeSaveStartAddressLow,X                      ; store
    INY                                                 ; data start and data end address
    INX                                                 ;
    CPX #8                                              ; loop for 8 bytes
    BNE -                                               ; if (not finished) then branch (loop back)
    LDA .filenameToSearchFor                            ;
    BNE .validFilenameLocal                             ;
    JMP .badStringErrorLocal                            ;

.validFilenameLocal
    JMP .validFilename                                  ;

; ***************************************************************************************
;
; *LOAD or *RUN a file
;
; See loading.png
;
; On Entry:
;       A=0     *RUN the file
;       A=$FF   *LOAD the named file and read its catalogue information
;
; See LoadFromTape.pdf
; See LoadFromROM.pdf
;
; ***************************************************************************************
.loadFile
    JSR .claimSerialSystemForLoadSave                   ; claim serial system for cassette
                                                        ; we can't use the cassette and the
                                                        ; RS-423 system at the same time
                                                        ; so we select the cassette here.
    LDA .fsExecutionAddressLow                          ; execution address low
    PHA                                                 ; save A on stack
    JSR .searchForFile                                  ; search for file
    PLA                                                 ; get back A
    BEQ .loadOrRun                                      ;
    LDX .fsLoadAddressLow                               ; read load address (low two bytes)
    LDA .fsLoadAddressMid1                              ; }
    CPX #$ff                                            ; }
    BNE .loadOrRunAX                                    ; } check for address $ffff
    CMP #$ff                                            ; }
    BNE .loadOrRunAX                                    ; }
    JMP .BDADDR                                         ; show 'Bad address' error

.loadOrRunAX
    STX .loadAddressLow                                 ;
    STA .loadAddressMid1                                ;
    JMP .loadOrRun                                      ;

-
    JSR .readBlockHeader                                ;

.loadOrRun
    LDA #%00110000                                      ; check bits 4 and 5

    ; See .tapeCurrentOptionsByte for description of the options
    AND .tapeCurrentOptionsByte                         ; check for 'ignore errors'
    BEQ +                                               ; if (ignore errors) then branch
    LDA .checksumIsValidFlag                            ; get checksum result
    BNE .checksumFail                                   ; if (checksum failed) then branch
+
    JSR .setStateForLoadingBlockDataOrReset             ; set state to read block data
.checksumFail
    JSR .loadBlock                                      ; load block from tape
    BNE .retryAfterFailure                              ; if (not found) then branch (retry)
    JSR .saveByteAndIncrementBlockNumbers               ; increment current block number

    BNE .retryAfterFailure                              ;
    JSR .incrementBlockNumbers2
    BIT .fsBlockFlagByte                                ; block flag
    BMI .reachedFinalBlock                              ; if (bit 7 set, i.e. this is the final block) then branch
    LDA .fsBlockLengthLow                               ; }
    CLC                                                 ; }
    ADC .loadAddressLow                                 ; }
    STA .loadAddressLow                                 ; } loadAddress += blockLength
    LDA .fsBlockLengthHigh                              ; }
    ADC .loadAddressMid1                                ; }
    STA .loadAddressMid1                                ; }
    JMP -                                               ;

; ***************************************************************************************
;
; Reached final block
;
; Stores the tape file length (low/high) and two zeros into the OSFILE parameter block.
;
; ***************************************************************************************
.reachedFinalBlock
    JSR .beepCancelAndPrintReturn                       ;
    JMP .CNTAPE                                         ;

.retryAfterFailure
    JSR .searchForSpecifiedBlock                        ;
    BNE .loadOrRun                                      ;

; ***************************************************************************************
;
; FSC - File System Control
;
; Well, that's kind of overstating this routine. You could say this is a forerunner to FSC,
; with only *RUN implemented
;
; ***************************************************************************************
.fscEntryPoint
    JSR .getFilenameFromXY                              ; get filename
    LDA #$ff                                            ; }
    STA .fsExecutionAddressLow                          ; } ?
    JSR .loadFile                                       ; load the file
    JMP (.fsExecutionAddressLow)                        ; execute code

.validFilename
    JSR .claimSerialSystemForLoadSave                   ; claim serial system for load/save on cassette
    LDA #0                                              ; A=0 (meaning read bytes from second processor, aka:
                                                        ;      'multiple single byte transfer: 2nd processor to I/O processor')
    STA .fsBlockNumberLow                               ; zero block number low
    STA .fsBlockNumberHigh                              ; zero block number high
    JSR .promptToRecordOnTape                           ;

.saveToTapeLoop
    LDX #$80                                            ; X=$80 (set last block flag)
    SEC                                                 ;

    ; work out the amount of file remaining to save, to calculate block length
    ; length = end address - current address
    LDA .tapeSaveEndAddressLow                          ;
    SBC .tapeSaveStartAddressLow                        ;
    TAY                                                 ;
    LDA .tapeSaveEndAddressMid1                         ;
    SBC .tapeSaveStartAddressMid1                       ;
    BEQ .skipSettingBlockLength                         ;

    CMP #1                                              ;
    BNE .setFullBlockLength                             ; if (remaining length is not $01XX) then branch
    CPY #0                                              ;
    BEQ .skipSettingBlockLength                         ; if (remaining length is exactly $100) then branch

.setFullBlockLength
    LDA #1                                              ; A = 1 (block length high)
    TAX                                                 ;
    DEX                                                 ; X = 0 (block flag byte)
    TAY                                                 ;
    DEY                                                 ; Y = 0 (block length low)
.skipSettingBlockLength
    STX .fsBlockFlagByte                                ;
    STY .fsBlockLengthLow                               ;
    STA .fsBlockLengthHigh                              ;
    JSR .claimAndSaveABlockToTape                       ;
    BIT .fsBlockFlagByte                                ;
    BMI +                                               ;
    INC .tapeSaveStartAddressMid1                       ;
    INC .fsBlockNumberLow                               ; block number
    BNE .saveToTapeLoop                                 ; if (not 0) then branch (loop back again)
    INC .fsBlockNumberHigh                              ; block number high
    BNE .saveToTapeLoop                                 ; ALWAYS branch (since block number high byte should never wrap around) (loop back again)
+
    JMP .CNTAPE                                         ;

; ***************************************************************************************
.selectTapeAndSearchForAnyFile
    CLI                                                 ; enable interrupts
    LDA .fsStatusByte                                   ;
    ORA #$80                                            ;
    STA .fsStatusByte                                   ; set top bit of status byte (EOF warning given)
    JSR .claimSerialSystemForLoadSave                   ; select tape filing system
    LDA #0                                              ; then start searching for any block
    ; fall through...

; ***************************************************************************************
;
; Search for the next block, checking for Tape or ROM
;
; Used when loading a file or cataloguing a directory.
;
; On Entry:
;       A = $FF - must match the current filename and block number
;       A = $00 - match anything (e.g. for catalogue)
;
; On Exit:
;       V clear if final block
;
; ***************************************************************************************
.searchForBlockCheckFilingSystem
    PHA                                                 ;
    JSR .readBlockHeader                                ;
    LDA .fsBlockNumberLow                               ;
    STA .currentBlockNumberLow                          ;
    LDA .fsBlockNumberHigh                              ;
    STA .currentBlockNumberHigh                         ;
    LDX #$FF                                            ; X=$FF
    STX .fsLastBlockReadFlagsCopy                       ; copy of last read block flag
    INX                                                 ; X=0
    STX .currentBlockHasDataErrorFlag                   ; reset data error flag to zero
    BEQ +                                               ; ALWAYS branch

.resetBlockNumberAndContinue
    LDA #$FF                                            ; A=$FF to reset block number
    STA .fsLastBlockReadFlagsCopy                       ; copy of last read block flag
    STA .fsBlockNumberLow                               ;
    STA .fsBlockNumberHigh                              ;

.searchForBlockLoop
    JSR .incrementBlockNumbers2                         ;
    JSR .readBlockHeader                                ; read block header
+
    PLA                                                 ; get back A (match flag)
    PHA                                                 ; save A on stack
    BEQ .finishReadingBlockAndContinue                  ; if (A == 0, i.e. match anything) then branch
    JSR .compareFilenameToSearchFor                     ;
    BNE .finishReadingBlockAndContinue                  ;
    LDA #%00110000                                      ;
    AND .tapeCurrentOptionsByte                         ; check bits 4/5 of current options,
                                                        ; checking for 'ignore errors'
    BEQ .pullAAndReturn                                 ; if (ignore errors) then branch
    LDA .fsBlockNumberLow                               ; block number
    CMP .nextBlockNumberLow                             ; next block number low

    BNE .finishReadingBlockAndContinue                  ;
    LDA .fsBlockNumberHigh                              ; block number high
    CMP .nextBlockNumberHigh                            ; next block number high
    BNE .finishReadingBlockAndContinue                  ;

.pullAAndReturn
    PLA                                                 ; get back A
    RTS                                                 ;

; ***************************************************************************************
;
; Finish reading block and continue
;
; On Entry:
;       V set means reset file system state (occurs when reading the last block of a ROMFS file)
;
; ***************************************************************************************
.finishReadingBlockAndContinue
    BVC +                                               ; if (V clear) then branch
    JSR .setProgressState4                              ;
+
    JSR .generateScreenReports                          ;
    LDX #0                                              ; X=0
    JSR .checkForChecksumError                          ; report 'Data?' if necessary
-
    JSR .checkForEscapeDuringCassetteOperation          ;
    LDA .fsReadProgressState                            ;
    BNE -                                               ;
    JSR .incrementBlockNumbers                          ;
    BIT .fsBlockFlagByte                                ; block flag
    BMI .resetBlockNumberAndContinue                    ; if (-ve) then branch
    BPL .searchForBlockLoop                             ; ALWAYS branch (loop back and do it again)

; ***************************************************************************************
;
; OSFIND - Open or close a file
;
; When opening a file, this returns a file handle ('channel') number:
;
;   1 = input file on tape
;   2 = output file on tape
;   3 = input file from ROMFS
;
; On Entry:
;       A determines action
;       Y may contain file handle (channel number)
;       or XY is the address of the filename terminated by $0D
;
;       A=0    closes file in channel Y; if Y = 0 closes all files
;       A=$40  open a file for input  (reading) XY points to filename
;       A=$80  open a file for output (writing) XY points to filename
;       A=$C0  open a file for both input and output (random Access)
;              (not supported by TAPE and ROM filing systems)
;
; On Exit:
;       A = file handle of opened file or zero on error
;       X,Y are preserved
;
; ***************************************************************************************
.osfindEntryPoint
    CLD
    STA .fsTempStorageAE                                ; save action in temporary store
    PHA                                                 ; }
    TXA                                                 ; }
    PHA                                                 ; } save A, X and Y on the stack
    TYA                                                 ; }
    PHA                                                 ; }
    LDA #$ff                                            ;
    BIT .fsTempStorageAE                                ; test bits of the action
    BEQ .closeOneFile                                   ; zero indicates close a file

    ; open a file
    PHP                                                 ; push flags
    JSR .getFilenameFromXY                              ; get filename from buffer at XY
    PLP
    BVC .openAFileForOutputOnly                         ; if (bit 6 not set, i.e. it's to be an output only file) then branch

    ; open a file for input
    JSR .openAFileForInput                              ;
    LDA #1                                              ;
    BNE .returnAWithXYRestoredFromStack                 ;

; ***************************************************************************************
;
; Open a file for output
;
; On Entry:
;       X is length of filename
; ***************************************************************************************
.openAFileForOutputOnly
    TXA                                                 ; A=X
    BNE +                                               ; if (filename length is non-zero) then branch
    JMP .badStringErrorLocal                            ; output 'Bad String' error

+
    LDX #0                                              ;
.copyFilenameLoop
    LDA .filenameToSearchFor,X                          ; sought filename
    STA .tapeBlockHeaderStart,X                         ; write it to BPUT file header block
    INX                                                 ;
    CMP #0                                              ;
    BNE .copyFilenameLoop                               ;

    LDA #$FF                                            ; A=$FF
    LDX #7                                              ; X=7
-
    STA .tapeBlockLoadAddressLow,X                      ; set load and exec address to $FF
    DEX                                                 ; X=X-1
    BPL -                                               ;

    LDA #0                                              ;
    LDX #.tapeBlockNumberLow - .tapeBlockHeaderStart    ; X=loop counter from $14 to $1E
-
    STA .tapeBlockHeaderStart,X                         ; BPUT file header block
    INX                                                 ; X=X+1
    CPX #.bgetBufferOffset - .tapeBlockHeaderStart      ; this zeros BPUT block
    BNE -                                               ;

    ROL .tapeBlockLengthHigh                            ;
    LDA .fsStatusByte                                   ; }
    ORA #%00000010                                      ; } set bit 1 of status byte (output file open)
    STA .fsStatusByte                                   ; }
    JSR .claimSerialSystemForLoadSave
    JSR .promptToRecordOnTape
    JSR .cancelTapeOperationAndMotor
    JSR .CNTAPE
    LDA #2                                              ; A=2=file handle of (tape) file open for output

.returnAWithXYRestoredFromStack
    STA .fsTempStorageAE                                ; store value of A temporarily

.restoreRegistersAndExit
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } Restore X and Y registers
    TAX                                                 ; }
    PLA
    LDA .fsTempStorageAE                                ; recall temporary store into A
    RTS                                                 ;

; ***************************************************************************************
.closeOneFile
    TYA                                                 ; A=Y
    BNE +                                               ; if (A is not zero) then branch (close specified file)
    JSR .closeFileThatsOpenForOutput                    ; close file open for output
    JSR .clearInputFileOpenFlag                         ; close file open for input
    LDA #120                                            ;
    JSR .OSBYTE                                         ; close any files being SPOOLed or EXECed
    JMP .restoreRegistersAndExit3                       ;

+
    CPY #2                                              ;
    BEQ .closeOutputFile                                ; if (output file) then branch
    CPY #1                                              ;
    BEQ .closeInputFIle                                 ; if (input file) then branch
    JMP .channelError                                   ;

.closeInputFIle
    JSR .clearInputFileOpenFlag                         ;
    JMP .restoreRegistersAndExit3                       ;

.closeOutputFile
    JSR .closeFileThatsOpenForOutput                    ; close file open for output

.restoreRegistersAndExit3
    PLA                                                 ;
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    PLA                                                 ;
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.openAFileForInput
    LDX #0                                              ; loop counter
-
    LDA .filenameToSearchFor,X                          ;
    STA .bgetFilename,X                                 ; loop to
    INX                                                 ; copy filename to new location
    CMP #0                                              ;
    BNE -                                               ;

    LDA .fsStatusByte                                   ; }
    AND #%11110011                                      ; } clear bits 2 and 3 (CAT status and EOF flags)
    STA .fsStatusByte                                   ; }
    LDA #0                                              ;
    LDX #3                                              ; loop counter
-
    STA .bgetBufferOffset,X                             ; }
    DEX                                                 ; } loop to clear bget buffer offset address
    BPL -                                               ; }
    STA $b5                                             ;
    STA $b6                                             ;
    JSR .claimSerialSystemForSequentialAccess           ;
    JSR .searchForFile                                  ;
    JSR .setLoadAddressAndLoadBlock                     ;
    LDX #7                                              ;
-
    LDA .fsLoadAddressLow,X                             ; }
    STA .bgetLoadAddressLow,X                           ; }
    DEX                                                 ; } copy load and execution addresses
    BPL -                                               ; }

    LDA .fsStatusByte                                   ; } set status byte bits:
    ORA #1                                              ; } set bit 0 (input file open)
    ORA #$20                                            ; } set bit 5 (?)
    STA .fsStatusByte                                   ; }
    RTS                                                 ;

; ***************************************************************************************
.clearInputFileOpenFlag
    LDA .fsStatusByte                                   ;
    LSR                                                 ; clear bit 0 (input file closed)
    ASL                                                 ;
    STA .fsStatusByte                                   ;
.exit30
    RTS                                                 ;

; ***************************************************************************************
.closeFileThatsOpenForOutput
    LDA #%00000010                                      ; }
    AND .fsStatusByte                                   ; } clear all of tape status byte except bit 1
    BEQ .exit30                                         ; if (output file not open) then branch (exit)
    LDA #%11111101                                      ;
    AND .fsStatusByte                                   ;
    STA .fsStatusByte                                   ;
    LDA #0                                              ; A=0
    STA .tapeBlockLengthHigh                            ; setting block length to current value of BPUT offset
    LDA #$80                                            ; A=$80 (last block)
    LDX .bputBufferOffset                               ; get BPUT buffer offset
    STX .tapeBlockLengthLow                             ; setting block length to current value of BPUT offset
    STA .tapeBlockFlagByte                              ; mark current block as last
    JMP .saveSequentialAccessBlockToTape                ;

; ***************************************************************************************
;
; OSBGET - get byte from file
;
; On Entry:
;       Y contains channel number (file handle)
; On Exit:
;       X and Y are preserved
;       C=0 indicates valid character
;       A contains character (or error) A=$FE End Of File
;
; See LoadFromTape.pdf
; See LoadFromROM.pdf
;
; ***************************************************************************************
.osbgetEntryPoint
    CLD                                                 ; clear decimal mode
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } X,Y saved on stack
    PHA                                                 ; }
    DEY                                                 ; check Y == 1 by decrementing and checking
    BNE +                                               ; if (Y != 0) then branch
    AND .fsStatusByte                                   ; check for input file open (check bit 0 of .fsStatusByte)
    BNE ++                                              ;
+
    JMP .channelError                                   ;

    JMP .finish                                         ; [unused]

++
    LDA .fsStatusByte                                   ;
    PHA                                                 ; store A
    AND #8                                              ; check bit 3 (EOF reached)
    BNE .eofError                                       ;
    PLA                                                 ;
    PHA                                                 ; restore A
    AND #4                                              ; check bit 2 (CAT status)
    BEQ +                                               ; CAT not set
    PLA                                                 ; restore A
    ORA #8                                              ; set EOF flag
    STA .fsStatusByte                                   ; store with EOF set
    SEC                                                 ;
    BCS .incrementAndFinish                             ; ALWAYS branch
+
    PLA                                                 ;
    LDX .bgetBufferOffset                               ;
    BNE ++                                              ;
    LDA #%00100000                                      ;
    BIT .fsStatusByte                                   ; check bit 5
    BEQ +                                               ; if (bit 5 is clear) then branch
    EOR .fsStatusByte                                   ; flip bit 5 of status byte
    STA .fsStatusByte                                   ; and store
    JMP ++                                              ;

+
    JSR .claimSerialSystemForSequentialAccess           ;
    JSR .readTapeBlockHeader                            ;
    JSR .bgetReadBlock                                  ;
    LDX #0                                              ;
++
    CLC                                                 ;
    BIT .blockFlagOfCurrentlyResidentBlock              ; block flag of currently resident block
    BPL .continueRead                                   ;

    ; deal with EOF reached
    BVC +                                               ;
    LDA .fsStatusByte                                   ; }
    ORA #%00001100                                      ; } set tape filing system status
    STA .fsStatusByte                                   ; } bits 2,3 (EOF reached, CAT status)
    SEC                                                 ;
    BCS .continueRead                                   ;
+
    INX                                                 ;
    CPX .tapeInputCurrentBlockSizeLow                   ;
    BNE .readFromFSBufferAndContinue                    ; if (not last byte of block) then branch
    LDA .fsStatusByte                                   ; }
    ORA #%00000100                                      ; } set tape filing system status bit 2 (CAT status)
    STA .fsStatusByte                                   ; }

.readFromFSBufferAndContinue
    CLC                                                 ; clear carry flag
    DEX                                                 ; X=X-1

.continueRead
    LDA .tapeOrRS423InputBuffer,X                       ; read byte from cassette buffer
    STA .fsTempStorageAE                                ; store return value temporarily

.incrementAndFinish
    INC .bgetBufferOffset                               ; }
    BNE .finish                                         ; } increment buffer offset
    INC .bgetBufferOffsetHigh                           ; }

.finish
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } restore X and Y registers
    TAX                                                 ; }
    LDA .fsTempStorageAE                                ; recall result
    RTS                                                 ;

; ***************************************************************************************
.eofError
    BRK                                                 ;
    !byte $DF                                           ; error number
    !text "Eof",0                                       ; string and zero terminator

; ***************************************************************************************
;
; OSBPUT - Write a byte to file
;
; This is for the TAPE filing system only. The OS supplies filing system code for TAPE and
; ROM filing systems, and obviously you can't write into the ROM filing system.
;
; On Entry:
;       Y contains channel number (file handle)
;       A contains byte to be written
;
; See .saveFileToTape for PDF showing the code path and how bytes are written to tape.
;
; ***************************************************************************************
.osbputEntryPoint
    CLD                                                 ;
    STA .tapeLastBputValue                              ; store A in temporary store
    TXA                                                 ; }
    PHA                                                 ; } save XY on the stack
    TYA                                                 ; }
    PHA                                                 ; }
    CPY #2                                              ; channel number must be 2
    BNE .channelError                                   ;
    AND .fsStatusByte                                   ;
    BNE +                                               ; if (output file open) then branch

.channelError
    BRK                                                 ;
    !byte $de                                           ;
    !text "Channel", 0                                  ;

+
    LDX .bputBufferOffset                               ; BPUT buffer offset for next byte
    LDA .tapeLastBputValue                              ; get back original value of A
    STA .tapeOrRS423OutputBuffer,X                      ; Write into cassette or RS-423 buffer
    INC .bputBufferOffset                               ;
    BNE +                                               ;
    INC .bputBufferOffsetHigh                           ; increment high byte
    JSR .saveSequentialAccessBlockToTape                ;
+
    PLA                                                 ;
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    LDA .tapeLastBputValue                              ;
    RTS                                                 ;

; ***************************************************************************************
;
; *OPT X,Y
;
; On Entry:
;
;        X,Y
;   *OPT 0,0  restore *OPT default message values
;   *OPT 1,0  turn off filing system messages
;   *OPT 1,1  turn on filing system messages (normal)
;   *OPT 1,2  turn on filing system messages (extended)
;   *OPT 2,0  ignore errors, though messages may be displayed
;   *OPT 2,1  on error prompt for retry
;   *OPT 2,2  on error, abort
;   *OPT 3,n  set interblock gaps to n/10 seconds (for tape SAVE operations)
;             if n>127 then set default value
;
; ***************************************************************************************
.starOptEntryPoint
    TXA                                                 ; A=X
    BEQ .restoreDefaultOPTs                             ; if (*OPT 0) then branch (set defaults)
    CPX #3                                              ;
    BEQ .tapeSetInterblockGap                           ; if (*OPT 3) then branch (to set interblock gap)
    CPY #3                                              ;
    BCS .issueBadCommand                                ; if (Y > 2) then branch ('Bad command' error)
    DEX                                                 ;
    BEQ .opt1                                           ; if (*OPT 1) then branch (set filing system message level)
    DEX                                                 ;
    BEQ .opt2                                           ; if (*OPT 2) then branch (response level to errors)
.issueBadCommand
    JMP .badCommandLocal                                ; issue 'Bad command' error

; ***************************************************************************************
; Set filing system message level
.opt1
    LDA #%00110011                                      ; set lower two bits of each nybble as a MASK
                                                        ; this allows us to set the top two bits of each nybble (message type) and
                                                        ; still keep the existing values for the bottom two bits
                                                        ; of each nybble (ignore/retry/abort)
    INY                                                 ; }
    INY                                                 ; } Y=Y+4 (offset into .tapeOptByteTable)
    INY                                                 ; }
    INY                                                 ; }
    BNE .setOptWithMask                                 ; ALWAYS branch

; ***************************************************************************************
; Set error levels
.opt2
    LDA #%11001100                                      ; setting top two bits of each nybble as a MASK
                                                        ; allows us to set the bottom two bits of each nybble (ignore/retry/abort) and
                                                        ; still keep the existing values for the top two bits
                                                        ; of each nybble (message type)
    INY                                                 ; Y=Y+1 (offset into .tapeOptByteTable)
.setOptWithMask
    AND .tapeOptionsByte                                ; keep bits set in MASK for keeping current tape options
.setOPTValueY
    ORA .tapeOptByteTable,Y                             ; OR with table value to set new options
    STA .tapeOptionsByte                                ; store it
    RTS                                                 ;

; ***************************************************************************************
.tapeSetInterblockGap
    TYA                                                 ; A=Y (interblock gap)
    BNE .useGapDontUseDefaultValue                      ; if (A != 0) then branch (don't use default value)
    LDA #25                                             ; A=25 (2.5 seconds by default)
.useGapDontUseDefaultValue
    STA .tapeSequentialAccessInterBlockGap              ; sequential block gap
    RTS                                                 ;

; ***************************************************************************************
.restoreDefaultOPTs
    TYA                                                 ; Y=A
    BNE .issueBadCommand                                ;
    BEQ .setOPTValueY                                   ; ALWAYS branch

; ***************************************************************************************
;
; Tape opt byte table
;
; Options are stored in top four bits (LOAD/SAVE) and bottom four bits (sequential access)
; See .tapeCurrentOptionsByte.
;
;   bit 0/4 = Abort bit
;   bit 1/5 = Retry bit
;   bit 2/6 } Message type: 00 = no messages
;   bit 3/7 }             : 10 = short messages
;           }             : 11 = long messages
;
; 0000     Ignore errors         no messages
; 0001     Abort if error        no messages
; 0010     Retry after error     no messages
; 1000     Ignore error          short messages
; 1001     Abort if error        short messages
; 1010     Retry after error     short messages
; 1100     Ignore error          long messages
; 1101     Abort if error        long messages
; 1110     Retry after error     long messages
;
; ***************************************************************************************
.tapeOptByteTable
    !byte %10100001                                     ; default value:
                                                        ; LOAD/SAVE: Retry; short messages
                                                        ; SEQUENTIAL: Abort; no messages
    !byte %00000000                                     ; ignore error
    !byte %00100010                                     ; retry if error
    !byte %00010001                                     ; abort if error
    !byte %00000000                                     ; no messages
    !byte %10001000                                     ; short messages
    !byte %11001100                                     ; long messages

; ***************************************************************************************
;
; Copies a four byte value from the tape filing system to zero page or vice versa
;
; On Entry:
;       A = action (4-7):
;           A  Y    X             Action
;
;           4  1    ptr to ZP     read sequential load address
;           4  !=1  ptr to ZP     read load/save load address?
;
;           5  1    ptr to ZP     write sequential load address
;           5  !=1  ptr to ZP     write load/save load address?
;
;           6  1    ptr to ZP     read sequential exec address?
;           6  !=1  ptr to ZP     read load/save exec address?
;
;           7  1    ptr to ZP     write sequential exec address?
;           7  !=1  ptr to ZP     write load/save exec address?
;
;       X = offset into zero page
;       Y = 0 or 1 for file pointer / load address
;
; ***************************************************************************************
.osargsEntryPoint
    STA .fsTempStorageAE                                ; save action in temporary store
    TYA                                                 ; }
    PHA                                                 ; }
    TXA                                                 ; } save X and Y on the stack
    PHA                                                 ; }
    LDA .fsTempStorageAE                                ; recall action
    BEQ .pullXYAndExit                                  ; OSARGS 0 - do nothing
    SEC                                                 ; }
    SBC #4                                              ; }
    BEQ +                                               ; } if (action is not in 4-8 range) then branch (exit)
    BCC .pullXYAndExit                                  ; } subtract 4 from action
    CMP #4                                              ; }
    BCS .pullXYAndExit                                  ; }

+
    LSR                                                 ; A is now in range 0-3
    ASL                                                 ; carry = bit 0; bit 0 = 0
    TAX                                                 ; X = A (0 or 2)
    DEY                                                 ; Y = Y - 1
    BEQ +                                               ; if (Y = 0) then branch
    INX                                                 ; X = X + 1 (X is 1 or 3)
+
    LDA .fsAddresses,X                                  ;
    STA .osfileBlockAddressLow                          ; set low byte of address
    LDA #$02                                            ;
    STA .osfileBlockAddressHigh                         ; set high byte of address to $02
    PLA                                                 ;
    PHA                                                 ;
    TAX                                                 ;
    LDY #0                                              ; loop counter
    ROR .fsTempStorageAE                                ;
    BCS .writeFSAddress                                 ; if (action is an odd number) then branch

    ; loop to read four byte address
-
    LDA (.osfileBlockAddressLow),Y                      ; read byte
    STA $00,X                                           ; store byte
    INX                                                 ;
    INY                                                 ;
    CPY #4                                              ;
    BNE -                                               ; if (Y != 4) then branch (loop back)

    BEQ .pullXYAndExit                                  ; ALWAYS branch

; ***************************************************************************************
.writeFSAddress
    LDA $00,X                                           ; read byte from ZP
    STA (.osfileBlockAddressLow),Y                      ; write byte to FS address
    INX                                                 ;
    INY                                                 ;
    CPY #4                                              ; loop four times
    BNE .writeFSAddress                                 ; if (not done yet) then branch (loop back)

.pullXYAndExit
    PLA                                                 ; }
    TAX                                                 ; }
    PLA                                                 ; } Restore X and Y from the stack
    TAY                                                 ; }
    RTS                                                 ;

; ***************************************************************************************
.fsAddresses
    !byte <.bgetLoadAddressLow                          ;
    !byte <.tapeBlockLoadAddressLow                     ;
    !byte <.bgetExecutableAddressLow                    ;
    !byte <.tapeBlockExecutableAddressLow               ;

; ***************************************************************************************
.updateACIATape
    ; deal with reading or writing to tape
    DEC .fsGotACharacterToReadOrWriteFlag               ; Used when writing to tape,
                                                        ; to decrement the value from zero to
                                                        ; 255 indicating the byte has been
                                                        ; written (which happens below)
    LDA .acia6850StatusRegister                         ; ACIA status register
    PHA                                                 ; save A on stack
    AND #2                                              ; clear all but bit 1
    BEQ .readByteFromTape                               ; if (transmit data register full,
                                                        ; i.e. not ready to send) then branch
                                                        ; (read from tape)
    LDY .tapeSendingFlag                                ; check we are sending to tape

    BNE .writeByteToTape                                ; if (sending to tape) then branch
                                                        ; (read from tape)

.readByteFromTape
    LDX .fsReadProgressState                            ; Get current read state
    LDA .tapeFunctionTable,X                            ; Look up function table (low)
    STA .fsTempStorageLow                               ; and store in temporary location
    LDA .tapeFunctionTable + 1,X                        ; same for high byte too
    STA .fsTempStorage                                  ;
    LDY .acia6850DataRegister                           ;
    PLA                                                 ;
    AND #4                                              ;
    JMP (.fsTempStorageLow)                             ; call routine to update state

; ***************************************************************************************
.tapeFunctionTable
    !word .exit9b                                       ;
    !word .updateTapeReadState1                         ;
    !word .updateTapeReadState2                         ;
    !word .updateTapeReadState3                         ;
    !word .updateTapeReadState4                         ;
    !word .updateTapeReadState5                         ;

; ***************************************************************************************
.writeByteToTape
    ; send a byte to tape
    PLA                                                 ; get back A
    LDA .fsCharacterJustReadOrCharToWrite               ; get character to send
    STA .acia6850DataRegister                           ; ACIA transmit data register
    RTS                                                 ;

.updateTapeReadState1
    BEQ .exit9b                                         ;
    LDY #4                                              ;
    BNE .storeTapeProgress                              ;
.updateTapeReadState2
    BNE .exit9b                                         ;
    TYA                                                 ; A=Y=byte read
    JSR .zeroChecksumAndFSFlag                          ;
    LDY #6                                              ; Y=6
    CMP #.fsSynchronisationByte                         ; check for the sync byte $2A
    BEQ .storeTapeProgress                              ; if (found sync byte) then branch
                                                        ; (store state and return)

    ; sync byte not found, revert back to progress state 2
    JSR .flipRelayOffAndOnThenSetToReadFromTape         ; control cassette system
    LDY #2                                              ; Y=2
    BNE .storeTapeProgress                              ; ALWAYS branch

.updateTapeReadState3
    BNE +                                               ;
    STY .fsCharacterJustReadOrCharToWrite               ;
    JMP .exit9b                                         ;

+
    LDA #$80                                            ;
    STA .fsGotACharacterToReadOrWriteFlag               ;
    BNE .exit9b                                         ;
.updateTapeReadState4
    BNE ++                                              ;
    JSR .updateCRCY                                     ;
    LDY .fsTempStorageAE                                ;
    INC .fsTempStorageAE                                ;
    BIT .fsCharacterJustReadOrCharToWrite               ;
    BMI +                                               ;
    STA (.loadAddressLow),Y                             ;
+
    INY                                                 ;
    CPY .fsBlockLengthLow                               ;
    BNE .exit9b                                         ;
    LDA #$01                                            ;
    STA .fsTempStorageAE                                ;
    LDY #10                                             ;
    BNE .storeTapeProgress                              ;
.updateTapeReadState5
    JSR .updateCRCY                                     ;
    DEC .fsTempStorageAE                                ;
    BPL .exit9b                                         ;
++
    JSR .resetACIA                                      ;
    LDY #0                                              ;
.storeTapeProgress
    STY .fsReadProgressState                            ;
.exit9b
    RTS                                                 ;

; ***************************************************************************************
.osgbpbEntryPoint
    STX .tempStoreB7                                    ;
    TAX                                                 ;
    PHP                                                 ;
-
    LDX .tempStoreB7                                    ;
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    INX                                                 ;
    JSR .incrementFourByteValue                         ;
    BCC .pullAndExit9c                                  ;
    JSR .incrementFourByteValue                         ;
    PLP                                                 ;
    PHP                                                 ;
    BEQ +                                               ;
    JSR .osbgetEntryPoint                               ;
    BCS .exit9c                                         ;
    LDX .tempStoreB7                                    ;
    STA ($00,X)                                         ;
    BCC -                                               ;

+
    LDA ($00,X)                                         ;
    JSR .osbputEntryPoint                               ;
    JMP -                                               ;

; ***************************************************************************************
.incrementFourByteValue
    SEC                                                 ;
    LDA #7                                              ; loop shift counter
-
    INC $00,X                                           ; increment flag per buffer
    BNE +                                               ; if (flag set) then branch (loop done)
    INX                                                 ;
    LSR                                                 ; update loop counter (7->3->1->0)
    BCS -                                               ; if (loop counter not done) then branch (loop back)
+
    LDX .tempStoreB7                                    ;
    RTS                                                 ;

.pullAndExit9c
    PLP                                                 ;
.exit9c
    RTS                                                 ;

; ***************************************************************************************
.checkForEOF
    TXA                                                 ; A = X = channel number (1 = input file; 2 = output file)
    DEX                                                 ;
    BEQ +                                               ; if (channel number == 1) then branch
    DEX                                                 ;
    BNE .channelErrorLocal                              ; if (channel number != 2) then branch
+
    AND .fsStatusByte                                   ; check input / output file is open
    BNE +                                               ; if (file open) then branch

.channelErrorLocal
    JMP .channelError                                   ;

+
    LDA .fsStatusByte                                   ;
    AND #%00000100                                      ; clear EOF flag
    TAX                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.searchForFile
    LDA #0                                              ; }
    STA .currentBlockNumberLow                          ; } reset current block number
    STA .currentBlockNumberHigh                         ; }

.searchForSpecifiedBlock
    LDA .currentBlockNumberLow                          ; current block number (low byte)
    PHA                                                 ; save A on stack
    STA .nextBlockNumberLow                             ; save as next block number (low byte)
    LDA .currentBlockNumberHigh                         ; current block number (high byte)
    PHA                                                 ; save A on stack
    STA .nextBlockNumberHigh                            ; save as next block number (high byte)

    JSR .safePrintFollowingMessage                      ; print message following call
    !text "Searching"                                   ;
    !text .charRETURN,0                                 ;

    LDA #$FF                                            ; A=$FF (Meaning 'Must match filename
                                                        ; and block number')
    JSR .searchForBlockCheckFilingSystem                ; read data from tape filing system/ROMFS
    PLA                                                 ; get back A
    STA .currentBlockNumberHigh                         ; current block number high
    PLA                                                 ; get back A
    STA .currentBlockNumberLow                          ; current block number low
    LDA .nextBlockNumberLow                             ; next block number low
    ORA .nextBlockNumberLow                             ; [BUG: Should be next block number high!]
    BNE +                                               ;
    STA .currentBlockNumberLow                          ; zero current block number low
    STA .currentBlockNumberHigh                         ; zero current block number high

    LDX #(.fsFilename-1) - .vduVariablesStart           ;
    JSR .copyToSoughtFilename                           ; copy filename from .fsFilename to .filenameToSearchFor
+
    LDY #$FF                                            ; Y=$FF
    RTS                                                 ;

; ***************************************************************************************
.bgetReadBlock
    LDY #<.bgetBufferOffset                             ;
    LDX #$dc                                            ;
    JSR .copyToSoughtFilenamePreservingY                ;
    JSR .startOfBlock                                   ;
    ; fall through...

; ***************************************************************************************
;
; Set Load Address and Load Block
;
; ***************************************************************************************
.setLoadAddressAndLoadBlock
    LDA .nextBGETBlockLow                               ; Expected BGET file block number low
    STA .currentBlockNumberLow                          ; current block number low
    LDA .nextBGETBlockHigh                              ; expected BGET file block number high
    STA .currentBlockNumberHigh                         ; current block number high
    LDA #<.tapeOrRS423InputBuffer                       ; }
    STA .loadAddressLow                                 ; }
    LDA #>.tapeOrRS423InputBuffer                       ; }
    STA .loadAddressMid1                                ; } set load address to $FFFF0A00
    JSR .setStateForLoadingBlockDataOrReset             ; set progress to read block data
    JSR .loadBlock                                      ; load block from tape
    BNE .searchForBlock                                 ; if (non zero) then branch
    JSR .saveByteAndIncrementBlockNumbers               ;
    BNE .searchForBlock                                 ;
    JSR .incrementBlockNumbers2                         ;
    LDA .currentBlockNumberLow                          ;
    STA $b5                                             ;
    LDA .currentBlockNumberHigh                         ;
    STA $b6                                             ;
    LDA .fsBlockLengthLow                               ;
    STA .tapeInputCurrentBlockSizeLow                   ;
    ORA .fsBlockLengthHigh                              ;
    PHP                                                 ;
    LDA .fsBlockFlagByte                                ;
    BPL +                                               ;
    PHA                                                 ;
    JSR .printReturnSafely                              ;
    PLA                                                 ;
+
    PLP                                                 ;
    BNE +                                               ;
    ORA #$40                                            ;
+
    STA .blockFlagOfCurrentlyResidentBlock              ;
    JSR .cancelTapeOperationAndMotor                    ;
    JMP .CNTAPE                                         ;

; ***************************************************************************************
.searchForBlock
    JSR .searchForSpecifiedBlock                        ; search for a specified block
    BNE .setLoadAddressAndLoadBlock                     ;
.readBlockHeader
    JSR .readTapeBlockHeader                            ;

.startOfBlock
    LDY #0                                              ;
    STY .tapeChecksumLow                                ;
    STY .tapeChecksumHigh                               ; zero checksum bytes

    ; read filename
-
    JSR .readByteFromTape1                              ; get character from file and do CRC
    BVC .reachedEndOfHeader                             ; if (V clear) then branch
    CMP #.charRETURN                                    ;
    BNE +                                               ;
    LDA #0                                              ;
+
    STA .fsFilename,Y                                   ; store
    CMP #0                                              ;
    BEQ +                                               ; or if A=0 then branch
    INY                                                 ; Y=Y+1
    CPY #11                                             ; check Y against 11
    BNE -                                               ; if (Y != 11) then branch (go back for next character)
    DEY                                                 ; Y=10

+
    ; read rest of header
    LDX #12                                             ; X=loop counter (from 12 to 31) to read rest of header
-
    JSR .readByteFromTape1                              ; get character from file and do CRC
    BVC .reachedEndOfHeader                             ; if (V clear) then branch
    STA .fsFilename,X                                   ; store byte
    INX                                                 ; X=X+1
    CPX #$1F                                            ; check X for 31
    BNE -                                               ; if (X is not 31) then loop back

.reachedEndOfHeader
    LDA #0                                              ; A=0
    STA .fsFilename,Y                                   ; store terminator
    LDA .tapeChecksumLow                                ; }
    ORA .tapeChecksumHigh                               ; } Check if the CRC value is zero
    STA .checksumIsValidFlag                            ; Checksum result is zero if valid

    LDA #0                                              ;
    STA .tapeChecksumLow                                ;
    STA .tapeChecksumHigh                               ; reset checksum
    STA .fsReadProgressState                            ; reset progress (Y=0)
    TYA                                                 ; A=X=length of filename
    BEQ .readBlockHeader                                ;
    LDY #0                                              ;
    RTS                                                 ;

.readByteFromTape1
    JSR .saveByteAToTapeInternal                        ;
    LDA .fsCharacterJustReadOrCharToWrite               ;
    JMP .updateCRC                                      ;

; ***************************************************************************************
.updateCRCY
    TYA                                                 ;
    ; fall through...

; ***************************************************************************************
;
; Update CRC
;
; A cyclic redundancy check is updated one byte at a time.
;
; Pseudo-code is as follows. HL = high and low bytes of the CRC. A = byte on input.
;
;   H = A EOR H
;   FOR X = 1 TO 8
;       Carry=bit 7 of H
;       IF (Carry = 1) THEN HL=HL EOR $0810
;       HL=(HL*2 + Carry) AND $FFFF
;   NEXT X
;
; On Entry:
;       A = byte just written or read
;       Preserves A, X and Y
;
; ***************************************************************************************
.updateCRC
    PHP                                                 ; save flags on stack
    PHA                                                 ; save A on stack

.updateCRCInternal
    SEC                                                 ; } Set top bit of CRC bit counter
    ROR .tapeCRCBitCounter                              ; } This acts as a loop counter

    EOR .tapeChecksumHigh                               ; }
    STA .tapeChecksumHigh                               ; } H = A EOR H
-
    LDA .tapeChecksumHigh                               ;
    ROL                                                 ; Carry = bit 7 (A = A * 2)
    BCC +                                               ;
    ROR                                                 ; A = A / 2 = H

    EOR #$08                                            ; }
    STA .tapeChecksumHigh                               ; }
    LDA .tapeChecksumLow                                ; } HL=HL EOR $0810
    EOR #$10                                            ; }
    STA .tapeChecksumLow                                ; }
    SEC                                                 ; set carry flag

+
    ROL .tapeChecksumLow                                ; }
    ROL .tapeChecksumHigh                               ; } HL=(HL*2 + Carry) AND &FFFF

    LSR .tapeCRCBitCounter                              ; shift loop counter right
    BNE -                                               ; if (eight bits not processed) then branch

    PLA                                                 ; get back A
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
.readTapeBlockHeader
    LDX #$ff                                            ;
    JSR .osbyte145Jumper                                ;
    JSR .set300BaudMotorOn                              ;
    LDA #2                                              ; start the read progress state
    STA .fsReadProgressState                            ;
    JSR .flipRelayOffAndOnThenSetToReadFromTape         ; control serial system

-
    JSR .checkForEscapeDuringCassetteOperation          ; confirm ESC not set and tape filing system not executing
    LDA #6                                              ;
    CMP .fsReadProgressState                            ; progress state
    BNE -                                               ; back until .fsReadProgressState=3
    RTS                                                 ;

; ***************************************************************************************
.setProgressState4
    LDA #$FF                                            ; A=$FF (searching)
    BNE .setCharAThenProgressState4OrReset              ; ALWAYS branch

; ***************************************************************************************
;
; Set state ready for loading block data (or reset)
;
; Set the character just read to zero, and the progress state to 4.
; Together this signifies we are ready to load block data.
; If V is clear, then we instead reset to progress state zero.
;
; On Entry:
;       If V clear, then reset to state zero
;       otherwise set to state 4, ready to read the block data bytes
;
; ***************************************************************************************
.setStateForLoadingBlockDataOrReset
    LDA #0                                              ; A=0
    ; fall through...

; ***************************************************************************************
;
; Set state ready for loading block data or searching (or reset state)
;
; Store the character just read. If all is well (V set and non-zero block length), then
; progress state is set to 4. Otherwise we revert back to progress state zero.
;
; On Entry:
;       A is $FF when searching, $00 when loading
;       V clear means reset progress state to zero
;       .fsBlockLengthLow/High holds the block length
;
; ***************************************************************************************
.setCharAThenProgressState4OrReset
    STA .fsCharacterJustReadOrCharToWrite               ; store character just read
    LDX #0                                              ; X=0
    STX .fsTempStorageAE                                ;
    BVC +                                               ;
    LDA .fsBlockLengthLow                               ; block length
    ORA .fsBlockLengthHigh                              ; block length high
    BEQ +                                               ; if (block length is zero) then branch

    LDX #8                                              ;
+
    STX .fsReadProgressState                            ; save progress state
    RTS                                                 ;

; ***************************************************************************************
; Sequential access writes bytes instead of files. (As used by BGET and BPUT in BASIC).
.saveSequentialAccessBlockToTape
    JSR .readKeyboardBuffer                             ;
    JSR .claimSerialSystemForSequentialAccess           ;

    LDA #$00                                            ; }
    STA .tapeSaveStartAddressLow                        ; }
    LDA #$09                                            ; } save start address = $0900
    STA .tapeSaveStartAddressMid1                       ; }

    LDX #17                                             ; loop counter
-
    LDA .tapeBlockLoadAddressLow,X                      ; }
    STA .fsLoadAddressLow,X                             ; } copy header block
    DEX                                                 ; X=X-1
    BPL -                                               ; loop back until X=255

    LDY #$cd                                            ;
    LDX #(.tapeBlockFilename-1) - .page2Start           ;
    JSR .copyToSoughtFilenamePreservingY                ;
    JSR .set300BaudMotorOn                              ;
    JSR .saveABlockToTape                               ;
    INC .tapeBlockNumberLow                             ;
    JSR .cancelTapeOperationAndMotor                    ;
    JMP .CNTAPE                                         ;

; ***************************************************************************************
.claimAndSaveABlockToTape
    JSR .claimSerialSystemForLoadSave                   ;
    ; fall through...

; ***************************************************************************************
;
; Save a block to tape
;
; When saving to tape, we record a five second delay before the first block, then a delay
; specified by the interblock gap for all subsequent blocks. After all blocks are recorded
; there is a further five second delay.
;
; ***************************************************************************************
.saveABlockToTape
    LDA .fsBlockNumberLow                               ; block number
    ORA .fsBlockNumberHigh                              ; block number high
    BNE .waitForInterblockGap                           ; if (block number is not zero) then branch
    JSR .waitFiveSeconds                                ; generate a 5 second delay
    BEQ +                                               ; ALWAYS branch

.waitForInterblockGap
    JSR .generateInterBlockGapDelay                     ;

+
    LDA #.fsSynchronisationByte                         ; A=synchronisation byte (byte to save to tape)
    STA .fsCharacterJustReadOrCharToWrite               ; store character to write
    JSR .zeroChecksumAndFSFlag                          ; initialise checksum and file system buffer flag
    STY .currentBlockHasDataErrorFlag                   ;
    JSR .activateRequestToSend                          ;
    JSR .saveByteAToTapeInternal                        ;
-
    LDA .filenameToSearchFor,Y                          ; move sought filename
    STA .fsFilename,Y                                   ; into filename block
    JSR .saveByteAToTapeAndUpdateCRC                    ;
    LDA .filenameToSearchFor,Y                          ;
    INY                                                 ;
    CMP #0                                              ;
    BNE -                                               ;

    ; save rest of header:
    ;   load address      (4 bytes)
    ;   execution address (4 bytes)
    ;   block number      (2 bytes)
    ;   block length      (2 bytes)
    ;   block flag byte   (1 byte)
    ;   spare bytes       (4 bytes)
    LDX #.fsLoadAddressLow - .fsFilename                ; X=offset to load address
-
    LDA .fsFilename,X                                   ; get filename byte
    JSR .saveByteAToTapeAndUpdateCRC                    ; transfer byte to tape filing system and do CRC
    INX                                                 ; X=X+1
    CPX #.fsChecksumLow - .fsFilename                   ; until X reaches the end of the header block (just before the start of the two checksum bytes)
    BNE -                                               ;

    JSR .saveChecksumToTape                             ; save checksum to TAPE reset buffer flag
    LDA .fsBlockLengthLow                               ; block length
    ORA .fsBlockLengthHigh                              ; block length high
    BEQ .saveFinalTwoBytes                              ; if (block length is zero) then branch

    LDY #0                                              ; Y=0
    STY .osfileBlockAddressLow                          ;
    STY .osfileBlockAddressHigh                         ;
-
    LDA (.tapeSaveStartAddressLow),Y                    ; get a data byte to save
    JSR .saveByteAToTapeAndUpdateCRC                    ; transfer byte to tape filing system and do CRC
    INY                                                 ; Y=Y+1
    CPY .fsBlockLengthLow                               ; check block length
    BNE -                                               ; if (block not done yet) then branch (loop back)

    JSR .saveChecksumToTape                             ; save checksum to TAPE

.saveFinalTwoBytes
    JSR .saveByteAToTapeInternal                        ;
    INC .fsGotACharacterToReadOrWriteFlag               ;
    JSR .saveByteAToTapeInternal                        ;
    JSR .resetACIA                                      ;

    LDA #1                                              ; A=1
    JSR .generateDelay                                  ; generate 0.1 second delay
    JSR .displayProgress                                ; PRINT filename (and address if reqd)
    JSR .clearCarryAndExit2                             ;
    BIT .fsBlockFlagByte                                ; block flag
    BPL +                                               ; if (this is NOT last block) then branch
    JSR .waitFiveSeconds                                ; generate a 5 second delay
    JMP .beepCancelAndPrintReturn                       ; sound bell and cancel

+
    JMP .checkForEscapeDuringCassetteOperation          ;

; ***************************************************************************************
.saveByteAToTapeAndUpdateCRC
    JSR .saveByteAToTape                                ; save byte
    PHP                                                 ;
    PHA                                                 ;
    JMP .updateCRCInternal                              ; update CRC

; ***************************************************************************************
;
; Save a byte to tape
;
; On Entry:
;       A = character to write
; On Exit:
;       A is preserved
;
; ***************************************************************************************
.saveByteAToTape
    PHA                                                 ;
    STA .fsCharacterJustReadOrCharToWrite               ; store character to write
    JSR .saveByteAToTapeInternal                        ;
    PLA                                                 ;
    RTS                                                 ;

.shouldPrintMessage
    LDA #$80                                            ;
    AND .fsStatusByte                                   ; check top bit
    BNE +                                               ; if (catalogue bit set) then branch (exit)
    LDA #%10001000                                      ; A=%10001000 (these are the bits
                                                        ; set if a message is required)
    AND .tapeCurrentOptionsByte                         ; AND with filing system options (short/long message bits)
+
    RTS                                                 ;

; ***************************************************************************************
.waitFiveSeconds
    JSR .resetACIA
    LDA #50                                             ; Set A for 50 tenths of a second
                                                        ; delay
    JSR .generateDelay                                  ; generate delay
                                                        ; 100ms * A (= 5 seconds)
    JMP .checkForEscapeDuringCassetteOperation          ;

; ***************************************************************************************
;
; Delay for the (temporary) interblock gap time
;
; ***************************************************************************************
.generateInterBlockGapDelay
    LDA .tapeInterBlockGap                              ; get current interblock flag
    ; fall through...

; ***************************************************************************************
;
; Wait for A/10 seconds, or until ESCAPE is pressed
;
; On Entry:
;       A = amount of delay in 10ths of a second
;
; ***************************************************************************************
.generateDelay
    LDX #5                                              ; X=loop counter

.delayLoop
    STA .verticalSyncCounter                            ; set vsync counter
-
    BIT .verticalSyncCounter                            ; check vsync counter (decremented 50 times a second)
    BPL -                                               ; if (not negative) then branch back
    DEX                                                 ; X--
    BNE .delayLoop                                      ;
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 20: Filing System Messaging and Error Reporting
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.generateScreenReports
    LDA .fsBlockNumberLow                               ; block number low
    ORA .fsBlockNumberHigh                              ; block number high
    BEQ .newlineAndContinue                             ; if (block number is zero) then branch (print newline and continue)
    BIT .fsLastBlockReadFlagsCopy                       ; copy of last read block flags
    BMI .newlineAndContinue                             ;
    LDY #$14                                            ;
    JSR .compareFilenames                               ;
    BEQ .updateBlockFlagAndDisplayProgress              ;

.newlineAndContinue
    JSR .printReturnSafely                              ;
    ; fall through...

; ***************************************************************************************
;
; Display progress
;
; ***************************************************************************************
.updateBlockFlagAndDisplayProgress
    LDX #0                                              ; X=0
    STX .currentBlockHasDataErrorFlag                   ; reset data error flag to zero
    DEX                                                 ; X=255 (lpop counter)
-
    INX                                                 ; X++
    LDA .fsFilename,X                                   ;
    STA $0314,X                                         ; copy filename
    BNE -                                               ; if (terminator not found, loop)

.displayProgress
    JSR .shouldPrintMessage                             ;
    BNE +                                               ;
    RTS                                                 ;

+
    ; print just a carriage return, to return text cursor to the start of the current line
    ; (without emitting a linefeed to go down to the next line)
    LDA #.charRETURN                                    ; carriage return
    JSR .OSWRCH                                         ; print it (note no linefeed; so text will overwrite any previous block's message)
    LDY #0                                              ; loop counter

.filenameLoop
    LDA .fsFilename,Y                                   ; get byte from filename (zero terminated)
    BEQ .filenameDone                                   ; if (filename is ended) then branch
    BMI .displayQuestionMark                            ; top bit set characters are shown as '?'
    CMP #.charDELETE                                    ;
    BEQ .displayQuestionMark                            ; DELETE is shown as '?'
    CMP #.charRETURN                                    ;
    BEQ .filenameDone                                   ; RETURN also indicates the end of the filename
    CMP #.charSPACE - 1                                 ;
    BCS .displayPrintableCharacter                      ; if (control code NOT found) then branch (show character)
.displayQuestionMark
    LDA #.charQUESTIONMARK                              ; A='?'
.displayPrintableCharacter
    JSR .OSWRCH                                         ; and print it
    INY                                                 ; Y=Y+1
    BNE .filenameLoop                                   ; ALWAYS branch (back to get rest of filename)
    ; fall through...

; ***************************************************************************************
;
; Display Progress (post-filename)
;
; ***************************************************************************************
.filenameDone
    JSR .printSpace                                     ; print a space
    INY                                                 ; Y=Y+1
    CPY #11                                             ;
    BCC .filenameDone                                   ; if (Y<11) then branch (loop again to fill out filename with spaces)

    ; print block number
    LDA .fsBlockNumberLow                               ; block number
    JSR .printHexByte
    BIT .fsBlockFlagByte                                ; block flag byte (bit 7 is 'last block' flag)
    BMI +                                               ; if (last block) then branch
    RTS                                                 ;

+
    LDA .fsBlockNumberLow                               ; block number
    CLC                                                 ;
    ADC .fsBlockLengthHigh                              ; add block length high byte (to get total file length high)
    JSR .printSpaceThenHexByte                          ; print space then hex byte as ASCII
    LDA .fsBlockLengthLow                               ; get block length (low byte)
    JSR .printHexByte                                   ; print hex byte as ASCII
    BIT .tapeCurrentOptionsByte                         ; current options
    BVS +                                               ;
    RTS                                                 ;

+
    ; print four spaces
    LDX #4                                              ; X=loop counter
-
    JSR .printSpace                                     ; print a space
    DEX                                                 ;
    BNE -                                               ; loop to print 4 spaces

    ; display load address, a space, then executable address
    LDX #.fsLoadAddressHigh - .fsFilename               ; X = offset to load address (high byte)
    JSR .printFourByteAddress                           ; print 4 bytes from tape filing system block header
    JSR .printSpace                                     ; print a space
    LDX #.fsExecutionAddressHigh - .fsFilename          ; X = offset to execution address (high byte)
    ; fall through...

; ***************************************************************************************
;
; Print four bytes from tape filing system block header
;
; On Entry:
;       X is offset to high byte of address from .fsFilename
;
; ***************************************************************************************
.printFourByteAddress
    LDY #4                                              ;
-
    LDA .fsFilename,X                                   ; block header
    JSR .printHexByte                                   ; print ASCII equivalent of hex byte
    DEX                                                 ; X=X-1
    DEY                                                 ; Y=Y-1
    BNE -                                               ;
    RTS                                                 ;

.beepCancelAndPrintReturn
    JSR .beepAndCancelTapeOperation                     ; bell, reset ACIA and motor

.printReturnSafely
    BIT .currentBlockHasDataErrorFlag                   ; current block flag
    BMI .exit28                                         ;

.saveFlagsPrintCR
    JSR .safePrintFollowingMessage                      ; print message following call (in this case a newline character)
    !byte .charRETURN, 0                                ; message
.exit28
    RTS                                                 ;

; ***************************************************************************************
.promptToRecordOnTape
    JSR .set300BaudMotorOn                              ;
    JSR .readKeyboardBuffer                             ;
    JSR .shouldPrintMessage                             ; check if free to print message
    BNE +                                               ; if (free to print message) then branch
    RTS                                                 ;

+
    JSR .safePrintFollowingMessage                      ; print message following call
    !text "RECORD then RETURN"                          ; message
    !byte 0                                             ; terminator

-
    JSR .checkForEscapeDuringCassetteOperation          ; check for ESCAPE
    JSR .OSRDCH                                         ; wait for keypress
    CMP #.charRETURN                                    ; check for the RETURN key
    BNE -                                               ; if (not RETURN key) then branch (loop back to test again)
    JMP .OSNEWL                                         ; output Carriage RETURN and LINE FEED then return

; ***************************************************************************************
.saveByteAToTapeInternal
    LDA #12                                             ;
    STA .verticalSyncCounter                            ; set to 12 vsyncs
-
    BIT .fsGotACharacterToReadOrWriteFlag               ;
    BMI +                                               ; if (byte written) then branch
    BIT .verticalSyncCounter                            ; check vertical sync counter
    BPL -                                               ; if (not timeout) then branch (loop back)
    JSR .checkForEscapeDuringCassetteOperation          ;
    BMI .saveByteAToTapeInternal                        ;

+
    ; byte is now read / written
    PHP                                                 ; store flags
    LDA #0                                              ; A=0
    STA .fsGotACharacterToReadOrWriteFlag               ; clear flag, we no longer have a byte
    PLP                                                 ; recall flags
    RTS                                                 ;

; ***************************************************************************************
.saveByteAndWait
    JSR .saveByteAToTapeInternal                        ;
    LDA .fsReadProgressState                            ;
    BNE .saveByteAndWait                                ;
    RTS

; ***************************************************************************************
.claimSerialSystemForLoadSave
    LDA .tapeOptionsByte                                ; get cassette filing system options byte
                                                        ; high nybble used for LOAD and SAVE operations
                                                        ; low nybble used for sequential access
                                                        ; See .tapeOptByteTable

    AND #%11110000                                      ; clear low nybble
    STA .tapeCurrentOptionsByte                         ; store as current OPTions
    LDA #6                                              ; set current interblock gap to 6/10ths of a second

.claimSerialSystem
    STA .tapeInterBlockGap                              ; set current interblock gap
    JMP .RSTIME                                         ;

; ***************************************************************************************
.claimSerialSystemForSequentialAccess
    LDA .tapeOptionsByte                                ; get cassette filing system options byte
                                                        ; high nybble used for LOAD and SAVE operations
                                                        ; low nybble used for sequential access
                                                        ; See .tapeOptByteTable

    ASL                                                 ; }
    ASL                                                 ; }
    ASL                                                 ; } move low nybble into high nybble
    ASL                                                 ; }
    STA .tapeCurrentOptionsByte                         ; save current OPTions
    LDA .tapeSequentialAccessInterBlockGap              ; get sequential block gap (>0)
    BNE .claimSerialSystem                              ; ALWAYS branch

; ***************************************************************************************
.printSpace
    LDA #.charSPACE                                     ; A=' '
    JMP .OSWRCH                                         ; print it

; ***************************************************************************************
;
; Copy filename from XY
;
; On Entry:
;       X and Y     source filename address (Low/High)
; On Exit:
;       A = 0
;       The filename is copied into the buffer at .filenameToSearchFor
; ***************************************************************************************
.getFilenameFromXY
    SEI                                                 ;
    STX .stringInputBufferAddressLow                    ; OS filename/command line pointer
    STY .stringInputBufferAddressHigh                   ; OS filename/command line pointer
    LDY #0                                              ; Y=0
    JSR .GSINIT                                         ; initialise string
    LDX #0                                              ; X=0
-
    JSR .GSREAD                                         ; GSREAD call
    BCS .terminateFilename                              ; if (end of character string) then branch
    BEQ .badStringErrorLocal                            ; if (zero found) then break ('Bad string' error)
    STA .filenameToSearchFor,X                          ; store character in tape filename area
    INX                                                 ; X=X+1
    CPX #11                                             ; check X with 11
    BNE -                                               ; if (X != 11) then branch (loop back)
+
    BEQ .badStringErrorLocal                            ;

; ***************************************************************************************
.terminateFilename
    LDA #0                                              ; terminate filename with 0
    STA .filenameToSearchFor,X                          ;
    CLI                                                 ;
    RTS                                                 ;

.badStringErrorLocal
    JMP .BDSTRI                                         ;

.badCommandLocal
    JMP .BDCOMM                                         ;

; ***************************************************************************************
.printSpaceThenHexByte
    PHA                                                 ; save A on stack
    JSR .printSpace                                     ; print a space
    PLA                                                 ; get back A
    ; fall through...

; ***************************************************************************************
;
; Print ASCII version of a hex value
;
; On Entry:
;       A = value to print
;       Preserves X and Y
;
; ***************************************************************************************
.printHexByte
    PHP                                                 ;
    PHA                                                 ;
    PHA                                                 ; save A on stack
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } divide by 16 to put high nybble in low
    LSR                                                 ; }
    JSR .printHexDigit                                  ; print its ASCII equivalent
    PLA                                                 ;
    JSR .printHexDigit                                  ; print its ASCII equivalent
    PLA                                                 ;
    PLP                                                 ;
    RTS                                                 ;

.printHexDigit
    CLC                                                 ; clear carry flag
    AND #%00001111                                      ; clear high nybble. A=0-15
    ADC #.charZERO                                      ; A = $30 to $3F
    CMP #.charNINE + 1                                  ; }
    BCC .writeCharJumper                                ; } if A <= ASC('9') then print
    ADC #.charA - (.charNINE + 1) - 1                   ; Convert $3A-$3F to A=$41-$46 ('A' to 'F')

.writeCharJumper
    JMP .OSWRCH                                         ; print character and return

;[ This routine could be smaller...
;.printHexByte
;    PHA                                                 ; save A on stack
;    LSR                                                 ; }
;    LSR                                                 ; }
;    LSR                                                 ; } divide by 16 to put high nybble in low
;    LSR                                                 ; }
;    JSR .printHexDigit                                  ; print its ASCII equivalent
;    PLA                                                 ; get back A
;    AND #%00001111                                      ; just the lower nybble
;.printHexDigit
;    SED                                                 ; set decimal mode
;    CMP #10                                             ; }
;    ADC #.charZERO                                      ; } decimal mode arithmetic trick
;    CLD                                                 ; clear decimal mode
;    JMP .OSWRCH                                         ; print character and return
;]

; ***************************************************************************************
.checkForEscapeDuringCassetteOperation
    PHP                                                 ; save flags on stack
    BIT .escapeFlag                                     ; }
    BMI .foundEscapeCondition                           ; } if (ESCAPE condition found) then branch
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
.foundEscapeCondition
    LDA #$7f                                            ;
    AND .fsStatusByte                                   ; clear ESCAPE condition
    STA .fsStatusByte                                   ;
    JSR .cancelTapeOperationAndMotor                    ;
    JSR .CNTAPE
    LDA #126                                            ; }
    JSR .OSBYTE                                         ; } Acknowledge ESCAPE condition

.escapeError
    BRK                                                 ; cause error
    !byte $11                                           ; error 17
    !text "Escape"                                      ; message
    !byte 0                                             ; terminator

; ***************************************************************************************
; On Entry:
;       Y = 0 for no messages
;       otherwise show messages
.loadBlock
    TYA                                                 ; A=Y
    BEQ +                                               ;
    JSR .safePrintFollowingMessage                      ; print message following call

    !text .charRETURN,"Loading",.charRETURN             ; message text
    !byte 0                                             ; terminator

+
    JSR .generateScreenReports                          ;
    JSR .compareFilenameToSearchFor                     ;
    BEQ +                                               ;
    LDX #$ff                                            ;
    JSR .checkIfWeShouldShowError                       ;

.fileError
    BRK                                                 ;
    !byte $DB                                           ; error number
    !text .charRETURN, "File?"                          ; message
    !byte 0                                             ; terminator

+
    LDX #$ff                                            ;

.checkForChecksumError
    LDA .fsBlockFlagByte                                ;
    STA .fsLastBlockReadFlagsCopy                       ;
    LDA .fsBlockNumberLow                               ;
    CMP .currentBlockNumberLow                          ;
    BNE +                                               ;
    LDA .fsBlockNumberHigh                              ;
    CMP .currentBlockNumberHigh                         ;
    BEQ ++                                              ;
+
    JSR .checkIfWeShouldShowError                       ;

.blockError
    BRK                                                 ;
    !byte $DA                                           ; error number
    !text .charRETURN, "Block?"                         ; message
    !byte 0                                             ; terminator

++
    LDA .checksumIsValidFlag                            ;
    BEQ +                                               ;
    JSR .checkIfWeShouldShowError                       ;

.headerError
    BRK                                                 ;
    !byte $d9                                           ; error number
    !text .charRETURN, "Header?"                        ; message
    !byte 0                                             ; terminator

+
    JMP .postFileError                                  ;

.saveByteAndIncrementBlockNumbers
    JSR .saveByteAndWait                                ;

.incrementBlockNumbers
    LDA .osfileBlockAddressLow                          ;
    ORA .osfileBlockAddressHigh                         ;
    BEQ ++                                              ;
    JSR .checkIfWeShouldShowError                       ;

.dataError
    BRK                                                 ;
    !byte $d8                                           ;
    !text .charRETURN, "Data?", 0                       ;

++
    JSR .postFileError                                  ;
    PHP                                                 ;
    BNE .printReturnSafely2                             ;
    JSR .clearCarryAndExit2                             ;

.printReturnSafely2
    BIT .currentBlockHasDataErrorFlag                   ;
    BPL +                                               ;
    JSR .saveFlagsPrintCR                               ;
+
    PLP                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.clearCarryAndExit2
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.postFileError
    LDA .currentBlockHasDataErrorFlag                   ; get current block flag
    BEQ .skipRewindTapeMessage                          ; if (zero) then branch
    TXA                                                 ; A=X
    BEQ .skipRewindTapeMessage                          ; if (X == 0) then branch (no retry)
    LDA #%00100010                                      ; A=$22
    BIT .tapeCurrentOptionsByte                         ; check current options
    BEQ .skipRewindTapeMessage                          ; if (not retry) then branch (no retry)

    ; rewind tape
    JSR .resetACIA
    JSR .printFollowingMessageAlways                    ; print following message
    !byte .charRETURN                                   ; Carriage Return
    !byte .charBELL                                     ; Beep
    !text "Rewind tape"                                 ; Message
    !byte .charRETURN                                   ; Carriage Return
    !byte 0                                             ; terminator

    LDA #$FF                                            ;
.skipRewindTapeMessage
    RTS                                                 ;

; ***************************************************************************************
.compareFilenameToSearchFor
    LDY #<.filenameToSearchFor                          ;
    LDA .vduVariablesStart,Y                            ;
    BEQ +                                               ;
    ; fall through...

; ***************************************************************************************
;
; Compare two filenames to see if they are identical
;
; On Entry:
;       Y is offset to filename within VDU Variables
;
; On Exit:
;       Z set if strings match
;
; ***************************************************************************************
.compareFilenames
    LDX #0                                              ;
-
    LDA .vduVariablesStart,Y                            ;
    CMP .fsFilename,X                                   ; check characters match
    BNE +                                               ; if (no match) then branch (exit)
    INY                                                 ; } move to next character in each string
    INX                                                 ; }
    CMP #0                                              ; check for end of filename
    BNE -                                               ; if (not end of filename) then branch (loop back)
+
    RTS                                                 ;

; ***************************************************************************************
.checkIfWeShouldShowError
    DEC .currentBlockHasDataErrorFlag                   ; set current block flag to $FF
    PLA                                                 ;
    STA .printMessageAddressLow                         ;
    PLA                                                 ;
    STA .printMessageAddressHigh                        ;
    TXA                                                 ; A=X
    BEQ .dontAbortOnError                               ;
    LDA #%00010001                                      ;
    AND .tapeCurrentOptionsByte                         ; current options (check for abort)
    BEQ .dontAbortOnError                               ; if (not abort on error) then branch

    JSR .CNTAPE                                         ;
    JSR .beepAndCancelTapeOperation                     ;
    JMP .printingFinished                               ;

; ***************************************************************************************
.dontAbortOnError
    CLC                                                 ; }
    LDA #2                                              ; }
    ADC .printMessageAddressLow                         ; }
    TAY                                                 ; } Add 2 to message address
    LDA #0                                              ; }
    ADC .printMessageAddressHigh                        ; }

    PHA                                                 ; }
    TYA                                                 ; } save AY on stack. This is the
    PHA                                                 ; } (byte before) the error message
                                                        ; } which will be printed by
                                                        ; } .printFollowingMessage below
    ; fall through...

; ***************************************************************************************
.safePrintFollowingMessage
    JSR .shouldPrintMessage                             ; check if free to print message
    TAY                                                 ; Y=A
    ; fall through...

; ***************************************************************************************
;
; Print the following message
;
; Prints the message at the address on the top of the stack (this is usually the
; return address, so represents the data that follows a JSR to this function).
; The alternative route here is that we fall through from .dontAbortOnError above, which
; has put the appropriate address on the stack.
;
; On returning from this routine, execution continues from the byte directly after the
; message.
;
; On Entry:
;       The top two bytes on the stack hold the address of the message - 1
;       Y = zero means don't actually output the message
;       otherwise print each character of the message using .OSASCI
; On Exit:
;       A = 0
;       Z is clear (not equal to zero)
; ***************************************************************************************
.printFollowingMessage
    PLA                                                 ; }
    STA .printMessageAddressLow                         ; } get calling address
    PLA                                                 ; } and store it in .printMessageAddressLow/High
    STA .printMessageAddressHigh                        ; }
    TYA                                                 ; A=Y (used to set Z flag if Y=0)
    PHP                                                 ; save Z flag on stack
-
    INC .printMessageAddressLow                         ;
    BNE +                                               ;
    INC .printMessageAddressHigh                        ;
+
    LDY #0                                              ; Y=0
    LDA (.printMessageAddressLow),Y                     ; get byte of message to print
    BEQ .pullPrintingFinished                           ; if (terminator found) then branch
                                                        ; (jump back to calling function after
                                                        ; message)
    PLP                                                 ; restore flags from stack
    PHP                                                 ; save flags on stack again
    BEQ -                                               ; if (Z=1, i.e. don't output message)
                                                        ; then branch (loop back to get next
                                                        ; character)
    JSR .OSASCI                                         ; print character
    JMP -                                               ; jump back to get next character

.pullPrintingFinished
    PLP                                                 ; get back flags
.printingFinished
    INC .printMessageAddressLow                         ; increment pointers
    BNE +                                               ;
    INC .printMessageAddressHigh                        ;
+
    JMP (.printMessageAddressLow)                       ; return control to just after the error message


; ***************************************************************************************
.printFollowingMessageAlways
    LDY #$FF                                            ; non-zero, to print message
    BNE .printFollowingMessage                          ; ALWAYS branch

; ***************************************************************************************
.cancelTape
    JSR .cancelTapeOperationAndMotor

    LDX #100                                            ; loop counter
-
    DEX                                                 ; delay loop
    BNE -                                               ;

.set300BaudMotorOn
    LDA #%10101101                                      ; set 300 baud, MOTOR on
    BNE .setSerialULADirectly                           ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 21: More Low Level Tape Operations
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.beepAndCancelTapeOperation
    JSR .shouldPrintMessage                             ; check if free to print message
    BEQ .cancelTapeOperationAndMotor                    ;
    LDA #.charBELL                                      ; beep
    JSR .OSWRCH                                         ;
    ; fall through...

; ***************************************************************************************
; Cancel the tape operation:
;       switch off the cassette motor
;       reset ACIA
.cancelTapeOperationAndMotor
    JSR .resetACIA                                      ;
    LDA #%00101101                                      ; transmit and recieve = 300 baud
                                                        ; cassette has control of the serial ULA
                                                        ; motor is off
.setSerialULADirectly
    STA .serialULAControlRegister                       ; write to control register
    RTS                                                 ;

; ***************************************************************************************
.resetACIA
    PHA                                                 ;
    LDA #%00000011                                      ; reset ACIA
    BNE .storeAToACIARegister                           ; ALWAYS branch

; ***************************************************************************************
.activateRequestToSend
    PHA                                                 ;
    LDA #%00110000                                      ; set current ACIA control register
                                                        ; 8 bit word, 2 stop bits, RTS low
                                                        ; (this is the active state), transmit
                                                        ; interrupt enabled
    STA .tapeSendingFlag                                ; set non-zero value to indicate
                                                        ; sending to tape
    BNE .setACIA6850ControlRegister                     ; ALWAYS branch

; ***************************************************************************************
.flipRelayOffAndOnThenSetToReadFromTape
    PHA                                                 ;
    JSR .cancelTape                                     ; cancel tape operation
    LDX #200                                            ; loop counter
-
    DEX                                                 ; delay loop
    BNE -                                               ;
    JSR .cancelTape                                     ; cancel tape operation
    LDA #%10010000                                      ;

.setACIA6850ControlRegister
    ORA .tapeBaudRate                                   ; set bits for baud rate:
                                                        ; 5 = %101 means 1200 baud
                                                        ; (divide by 16; 1 stop bit)
                                                        ; 6 = %110 means  300 baud
                                                        ; (divide by 64; 1 stop bit)
.storeAToACIARegister
    STA .acia6850ControlRegister                        ;
    PLA                                                 ;
    RTS                                                 ;

; ***************************************************************************************
.incrementBlockNumbers2
    LDX .fsBlockNumberLow                               ; block number
    LDY .fsBlockNumberHigh                              ; block number high
    INX                                                 ; X=X+1
    STX .currentBlockNumberLow                          ; current block number low
    BNE +                                               ;
    INY                                                 ; Y=Y+1
+
    STY .currentBlockNumberHigh                         ; current block number high
    RTS                                                 ;

; ***************************************************************************************
.zeroChecksumAndFSFlag
    LDY #0                                              ;
    STY .fsGotACharacterToReadOrWriteFlag               ; clear 'just read character' flag
    STY .osfileBlockAddressLow                          ;
    STY .osfileBlockAddressHigh                         ;
    RTS                                                 ;

.copyToSoughtFilenamePreservingY
    TYA                                                 ;
    PHA                                                 ;
    JSR .copyToSoughtFilename                           ;
    STA .fsLastBlockReadFlagsCopy                       ;
    PLA                                                 ;
    TAY                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Copy zero terminated string to .filenameToSearchFor
;
; On Entry:
;       X is offset from $301 for source string
; ***************************************************************************************
.copyToSoughtFilename
    LDY #$FF                                            ; Y=$FF
-
    INY                                                 ; Y=Y+1
    INX                                                 ; X=X+1
    LDA .page2Start,X                                   ;
    STA .filenameToSearchFor,Y                          ; sought filename
    BNE -                                               ; until end of filename (0)
    RTS                                                 ;

; ***************************************************************************************
.saveChecksumToTape
    LDA .tapeChecksumHigh                               ;
    JSR .saveByteAToTape                                ;
    LDA .tapeChecksumLow                                ;
    JMP .saveByteAToTape                                ;

; ***************************************************************************************
.readKeyboardBuffer
    LDX #0                                              ;
.osbyte145Jumper
    LDA #145                                            ;
    JMP .OSBYTE                                         ;

    !text " :SETSDF LDA"                                ; [unused]

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 22: Credits
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Credits
;
; ***************************************************************************************
; This area of memory from $FC00-$FF00 is the memory mapped IO space, so this memory cannot
; be used as a normal part of the OS. Instead the memory locations store a string of credits.
; For memory mapped I/O, see Chapter 3.
;
;   Herman Hauser       Co-founder of Acorn
;                       Vice-president for research at Olivetti; Co-founder of Olivetti
;                       Research Laboratory in Cambridge; involved with spinning out ARM from
;                       Acorn; Serial entrepreneur; Holds honorary doctorates from three
;                       universities; Serves on educational advisory boards; Fellow of the
;                       Institute of Physics; International Fellow of the Royal Academy of
;                       Engineering; Honorary fellowship of King's College, Cambridge; Patron
;                       of The Centre for Computing History; Awarded the Mountbatten Medal.
;                       Became a Fellow of the Royal Society in 2012.
;                       Awarded the KBE in 2015.
;                       https://en.wikipedia.org/wiki/Hermann_Hauser
;
;   Christopher Curry   Co-founder of Acorn
;                       Sinclair Radionics; co-founded Redwood Publishing and bought Acorn
;                       User; Founded General Information Systems Ltd (GIS) and remains a
;                       director.
;
;                       Led the development of the Atom.
;                       https://en.wikipedia.org/wiki/Christopher_Curry
;
;   Andy Hopper         Co-founder of Acorn
;                       Treasurer and Vice-President of the Royal Society; Professor of
;                       Computer Technology; Former Head of the University of Cambridge
;                       Department of Computer Science and Technology; an Honorary Fellow
;                       of Trinity Hall, Cambridge and Corpus Christi College, Cambridge;
;                       Serial entrepreneur; Awarded CBE in 2006.
;
;                       Head of the University of Cambridge computer lab;
;                       His academic research lead to the Cambridge Ring Interface (Econet);
;                       Contributed to chip designs;
;                       Wrote an Acorn Atom game (a clone of Asteroids);
;                       A qualified pilot with over 6000 hours logged;
;                       Technical director at Olivetti
;                       Became a Fellow of the Royal Society in 2006.
;                       Awarded the CBE in 2007.
;                       https://en.wikipedia.org/wiki/Andy_Hopper
;                       http://news.bbc.co.uk/1/hi/technology/6217447.stm
;
;   Chris Turner        Chief Engineer and Manufacturing; Employee number one;
;                       Owned the overall circuit diagram; Integrated Teletext chip;
;                       Named Fred, Jim, and Sheila; Testing Equipment;
;                       Managed over 200 engineering staff; Product Manager for Domesday
;                       system; Operations Director in the business systems division.
;                       http://www.computinghistory.org.uk/det/40132/Chris-Turner-Acorn-and-the-BBC-Micro/
;                       https://youtu.be/GKHEsp8MYTM?t=1225
;                       https://www.linkedin.com/in/cbturner/?originalSubdomain=uk
;
;   Steve Furber        Principal Hardware Designer; Productionisation;
;                       "I was sort of deputy manager of advanced R&D";
;                       Responsible for the 6502 Second Processor;
;                       Responsible for sorting out the manufacturing troubles with the
;                       Ferranti gate arrays (ULAs);
;                       Went on to lead ARM development;
;                       Wrote a reference model for ARM in BBC BASIC;
;                       ICL Professor of Computer Engineering at the School of Computer
;                       Science at the University of Manchester.
;                       Awarded the CBE in 2008.
;                       https://en.wikipedia.org/wiki/Steve_Furber
;                       https://sounds.bl.uk/Oral-history/Science/021M-C1379X0078XX-0003V0
;
;   Sophie Wilson       (formerly Roger Wilson)
;                       Major architect involved in both software and hardware;
;                       Wrote the BASIC interpreter software for the Atom, the BBC Micro, and
;                       Archimedes;
;                       Wrote the instruction set architecture for the ARM;
;                       Became a Fellow of the Royal Society in 2013.
;                       Awarded the CBE in 2019.
;                       https://en.wikipedia.org/wiki/Sophie_Wilson
;
;   Laurence Hardwick   Network Product Manager (1980-1990)
;                       Management of all aspects of company network product strategy,
;                       product definition, sales forecasting, marketing materials and
;                       marketing events.
;                       Perhaps involved with writing the CFS
;                       https://stardot.org.uk/forums/viewtopic.php?p=313036#p313036
;                       https://www.linkedin.com/in/laurencehardwick/?originalSubdomain=uk
;
;   Peter Robinson      Video processor custom design with Jeremy Dion;
;                       Worked for Andy Hopper;
;                       Involved with the Cambridge University computer lab.
;                       Researching and developing computer systems that understand emotions.
;                       https://en.wikipedia.org/wiki/Peter_Robinson_(computer_scientist)
;                       https://www.youtube.com/watch?v=whCJ4NLUSB8
;                       http://www.bbc.co.uk/ahistoryoftheworld/objects/MKG9WQ8WSyasxVeM0Z9T3A
;
;   Jeremy Dion         Video processor custom design with Peter Robinson;
;                       Worked for Andy Hopper;
;                       http://www.bbc.co.uk/ahistoryoftheworld/objects/MKG9WQ8WSyasxVeM0Z9T3A
;
;   Allen Boothroyd     BBC Micro and Atom case and keyboard design. Industrial design for a
;                       number of companies.
;                       https://en.wikipedia.org/wiki/Allen_Boothroyd
;
;   Paul Bond           A contractor from "Top Express", who led a team of around
;                       "30 software developers" that wrote the MOS 0.1.
;                       Jon Thackray took over the MOS for 1.0 and later.
;                       Also led the software team for the Acorn Communicator.
;                       https://stardot.org.uk/forums/viewtopic.php?f=3&t=15786&p=216537&hilit=Paul+Bond#p216537
;                       https://sounds.bl.uk/Oral-history/Science/021M-C1379X0078XX-0003V0
;                       https://en.wikipedia.org/wiki/Acorn_Communicator
;
;   Andrew Cripps       Software Engineer (1981–1983)
;                       Developed operating system software, drivers and supporting utilities
;                       for the BBC Microcomputer and for server operating systems.
;                       https://www.linkedin.com/in/cripps/?originalSubdomain=ca
;
;   Kim Spence-Jones    A consultant for Acorn, worked on the cassette interface hardware;
;                       worked with Paul Bond; Formed SJ Research which made Econet peripherals.
;                       https://youtu.be/GKHEsp8MYTM?t=1108
;                       https://stardot.org.uk/forums/viewtopic.php?p=6542#p6542
;                       http://www.spencejones.com/Kim_CV_2012.pdf
;
;   Chris Jordan        Acorn Design Team Member
;                       Publications Editor, Acornsoft
;                       Programmed the BBC Micro's sound chip; Designed the Acorn Music 500
;                       and Hybrid Music System.
;                       https://en.wikipedia.org/wiki/Acornsoft
;                       http://www.muzines.co.uk/articles/midi-what-s-wrong-with-it/1398
;                       https://stardot.org.uk/forums/viewtopic.php?f=13&t=7704
;
;   Tim Dobson          Acornsoft programmer
;                       Wrote Monsters, Maze, co-wrote Magic Mushrooms
;                       https://en.wikipedia.org/wiki/Acornsoft
;
;   Martin Jackson      Responsible for the Tube interface?
;                       Founded Tadpole technology
;                       https://youtu.be/GKHEsp8MYTM?t=1162
;
;   Andrew Gordon       Worked on the Teletext adapter and contributed to OS features, notably
;                       the sideways-ROM call interface.
;
;   Joe Dunn            Engineering Project Management (1980-1988)
;                       Worked on Econet. Perhaps worked on the cassette filing system.
;                       https://www.linkedin.com/in/joeddunn/
;                       https://stardot.org.uk/forums/viewtopic.php?p=310032#p310032
;
;   Arthur Norman       Norcroft C Compiler; Lisp on the BBC Micro; Functional programming;
;                       Fellow of Trinity College, Cambridge; Former Director of Studies for
;                       Computer Science at Trinity College, Cambridge
;                       Wrote mathematical routines for BASIC
;                       https://en.wikipedia.org/wiki/Arthur_Norman_(computer_scientist)
;
;   Jon Thackray        Took over from Paul Bond as leading the MOS development for 1.0 and 1.2.
;                       Lead the Electron MOS.
;                       Wrote MASM for the 6502 second processor, and the ARM version.
;                       Co-wrote Acheton (with David Seal and Jonathan Partington)
;                       Wrote early test programs for the ARM
;
;   Ram Banerjee        (Ramanuj Banerjee)
;                       Wire wrapped the prototype machine to show the BBC.
;                       https://youtu.be/GKHEsp8MYTM?t=1895
;
;   Dylan Harris        Programmer (Jul 1981–Sep 1981)
;                       As a summer job helped finish a 6502 Assembler, used to build the MOS.
;                       https://dylanharris.org/blog/1981/b1.shtml
;                       https://www.linkedin.com/in/devongarde/?originalSubdomain=lu
;
;   John Cox            In a gap year wrote tools that helped design the Electron ULA;
;                       Helped to port the System 3 DFS to the BBC Micro.
;                       Author of Computer Concepts Snake.
;                       http://bbcmicro.co.uk/game.php?id=682
;                       https://stardot.org.uk/forums/viewtopic.php?f=3&t=13806&p=181329&hilit=John+Cox#p181329
;
;   Brian Jones         Helped to build prototypes of the Electron. Later worked for SJ Research.
;                       Wrote Advanced Graphics with the Acorn Electron;
;                             Advanced Graphics with the BBC Model B Microcomputer
;                       https://www.cl.cam.ac.uk/research/dtg/www/people/bdj23/
;
;   Graham Tebby        Wrote much of the graphics routines.
;                       http://abug.org.uk/index.php/2020/09/05/jon-thackray/
;                       Possibly https://www.linkedin.com/in/graham-tebby-93a7208/?originalSubdomain=uk
;                       But not really much detail.
;
;   Peter Miller        Wrote much of the sound code. Later ran his own company Micro Robotics Ltd
;                       initially doing BBC add-ons and gradually developing its own range of
;                       control-oriented micros.
;
;   Bob Austin          Lead the motherboard design team, responsible for the PCB layout.
;                       ("Bob's board" is printed on the motherboard, underneath the
;                       6502 chip.)
;                       https://stardot.org.uk/forums/viewtopic.php?p=20687#p20687
;
;   Glyn Phillips       Developed the FIT and PET test tools for use in manufacturing/repair of the
;                       BBC micro.  Later (with Mel Pullen, also ex-Acorn) founded SoftMachinery Ltd
;                       which (among other things) produced Prestel terminal software to run on the
;                       BBC.  Also ran the "Gnome at Home" BBS.
;
;   From the BBC
;   ------------
;   John Radcliffe      Executive Producer, BBC Computer Literacy Project
;                       https://www.theregister.co.uk/Print/2008/03/20/ft_bbc_micro/
;                       https://clp.bbcrewind.co.uk/aef4287b5161099b147d9c4a75f9c1d3
;
;   David Allen         Project Leader, BBC Computer Literacy Project; Producer of the BBC TV
;                       show Micro Live, Making the Most of the Micro; Edited the User Guide;
;                       Commissioned the Welcome Tape, which led to the need to control the
;                       tape motor.
;                       https://www.theregister.co.uk/Print/2008/03/20/ft_bbc_micro/
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;                       https://clp.bbcrewind.co.uk/aef4287b5161099b147d9c4a75f9c1d3
;
;   John Coll           School teacher who then served on the committee that was selecting the
;                       manufacturer to produce the BBC Micro.
;                       Primary author of the User Guide ('for which he received £150,000');
;                       wrote initial functional description of the BBC Micro; wrote for
;                       Personal Computer World; Worked on the Micro Live programme.
;                       Ended up working for Acorn as an employee, later moving to CET
;                       (Council for Educational Technology).
;                       https://en.wikipedia.org/wiki/John_Coll
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;
;   David Kitson        Design Engineering Manager
;                       Worked with Richard Russell; Liaised with Chris Turner to track
;                       progress, reported to John Radcliffe.
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;
;   David King          The BBC's cassette and ROM filing system expert. Tested the
;                       functionality. Worked under David Kitson.
;                       https://stardot.org.uk/forums/viewtopic.php?p=216681#p216681
;                       https://stardot.org.uk/forums/viewtopic.php?p=216639#p216639
;
;   Richard Russell     Design engineer at the BBC; 'Led the BBC's efforts'; Specification of
;                       BBC BASIC, working with Sophie Wilson; helped with the BBC User Guide;
;                       Domesday Project; BBC BASIC for Windows; Television 'Chroma dot'
;                       colour recovery system.
;                       https://en.wikipedia.org/wiki/Richard_T._Russell
;                       http://www.rtrussell.co.uk
;
;   Paul Kriwaczek      Producer 'The Computer Programme', BBC Computer Literacy Project;
;                       Dialogue Coach; Dentist to the Afghan royal family; Programmes on
;                       Yiddish and Islamic history and culture.
;                       https://en.wikipedia.org/wiki/Paul_Kriwaczek
;                       https://www.independent.co.uk/news/obituaries/paul-kriwaczek-bbc-tv-producer-and-author-of-engaging-books-on-the-ancient-world-2266387.html
;
;   Other
;   -----
;   6502 designers      Chuck Peddle, Rod Orgill, and Wil Mathys
;                       https://en.wikipedia.org/wiki/MOS_Technology_6502#Design_notes
;
;   Hitachi             Supplied DRAM chips
;                       https://youtu.be/GKHEsp8MYTM?t=1816
;
;   Ferranti            Made the custom ULAs for Acorn
;
;   ICL and Cleartone   Manufacturers
;                       According to Acorn User issue 1 - July/Aug 1982: "Acorn currently
;                       use two manufacturing plants in the UK. ICL at Kidsgrove are largely
;                       responsible for manufacturing the model B and Cleartone in Gwent for
;                       model A computers. Cleartone have recently been taken over by AB
;                       Electronics. A third UK plant is starting production of both models
;                       this month."
;                       https://archive.org/details/Acorn_User_Number_001_1982-08_Adn-Wesley_GB/page/n5/mode/2up
;
;   Cambridge           Home of Acorn; University town in Cambridgeshire, England
;                       https://en.wikipedia.org/wiki/Cambridge
;
;   Computer Laboratory Academic department within the University of Cambridge
;                       https://www.cl.cam.ac.uk
;
;   Wilberforce Road    A road in Cambridge where some of the developers lived in the early days.
;                       https://youtu.be/Rphep1dS2NU?t=2191
;                       https://map.cam.ac.uk/Wilberforce+Road#52.209604,0.100091,17
;
;   Unknown
;   -------
;   Paul Farrell
;   Jon Gibbons
;   Mike Prees
;   Adrian Warner
;   Alan Wright

* = $fc00

!byte $bb
!byte $c0

    !text "(C) 1981 Acorn Computers Limited.Thanks are extended to the following people, "
    !text "companies and locations, contributors (among others too numerous to mention) to "
    !text "the development of the BBC Computer:"
    !text "David Allen,Bob Austin,Ram Bannerjee,Paul Bond,Allen Boothroyd,Cambridge,"
    !text "Cleartone,John Coll,Computer Laboratory,Chris Curry,Designers of the 6502,"
    !text "Jeremy Dion,Tim Dobson,Joe Dunn,Paul Farrell,Ferranti,Steve Furber,Jon Gibbons,"
    !text "Lawrence Hardwick,Dylan Harris,Hermann Hauser,Hitachi,Andy Hopper,"
    !text "ICL,Martin Jackson,Brian Jones,Chris Jordan,David King,David Kitson,"
    !text "Paul Kriwaczek,Peter Miller,Arthur Norman,Glyn Phillips,"
    !text "Mike Prees,John Radcliffe,Peter Robinson,Richard Russell,"
    !text "Kim Spence-Jones,Graham Tebby,Chris Turner,Adrian Warner,Wilberforce Road,"
    !text "Roger Wilson,Alan Wright."

!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]
!byte 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0                ; [unused]

* = $FFA0
.nmiEntryPoint
    RTI                                                 ;

; ***************************************************************************************
;
; Operating System function calls
;
; Historical note: The Acorn System 2 began the practice of placing entry points like
; these at the high end of the ROM, (mostly) spaced three bytes apart so that each can
; jump directly back into the ROM or through a vector, and still be called as if they
; were subroutines. This practice protected user programs from breaking when the MOS was
; revised, since it meant there were reliable addresses to call. Though System 2, and
; similarly the Atom, have a slightly smaller set of entry points, so addresses are not
; the same (OSWRCH is at $FFF4 on the System 2 and Atom, not $FFEE as here), the basic
; design is identical. System 2 and the Atom both perform the CR/LF manoeuvre below in
; which OSASCI, OSNEWL and OSWRCH are combined.
;
; ***************************************************************************************
.BDSTRI
    JMP .brkBadString                                   ;
.BDADDR
    JMP .brkBadAddress                                  ;
.BDCOMM
    JMP .badCommandError                                ;
.RSTIME
    JMP .waitForRS423ToTimeout                          ;
.CNTAPE
    JMP .cancelTapeOperation                            ;
.OSEXEC
    JMP .starExec                                       ;
.OSSPLL
    JMP .starSpool                                      ;
.OSINSE
    JMP .insEntryPoint                                  ;
.OSFLUS
    JMP .flushBufferX                                   ;
.OSEXBF
    JMP .osbyte152EntryPoint                            ; examine buffer status
.OSRDBF
    JMP .osbyte145EntryPoint                            ; get byte from buffer
.GSINIT
    JMP .gsinitEntryPoint                               ; initialise for parsing a string
.GSREAD
    JMP .gsreadEntryPoint                               ; parse character from string
.OSDBUG
    JMP .starDebug                                      ; *DEBUG
.OSFSC
    JMP (.vectorFSCV)                                   ;
.OSFIND
    JMP (.vectorFINDV)                                  ; open or close a file
.OSGBPB
    JMP (.vectorGBPBV)                                  ; transfer data to or from a file
.OSBPUT
    JMP (.vectorBPUTV)                                  ; save a byte to file
.OSBGET
    JMP (.vectorBGETV)                                  ; get a byte from file
.OSARGS
    JMP (.vectorARGSV)                                  ; read or write file arguments
.OSFILE
    JMP (.vectorFILEV)                                  ; read or write a file
.OSRDCH
    JMP (.vectorRDCHV)                                  ; get byte from current input stream
.OSASCI
    CMP #.charRETURN                                    ; output byte, expanding carriage
    BNE .OSWRCH                                         ; returns to CR/LF ($0A,$0D)
.OSNEWL
    LDA #.charLINEFEED                                  ; output a CR/LF to VDU stream
    JSR .OSWRCH                                         ;
    LDA #.charRETURN                                    ;
.OSWRCH
    JMP (.vectorWRCHV)                                  ; output a character (to the screen
                                                        ; and/or other output streams)
.OSWORD
    JMP (.vectorWORDV)                                  ; perform operation with data from
                                                        ; a parameter table
.OSBYTE
    JMP (.vectorBYTEV)                                  ; perform operation with three
                                                        ; parameters <A>,<X>,<Y>
                                                        ; (equivalent to BASIC's *FX command)
.OSCLI
    JMP (.vectorCLIV)                                   ; pass string to command line
                                                        ; interpreter


; ***************************************************************************************
;
; 6502 Vectors
;
; See 6502.png
;
; Finally the last 6 bytes are designated (by the design of the 6502 chip) to contain the
; addresses of the routines that handle an NMI, a RESET and an IRQ condition.
;
; ***************************************************************************************
* = $FFFA
    !word .nmiEntryPoint                                ; NMI   address
    !word .resetEntryPoint                              ; RESET address
    !word .irqEntryPoint                                ; IRQ   address

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 25: Appendix
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; 'Broader horizons' advertisement
;
; See AU6-Jan83P66.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Circuit diagrams in vector format
;
; Circuit diagram for the motherboard, see CircuitDiagram.pdf
; Circuit diagram for the keyboard, see CircuitKeyboard.pdf
;
; ***************************************************************************************

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 26: Index
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSWRCH
;
; This is the 'VDU' command in BBC BASIC. The non-printable characters are handled by
; individual routines. See .oswrchEntryPoint
;
; VDU   0    - Does nothing                                   See .vdu0EntryPoint
; VDU   1    - Send next character to printer only            See .vdu1EntryPoint
; VDU   2    - Enable printer                                 See .vdu2EntryPoint
; VDU   3    - Disable printer                                See .vdu3EntryPoint
; VDU   4    - Write text at text cursor                      See .vdu4EntryPoint
; VDU   5    - Write text at graphics cursor                  See .vdu5EntryPoint
; VDU   6    - Enable VDU drivers                             See .vdu6EntryPoint
; VDU   7    - Make a short beep                              See .vdu7EntryPoint
; VDU   8    - Move cursor left                               See .vdu8EntryPoint
; VDU   9    - Move cursor right                              See .vdu9EntryPoint
; VDU  10    - Move cursor down                               See .vdu10EntryPoint
; VDU  11    - Move cursor up                                 See .vdu11EntryPoint
; VDU  12    - Clear text window                              See .vdu12EntryPoint
; VDU  13    - Move cursor to start of current line           See .vdu13EntryPoint
; VDU  14    - Paged mode on                                  See .vdu14EntryPoint
; VDU  15    - Paged mode off                                 See .vdu15EntryPoint
; VDU  16    - Clear graphics window                          See .vdu16EntryPoint
; VDU  17    - Define text colour                             See .vdu17EntryPoint
; VDU  18    - Define graphics colour                         See .vdu18EntryPoint
; VDU  19    - Change palette colour                          See .vdu19EntryPoint
; VDU  20    - Restore default palette                        See .vdu20EntryPoint
; VDU  21    - Disable VDU drivers / delete line              See .vdu21EntryPoint
; VDU  22    - Select screen MODE                             See .vdu22EntryPoint
; VDU  23    - Define character shape (etc)                   See .vdu23EntryPoint
; VDU  24    - Define graphics window                         See .vdu24EntryPoint
; VDU  25    - PLOT                                           See .vdu25EntryPoint
; VDU  26    - Restore default windows                        See .vdu26EntryPoint
; VDU  27    - Does nothing                                   See .vdu27EntryPoint
; VDU  28    - Define text window                             See .vdu28EntryPoint
; VDU  29    - Define graphics origin                         See .vdu29EntryPoint
; VDU  30    - Move text cursor to top left                   See .vdu30EntryPoint
; VDU  31    - Move text cursor to X,Y                        See .vdu31EntryPoint
; VDU 127    - Delete                                         See .vdu127EntryPoint
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE
;
; See .osbyteEntryPoint
;
; OSBYTE   0 - Display version number                       See .osbyte0EntryPoint
; OSBYTE   1 - Read/Write user flag                         See .osbyte1EntryPoint
; OSBYTE   2 - select input stream                          See .osbyte2EntryPoint
; OSBYTE   3 - Select output stream                         See .osbyte3EntryPoint
; OSBYTE   4 - Enable / disable cursor editing              See .osbyte4EntryPoint
; OSBYTE   5 - Select printer type                          See .osbyte5EntryPoint
; OSBYTE   6 - Set printer ignore character                 See .osbyte6EntryPoint
; OSBYTE   7 - Set RS-423 baud rate for receiving data      See .osbyte7EntryPoint
; OSBYTE   8 - Set RS-423 baud rate for transmitting data   See .osbyte8EntryPoint
; OSBYTE   9 - Duration of first colour                     See .osbyte9EntryPoint
; OSBYTE  10 - Duration of second colour                    See .osbyte10EntryPoint
; OSBYTE  11 - Set keyboard autorepeat delay                See .osbyte11EntryPoint
; OSBYTE  12 - Set keyboard autorepeat rate                 See .osbyte12EntryPoint
;
; OSBYTEs 13-14 are undefined
;
; OSBYTE  15 - Flush selected buffer class                  See .osbyte15EntryPoint
; OSBYTE  16 - Select ADC channels                          See .osbyte16EntryPoint
;
; OSBYTEs 17-119 are undefined
;
; OSBYTE 120 - Write key pressed data                       See .osbyte120EntryPoint
; OSBYTE 121 - Keyboard scan from value in X                See .osbyte121EntryPoint
; OSBYTE 122 - Set CAPS/SHIFT LOCK LED state                See .osbyte122EntryPoint
; OSBYTE 123 - Generate BRK                                 See .osbyte123EntryPoint
; OSBYTE 124 - Clear ESCAPE condition                       See .osbyte124EntryPoint
; OSBYTE 125 - Set ESCAPE condition                         See .osbyte125EntryPoint
; OSBYTE 126 - Acknowledge detection of ESCAPE condition    See .osbyte126EntryPoint
; OSBYTE 127 - Check for EOF on open file                   See .osbyte127EntryPoint
; OSBYTE 128 - Read ADC Channel / get buffer status         See .osbyte128EntryPoint
; OSBYTE 129 - Read key within time limit                   See .osbyte129EntryPoint
; OSBYTE 130 - Read machine high order address              See .osbyte130EntryPoint
; OSBYTE 131 - Read OSHWM (OS High Water Mark)              See .osbyte131EntryPoint
; OSBYTE 132 - Read HIMEM (start of screen memory)          See .osbyte132EntryPoint
; OSBYTE 133 - Display filing system catalogue              See .osbyte133EntryPoint
; OSBYTE 134 - Read text cursor position                    See .osbyte134EntryPoint
; OSBYTE 135 - Read character at text cursor position       See .osbyte135EntryPoint
; OSBYTE 136 - Do nothing                                   See .osbyte136EntryPoint
; OSBYTE 137 - Turn on tape motor                           See .osbyte137EntryPoint
; OSBYTE 138 - Put byte into buffer                         See .osbyte138EntryPoint
; OSBYTE 139 - Select file options (*OPT)                   See .osbyte139EntryPoint
; OSBYTE 140 - Select TAPE file system                      See .osbyte140EntryPoint
; OSBYTE 141 - Insert byte A into buffer X                  See .osbyte141EntryPoint
; OSBYTE 142 - Enumerate *KEY definitions                   See .osbyte142EntryPoint
; OSBYTE 143 - Get number of *KEY definitions               See .osbyte143EntryPoint
; OSBYTE 144 - *TV                                          See .osbyte144EntryPoint
;
; OSBYTEs 145-255 are undefined.
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSWORD
;
; See .oswordEntryPoint
;
; OSWORD   0 - Read line from current input into memory     See .osword0EntryPoint
; OSWORD   1 - Read system clock                            See .osword1EntryPoint
; OSWORD   2 - Write system clock                           See .osword2EntryPoint
; OSWORD   3 - Read interval timer                          See .osword3EntryPoint
; OSWORD   4 - Write interval timer                         See .osword4EntryPoint
; OSWORD   5 - Read system clock B                          See .osword5EntryPoint
; OSWORD   6 - Write system clock B                         See .osword6EntryPoint
; OSWORD   7 - Make a sound                                 See .osword7EntryPoint
; OSWORD   8 - Define an envelope                           See .osword8EntryPoint
; OSWORD   9 - Read a pixel                                 See .osword9EntryPoint
; OSWORD  10 - Read character definition                    See .osword10EntryPoint
; OSWORD  11 - Read palette                                 See .osword11EntryPoint
; OSWORD  12 - Write palette                                See .osword12EntryPoint
;
; OSWORDs 13-255 are undefined.
;
; ***************************************************************************************

; ***************************************************************************************
;
; OS Entry Points
;
; OS Call       Vector             Default handler         Description
; ---------------------------------------------------------------------------------------
; See .GSINIT   -                  See .gsinitEntryPoint   Initialise for parsing a string
; See .GSREAD   -                  See .gsreadEntryPoint   Parse a character from string
; See .NVRDCH   -                  See .osrdchEntryPoint   Non-vectored .OSRDCH
; See .NVWRCH   -                  See .oswrchEntryPoint   Non-vectored .OSWRCH
; See .OSARGS   See .vectorARGSV   See .osargsEntryPoint   Read or write file arguments
; See .OSASCI   -                  See .OSASCI             Output byte, expanding CR
; See .OSBGET   See .vectorBGETV   See .osbgetEntryPoint   Get a byte from file
; See .OSBPUT   See .vectorBPUTV   See .osbputEntryPoint   Save a byte to file
; See .OSBYTE   See .vectorBYTEV   See .osbyteEntryPoint   OS call with A,X,Y parameters
; See .OSCLI    See .vectorCLIV    See .oscliEntryPoint    Execute star command string
; See .OSEVEN   -                  See .eventEntryPoint    Generate an EVENT
; See .OSFILE   See .vectorFILEV   See .osfileEntryPoint   Read or write a file
; See .OSFIND   See .vectorFINDV   See .osfindEntryPoint   Open or close a file
; See .OSGBPB   See .vectorGBPBV   -                       Transfer block to or from a file
; See .OSNEWL   -                  See .OSNEWL             Output CR/LF
; See .OSRDCH   See .vectorRDCHV   See .osrdchEntryPoint   Get byte from current input stream
; See .OSWORD   See .vectorWORDV   See .oswordEntryPoint   OS call with parameter block
; See .OSWRCH   See .vectorWRCHV   See .oswrchEntryPoint   Output a character
; See .VDUCHR   -                  See .vduChrEntryPoint   Output a character to screen
;
; ***************************************************************************************

; ***************************************************************************************
;
; Vectors
;
; Vector              Address   Default handler          Description
; ---------------------------------------------------------------------------------------
; See .vectorARGSV    $0214     See .osargsEntryPoint    Load / Save file parameters
; See .vectorBGETV    $0216     See .osbgetEntryPoint    Get byte from file
; See .vectorBPUTV    $0218     See .osbputEntryPoint    Put byte to file
; See .vectorBRKV     $0202     See .brkHandler          BRK vector
; See .vectorBYTEV    $020A     See .osbyteEntryPoint    OSBYTE call
; See .vectorCLIV     $0208     See .oscliEntryPoint     Command line interpreter
; See .vectorFILEV    $0212     See .osfileEntryPoint    Load / Save file
; See .vectorFINDV    $021C     See .osfindEntryPoint    Open / Close file
; See .vectorFSCV     $021E     See .fscEntryPoint       Filing system control
; See .vectorGBPBV    $021A     -                        Multiple BPUT/BGET
; See .vectorIRQ1V    $0204     See .irq1Handler         Primary IRQ vector
; See .vectorIRQ2V    $0206     See .irq2Handler         Unrecognised IRQ vector
; See .vectorRDCHV    $0210     See .osrdchEntryPoint    OSRDCH call
; See .vectorUSERV    $0200     See .badCommandError     User vector
; See .vectorWORDV    $020C     See .oswordEntryPoint    OSWORD call
; See .vectorWRCHV    $020E     See .oswrchEntryPoint    OSWRCH call
;
; ***************************************************************************************

; ***************************************************************************************
;
; 6502 Vectors
;
; NMI         See .nmiEntryPoint
; RESET       See .resetEntryPoint
; IRQ         See .irqEntryPoint
;
; ***************************************************************************************
