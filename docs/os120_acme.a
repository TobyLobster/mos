; BBC Microcomputer OS 1.20
; Reassembly by Toby Nelson, 2020
;
; Table of Contents
; -----------------
;         Chapter 1: Introduction
;         Chapter 2: Memory Layout and Constants
;         Chapter 3: Memory Mapped IO
; ($C000) Chapter 4: Character definitions and VDU tables                         (1216 bytes)
;           Character definitions; Boot message; VDU tables
; ($C4C0) Chapter 5: VDU and OSWORD routines                                      (1629 bytes)
;           VDU 0-6, 8-31, 127. OSWORD 9, 11, 12; VDUCHR entry point; Swap cursor variables
;           Check text or graphics cursor active; Hardware scrolling; Scroll in paged mode
; ($CB1D) Chapter 6: Changing MODEs                                                (475 bytes)
;           MODE change code; OSWORD 10; Clear screen
; ($CCF8) Chapter 7: Graphics cursor and soft character definitions                (872 bytes)
;           OSBYTE 20; Cursor editing mode; Software scroll up/downwards
;           Exchange four VDU variables; Plot character at graphics cursor
;           Graphics cursor handling; MODE 7 character conversion
;           Setup soft character definitions
; ($D060) Chapter 8: PLOT                                                         (1890 bytes)
;           OSBYTE 134; OSWORD 13; PLOT routine; Checking graphics cursor bounds
;           Coordinate conversion; PLOT line; Move graphics cursor; Copy VDU variables
;           PLOT lateral fill; PLOT fill triangle
; ($D7C2) Chapter 9: Cursor editing mode                                           (382 bytes)
;           OSBYTE 132, 133, 135; Cursor editing mode routines
; ($D940) Chapter 10: Resets                                                       (732 bytes)
;           OSBYTE 142; Default vector table; Default MOS variables table; Reset entry point
; ($DC1C) Chapter 11: Interrupt processing                                         (681 bytes)
;           OSBYTE 17; IRQ entry point; BRK handler; IRQ1, IRQ2 handlers; Display string
; ($DEC5) Chapter 12: Command Line Interpreter (star commands)                     (479 bytes)
;           OSBYTE 127, 139; OSRDCH entry point; OSCLI Handler; Table of star commands; *BASIC
;           Reading hex values from strings; Copyright string (backwards)
; ($E0A4) Chapter 13: Writing characters; printer; buffers                         (362 bytes)
;           OSBYTE 123, 156; OSWRCH entry point; Econet / User printer routines; Flush buffers
;           Count or purge buffer (CNPV); Append to buffer
; ($E20E) Chapter 14: Star commands                                                (933 bytes)
;           *LOAD; *SAVE; *SPOOL; *KEY; *FX; OSBYTE 119, 138, 145, 152, 153
;           Clear OSFILE address; Tables of buffer addresses; EVENT entry point
;           Remove from buffer (REMV); Insert into buffer (INSV)
; ($E5B3) Chapter 15: OSBYTE and OSWORD                                            (1360 bytes)
;           VDU 7; OSBYTE 0-14, 16, 18, 19, 117, 118, 124-126, 128-130, 136, 137, 144, 147, 149, 151, 154, 155, 160, 247
;           OSWORD 0-8; OSBYTE entry point; OSWORD entry point; *LINE; *CODE
;           Serial baud rate / sound buffer table; GSINIT; GSREAD
;           Keyboard handling routines
; ($EB03) Chapter 16: Sound and Speech                                             (983 bytes)
;           OSBYTE 158, 159; Sound and speech interrupt processing; ROM/PHROM read byte
; ($EEDA) Chapter 17: Keyboard processing                                          (603 bytes)
;           OSBYTE 15, 21, 120-122, 131; Keyboard processing, translation table, scanning code
;           KEYV entry point; Speech table; *HELP
; ($F135) Chapter 18: Tape and ROM Filing systems                                  (1107 bytes)
;           OSBYTE 140, 141, 143; OSARGS entry; OSFILE entry; OSFIND entry; OSBGET entry
;           OSBPUT entry; File system vector table; FSC entry point; Setup tape options
;           Load and save file; Copy filename; *RUN; *CAT; *OPT; Search for block; Open a file
;           Save a block to tape
; ($F588) Chapter 19: Low Level Tape Operations                                    (801 bytes)
;           Update ACIA; Check EOF; Search for file; Spool or Exec file; Load and save block
;           Load block header; Load and save byte; Update CRC
; ($F8A9) Chapter 20: Filing System Messaging and Error Reporting                  (575 bytes)
;           Print progress; Prompt to record on tape; Print four byte hex
;           Check for ESCAPE during tape operations; Load block from tape
;           Print following message; Data? File? Block? error messages
; ($FAE8) Chapter 21: More Low Level Tape Operations                               (280 bytes)
;           Setup, Claim, and Reset ACIA; Cancel tape operation
;           Activate / deactivate RTS; Zero checksum; Copy filename; Motor on/off
;           Check file is open; Send data to second processor; Setup for cassette write
; ($FC00) Chapter 22: Credits                                                      (768 bytes)
;           Credits string
; ($FF00) Chapter 23: Extended vectors                                             (167 bytes)
;           Extended vector entry points table; Extended vector handler
; ($FFA7) Chapter 24: OS entry points; Tube; FRED; JIM; SHEILA                      (89 bytes)
;           OSBYTE 146, 148, 150, 157; OS Entry points and 6502 Vectors (NMI, Reset, IRQ)
;         Chapter 25: Appendix
;           Circuit diagrams in vector format
;         Chapter 26: Index
;           Index of MOS features as they are seen by user programs
;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 1: Introduction
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; About this document
;
; See mos.png
;
; ***************************************************************************************
;
; This is a fully annotated reassembly of the operating system of the BBC Micro, v1.20.
;
; It attempts to explain every corner of the 16K ROM in some detail, hopefully throwing light
; onto often poorly understood sections, and in general to admire its vision, scope, ingenuity
; and succinctness. It also documents some of its few quirks / bugs. By creating this document
; I understand it a lot better now, and I hope that readers will gain some insight too.
;
; In the comments I often refer to 'NAUG' the 'New Advanced User Guide'
; see https://stardot.org.uk/forums/viewtopic.php?f=42&t=17243.
;
; This document was originally based on the annotated disassembly by Geoff Cox (Micronet,
; 1991) for which I am indebted. It has evolved considerably since it started development
; in late 2019, and development has continued well into 2020.
;
; Just as the BBC Micro hardware contained both innovation and also points of similarity
; with Acorn's System 2 to 5 and Atom microcomputers, so too the MOS operating system
; design shows clear signs of having evolved from their "monitors". As noted above, the
; Atom monitor occupied just 4K, and the System 2 was even smaller, at 2K: nevertheless
; they contributed design ideas to the MOS, and occasional "Historical Notes" below give
; details. The tiny System 1, a control keypad now best known for having appeared in an
; episode of "Blake's 7", had only 512 bytes of ROM and is not really in the same family.
;
; Thanks to Graham Nelson whose Inweb software is used to format/layout the HTML version of
; this document, and for his helpful comments, corrections and suggestions and to Adrian
; Nelson for more corrections and suggestions.
;
; tobymnelson@gmail.com

; ***************************************************************************************
;
; Building with the ACME Assembler
;
; ***************************************************************************************
;
; This document is downloadable ('os120_acme.a') in the syntax for the ACME assembler (as
; well as being browsable in HTML format).
;
; To assemble, producing os120.bin as a binary, and a report file os120_report.txt:
;
;       acme -r os120_report.txt -o os120.bin os120_acme.a
;
; When assembled it should produce a binary file that is byte for byte identical to the
; original OS1.20 ROM image. Its MD5 checksum is 0a59a5ba15fe8557b5f7fee32bbd393a
;
; To explain some perhaps non-obvious points of the ACME assembler syntax:
;
;     * When a branch uses the '+' symbol, the destination is the next     '+' label.
;     * When a branch uses the '-' symbol, the destination is the previous '-' label.
;     * Symbols '++' and '--' work similarly.
;     * !word outputs a 16 bit value as two bytes in little endian order
;     * !be16 outputs a 16 bit value as two bytes in big endian order
;     * ">.address" means the high byte of .address
;     * "<.address" means the low byte of .address
;
; To download the ACME assembler, see https://github.com/meonwax/acme
; To download this document as assembly language source, see os120_acme.a

; ***************************************************************************************
;
; The Machine Operating System (MOS)
;
; ***************************************************************************************
; An operating system initialises and keeps a computer running properly. This includes
; servicing requests from hardware in a timely manner. An OS also provides a standardised
; set of useful functionality available to user programs.
;
; The 6502 can directly address up to 64k of memory which is broadly assigned as follows:
;
;    $0000-$7FFF (32k) = RAM        (or $0000-$3FFF (16k) = RAM for Model A computer)
;    $8000-$BFFF (16k) = BASIC or other Paged ROM (aka "Sideways ROM")
;    $C000-$FFFF (16k) = Operating System ROM
;
; Each 256 bytes of memory is called a 'page', so addresses $0000 to $00FF is called 'page
; zero', $0100-$01FF is 'page one', etc. Page zero is also known as 'zero page'.
;
; See circuit_mos.png

; ***************************************************************************************
;
; Memory Mapped IO ($FC00-$FEFF)
;
; ***************************************************************************************
; Addresses in the range $FC00-$FEFF are not mapped to the OS ROM as might be expected, but
; are connected to hardware devices. Consequently the CPU can communicate with hardware
; devices by reading and writing to specific addresses in this range.
;
; See Chapter 3.

; ***************************************************************************************
;
; The Internal Hardware We Talk Directly To (via SHEILA)
;
; We use an area of memory mapped I/O called SHEILA ($FE00-$FEFF) to talk to hardware devices
; inside the computer:
;
; Chip              What it does
; ---------------------------------------------------------------------------------------
; CRTC 6845         Cathode Ray Tube Controller. Handles the video screen format and the
;                   cursor height.
; ACIA 6850         } The ACIA and Serial ULA together control the RS-423 and cassette,
; Serial ULA        } including serial printers connected to the RS-423 port.
; Video ULA         Controls video output: timing, logical and physical colours, cursor width.
; System VIA 6522   Controls Sound, Speech, Keyboard, and selects one of four screen hardware
;                   addresses for scrolling purposes
; User VIA 6522     Parallel Printer (Port A) and User Port (Port B).
; ADC 7002          Analogue to Digital Convertor. Analogue input, often for Joysticks.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Power On / Reset
;
; ***************************************************************************************
; When powered on or reset (via the BREAK key) the 6502 executes code at the address
; retrieved from $FFFC/D (See .resetEntryPoint).
; The 'BREAK' key causes a soft reset. 'CTRL BREAK' causes a hard reset. A hard reset
; clears RAM and resets more of the OS variables.

; ***************************************************************************************
;
; Interrupts
;
; ***************************************************************************************
; The BBC Micro is a single processor with no threads or job queues. It uses interrupts
; to run code concurrently with regular code. Interrupt code must finish executing in a
; short amount of time to allow the system to continue updating effectively. Acorn
; recommends it should last less than 2ms (4000 clock cycles).
;
; The CPU receives interrupts generated by hardware devices when they need attention.
;
; There are three interrupt types (NMI; IRQ1; IRQ2)
;
; NMI = non-maskable interrupts
;   These are the highest priority of interrupt. They cannot be disabled. They are only
;   produced by certain additional hardware (hard disk controllers and Econet).
;   When an NMI is generated the 6502 interrupts its normal operation and executes from
;   the location given in the OS at $FFFA-B (i.e. $0D00 = .nmiEntryPoint). This is the
;   NMI handling code. By default this just returns immediately by executing an RTI
;   instruction.
;
; IRQ1 = interrupt request 1
;   This occurs when hardware generates an IRQ, or a BRK instruction occurs. The OS uses
;   this IRQ extensively. If a BRK instruction was the cause then the BRKV vector is used
;   to handle it (the OS uses this to output error messages). Otherwise the operating
;   system checks each hardware in turn to see what needs attention. The OS services the
;   RS-423, cassette, vertical sync, 100Hz timer, interval timer, ADC conversion (e.g. used
;   for analogue joysticks), keyboard, speech (if speech hardware is present), and printer
;   as needed. Based on the 100Hz timers, it also updates sounds and updates the flashing
;   colours.
;
;   Finally any unhandled interrupt gets passed on to IRQ2.
;
; IRQ2 = interrupt request 2
;   This is available for user code to intercept unhandled interrupts. It is the lowest
;   priority of interrupt.
;
; Calls to IRQ1 and IRQ2 handlers are indirected through 'vectors' (2 byte addresses
; stored in RAM at $0200 upwards), meaning the user can intercept them and do their own
; processing (often then passing through any unwanted interrupts back into the original
; default interrupt routine). NMIs cannot be redirected.

; ***************************************************************************************
;
; BRK instruction
;
; ***************************************************************************************
; The BRK instruction is used for error handling. It pushes the program counter and flags
; onto the stack (including a set bit for the BRK flag) and starts executing from the address
; stored at $FFFE/F (which is set to .irqEntryPoint).
;
; The OS uses BRK to display error messages (as does the BASIC ROM). The BRK instruction
; is followed by an error number then the error string to display. The .brkHandler code
; displays the error message then enters the current language. Typically though, as soon
; as the machine has started up it will be running a language such as BASIC. BASIC installs
; its own BRK handler, at which point the OS BRK handler is no longer used.
;
; Note that the BRK instruction is unrelated to the BREAK key. Pressing BREAK causes the 6502
; to RESET.

; ***************************************************************************************
;
; Paged ROMs (aka "Sideways" ROMs)
;
; ***************************************************************************************
; Functionality of the BBC Micro can be extended via the use of Paged ROMs. These ROMs
; can be quickly switched ('paged in') into the memory map as needed at address range
; $8000-$BFFF. Once the ROM code has finished executing the ROM is 'paged out' and the
; previous ROM reinstated into the memory map (which is normally the current language, often
; BASIC).
;
; Paged ROMs can implement programming languages, provide more commands (star commands) to
; the user, or even act as a Read Only filing system (using ROMFS).
;
; An optional speech ROM is also supported, which generates speech from text. It is used
; alongside a Phrase ROM or 'PHROM' that provides the word and phoneme data for generating
; speech.
;
; The BBC Micro has 5 ROM sockets available for Paged ROMs (and the MOS supports up to 16 with
; some additional hardware). In a default configuration (as shipped) the first two ROM sockets
; hold the OS and BASIC.
;
; 'Sideways RAM'
; Later in the BBC Micro's life it was discovered that you could add 'Sideways RAM' instead
; of a ROM. This requires a write signal as the BBC Micro is hard-wired to prevent writing to
; the Sideways area.
;
; A common 'Sideways RAM' implementation consists of an expansion board (aka 'daughter board')
; that plugs into a ROM socket with a flying lead connected to the motherboard. This can
; then be used as either additional program RAM or (perhaps more often) to hold a ROM image.

; ***************************************************************************************
;
; Calling the Operating System
;
; ***************************************************************************************
; There is a standard set of specific addresses (high in memory, between $FFB9 and $FFF7)
; that the user calls to access OS routines. These are detailed below.
;
; The following entry points are the API for user programs, or other ROMs, which want to
; access MOS facilities. Note that they occur at addresses which are guaranteed not to
; change: for example, in all versions of the MOS, OSBYTE is at $FFF4. It is therefore safe
; for a user program to 'JSR .OSBYTE' without knowing which MOS version is present. No other
; addresses in the ROM are safe to jump to from outside the ROM.
;
; Many of these calls are then indirected through a set of 'standard vectors' located in RAM
; at $0200-$0235. A vector is a two byte address. By default each vector contains the address
; within the OS ROM of the relevant routine. Advanced users can change a vector to point to
; their own routine in RAM to handle the call. This allows the user to extend or replace the
; existing functionality provided by the OS.
;
; If a Paged ROM wishes to change the vectors (for example a filing system ROM would want to
; redirect filing system calls to its own routines within its ROM) then a different system of
; overriding these vectors is used. See the 'Extended Vectors' section below.
;
; Incidentally the 6502 based Commodore computers from the Commodore PET, the VIC 20 through
; to the Commodore 64 have a similar arrangement of vectors, with its KERNAL functions.
; See https://www.pagetable.com/?p=926 .

; ***************************************************************************************
;
; OSWRCH (For displaying text and graphics) ($FFEE)
;
; ***************************************************************************************
; OSWRCH is generally used to output text or graphics. Output is usually sent to the screen,
; but it can be redirected to other output devices, such as a printer or a file.
;
; OSWRCH is the equivalent of the 'VDU' command from BASIC, which we use here for brevity.
;
; VDU 32-126 shows ASCII text characters on screen.
; VDU 127 is delete, which removes the previous character.
; VDU 128-255 displays custom characters on screen (or Teletext codes in MODE 7).
; VDU 0-31 have individual special meanings, and often require more VDU calls that act as
; parameters. For example VDU 22 is the code to change display MODE. Calling this does
; nothing on it's own, as it's waiting for the next VDU call (e.g. VDU 2) specifying the
; MODE number to change to.
;
; Complex code is found within VDU 25 (the equivalent of BASIC's PLOT command) and is used
; to plot points, lines, dotted lines, filled triangles, and perform horizontal line fills.
; See Chapter 8.
;
; Because OSWRCH does so much, a large chuck (37%) of the operating system is devoted to it.
;
; See .oswrchEntryPoint.
;
; The BBC Micro defines eight screen MODEs (0-7) each with different combinations of pixel
; resolutions, colours, text vs graphics capability, and therefore memory usage.

; ***************************************************************************************
;
; OSRDCH ($FFE0)
;
; ***************************************************************************************
; Reads a character from the keyboard (or other input source such as RS-423 or file).
; See .osrdchEntryPoint.

; ***************************************************************************************
;
; OSBYTE ($FFF4) (aka *FX)
;
; ***************************************************************************************
; OSBYTE provides a wide range of miscellaneous functionality. This can be accessed from
; BASIC as a '*FX' command. For example:
;
;   *FX 12,2
;
; sets the keyboard auto-repeat rate to a faster value than the default. This is equivalent
; to the assembler version:
;
;   LDA #12
;   LDX #2
;   JSR .OSBYTE
;
; The A,X,Y registers are the parameters to this call to the OS. Register 'A' determines
; the type of the call, and X and Y are the parameters for that type.
; See .osbyteEntryPoint.

; ***************************************************************************************
;
; OSWORD ($FFF1)
;
; ***************************************************************************************
; Some calls to the OS needs more parameters than an OSBYTE can provide. In this case OSWORD
; is used. Registers X and Y together form an address that holds a parameter block of data
; specific to the type of OSWORD given by register 'A'.
;
; OSWORD calls are available to machine code programs but there is no equivalent star
; command like *FX.
; See .oswordEntryPoint.
; See .osbyteAndOSWORDRoutineTable (end of table for OSWORD entry points)

; ***************************************************************************************
;
; Filing System ($FFCE - $FFDD)
;
; ***************************************************************************************
; A filing system is selected via a star command. The OS ships with support for tape (*TAPE)
; and ROM filing systems (*ROM). Support for other filing systems (e.g. *ADFS, the
; Advanced Disk Filing System) can be added using Paged ROMs. There is a range of OS calls
; designed to perform operations on the current filing system:
;
;           OSFIND ($FFCE) - Open or close a file (See .osfindEntryPoint)
;           OSGBPB ($FFD1) - Read / write multiple bytes to an open file. This is not
;                            implemented in this OS for the TAPE/ROM filing systems.
;                            Filing System Paged ROMs implement this.
;           OSBPUT ($FFD4) - Write a single byte to an open file (See .osbputEntryPoint)
;           OSBGET ($FFD7) - Read a single byte to an open file (See .osbgetEntryPoint)
;           OSARGS ($FFDA) - Read / write a file's attributes (See .osargsEntryPoint)
;           OSFILE ($FFDD) - Load / Save an entire file (See .osfileEntryPoint)

; ***************************************************************************************
;
; OSCLI (aka 'star commands') ($FFF7)
;
; ***************************************************************************************
; The OS is shipped with a Command Line Interpreter (CLI). This is a primitive form of
; shell. Commands can be accessed from BASIC or via the OSCLI routine.
;
; BASIC prefixes these with an asterisk, e.g. '*FX' etc. Hence these commands are known as
; 'star commands'. OSCLI executes a command supplied as a string. The OS provides a standard
; set, and Paged ROMs can add more.
; See .oscliEntryPoint.
; See .starCommandTable.
;
; ***************************************************************************************
;
; Others
;
; ***************************************************************************************
; OSRDRM ($FFB9)                  - Read byte from Paged ROM (new in MOS 1.20)
;                                   (See .osrdrmEntryPoint)
; VDUCHR ($FFBC)                  - A cut down form of OSWRCH just for writing to the screen
;                                   (See .vduChrEntryPoint)
; OSEVEN ($FFBF)                  - Generates an EVENT, a kind of managed interrupt
;                                   (See .eventEntryPoint)
; GSINIT ($FFC2) / GSREAD ($FFC5) - Parse a string in memory (e.g. from an OSCLI command)
;                                   (See .gsinitEntryPoint)
; NVRDCH ($FFC8) / NVWRCH ($FFCB) - Non vectored versions of OSRDCH / OSWRCH
; OSASCI ($FFE3)                  - Write character using OSWRCH, or write CR/LF if CR found
;                                   (See .OSASCI)
; OSNEWL ($FFE7)                  - Write CR/LF (See .OSNEWL)

; ***************************************************************************************
;
; Extended vectors
;
; ***************************************************************************************
; Extended vectors allow Paged ROMs to intercept the standard vectors at $0200 upwards,
; effectively getting them to point to an address *within a specified Paged ROM*.
; A table containing 27 entries is stored at $0D9F (.extendedVectorSpace) with 3 bytes per
; entry:
;      the two byte address
;      a single byte holding the ROM number
;
; To use an extended vector write appropriate values into these locations, then store
; the address '$FF00+3*N' in OS vector at '$0200+2*N' (remembering the old address at
; $0200+2*N if required).
; See Chapter 23.

; ***************************************************************************************
;
; Memory Map for RAM
;
; ***************************************************************************************
; $0000-$008F   Current language workspace
; $0090-$009F   Econet workspace
; $00A0-$00A7   NMI workspace       [unused by the OS, can be used by Paged ROMs]
; $00A8-$00AF   "OS temp workspace" [unused by the OS, can be used by Paged ROMs]
; $00B0-$00CF   Filing System workspace
; $00D0-$00FF   VDU/OS workspace
; $0100-$01FF   6502 stack (the stack works downwards from $01FF)
; $0200-$0235   OS vectors
; $0236-$02FF   OS variables
; $0300-$037F   VDU variables
; $0380-$03DF   Cassette Filing System workspace
; $03E0-$03FF   Keyboard input buffer
; $0400-$07FF   Workspace for the currently active language (e.g. BASIC)
; $0800-$08FF   Sound workspace; Sound buffers; Printer buffer; Envelope storage
; $0900-$09FF   Envelope/Speech/Cassette buffers
; $0A00-$0AFF   Cassette/RS-423 input buffer
; $0B00-$0BFF   Soft key buffer
; $0C00-$0CFF   Soft character ('font') definitions
; $0D00-$0D9E   NMI routine (used by Disc Controllers and Econet)
; $0D9F-$0DEF   Expanded vector set
; $0DF0-$0DFF   Paged ROM workspace storage locations
; $0E00-$7FFF   Available user memory
;
; Available user memory starts at $0E00 for a standard TAPE based machine. At reset time,
; Paged ROMs such as disc controllers can request more RAM pages from $0E00 upwards. This
; will commonly raise the start of user memory to $1900. Soft character definitions (aka
; 'font explosions') also raise the start of available memory.
; See .osbyte20EntryPoint
;
; OSBYTE 131 reads the current OSHWM (OS High Water Mark), the true address of the start
; of user memory after ROMs and font explosions have claimed memory. This often has the
; same value as the PAGE variable in BASIC (unless PAGE is manually changed), which is
; where BASIC programs are located.
; See .osbyte131EntryPoint
; See .currentOSHWM

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 2: Memory Layout and Constants
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Constants
;
; The following sections list all the constants used. This is followed by the memory
; addresses used, see .fileWorkspaceA.
;
; ***************************************************************************************

; ***************************************************************************************
;
; Characters (VDU codes)
;
; ***************************************************************************************
.charBELL                                   = 7         ; (CTRL-G)
.charBACKSPACE                              = 8         ;
.charLINEFEED                               = 10        ;
.charRETURN                                 = 13        ;
.charDisableVDUOrDeleteLine                 = 21        ; (CTRL-U)
.charESCAPE                                 = 27        ;
.charSPACE                                  = 32        ;
.charEXCLAMATIONMARK                        = 33        ; !
.charDOUBLEQUOTE                            = 34        ; "
.charSTAR                                   = 42        ; *
.charPLUS                                   = 43        ; +
.charCOMMA                                  = 44        ; ,
.charDOT                                    = 46        ; .
.charFORWARDSLASH                           = 47        ; /
.charZERO                                   = 48        ; 0
.charNINE                                   = 57        ; 9
.charQUESTIONMARK                           = 63        ; ?
.charAT                                     = 64        ; @
.charA                                      = 65        ; A
.charF                                      = 70        ; F
.charZ                                      = 90        ; Z
.charUNDERSCORE                             = 95        ; _
.charPOUND                                  = 96        ; £
.charBAR                                    = 124       ; |
.charDELETE                                 = 127       ;
.charCOPY                                   = $87       ; (character equivalent of the COPY key)
.charKEY10                                  = $CA       ; (character equivalent of code used for *KEY 10)

; ***************************************************************************************
;
; Internal key codes
;
; The internal key code for the space bar is inserted into the first key pressed
; (.firstKeyPressedInternal) on RESET. Otherwise, for example if SHIFT remained in the
; 'first key pressed' after a RESET then the next key press might be misinterpreted as a
; SHIFTed character.
;
; In general the internal key codes are converted to ASCII style codes using a table lookup,
; see .getASCIICode
;
; ***************************************************************************************
.internalKeyNumberSPACEBAR                  = $62       ;

; ***************************************************************************************
;
; Buffer numbers
;
; See NAUG Section 9, Page 136
;
;                                Address         Empty     Start      End
;         Buffer number          Range           Flag      pointer    pointer   Size
;         --------------------------------------------------------------------------------
;         0 = Keyboard           $03E0-$03FF     $02CF     $02D8      $02E1       32 bytes
;         1 = RS-423 Input       $0A00-$0AFF     $02D0     $02D9      $02E2      256 bytes
;         2 = RS-423 Output      $0900-$09BF     $02D1     $02DA      $02E3      192 bytes
;         3 = Printer            $0880-$08BF     $02D2     $02DB      $02E4       64 bytes
;         4 = Sound Channel 0    $0840-$084F     $02D3     $02DC      $02E5       16 bytes
;         5 = Sound Channel 1    $0850-$085F     $02D4     $02DD      $02E6       16 bytes
;         6 = Sound Channel 2    $0860-$086F     $02D5     $02DE      $02E7       16 bytes
;         7 = Sound Channel 3    $0870-$087F     $02D6     $02DF      $02E8       16 bytes
;         8 = Speech             $08C0-$08FF     $02D7     $02E0      $02E9       64 bytes
;
; ***************************************************************************************
.bufferNumberKeyboard                       = 0         ;
.bufferNumberRS423Input                     = 1         ;
.bufferNumberRS423Output                    = 2         ;
.bufferNumberPrinter                        = 3         ;
.bufferNumberSound0                         = 4         ; Noise channel
.bufferNumberSound1                         = 5         ;
.bufferNumberSound2                         = 6         ;
.bufferNumberSound3                         = 7         ;
.bufferNumberSpeech                         = 8         ;
.bufferNumberHighest                        = 8         ;

; Buffer offsets. When we add the buffer length it sums to 256.
.keyboardInputBufferOffset                  = 256 - 32  ;  32 bytes
.tapeOrRS423InputBufferOffset               = 256 - 256 ; 256 bytes
.rs423OutputBufferOffset                    = 256 - 192 ; 192 bytes
.printerBufferOffset                        = 256 - 64  ;  64 bytes
.soundChannel0BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel1BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel2BufferOffset                  = 256 - 16  ;  16 bytes
.soundChannel3BufferOffset                  = 256 - 16  ;  16 bytes
.speechBufferOffset                         = 256 - 64  ;  64 bytes

; ***************************************************************************************
;
; Event Types
;
; For information on Events see .eventEntryPoint
;
; ***************************************************************************************
.eventOutputBufferBecomesEmpty              = 0         ; X = buffer number
.eventInputBufferBecomesFull                = 1         ; X = buffer number, Y = character that can't be inserted
.eventCharacterEnteringInputBuffer          = 2         ; Y = ASCII value of character
.eventADCConversionComplete                 = 3         ; Y = ADC channel number
.eventStartOfVSync                          = 4         ;
.eventIntervalTimerCrossingZero             = 5         ; as used by OSWORD 3 / OSWORD 4
.eventESCAPEConditionDetected               = 6         ;
.eventRS423ErrorDetected                    = 7         ; X = ACIA 6850 status register
                                                        ; shifted right once
                                                        ; (see .acia6850StatusRegister)
                                                        ; Y = character received
.eventEconetEvent                           = 8         ; Econet event detected
.eventUserEvent                             = 9         ; For user events

; ***************************************************************************************
;
; CRTC registers
;
; See 6845.png
;
; These 18 registers are mostly write only
; See NAUG Section 13.3.3, Page 190
;
; Register  Description                             Default value for MODE
;                                              0     1     2     3     4     5     6     7
; ----------------------------------------------------------------------------------------
; R0        Horizontal total                 127   127   127   127    63    63    63    63
; R1        Characters per line               80    80    80    80    40    40    40    40
; R2        Horizontal sync position          98    98    98    98    49    49    49    51
; R3        Horizontal sync width (bits 0-3)   8     8     8     8     4     4     4     4
;           + Vertical sync width (bits 4-7)   2     2     2     2     2     2     2     2
; R4        Vertical total                    38    38    38    30    38    38    30    30
; R5        Vertical total adjust              0     0     0     2     0     0     2     2
; R6        Vertical displayed characters     32    32    32    25    32    32    25    25
; R7        Vertical sync position            34    34    34    27    34    34    27    27
; R8        Interlace mode (bits 0,1)          1     1     1     1     1     1     1     3
;           + Display delay (bits 4,5)         0     0     0     0     0     0     0     1
;           + Cursor delay (bits 6,7)          0     0     0     0     0     0     0     2
; R9        Scan lines per character           7     7     7     9     7     7     9    18
; R10       Cursor start (bits 0-4)            7     7     7     7     7     7     7    18
;           Cursor type (bit 5)                1     1     1     1     1     1     1     1
;           Cursor blink (bit 6)               1     1     1     1     1     1     1     1
; R11       Cursor end                         8     8     8     9     8     8     9    19
; R12,R13   Screen start address / 8           -     -     -     -     -     -     -     -
; R14,R15   Cursor position                    -     -     -     -     -     -     -     -
; R16,R17   Light pen position                 -     -     -     -     -     -     -     -
;
; R0    = The total number of 'character time units' across the screen - 1 (including
;         non-displayed characters)
; R1    = Number of displayed characters across the screen
; R2    = Horizontal sync pulse (changing this moves the screen left/right)
; R3    = Horz/Vert sync pulse width. Not advisable to change since most TVs/monitors require
;         the standard values.
; R4/R5 = (Integer) number of character rows (R4) + (fractional) number of scan lines (R5)
;         to make a 50Hz refresh rate.
; R6    = Number of displayed character rows
; R7    = Vertical sync position in character rows (moves display up and down by character
;         rows. Used by *TV)
; R8    = bits 0-1 = interlacing (0 or 2 = non interlaced; 1 = interlaced; 2 = interlace and
;         video for MODE 7 support)
;         bits 2-3 = unused
;         bits 4-5 = display blanking delay (0 = no delay; 1 = one character delay; 2 = two
;         character delay; 3 = disable video output)
;         bits 6-7 = cursor blanking delay (0 = No delay; 1 = one character delay; 2 = two
;         character delay; 3 = disable cursor output)
; R9    = scan lines per character - 1
; R10   = cursor start register
;           bit 7 = unused
;           bit 6 = enable / disable blinking
;           bit 5 = blink rate (fast when set)
;           bits 0-4 = cursor start scan line
; R11   = bits 0-4 = cursor end scan line
; R12/R13 = When setting R12/R13 the value to set is related to the screen start address as
; follows:
;
; MODE 0-6: set (screen address / 8)
;   MODE 7: set (screen address - $7400 EOR $2000)
;
; The same logic applies to setting R14/R15 (cursor position)
;
; R16/R17 = light pen position. See NAUG Section 13.3.9, Page 196.
;
; The CRTC registers can be set directly by writing to memory mapped IO. Write the register
; to change in .crtcAddressRegister ($FE00) then write the new value in .crtcAddressWrite
; ($FE01). (The OS sets these registers in .setCRTCRegisterDirect and .setTwoCRTCRegisters)
;
; A more OS friendly method is to use "VDU 23,0,R,V,0,0,0,0,0,0" to set register R to value V.
;
; ***************************************************************************************
.crtcHorizontalTotalRegister                = 0         ;
.crtcHorizontalDisplayedRegister            = 1         ;
.crtcHorizontalSyncPositionRegister         = 2         ;
.crtcSyncWidthRegister                      = 3         ;
.crtcVerticalTotalRegister                  = 4         ;
.crtcVerticalTotalAdjustRegister            = 5         ;
.crtcVerticalDisplayedCharactersRegister    = 6         ;
.crtcVerticalSyncPositionRegister           = 7         ;
.crtcInterlaceAndDelayRegister              = 8         ;
.crtcScanLinesPerCharacterRegister          = 9         ;
.crtcCursorStartRegister                    = 10        ;
.crtcCursorEndRegister                      = 11        ;
.crtcStartScreenAddressHighRegister         = 12        ;
.crtcStartScreenAddressLowRegister          = 13        ;
.crtcCursorPositionHighRegister             = 14        ;
.crtcCursorPositionLowRegister              = 15        ;
.crtcLightPenPositionHighRegister           = 16        ;
.crtcLightPenPositionLowRegister            = 17        ;

; ***************************************************************************************
;
; Paged ROM service calls
;
; See NAUG Section 17, Page 295
; See .osbyte143EntryPoint
;
; ***************************************************************************************
.romServiceCallAbsoluteWorkspaceClaim          = $01    ; memory used only when ROM is paged in
.romServiceCallPrivateWorkspaceClaim           = $02    ; memory used even when ROM is not paged in
.romServiceCallAutoBoot                        = $03    ;
.romServiceCallUnrecognisedCommand             = $04    ; star command not recognised
.romServiceCallUnrecognisedInterrupt           = $05    ;
.romServiceCallBreakInstruction                = $06    ;
.romServiceCallUnrecognisedOSBYTE              = $07    ;
.romServiceCallUnrecognisedOSWORD              = $08    ;
.romServiceCallHelp                            = $09    ;
.romServiceCallClaimStaticWorkspace            = $0A    ; (Issued by paged ROMs, not the OS)
.romServiceCallNMIRelease                      = $0B    ; (Issued by paged ROMs, not the OS)
.romServiceCallNMIClaim                        = $0C    ; (Issued by paged ROMs, not the OS)
.romServiceCallROMFilingSystemInitialize       = $0D    ;
.romServiceCallROMFilingSystemByteGet          = $0E    ;
.romServiceCallVectorsClaimed                  = $0F    ; Used when a filing system starts
.romServiceCallSpoolExecClosureWarning         = $10    ;
.romServiceCallFontImplosionExplosionWarning   = $11    ;
.romServiceCallInitialiseFilingSystem          = $12    ; (Issued from paged ROMs, not the OS)
.romServiceCallTubeSystemPostInitialisation    = $FE    ;
.romServiceCallTubeMainInitialisation          = $FF    ;

; ***************************************************************************************
;
; The Tube - Service calls
;
; See NAUG Section 18.8, Page 338
;
; ***************************************************************************************
.tubeClaimReasonCode                        = $C0       ;
.tubeCallerIDCassetteFS                     = $00       ;
.tubeCallerIDDiscFS                         = $01       ;
.tubeCallerIDEconetLowLevelPrimitives       = $02       ;
.tubeCallerIDEconetHighLevelPrimitives      = $03       ;

; ***************************************************************************************
;
; Tape / ROM filing system synchronisation bytes
;
; See NAUG Section 16.3.1, Page 263 for tape header
; See NAUG Section 17.5.6, Page 317 for ROM header
;
; ***************************************************************************************
.fsSynchronisationByte                      = $2A       ; Tape or ROM filing system synchronisation byte
.romFSMiddleBlockHeaderByte                 = $23       ; ROM filing system header byte
.romFSFinalBlockHeaderByte                  = $2B       ; ROM filing system header byte


; ***************************************************************************************
;
; Memory addresses
;
; For the remainder of this chapter all constants refer to addresses in memory.
;
; See ram.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Zero Page Addresses ($00B0-$00FF)
;
; ***************************************************************************************
.fileWorkspaceA                             = $B0       ; }
.fileWorkspaceB                             = $B1       ; } workspace values are used while we
.fileWorkspaceC                             = $B2       ; } load or save to the tape or ROM
.fileWorkspaceD                             = $B3       ; } file system. They hold different
.fileWorkspaceE                             = $B4       ; } values when saving vs. loading.
.fileWorkspaceF                             = $B5       ; } See uses below.
.fileWorkspaceG                             = $B6       ; }
.fileWorkspaceH                             = $B7       ; }

; when loading from tape or ROM we store the load address, current and next block numbers:
.loadAddressLow                             = .fileWorkspaceA ;
.loadAddressMid1                            = .fileWorkspaceB ;
.loadAddressMid2                            = .fileWorkspaceC ;
.loadAddressHigh                            = .fileWorkspaceD ;

.currentBlockNumberLow                      = .fileWorkspaceE ;
.currentBlockNumberHigh                     = .fileWorkspaceF ;

.nextBlockNumberLow                         = .fileWorkspaceG ;
.nextBlockNumberHigh                        = .fileWorkspaceH ;

; when saving to tape we store the current start address and end address:
.tapeSaveStartAddressLow                    = .fileWorkspaceA ;
.tapeSaveStartAddressMid1                   = .fileWorkspaceB ;
.tapeSaveStartAddressMid2                   = .fileWorkspaceC ;
.tapeSaveStartAddressHigh                   = .fileWorkspaceD ;

.tapeSaveEndAddressLow                      = .fileWorkspaceE ;
.tapeSaveEndAddressMid1                     = .fileWorkspaceF ;
.tapeSaveEndAddressMid2                     = .fileWorkspaceG ;
.tapeSaveEndAddressHigh                     = .fileWorkspaceH ;


.printMessageAddressLow                     = $B8       ; } stores either the address of an
.printMessageAddressHigh                    = $B9       ; } error routine, or the return
                                                        ; } address after printing a message.

.currentBlockHasDataErrorFlag               = $BA       ; set to $FF if the header of the
                                                        ; current block was read OK, but there
                                                        ; has been a data checksum error when
                                                        ; reading the actual data from the
                                                        ; current block. Otherwise $00.
                                                        ; Used to know whether to display the
                                                        ; 'Rewind tape' message.
                                                        ; See .postFileError.
.tapeCurrentOptionsByte                     = $BB       ; current options for the tape
                                                        ; filing system. See .tapeOptionsByte
                                                        ; below.
                                                        ;
                                                        ; options are in the top four bits:
                                                        ;   bit 4 = Abort bit
                                                        ;   bit 5 = Retry bit
                                                        ;   bit 6 }
                                                        ;   bit 7 } Message type:
                                                        ;
                                                        ;       00 = no messages
                                                        ;       10 = short messages
                                                        ;       11 = long messages
                                                        ;
                                                        ; Bits   Errors     Message Type
                                                        ; --------------------------------
                                                        ; 0000   Ignore     no messages
                                                        ; 0001   Abort      no messages
                                                        ; 0010   Retry      no messages
                                                        ; 1000   Ignore     short messages
                                                        ; 1001   Abort      short messages
                                                        ; 1010   Retry      short messages
                                                        ; 1100   Ignore     long messages
                                                        ; 1101   Abort      long messages
                                                        ; 1110   Retry      long messages

.fsTempStorage                              = $BC       ; temporary storage used by filing
                                                        ; system routines
.fsCharacterJustReadOrCharToWrite           = $BD       ;
.tapeChecksumLow                            = $BE       ; }
.tapeChecksumHigh                           = $BF       ; } CRC checksum
.fsGotACharacterToReadOrWriteFlag           = $C0       ; the top bit is set when a byte of
                                                        ; data from tape or ROM has (a) been
                                                        ; read or (b) is ready to write to
                                                        ; tape, and is ready to be processed.
                                                        ; The value of the byte is stored in
                                                        ; .fsCharacterJustReadOrCharToWrite
.checksumIsValidFlag                        = $C1       ; non-zero value indicates an error
.fsReadProgressState                        = $C2       ; current state of reading from tape
                                                        ; or ROM filing system (0-5)
                                                        ; See .postReadByte
.tapeCurrentFileHandle                      = $C3       ; handle for currently open file
.tapeLastBputValue                          = $C4       ; Last byte BPUT, see .osbputEntryPoint

.unusedC5                                   = $C5       ; [unused]

.tapeBaudRate                               = $C6       ; current cassette baud rate:
                                                        ; 5 for 1200 baud
                                                        ; 6 for 300 baud
.tapeInterBlockGap                          = $C7       ; current duration (in tenths of a
                                                        ; second) of the gap between blocks
                                                        ; of data when saving to tape.
.osfileBlockAddressLow                      = $C8       ; } Address of parameter block for
.osfileBlockAddressHigh                     = $C9       ; } OSFILE
.tapeSendingFlag                            = $CA       ; non-zero = currently sending to tape
.tapeCRCBitCounter                          = $CB       ; loop counter when calculating CRC
.tapeFileLengthLow                          = $CC       ; } temporarily stores the file length
.tapeFileLengthHigh                         = $CD       ; } before writing it into the OSFILE
                                                        ; } parameter block

.unusedCE                                   = $CE       ; [unused]
.unusedCF                                   = $CF       ; [unused]

.vduStatusByte                              = $D0       ; Each bit holds part the VDU status:
                                                        ; bit 0 = printer enable
                                                        ; bit 1 = scrolling disabled
                                                        ; bit 2 = paged scrolling selected
                                                        ; bit 3 = software scrolling (text window)
                                                        ; bit 4 = not used
                                                        ; bit 5 = graphics cursor enabled (VDU 5)
                                                        ; bit 6 = separated cursors
                                                        ; bit 7 = VDU disabled
.vduCurrentPlotByteMask                     = $D1       ; bits to write a pixel within a byte

.vduTextColourByteOR                        = $D2       ; } bytes to implement current foreground
.vduTextColourByteEOR                       = $D3       ; } and background text colours

.vduGraphicsColourByteOR                    = $D4       ; } bytes to implement current GCOL
.vduGraphicsColourByteEOR                   = $D5       ; } mode and graphics colours

.vduScreenAddressOfGraphicsCursorCellLow    = $D6       ; } address of the top of the cell
.vduScreenAddressOfGraphicsCursorCellHigh   = $D7       ; } on screen containing the graphics
                                                        ; } cursor position

.vduWriteCursorScreenAddressLow             = $D8       ; } address of the top of the cell
.vduWriteCursorScreenAddressHigh            = $D9       ; } on screen for the write cursor

.vduTempStoreDA                             = $DA       ; }
.vduTempStoreDB                             = $DB       ; }
.vduTempStoreDC                             = $DC       ; } store for temporary values,
.vduTempStoreDD                             = $DD       ; } used in multiple VDU related
.vduTempStoreDE                             = $DE       ; } functions.
.vduTempStoreDF                             = $DF       ; }

.vduMultiplicationTableLow                  = $E0       ; stores which multiplication table
.vduMultiplicationTableHigh                 = $E1       ; to use
.fsStatusByte                               = $E2       ; bit 0  input file open
                                                        ; bit 1  output file open
                                                        ; bit 2  not used
                                                        ; bit 3  current CATalogue status
                                                        ; bit 4  not used
                                                        ; bit 5  not used
                                                        ; bit 6  EOF reached
                                                        ; bit 7  EOF warning given

.tapeOptionsByte                            = $E3       ; options for the tape filing
                                                        ; system
                                                        ;
                                                        ; we store two sets of options, one
                                                        ; for LOAD and SAVE operations on a
                                                        ; whole file (top four bits), and
                                                        ; the other for 'sequential access'
                                                        ; byte by byte (lower four bits).
                                                        ;
                                                        ; Only one of these two sets of
                                                        ; options is active at one time.
                                                        ; These are stored in the top
                                                        ; four bits of .tapeCurrentOptionsByte.
                                                        ; See .tapeCurrentOptionsByte.
                                                        ;
                                                        ;   bit 0/4 = Abort bit
                                                        ;   bit 1/5 = Retry bit
                                                        ;   bit 2/6 }
                                                        ;   bit 3/7 } Message type:
                                                        ;
                                                        ;       00 = no messages
                                                        ;       10 = short messages
                                                        ;       11 = long messages
                                                        ;
                                                        ; Bits   Errors     Message Type
                                                        ; --------------------------------
                                                        ; 0000   Ignore     no messages
                                                        ; 0001   Abort      no messages
                                                        ; 0010   Retry      no messages
                                                        ; 1000   Ignore     short messages
                                                        ; 1001   Abort      short messages
                                                        ; 1010   Retry      short messages
                                                        ; 1100   Ignore     long messages
                                                        ; 1101   Abort      long messages
                                                        ; 1110   Retry      long messages

.stringInputOptions                         = $E4       ; When parsing an input string
                                                        ; bit 7 = double-quote character found at start
                                                        ; bit 6 = space character is not a terminator
                                                        ; See .gsinitEntryPoint
.starCommandYParameter                      = $E4
.stringInputPlingFlag                       = $E5       ; When parsing an input string
                                                        ; $80 if previous character is '!'
                                                        ; $00 otherwise
.starCommandXParameter                      = $E5
.readCharacterTimedFlag                     = $E6       ; 0 means read key instantly
                                                        ; 255 means read key timed
.tempWorkspaceE6                            = $E6       ; general workspace
.currentStringPointer                       = $E6       ; offset within command string

.autorepeatCountdownTimer                   = $E7
.osword0BufferAddressLow                    = $E8       ; reading line of input by OSWORD 0
.osword0BufferAddressHigh                   = $E9       ;
.rs423TimeoutCounter                        = $EA       ;  1: the tape FS has control
                                                        ;  0: RS-423 in control, timed out
                                                        ; <0: RS-423 in control, not timed out
.tapeCritical                               = $EB       ; bit 7 set while doing a BGET/BPUT
                                                        ;   (other bits are ignored)

.keyPressedInternalTable                    = $EC       ; start of two byte table of keys
.lastKeyPressedInternal                     = $EC       ; see table below
.firstKeyPressedInternal                    = $ED       ; see table below

    ; Situation              .lastKeyPressedInternal    .firstKeyPressedInternal
    ; -------------------------------------------------------------------------
    ; no keys pressed        $00                        $00
    ; one key pressed        first key number           $00
    ; two keys pressed       second key  number         first key number
    ; second key released    $00                        first key number

.keyToIgnoreWhenScanningWithOSBYTE121or122  = $EE       ; See .scanKeyboard

.osbyteA                                    = $EF       ; }
.oswordA                                    = $EF       ; } stores register values when
.osbyteX                                    = $F0       ; } calling OSBYTE and OSWORD
.oswordX                                    = $F0       ; }
.stackPointerLastBRK                        = $F0       ; stores the stack pointer on a BRK instruction
.osbyteY                                    = $F1       ; } stores register values when
.oswordY                                    = $F1       ; } calling OSBYTE and OSWORD

.stringInputBufferAddressLow                = $F2       ; } Start address of input string
.stringInputBufferAddressHigh               = $F3       ; }

.currentlySelectedROM                       = $F4       ; current Paged ROM selected
.currentSpeechPHROMOrROMNumber              = $F5       ; if bit 7 set:
                                                        ;   ROM number for Speech PHROM ($F0-$FF)
                                                        ; if bit 7 clear:
                                                        ;   ROM number for current ROMFS ($00-$0F)

.romAddressLow                              = $F6       ;
.romAddressHigh                             = $F7       ;

.unusedF8                                   = $F8       ; [unused]
.unusedF9                                   = $F9       ; [unused]

.tempStoreFA                                = $FA       ; }
.tempStoreFB                                = $FB       ; } General purpose temporary store

.interruptAccumulator                       = $FC       ; used during IRQ processing to
                                                        ; remember the accumulator and also
                                                        ; used during a reset (before
                                                        ; IRQs are enabled)

.languageVersionString                      = $FD       ; offset to language ROM version string
                                                        ;                 (- multiple uses)
.displayStringAddressLow                    = $FD       ;                 (- multiple uses)
.brkAddressLow                              = $FD       ; } address after (- multiple uses)
.brkAddressHigh                             = $FE       ; } last BRK      (- multiple uses)
.displayStringAddressHigh                   = $FE       ;                 (- multiple uses)

.escapeFlag                                 = $FF       ; the ESCAPE flag
                                                        ; this is set when an ESCAPE character
                                                        ; (normally .charESCAPE) is entered
                                                        ; into an input buffer.
                                                        ; It should be acknowledged using
                                                        ; OSBYTE 126. This tells the second
                                                        ; processor of the event and clears
                                                        ; the flag.

; ***************************************************************************************
;
; The 6502 Stack ($0100-$01FF)
;
; The 6502 stack starts at $01FF and grows downwards.
;
; ***************************************************************************************
.stackPage                                  = $0100     ; 6502 stack

; ***************************************************************************************
;
; Vectors ($0200-$0235)
;
; Vectors are addresses that can be set to point to a user routine to handle operating system
; calls, overriding or augmenting the standard behaviour. By default they are set to locations
; in the MOS ROM.
;
; See .defaultVectorTable for the default entry points for each vector
; See NAUG Section 6, Page 102
;
; Historical note: Acorn began storing vectors at $0200 with the System 2 (1980) and then
; the Atom (also 1980). Many of the vectors below appear there too, but not .vectorIRQ2V,
; .vectorBYTEV, .vectorWORDV or anything beyond .vectorNETV.
;
; ***************************************************************************************
.page2Start                                 = $0200

.vectorUSERV                                = $0200     ; User vector
.vectorBRKV                                 = $0202     ; BRK vector
.vectorIRQ1V                                = $0204     ; Primary IRQ vector
.vectorIRQ2V                                = $0206     ; Unrecognised IRQ vector
.vectorCLIV                                 = $0208     ; Command line interpreter
.vectorBYTEV                                = $020A     ; OSBYTE call
.vectorWORDV                                = $020C     ; OSWORD call
.vectorWRCHV                                = $020E     ; OSWRCH call
.vectorRDCHV                                = $0210     ; OSRDCH call
.vectorFILEV                                = $0212     ; Load / Save file
.vectorARGSV                                = $0214     ; Load / Save file parameters
.vectorBGETV                                = $0216     ; Get byte from file
.vectorBPUTV                                = $0218     ; Put byte to file
.vectorGBPBV                                = $021A     ; Transfer data to or from a file
.vectorFINDV                                = $021C     ; Open / Close file
.vectorFSCV                                 = $021E     ; Filing system control
.vectorEVNTV                                = $0220     ; Events
.vectorUPTV                                 = $0222     ; User print
.vectorNETV                                 = $0224     ; Econet
.vectorVDUV                                 = $0226     ; Unrecognised PLOT / VDU 23 commands
.vectorKEYV                                 = $0228     ; Keyboard
.vectorINSV                                 = $022A     ; Insert character into buffer
.vectorREMV                                 = $022C     ; Remove character from buffer
.vectorCNPV                                 = $022E     ; Count or purge buffer
.vectorIND1V                                = $0230     ; Unused vector
.vectorIND2V                                = $0232     ; Unused vector
.vectorIND3V                                = $0234     ; Unused vector

; ***************************************************************************************
;
; OS Variables ($0236-$02FF)
;
; ***************************************************************************************

; This value is offset when reading / writing OS variables using OSBYTE 166-255
.mosVariablesMinus166                       = .mosVariables - 166
                                                        ; value to add the OSBYTE (166-255)
                                                        ; number to get the address to
                                                        ; read/write

.mosVariables                               = $0236     ; Constant value .mosVariablesMinus166
                                                        ; (Read using OSBYTE 166/167)
.romPointerTable                            = $0238     ; Constant value .extendedVectorSpace
                                                        ; (Read using OSBYTE 168/169)
.romInformationTable                        = $023A     ; Constant value .romTypeTable
                                                        ; (Read using OSBYTE 170/171)
.keyTranslationTable                        = $023C     ; Constant value .keyDataTable1 - 16
                                                        ; (Read using OSBYTE 172/173)
.vduVariablesTable                          = $023E     ; Constant value .vduVariablesStart
                                                        ; (Read using OSBYTE 174/175)

.verticalSyncCounter                        = $0240     ; decremented every vertical sync
                                                        ; (Read/Write using OSBYTE 176)
.currentInputBuffer                         = $0241     ; buffer number for current input
                                                        ; (Read/Write using OSBYTE 177)
.enableKeyboardInterruptProcessingFlag      = $0242     ; aka 'Keyboard semaphore'
                                                        ; $00 = don't update key presses
                                                        ;       on 100Hz interrupts
                                                        ; $FF = key presses are processed
                                                        ;       as normal
                                                        ; (Read/Write using OSBYTE 178)
.defaultOSHWM                               = $0243     ; default/primary High Water Mark.
                                                        ; this is after Paged ROMs have
                                                        ; asked for their workspace memory,
                                                        ; but before soft character
                                                        ; definitions have been 'exploded'.
                                                        ; Initialised at RESET time, and
                                                        ; otherwise remains constant.
                                                        ; (Read/Write using OSBYTE 179)
.currentOSHWM                               = $0244     ; current OS High Water Mark, which
                                                        ; varies due to font explosions.
                                                        ; (Read/Write using OSBYTE 180)
.rs423Mode                                  = $0245     ; RS-423 mode (1 is default):
                                                        ;   0 = treat RS-423 input the same
                                                        ;       as the keyboard
                                                        ;   1 = ESCAPE is ignored;
                                                        ;       Soft keys are not expanded;
                                                        ;       no events are triggered
                                                        ; (Read/Write using OSBYTE 181)
.softCharacterDefinitionsSwitch             = $0246     ; which ranges of characters are Soft
                                                        ; character definitions (i.e. the
                                                        ; value X used in *FX 20,X)
                                                        ; (Read using OSBYTE 182 but note
                                                        ; that this is incompatible with
                                                        ; the Master series)
.tapeOrROMSwitch                            = $0247     ; 0 is *TAPE, 2 = *ROM
                                                        ; (Read/Write using OSBYTE 183)
.videoULAVideoControlRegisterCopy           = $0248     ; OS copy of video control register
                                                        ; (Read using OSBYTE 184)
.videoULAPaletteValue                       = $0249     ; value last written to the palette:
                                                        ; bits 0-3: physical colour EOR 7
                                                        ; bits 4-7: logical colour
                                                        ; (Read using OSBYTE 185)
.romNumberActiveLastBRK                     = $024A     ; ROM socket number when last BRK occurred
                                                        ; (Read using OSBYTE 186)
.basicROMNumber                             = $024B     ; ROM socket number containing BASIC or $FF
                                                        ; (Read using OSBYTE 187)
.adcCurrentChannel                          = $024C     ; current ADC channel number
                                                        ; (Read using OSBYTE 188)
.maximumADCChannelNumber                    = $024D     ; read maximum ADC channel number
                                                        ; (Read using OSBYTE 189)
.adcConversionType                          = $024E     ; ADC conversion type:
                                                        ; 0 = default (12 bits)
                                                        ; 8 = 8 bits
                                                        ; 12 = 12 bits
                                                        ; (Read/Write using OSBYTE 190)
.rs423ReadyFlag                             = $024F     ; bit 7 set means RS-423 is ready
                                                        ; otherwise RS-423 is busy
                                                        ; (Read/Write using OSBYTE 191)
.rs423ControlRegisterCopy                   = $0250     ; OS copy of the RS-423 control flag
                                                        ; (Read/Write using OSBYTE 192)
.videoULAFlashingColourIntervalCount        = $0251     ; counts down time before flashing the colours
                                                        ; (Read/Write using OSBYTE 193)
.videoULAFirstFlashingColourInterval        = $0252     ; number of frames to spend on the first flashing colour
                                                        ; (Read/Write using OSBYTE 194, but prefer OSBYTE 9)
.videoULASecondFlashingColourInterval       = $0253     ; number of frames to spend on the second flashing colour
                                                        ; (Read/Write using OSBYTE 195, but prefer OSBYTE 10)
.keyboardAutoRepeatDelay                    = $0254     ; delay before a key held down autorepeats in centi-seconds
                                                        ; (Read/write using OSBYTE 196, but prefer OSBYTE 11)
.keyboardAutoRepeatRate                     = $0255     ; keyboard autorepeat rate in centi-seconds
                                                        ; (Read/write using OSBYTE 197, but prefer OSBYTE 12)
.execFileHandle                             = $0256     ; file handle of open EXEC file or zero if none open
                                                        ; (Read/Write using OSBYTE 198)
.spoolFileHandle                            = $0257     ; file handle of open SPOOL file or zero if none open
                                                        ; (Read/Write using OSBYTE 199)
.escapeAndBreakEffect                       = $0258     ; bit 0 set disables ESCAPE
                                                        ; bit 1 set clears memory on BREAK
                                                        ; (Read/write using OSBYTE 200)
.keyboardDisableFlag                        = $0259     ; 0=Normal
                                                        ; otherwise ignore all keys except ESCAPE
                                                        ; (Read/Write using OSBYTE 201)
.keyboardStatusFlags                        = $025A     ; bit 3 = 1 means SHIFT pressed
                                                        ; bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; bit 6 = 1 means CTRL pressed
                                                        ; bit 7 = 1 means SHIFT enabled
                                                        ; (Read/Write using OSBYTE 202)
.rs423HandshakeExtent                       = $025B     ; how many bytes free when dealing with a full buffer
                                                        ; (Read/Write using OSBYTE 203)
.rs423InputSuppressionFlag                  = $025C     ; non-zero value inhibits RS-423 input
                                                        ; (Read/Write using OSBYTE 204)
.tapeRS423SelectionFlag                     = $025D     ; 0 = RS-423; $40 = TAPE (Comes into effect when using OSBYTE 7/8 to change)
                                                        ; (Read/Write using OSBYTE 205)
.econetOSCallInterceptionFlag               = $025E     ; bit 7 set sends OS calls through the econet vector
                                                        ; otherwise should be set to zero
                                                        ; (see .osbyteOrOSWORDTableLookup)
                                                        ; (Read/Write using OSBYTE 206)
.econetReadCharacterInterceptionFlag        = $025F     ; read character from ECONET if bit 7 set
                                                        ; (Read/Write using OSBYTE 207)
.econetWriteCharacterInterceptionFlag       = $0260     ; bit 7 set means direct the character to write to ECONET
                                                        ; (Read/Write using OSBYTE 208)
.speechSuppressionStatus                    = $0261     ; $50 to enable speech; $20 to disable
                                                        ; (Read/Write using OSBYTE 209)
.soundDisableFlag                           = $0262     ; non-zero disables sound
                                                        ; (Read/Write using OSBYTE 210)
.soundBELLChannel                           = $0263     ; sound channel for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 211)
.soundBELLAmplitudeEnvelope                 = $0264     ; sound amplitude/envelope for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 212)
.soundBELLPitch                             = $0265     ; sound pitch for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 213)
.soundBELLDuration                          = $0266     ; sound duration for CTRL-G BELL
                                                        ; (Read/Write using OSBYTE 214)
.startupMessageSuppressionAndBootOptions    = $0267     ; bit 7 = 0 means ignore OS startup message
                                                        ; bit 0 = 1 means if !BOOT errors from DISC because no language found, then lock up machine
                                                        ; bit 0 = 0 means if !BOOT errors from *ROM because no language found, then lock up machine
                                                        ; (Read/Write using OSBYTE 215)
.softKeyStringLength                        = $0268     ; length of the current *KEY string being decoded
                                                        ; (Read/Write using OSBYTE 216)
.pagedModeCounter                           = $0269     ; number of lines printed since last paged mode pause
                                                        ; (Read/Write using OSBYTE 217)
.twosComplimentOfNumberOfBytesInVDUQueue    = $026A     ; 255 - bytes in vdu queue
                                                        ; (Read/Write using OSBYTE 218)
.asciiCodeGeneratedByTABKey                 = $026B     ; ASCII value to be produced by TAB
                                                        ; (Read/Write using OSBYTE 219)
.asciiCodeThatGeneratesESCAPEAction         = $026C     ; key's ASCII code that will generate an ESCAPE action
                                                        ; (Read/Write using OSBYTE 220)

.functionAndCursorKeyCodes                  = $026D     ; 8 bytes that determine how to interpret special keys:

    ; byte  range of keys
    ;  0      $C0-$CF
    ;  1      $D0-$DF
    ;  2      $E0-$EF
    ;  3      $F0-$FF
    ;  4      $80-$8F  Function keys
    ;  5      $90-$9F  SHIFT+Function keys
    ;  6      $A0-$AF  CTRL+Function keys
    ;  7      $B0-$BF  CTRL+SHIFT+Function keys
    ;
    ; 0 = ignore key
    ; 1 = expand as 'soft' key
    ; 2-255 = add this to base for 'ASCII' code
    ;
    ; note that provision is made for keypad operation
    ; as codes $C0-$FF cannot be generated from keyboard
    ; but are recognised by OS
    ;
    ; (Read/Write using OSBYTE 221-228)

.escapeAction                               = $0275     ; 0 = normal ESCAPE action
                                                        ; otherwise ASCII
                                                        ; (Read/Write using OSBYTE 229)
.escapeEffects                              = $0276     ; 0 = ESCAPE cleared, EXEC file
                                                        ; closed, all buffers purged, reset
                                                        ; VDU paging counter; otherwise
                                                        ; nothing.
                                                        ; (Read/Write using OSBYTE 230)
.userVIAIRQBitMask                          = $0277     ; (Read using OSBYTE 231)
.rs423IRQBitMask                            = $0278     ; (Read using OSBYTE 232)
.systemVIAIRQBitMask                        = $0279     ; (Read using OSBYTE 233)
.tubePresentFlag                            = $027A     ; 0 = no Tube
                                                        ; 255 = Tube present
                                                        ; (Read using OSBYTE 234)
.speechSystemPresentFlag                    = $027B     ; 0 = no speech
                                                        ; 255 = SPEECH present
                                                        ; (Read using OSBYTE 235)

.characterDestinationsAvailableFlags        = $027C     ; bit 0 - enable RS-423 driver
                                                        ; bit 1 - disable VDU driver
                                                        ; bit 2 - disable printer driver
                                                        ; bit 3 - enable printer, independent of CTRL-B/C
                                                        ; bit 4 - disable SPOOLed output
                                                        ; bit 5 - not used
                                                        ; bit 6 - disable printer driver (unless preceded by VDU 1)
                                                        ; bit 7 - not used
                                                        ; (Read using OSBYTE 236)
.cursorEditingType                          = $027D     ; 0 = enable normal cursor editing
                                                        ; 1=disable (cursor keys return codes $87-$8B)
                                                        ; 2=disable (cursor keys and COPY key
                                                        ;      are soft keys 11=COPY,12=LEFT,
                                                        ;      13=RIGHT,14=DOWN,15=UP)
                                                        ; (Read using OSBYTE 237)

.unused27E                                  = $027E     ; [initialised to zero, otherwise unused]
                                                        ; (Read/Write using OSBYTE 238)
.unused27F                                  = $027F     ; [initialised to zero, otherwise unused]
                                                        ; (Read/Write using OSBYTE 239)

.countryCode                                = $0280     ; 0 = UK
                                                        ; 1 = US (not used by this OS)
                                                        ; (Read/Write using OSBYTE 240)
.userFlag                                   = $0281     ; free for use by an application (not used by the OS)
                                                        ; (Read/Write with OSBYTE 241 but prefer using OSBYTE 1)

.serialULARegisterCopy                      = $0282     ; copy of the Serial ULA control register
                                                        ; (Read using OSBYTE 242)
.timeClockSwitch                            = $0283     ; which five byte clock is in currently use (5 or 10)
                                                        ; (Read using OSBYTE 243)
.softKeyConsistencyFlag                     = $0284     ; 0 = normal; otherwise inconsistent
                                                        ; (Read/Write using OSBYTE 244)
.printerDestination                         = $0285     ; 0 = no printer output
                                                        ; 1 = parallel printer
                                                        ; 2 = serial printer
                                                        ; 3 = user printer routine
                                                        ; 4 = net printer
                                                        ; 5-255 = user printer routine
                                                        ; (Read/Write using OSBYTE 245)
.printerIgnoreCharacter                     = $0286     ; character that the printer ignores
                                                        ; (Read/Write using OSBYTE 246)
.breakInterceptJMPInstruction               = $0287     ; }
.breakInterceptLowAddress                   = $0288     ; } Three bytes form a 'JMP address' instruction, activated on BREAK
.breakInterceptHighAddress                  = $0289     ; } (Read/Write using OSBYTE 247-249)

.unused28A                                  = $028A     ; [initialised to zero but otherwise unused]
                                                        ; (Read/Write using OSBYTE 250)
.unused28B                                  = $028B     ; [initialised to zero but otherwise unused]
                                                        ; (Read/Write using OSBYTE 251)

.languageROMNumber                          = $028C     ; ROM Number for current language
                                                        ; (Read/Write using OSBYTE 252)
.lastResetType                              = $028D     ; what type of reset was last done?
                                                        ;        0    Soft reset (BREAK)
                                                        ;        1    Power on
                                                        ;        2    Hard reset (CTRL-BREAK)
                                                        ; only used during the boot sequence itself
                                                        ; (Read/Write using OSBYTE 253)
.systemAvailableRAM                         = $028E     ; $40 = 16k (usually Model A)
                                                        ; $80 = 32k (usually Model B)
                                                        ; (Read using OSBYTE 254)
.startUpOptions                             = $028F     ; bits 0-2 are the initial MODE
                                                        ; bit 3 (if clear, reverses the action of SHIFT-BREAK)
                                                        ; bits 4-5 are disc drive timings
                                                        ; bits 6-7 unused
                                                        ; (Read/Write with OSBYTE 255)

.hardResetLWM                               = $0290     ; low water mark for resetting variables on a hard reset / power on reset
                                                        ; (variables are reset from here to end of page)
.vduVerticalAdjust                          = $0290     ; *TV value
.vduInterlaceValue                          = $0291     ; *TV interlace value
.timeClockA                                 = $0292     ; } 5 byte clock as read by TIME
.timeClockB                                 = $0297     ; } read and write alternates between
                                                        ; these two 5 byte buffers
                                                        ; (see .timeClockSwitch)
.softResetLWM                               = $029C     ; low water mark in Page 2 for
                                                        ; resetting variables on a soft reset
                                                        ; (sets variables from here to end
                                                        ; of page) - dual use
.countdownIntervalTimer                     = $029C     ; 5 byte countdown interval timer (causes an EVENT when it reaches zero)

.romTypeTable                               = $02A1     ; the type of each of the sixteen ROMs $02A1-$2B0
.inkeyTimeoutCounterLow                     = $02B1     ; } 16 bit value that is decremented
.inkeyTimeoutCounterHigh                    = $02B2     ; } at 100Hz while processing a timed keyboard read

.osword0MaxLineLength                       = $02B3     ; }
.osword0MinASCIICharacter                   = $02B4     ; } copies of the values in the OSWORD 0 parameter block
.osword0MaxASCIICharacter                   = $02B5     ; }
.lowByteLastByteFromADCChannel1             = $02B6     ;
.lowByteLastByteFromADCChannel2             = $02B7     ;
.lowByteLastByteFromADCChannel3             = $02B8     ;
.lowByteLastByteFromADCChannel4             = $02B9     ;
.highByteLastByteFromADCChannel1            = $02BA     ;
.highByteLastByteFromADCChannel2            = $02BB     ;
.highByteLastByteFromADCChannel3            = $02BC     ;
.highByteLastByteFromADCChannel4            = $02BD     ;
.adcLastChannelRead                         = $02BE     ; Stores the last ADC channel read
                                                        ; (1-4), or zero if (a) no ADC
                                                        ; conversions have taken place yet,
                                                        ; or (b) one is pending via OSBYTE 17
                                                        ; or (c) if we have already read this
                                                        ; value using OSBYTE 128.

.eventEnabledFlags                          = $02BF     ; }
.outputBufferEmptyEventEnabled              = $02BF     ; }
.inputBufferFullEventEnabled                = $02C0     ; }
.characterEnteringBufferEventEnabled        = $02C1     ; }
.adcConversionCompleteEventEnabled          = $02C2     ; }
.startOfVSyncEventEnabled                   = $02C3     ; } 'Event enabled' flags (0 means
.intervalTimerCrossingZeroEventEnabled      = $02C4     ; } disabled, non-zero is enabled)
.escapeConditionEventEnabled                = $02C5     ; }
.rs423ErrorDetectedEventEnabled             = $02C6     ; }
.econetGeneratedEventEnabled                = $02C7     ; }
.userEventEnabled                           = $02C8     ; }

.softKeyExpansionPointer                    = $02C9     ; next byte to expand is at
                                                        ; ($0B09 + .softKeyExpansionPointer)

.keyboardFirstAutorepeatCount               = $02CA     ;
.previousKeyPressedWhenReadingLastKey       = $02CB     ; previous key pressed when reading
                                                        ; keyboard last key
                                                        ; (see .lastKeyPressedInternal)
.previousKeyPressedWhenReadingFirstKey      = $02CC     ; previous key pressed when reading
                                                        ; keyboard first key
                                                        ; (see .firstKeyPressedInternal)
.previousKeyPressedWhenReadingOSBYTE        = $02CD     ; previous key pressed when reading
                                                        ; keyboard from OSBYTE 121 / 122

.soundIsUpdatingFlag                        = $02CE     ; aka 'Sound semaphore'
                                                        ; $FF if sound interrupt is updating
                                                        ; $00 otherwise

.bufferEmptyFlags                           = $02CF     ;
.keyboardBufferEmptyFlag                    = $02CF     ; }
.rs423InputBufferEmptyFlag                  = $02D0     ; }
.rs423OutputBufferEmptyFlag                 = $02D1     ; }
.printerBufferEmptyFlag                     = $02D2     ; }
.soundChannel0BufferEmptyFlag               = $02D3     ; } Bit 7 set if buffer is empty
.soundChannel1BufferEmptyFlag               = $02D4     ; }
.soundChannel2BufferEmptyFlag               = $02D5     ; }
.soundChannel3BufferEmptyFlag               = $02D6     ; }
.speechBufferEmptyFlag                      = $02D7     ; }

.bufferStartIndices                         = $02D8     ;
.keyboardBufferStartIndex                   = $02D8     ; }
.rs423InputBufferStartIndex                 = $02D9     ; }
.rs423OutputBufferStartIndex                = $02DA     ; }
.printerBufferStartIndex                    = $02DB     ; } Offset to next byte to be removed
.soundChannel0BufferStartIndex              = $02DC     ; } Highest location in each
.soundChannel1BufferStartIndex              = $02DD     ; }    buffer has offset $FF
.soundChannel2BufferStartIndex              = $02DE     ; }
.soundChannel3BufferStartIndex              = $02DF     ; }
.speechBufferEmptyStartIndex                = $02E0     ; }

.bufferEndIndices                           = $02E1     ;
.keyboardBufferEndIndex                     = $02E1     ; }
.rs423InputBufferEndIndex                   = $02E2     ; }
.rs423OutputBufferEndIndex                  = $02E3     ; }
.printerBufferEndIndex                      = $02E4     ; }
.soundChannel0BufferEndIndex                = $02E5     ; } Offset to last byte entered in
.soundChannel1BufferEndIndex                = $02E6     ; } each buffer
.soundChannel2BufferEndIndex                = $02E7     ; }
.soundChannel3BufferEndIndex                = $02E8     ; }
.speechBufferEmptyEndIndex                  = $02E9     ; }

.tapeInputCurrentBlockSizeLow               = $02EA     ;
.tapeInputCurrentBlockSizeHigh              = $02EB     ;

.blockFlagOfCurrentlyResidentBlock          = $02EC     ; bit 0 = *RUN only
                                                        ; bit 6 = no data
                                                        ; bit 7 = last block
.lastCharacterOfCurrentlyResidentBlock      = $02ED     ;

.osfileBlockStart                           = $02EE     ;
.osfileFilenameAddressLow                   = $02EE     ;
.osfileFilenameAddressHigh                  = $02EF     ;
.osfileLoadAddressLow                       = $02F0     ; the Load/Exec/Start/End addresses
.osfileLoadAddressMid1                      = $02F1     ; are all 32 bit values. The upper
.osfileLoadAddressMid2                      = $02F2     ; two bytes are $FF $FF by default,
.osfileLoadAddressHigh                      = $02F3     ; meaning the code is for the main
.osfileExecAddressLow                       = $02F4     ; processor. If they have other
.osfileExecAddressMid1                      = $02F5     ; values the data is sent via the
.osfileExecAddressMid2                      = $02F6     ; Tube to the second processor
.osfileExecAddressHigh                      = $02F7     ; (if present).
.osfileStartAddressLow                      = $02F8     ;
.osfileStartAddressMid1                     = $02F9     ;
.osfileStartAddressMid2                     = $02FA     ;
.osfileStartAddressHigh                     = $02FB     ;
.osfileEndAddressLow                        = $02FC     ;
.osfileEndAddressMid1                       = $02FD     ;
.osfileEndAddressMid2                       = $02FE     ;
.osfileEndAddressHigh                       = $02FF     ;

; ***************************************************************************************
;
; VDU Variables ($0300-$37F)
;
; ***************************************************************************************
.vduVariablesStart                          = $0300     ;

.vduGraphicsWindowPixelsLeftLow             = $0300     ; }
.vduGraphicsWindowPixelsLeftHigh            = $0301     ; }
.vduGraphicsWindowPixelsBottomLow           = $0302     ; }
.vduGraphicsWindowPixelsBottomHigh          = $0303     ; }
.vduGraphicsWindowPixelsRightLow            = $0304     ; } graphics window in pixels
.vduGraphicsWindowPixelsRightHigh           = $0305     ; }
.vduGraphicsWindowPixelsTopLow              = $0306     ; }
.vduGraphicsWindowPixelsTopHigh             = $0307     ; }

.vduTextWindowLeft                          = $0308     ; }
.vduTextWindowBottom                        = $0309     ; }
.vduTextWindowRight                         = $030A     ; } text window
.vduTextWindowTop                           = $030B     ; }

.vduGraphicsWindowOriginXLow                = $030C     ; }
.vduGraphicsWindowOriginXHigh               = $030D     ; } graphics origin in external
.vduGraphicsWindowOriginYLow                = $030E     ; } coordinates
.vduGraphicsWindowOriginYHigh               = $030F     ; }

.vduGraphicsCursorPositionXLow              = $0310     ; }
.vduGraphicsCursorPositionXHigh             = $0311     ; } graphics cursor position in
.vduGraphicsCursorPositionYLow              = $0312     ; } external coordinates
.vduGraphicsCursorPositionYHigh             = $0313     ; }

.vduOldGraphicsCursorPixelsXLow             = $0314     ; }
.vduOldGraphicsCursorPixelsXHigh            = $0315     ; } old graphics cursor in pixels
.vduOldGraphicsCursorPixelsYLow             = $0316     ; }
.vduOldGraphicsCursorPixelsYHigh            = $0317     ; }

.vduTextCursorXPosition                     = $0318     ; } text cursor position
.vduTextCursorYPosition                     = $0319     ; }

.vduGraphicsCursorVerticalOffsetInCell      = $031A     ; offset within a character cell of
                                                        ; the current graphics cursor Y
                                                        ; coordinate

.vduQueueStartByte                          = $031B     ; } nine bytes for vdu queue (start)

.vduTriangleFillHeightLow                   = $031B     ; }
.vduTriangleFillHeightHigh                  = $031C     ; } height used when filling triangles

.vduQueueEndByte                            = $0323     ; } nine bytes for vdu queue (end)

.vduGraphicsCursorPixelsXLow                = $0324     ; current graphics cursor position in
.vduGraphicsCursorPixelsXHigh               = $0325     ; pixels
.vduGraphicsCursorPixelsYLow                = $0326     ;
.vduGraphicsCursorPixelsYHigh               = $0327     ;

.vduWorkspaceA                              = $0328     ; workspace A-V
.vduWorkspaceB                              = $0329     ; these have multiple uses.
.vduWorkspaceC                              = $032A     ; Notably these are used when drawing
.vduWorkspaceD                              = $032B     ; lines and triangles.
.vduWorkspaceE                              = $032C     ;
.vduWorkspaceF                              = $032D     ;
.vduWorkspaceG                              = $032E     ;
.vduWorkspaceH                              = $032F     ;
.vduWorkspaceI                              = $0330     ;
.vduWorkspaceJ                              = $0331     ;
.vduWorkspaceK                              = $0332     ;
.vduWorkspaceL                              = $0333     ;
.vduWorkspaceM                              = $0334     ;
.vduWorkspaceN                              = $0335     ;
.vduWorkspaceO                              = $0336     ;
.vduWorkspaceP                              = $0337     ;
.vduWorkspaceQ                              = $0338     ;
.vduWorkspaceR                              = $0339     ;
.vduWorkspaceS                              = $033A     ;
.vduWorkspaceT                              = $033B     ;
.vduWorkspaceU                              = $033C     ;
.vduWorkspaceV                              = $033D     ;

.vduClearGraphicsWindowLineCount            = .vduWorkspaceI ; line counter used in VDU 16 (clear graphics window)
.vduMODE7CursorCharacter                    = .vduWorkspaceQ ;

; Plot line variables
.vduPlotLineDeltaXLow                       = .vduWorkspaceA ; 'plot line' variables
.vduPlotLineDeltaXHigh                      = .vduWorkspaceB ;
.vduPlotLineDeltaYLow                       = .vduWorkspaceC ;
.vduPlotLineDeltaYHigh                      = .vduWorkspaceD ;
.vduPlotLineCurrentPointXLow                = .vduWorkspaceE ;
.vduPlotLineCurrentPointXHigh               = .vduWorkspaceF ;
.vduPlotLineCurrentPointYLow                = .vduWorkspaceG ;
.vduPlotLineCurrentPointYHigh               = .vduWorkspaceH ;
.vduPlotLineTerminationValueLow             = .vduWorkspaceI ; } final coordinate in the
.vduPlotLineTerminationValueHigh            = .vduWorkspaceJ ; } dominant axis. Used to check
                                                             ; } when done plotting a line.

.vduPlotLineRoutineLow                      = .vduWorkspaceK ; } address of routine to use
.vduPlotLineRoutineHigh                     = .vduWorkspaceL ; } when drawing a line
.vduPlotLinePlotDottedPixelFlag             = .vduWorkspaceM ; 127 to draw a dot; 128 to skip
.vduPlotLineErrorTermLow                    = .vduWorkspaceN ;
.vduPlotLineErrorTermHigh                   = .vduWorkspaceO ;
.vduPlotLineAbsNonDominantAxisDeltaLow      = .vduWorkspaceP ;
.vduPlotLineAbsNonDominantAxisDeltaHigh     = .vduWorkspaceQ ;
.vduPlotLineAbsDominantAxisDeltaLow         = .vduWorkspaceR ;
.vduPlotLineAbsDominantAxisDeltaHigh        = .vduWorkspaceS ;

; Plot triangle variables
.vduPlotTriMainLineErrorTermLow             = .vduWorkspaceA ; 'plot triangle' variables
.vduPlotTriMainLineErrorTermHigh            = .vduWorkspaceB ; tracking the 'main line'
.vduPlotTriMainLineDeltaXLow                = .vduWorkspaceC ;
.vduPlotTriMainLineDeltaXHigh               = .vduWorkspaceD ;
.vduPlotTriMainLineDeltaYLow                = .vduWorkspaceE ;
.vduPlotTriMainLineDeltaYHigh               = .vduWorkspaceF ;
.vduPlotTriMainLineCurrentPointXLow         = .vduWorkspaceG ;
.vduPlotTriMainLineCurrentPointXHigh        = .vduWorkspaceH ;
.vduPlotTriMainLineCurrentPointYLow         = .vduWorkspaceI ;
.vduPlotTriMainLineCurrentPointYHigh        = .vduWorkspaceJ ;
.vduPlotTriMainLineXDirectionFlag           = .vduWorkspaceK ;

.vduPlotTriMinorLineErrorTermLow            = .vduWorkspaceL ; 'plot triangle' variables
.vduPlotTriMinorLineErrorTermHigh           = .vduWorkspaceM ; tracking the 'minor line'
.vduPlotTriMinorLineDeltaXLow               = .vduWorkspaceN ;
.vduPlotTriMinorLineDeltaXHigh              = .vduWorkspaceO ;
.vduPlotTriMinorLineDeltaYLow               = .vduWorkspaceP ;
.vduPlotTriMinorLineDeltaYHigh              = .vduWorkspaceQ ;
.vduPlotTriMinorLineCurrentPointXLow        = .vduWorkspaceR ;
.vduPlotTriMinorLineCurrentPointXHigh       = .vduWorkspaceS ;
.vduPlotTriMinorLineCurrentPointYLow        = .vduWorkspaceT ;
.vduPlotTriMinorLineCurrentPointYHigh       = .vduWorkspaceU ;
.vduPlotTriMinorLineXDirectionFlag          = .vduWorkspaceV ;

.vduPlotTriStorageForCoordinates            = $033E     ; eight bytes used when drawing a
                                                        ; triangle to remember the original
                                                        ; XY coordinates (four bytes) and
                                                        ; graphics cursor (four bytes)
                                                        ; ($033E to $0345)

.unused346                                  = $0346     ; [unused]
.unused347                                  = $0347     ; [unused]
.unused348                                  = $0348     ; [unused]
.unused349                                  = $0349     ; [unused]

.vduTextCursorCRTCAddressLow                = $034A     ; CRTC address of the cursor
.vduTextCursorCRTCAddressHigh               = $034B     ;

.vduTextWindowWidthInBytesLow               = $034C     ;
.vduTextWindowWidthInBytesHigh              = $034D     ;

.vduStartScreenAddressHighByte              = $034E     ;
.vduBytesPerCharacter                       = $034F     ;
.vduScreenTopLeftAddressLow                 = $0350     ;
.vduScreenTopLeftAddressHigh                = $0351     ;

.vduBytesPerCharacterRowLow                 = $0352     ;
.vduBytesPerCharacterRowHigh                = $0353     ;
.vduScreenSizeHighByte                      = $0354     ;
.vduCurrentScreenMODE                       = $0355     ;
.vduCurrentScreenMODEGroup                  = $0356     ; MODE group = screen memory size:
                                                        ;          0 = 20k (MODE 0,1,2)
                                                        ;          1 = 16k (MODE 3)
                                                        ;          2 = 10k (MODE 4,5)
                                                        ;          3 =  8k (MODE 6)
                                                        ;          4 =  1k (MODE 7)
.vduForegroundTextColour                    = $0357     ; } Current colours. Stored as the
.vduBackgroundTextColour                    = $0358     ; } byte value to colour the whole
.vduForegroundGraphicsColour                = $0359     ; } byte the given colour
.vduBackgroundGraphicsColour                = $035A     ; }
.vduForegroundGCOLMode                      = $035B     ; GCOL foreground mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
.vduBackgroundGCOLMode                      = $035C     ; GCOL background mode
                                                        ; (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)

.vduJumpVectorLow                           = $035D     ;
.vduJumpVectorHigh                          = $035E     ;

.vduLastCursorStartRegisterValue            = $035F     ;

.vduNumberOfLogicalColoursMinusOne          = $0360     ;
.vduPixelsPerByteMinusOne                   = $0361     ;

.vduColourMaskLeft                          = $0362     ; colour mask left.  Bits for the
                                                        ; setting the leftmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $80
                                                        ; MODE 1,5          = $88
                                                        ; MODE 2            = $AA
.vduColourMaskRight                         = $0363     ; colour mask right. Bits for the
                                                        ; setting the rightmost pixel of a
                                                        ; byte to white:
                                                        ; MODE 0,3,4,6,7    = $01
                                                        ; MODE 1,5          = $11
                                                        ; MODE 2            = $55
.vduTextInputCursorXCoordinate              = $0364     ;
.vduTextInputCursorYCoordinate              = $0365     ;
.vduTeletextCharacterForCursor              = $0366     ;
.vduFontFlags                               = $0367     ; ranges of characters that have SOFT character definitions:
                                                        ;     bit 7 = characters  32-63
                                                        ;     bit 6 = characters  64-95
                                                        ;     bit 5 = characters  96-127
                                                        ;     bit 4 = characters 128-159
                                                        ;     bit 3 = characters 160-191
                                                        ;     bit 2 = characters 192-223
                                                        ;     bit 1 = characters 224-255
                                                        ;     bit 0 = unused
                                                        ; See .osbyte20EntryPoint
.vduFontZoneAddressesHigh1                  = $0368     ; high byte of the address (=page number) for storing character definitions  32-63  (in ROM or RAM)
.vduFontZoneAddressesHigh2                  = $0369     ; high byte of the address (=page number) for storing character definitions  64-95  (in ROM or RAM)
.vduFontZoneAddressesHigh3                  = $036A     ; high byte of the address (=page number) for storing character definitions  96-127 (in ROM or RAM)
.vduFontZoneAddressesHigh4                  = $036B     ; high byte of the address (=page number) for storing character definitions 128-159 (in ROM or RAM)
.vduFontZoneAddressesHigh5                  = $036C     ; high byte of the address (=page number) for storing character definitions 160-191 (in ROM or RAM)
.vduFontZoneAddressesHigh6                  = $036D     ; high byte of the address (=page number) for storing character definitions 192-223 (in ROM or RAM)
.vduFontZoneAddressesHigh7                  = $036E     ; high byte of the address (=page number) for storing character definitions 224-255 (in ROM or RAM)

.vduColourPaletteStart                      = $036F     ; } 16 bytes of palette information
.vduColourPaletteEnd                        = $037E     ; }

.unused37F                                  = $037F     ; [unused]

.vduVariablesEnd                            = $037F     ;

; ***************************************************************************************
;
; Cassette Filing System Workspace ($0380-$03DF)
;
; ***************************************************************************************
.tapeBlockHeaderStart                       = $0380     ;
.tapeBlockFilename                          = $0380     ; filename (11 bytes)

.unused38B                                  = $038B     ; [unused]


.tapeBlockLoadAddressLow                    = $038C     ; }
.tapeBlockLoadAddressMid1                   = $038D     ; }
.tapeBlockLoadAddressMid2                   = $038E     ; } load address
.tapeBlockLoadAddressHigh                   = $038F     ; }
.tapeBlockExecutableAddressLow              = $0390     ; }
.tapeBlockExecutableAddressMid1             = $0391     ; }
.tapeBlockExecutableAddressMid2             = $0392     ; } executable address
.tapeBlockExecutableAddressHigh             = $0393     ; }
.tapeBlockNumberLow                         = $0394     ; block number (low byte)
.tapeBlockNumberHigh                        = $0395     ; block number (high byte)
.tapeBlockLengthLow                         = $0396     ;
.tapeBlockLengthHigh                        = $0397     ;
.tapeBlockFlagByte                          = $0398     ; bit 7=last block, written when
                                                        ; closing a file for output
.tapeBlockSpareByteA                        = $0399     ;
.tapeBlockSpareByteB                        = $039A     ;
.tapeBlockSpareByteC                        = $039B     ;
.tapeBlockSpareByteD                        = $039C     ;


.bputBufferOffset                           = $039D     ; offset in buffer for next BPUT
.bgetBufferOffset                           = $039E     ; offset in buffer for next BGET

.unused39F                                  = $039F     ; [unused]
.unused3A0                                  = $03A0     ; [unused]
.unused3A1                                  = $03A1     ; [unused]
.unused3A2                                  = $03A2     ; [unused]
.unused3A3                                  = $03A3     ; [unused]
.unused3A4                                  = $03A4     ; [unused]
.unused3A5                                  = $03A5     ; [unused]
.unused3A6                                  = $03A6     ; [unused]

.bgetFilename                               = $03A7     ; zero terminated filename (11 bytes)

.fsFilename                                 = $03B2     ; zero terminated filename (11 bytes)

.unused3BD                                  = $03BD     ; [unused]


.fsLoadAddressLow                           = $03BE     ;
.fsLoadAddressMid1                          = $03BF     ;
.fsLoadAddressMid2                          = $03C0     ;
.fsLoadAddressHigh                          = $03C1     ;
.fsExecutionAddressLow                      = $03C2     ;
.fsExecutionAddressMid1                     = $03C3     ;
.fsExecutionAddressMid2                     = $03C4     ;
.fsExecutionAddressHigh                     = $03C5     ;
.fsBlockNumberLow                           = $03C6     ;
.fsBlockNumberHigh                          = $03C7     ;
.fsBlockLengthLow                           = $03C8     ;
.fsBlockLengthHigh                          = $03C9     ;
.fsBlockFlagByte                            = $03CA     ; block flag byte:
                                                        ;   bit 0 set = *RUN only
                                                        ;   bit 7 set = last block
.fsSpareByteA                               = $03CB     ;
.fsSpareByteB                               = $03CC     ;
.fsSpareByteC                               = $03CD     ;
.fsSpareByteD                               = $03CE     ;

.fsChecksumLow                              = $03CF     ; }
.fsChecksumHigh                             = $03D0     ; } checksum


.tapeSequentialAccessInterBlockGap          = $03D1     ; time between writing blocks (for
                                                        ; sequential access, BGET and BPUT)
                                                        ; to cassette (> 0) in tenths of a second.
.filenameToSearchFor                        = $03D2     ; zero terminated filename (11 bytes)
.nextBGETBlockLow                           = $03DD     ;
.nextBGETBlockHigh                          = $03DE     ;
.fsLastBlockReadFlagsCopy                   = $03DF     ;

; ***************************************************************************************
;
; Keyboard Buffer ($03E0-$03FF)
;
; ***************************************************************************************
.keyboardInputBuffer                        = $03E0     ; keyboard input buffer (32 bytes)

; ***************************************************************************************
;
; Second Processor service points
;
; These are addresses to access the Second Processor.
;
; See circuit_tube.png
;
; The Tube interface gives access to a second processor and is partly implemented by the
; 'DNFS' ROM.
;
; Initialising the DNFS ROM copies 1K of Tube Operating System service code into
; the current language workspace at $0400-$07FF. A call to .tubeCopyLanguageROMToSecondProcessor
; ($0400) calls into this Tube service code. It finds and copies code from an appropriate
; language ROM into the second processor and runs it there. The 6502 Second Processor shipped
; with HI-BASIC, a version of the BASIC ROM designed to run on the second processor at a high
; memory address range leaving more memory (44K) for BASIC programs on the second
; processor.
;
; The regular standard 6502 processor is sometimes called the 'first', 'host' or I/O processor,
; as it has control over input and output devices like the keyboard and the display. The second
; processor is sometimes known as the 'parasite'.
;
; See NAUG Section 18.4, Page 330
;
; ***************************************************************************************
.tubeCopyLanguageROMToSecondProcessor       = $0400     ; copy a language ROM code to the
                                                        ; second processor
.tubeCopyESCAPEFlagToSecondProcessor        = $0403     ;
.tubeTransferData                           = $0406     ;

; ***************************************************************************************
;
; Sound Workspace ($0800-$083F)
;
; ***************************************************************************************
.unused800                                  = $0800     ; [unused]
.unused801                                  = $0801     ; [unused]
.unused802                                  = $0802     ; [unused]
.unused803                                  = $0803     ; [unused]

.channel0Occupancy                          = $0804     ; }
.channel1Occupancy                          = $0805     ; } top bit set if a sound is playing
.channel2Occupancy                          = $0806     ; } on this channel, $00 otherwise
.channel3Occupancy                          = $0807     ; }

.channel0Volume                             = $0808     ; } current volume (loud to soft):
.channel1Volume                             = $0809     ; } SOUND
.channel2Volume                             = $080A     ; } volume  Value
.channel3Volume                             = $080B     ; } -15     $3F
                                                        ; } -14     $37
                                                        ; } -13     $2F
                                                        ; } -12     $27
                                                        ; } -11     $1F
                                                        ; } -10     $17
                                                        ; }  -9     $0F
                                                        ; }  -8     $07
                                                        ; }  -7     $FF
                                                        ; }  -6     $F7
                                                        ; }  -5     $EF
                                                        ; }  -4     $E7
                                                        ; }  -3     $DF
                                                        ; }  -2     $D7
                                                        ; }  -1     $CF
                                                        ; }   0     $C7

.channel0PhaseCounter                       = $080C     ; }
.channel1PhaseCounter                       = $080D     ; }
.channel2PhaseCounter                       = $080E     ; } phase counter for current amplitude envelope (which phase of 'ADSR' is current)
.channel3PhaseCounter                       = $080F     ; }

.channel0BasePitch                          = $0810     ; }
.channel1BasePitch                          = $0811     ; }
.channel2BasePitch                          = $0812     ; } base pitch (pitch at start of current pitch section)
.channel3BasePitch                          = $0813     ; }

.channel0Section                            = $0814     ; }
.channel1Section                            = $0815     ; }
.channel2Section                            = $0816     ; } current pitch section (0-2)
.channel3Section                            = $0817     ; }

.channel0SectionCountdownProgress           = $0818     ; }
.channel1SectionCountdownProgress           = $0819     ; }
.channel2SectionCountdownProgress           = $081A     ; } current countdown timer within pitch section
.channel3SectionCountdownProgress           = $081B     ; }

.channel0Duration                           = $081C     ; }
.channel1Duration                           = $081D     ; }
.channel2Duration                           = $081E     ; } remaining duration of current sound in 20ths of a second
.channel3Duration                           = $081F     ; }

.channel0Countdown20Hz                      = $0820     ; }
.channel1Countdown20Hz                      = $0821     ; }
.channel2Countdown20Hz                      = $0822     ; } Count from 5 to 0 to give a signal every 20th of a second
.channel3Countdown20Hz                      = $0823     ; }

.channel0EnvelopeOffset                     = $0824     ; }
.channel1EnvelopeOffset                     = $0825     ; }
.channel2EnvelopeOffset                     = $0826     ; } Offset from .envelopeBuffer of current
.channel3EnvelopeOffset                     = $0827     ; } envelope data (or $FF if no envelope in use)

.channel0StepCountdownProgress              = $0828     ; }
.channel1StepCountdownProgress              = $0829     ; }
.channel2StepCountdownProgress              = $082A     ; } Amplitude step countdown timer of current envelope
.channel3StepCountdownProgress              = $082B     ; }

.channel0SyncFlag                           = $082C     ; }
.channel1SyncFlag                           = $082D     ; }
.channel2SyncFlag                           = $082E     ; } synchronising flag of current envelope
.channel3SyncFlag                           = $082F     ; }

.channel0Pitch                              = $0830     ; }
.channel1Pitch                              = $0831     ; }
.channel2Pitch                              = $0832     ; } pitch of current envelope
.channel3Pitch                              = $0833     ; }

.channel0PitchOffset                        = $0834     ; }
.channel1PitchOffset                        = $0835     ; }
.channel2PitchOffset                        = $0836     ; } pitch offset (the actual current pitch = base pitch + pitch offset)
.channel3PitchOffset                        = $0837     ; }

.soundSyncCount                             = $0838     ; $FF if sync is clear
                                                        ; >$00 is the number of channels to
                                                        ; sync (The 'S' in the 'SOUND &HSFC'
                                                        ; command)
.currentAmplitudeStep                       = $0839     ;
.targetAmplitude                            = $083A     ;
.numberOfSoundChannelsOnHold                = $083B     ;

.fractionalSemitones                        = $083C     ; when setting pitch, this is the
                                                        ; value 0-3 between semitones

; The code to play a sound calculates the frequency from the input pitch
; and from that calculates the bytes to send to the sound chip.
; These three variables are used in those calculations (See .setPitchNotNoise).
.soundPitchLow                              = $083D     ; }
.soundPitchHigh                             = $083E     ; } pitch to frequency variables
.soundFractional                            = $083F     ; }

; ***************************************************************************************
;
; Sound, Printer and Envelope Buffers ($0840-$08FF)
;
; ***************************************************************************************
.soundChannel0Buffer                        = $0840     ; 16 byte sound buffer
.soundChannel1Buffer                        = $0850     ; 16 byte sound buffer
.soundChannel2Buffer                        = $0860     ; 16 byte sound buffer
.soundChannel3Buffer                        = $0870     ; 16 byte sound buffer
.printerBuffer                              = $0880     ; 64 byte printer buffer

.envelopeBuffer                             = $08C0     ; 64 byte buffer

; ***************************************************************************************
;
; Tape and Speech Buffers ($0900-$0AFF)
;
; ***************************************************************************************
.tapeOrRS423OutputBuffer                    = $0900     ; 192 byte buffer
.speechBuffer                               = $09C0     ; 64 byte buffer
.tapeOrRS423InputBuffer                     = $0A00     ; 256 byte buffer

; ***************************************************************************************
;
; Soft Key Definitions ($0B00-$0BFF)
; See .starKey.
;
; ***************************************************************************************
.softKeyPage                                = $0B00     ;
.softKeysCurrentEndOffset                   = $0B10     ; offset from $0B01 to the first free
                                                        ; byte after all current soft key
                                                        ; definitions

; ***************************************************************************************
;
; Soft Character Definitions ($0C00-$0CFF)
;
; Also known as 'soft fonts' which are stored in a 'font zone'. This is font zone zero.
; See .osbyte20EntryPoint
;
; ***************************************************************************************
.softCharacterDefinitions                   = $0C00     ; soft character definitions
                                                        ; for characters 224-255

; ***************************************************************************************
;
; NMI Routine ($0D00-$0D9E) and Extended Vector Space ($0D9F-$0DFF)
;
; ***************************************************************************************
.nmiEntryPoint                              = $0D00     ; non maskable interrupt routine
.extendedVectorSpace                        = $0D9F     ; mechanism for changing vectors at
                                                        ; $200+2*n to point into a paged ROM.
                                                        ; pointer to table of 27 entries,
                                                        ; where each entry contains three
                                                        ; bytes:
                                                        ;   ROM address low
                                                        ;   ROM address high
                                                        ;   ROM number

; ***************************************************************************************
;
; User Space ($0E00-$7FFF)
;
; ***************************************************************************************
.initialOSHWM                               = $0E00     ; start of user memory (OSHWM / PAGE)
                                                        ; (before Paged ROMs and soft
                                                        ; character definitions take pages
                                                        ; for their own use)

; ***************************************************************************************
;
; ROM Header Addresses
;
; Paged ROMs are switched into the memory map at $8000-$BFFF. When the MOS wants to identify
; ROMs, it reads the first bytes from each ROM in turn, which is a header containing useful
; information about the ROM.
;
; See .selectROMLoop
;
; ***************************************************************************************
.romStartAddress                            = $8000     ;
.romLanguageEntry                           = $8000     ;
.romServiceEntry                            = $8003     ;
.romTypeByte                                = $8006     ;
.romCopyrightOffsetPointer                  = $8007     ;
.romTitleString                             = $8009     ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 3: Memory Mapped IO
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Memory Mapping
;
; Addresses in the range $FC00-$FEFF are not mapped to the OS ROM as might be expected, but
; are connected to hardware devices. Consequently the CPU can communicate with hardware
; devices by reading and writing to specific addresses in this range.
;
; $FC00-$FCFF   - FRED      - Addresses are assigned to external devices:
;                             Winchester Disc / Teletext / Prestel / IEEE488 etc
; $FD00-$FDFF   - JIM       - Access to an optional extra 64K of RAM. See .jimPage.
; $FE00-$FEFF   - SHEILA    - Read / Write hardware internal to the BBC Micro (see next
;                             section).
;
; The OS provides OSBYTE calls for user programs to access these locations.
; See .osbyte146EntryPoint.
;
; Unlike the Commodore 64, this region of memory is permanently assigned to memory mapped IO,
; and is not bank switchable.
;
; Because of this address mapping, the underlying memory in the ROM can't be read or written
; by the OS. This memory stores credits text instead. See Chapter 22.
;
; ***************************************************************************************

; ***************************************************************************************
;
; FRED
;
; Accesses peripherals on the 1Mhz bus. Peripherals are allocated address ranges as follows:
;
;   Address range      Hardware allocated           Later additions
;   ---------------------------------------------------------------------
;   $FC00 - $FC0F      Test hardware                -
;   $FC10 - $FC13      Teletext                     -
;   $FC14 - $FC1F      Prestel                      -
;   $FC20 - $FC27      IEEE 488 Interface           -
;   $FC28 - $FC2F      -                            Econet (Electron)
;   $FC30 - $FC3F      Cambridge Ring Interface     -
;   $FC40 - $FC47      Winchester Disc              } Compact Flash Interface
;   $FC48 - $FC4F      Reserved                     }
;   $FC50 - $FC5F      -                            -
;   $FC60 - $FC6F      Serial expansion             -
;   $FC70 - $FC7F      -                            -
;   $FC80 - $FC8F      Test hardware                -
;   $FC90 - $FC9F      -                            -
;   $FCA0 - $FCAF      -                            -
;   $FCB0 - $FCBF      -                            6522 VIA (Electron)
;   $FCC0 - $FCCF      -                            1770 FDC (Electron)
;   $FCD0 - $FCDF      -                            -
;   $FCE0 - $FCEF      -                            Tube (Electron)
;   $FCF0 - $FCF7      -                            -
;   $FCF8 - $FCFD      -                            RetroClinic DataCentre
;   $FCFE              JIM paging register MSB      -
;   $FCFF              JIM paging register LSB      -
;
; ***************************************************************************************
.fredPage                                   = $FC00     ;

; ***************************************************************************************
;
; JIM
;
; If fitted JIM allows access to either an optional 64K of RAM or even up to 16Mb of RAM, one
; page at a time. Select which page by writing to location $FCFF (the JIM paging register)
; and if a 16 bit register is available also write to $FCFE. Then $FD00-$FDFF can be read
; or written to as RAM. Reading and writing is about half the speed of regular RAM.
;
; ***************************************************************************************
.jimPage                                    = $FD00     ;
.jimPagedEntryPoint                         = $FDFE     ; at reset time, holds the address
                                                        ; to call to initialise JIM hardware

; ***************************************************************************************
;
; SHEILA
;
; ***************************************************************************************
.sheilaPage                                 = $FE00     ;
.crtcAddressRegister                        = $FE00     ;
.crtcAddressWrite                           = $FE01     ;

; ***************************************************************************************
;
; ACIA 6850, Control Register ($FE08)
;
; This is used for writing values. By convention (for clarity) we use the Status Register
; (See .acia6850StatusRegister below) for reading values. Even though they both refer to
; the same memory location, they have different meanings depending on whether it's being
; read or written.
;
;     bits 0,1 - the counter divide select bits (CR0/CR1)
;          %00 - divide counter by 1
;          %01 - divide counter by 16                     (used for 1200 baud tape)
;          %10 - divide counter by 64 (default for RS-423) (used for 300 baud tape)
;          %11 - master reset
;     bit 2 - set means odd parity; otherwise even parity
;     bit 3 - set means 1 stop bit; otherwise 2 stop bits
;     bit 4 - set means 8 bit word; otherwise 7 bit word
;     bits 5,6:
;          %00 - 'Request To Send' ('RTS') low, transmit interrupt disabled
;          %01 - RTS low, transmit interrupt enabled
;          %10 - RTS high, transmit interrupt disabled
;          %11 - RTS low, break level on data output, transmit interrupt disabled
;     bit 7 - enable receive data register full, overrun, DCD transition interrupts
;
;         DCD = Data Carrier Detect interrupt occurs when the tone at the end of a cassette
;               block is discontinued
;
;     RTS low is the active state ('Request To Send')
;
; ***************************************************************************************
.acia6850ControlRegister                    = $FE08     ;

; ***************************************************************************************
;
; ACIA 6850, Status Register ($FE08)
;
; This is used for reading values. By convention (for clarity) we use the Control Register
; (See .acia6850ControlRegister above) for writing values. Even though they both refer to
; the same memory location, they have different meanings depending on whether it's being
; read or written.
;
;     bit 0 - set when a receiver interrupt is generated
;     bit 1 - set when a transmit interrupt is generated
;     bit 2 - set when a Data Carrier Detect ('DCD') interrupt is generated
;     bit 3 - set if the 6850 is not clear to send ('CTS')
;     bit 4 - framing error     } only valid if bit 0 set
;     bit 5 - receiver over run } only valid if bit 0 set
;     bit 6 - parity error      } only valid if bit 0 set
;     bit 7 - set if the 6850 generated the current interrupt
;
; ***************************************************************************************
.acia6850StatusRegister                     = $FE08     ;

.acia6850DataRegister                       = $FE09     ; ACIA 6850, transmit / receive data register ('TDR'/'RDR')

; ***************************************************************************************
;
; Serial ULA, Control Register ($FE10)
;
; See ula.png
;
;     bits 0-2 - transmit rate
;     bits 3-5 - receive rate
;                   %000    19200 baud
;                   %001     9600 baud
;                   %010     4800 baud
;                   %011     2400 baud
;                   %100     1200 baud
;                   %101      300 baud
;                   %110      150 baud
;                   %111       75 baud
;     bit 6 - if set, the RS-423 system has control of the serial system; otherwise the cassette system has control
;     bit 7 - if set, switch on the cassette motor and relay
;
; ***************************************************************************************
.serialULAControlRegister                   = $FE10     ; Serial ULA control register

; ***************************************************************************************
;
; Video ULA Control Register ($FE20)
;
; See vula.png
; https://github.com/YazanMehyar/FPGA-BBC-micro/blob/master/docs/VULA.txt
;
; bit 0   = flash on/off
; bit 1   = teletext / normal
; bit 2/3 = number of characters per line
;           %00=10 characters
;           %01=20 characters
;           %10=40 characters
;           %11=80 characters
; bit 4   = 0 means low clock frequency,  used in MODES 4-7
;           1 means high clock frequency, used in MODES 0-3
; bit 5-7 = cursor width
;           %000  hide cursor
;           %100  MODE 0,3,4,6
;           %110  MODE 1,5
;           %111  MODE 2
;           %010  MODE 7
;
; ***************************************************************************************
.videoULAControlRegister                    = $FE20     ; Video ULA control register

; ***************************************************************************************
;
; Video ULA Palette Register ($FE21)
;
; Write to this register to change the palette. The top four bits define the logical colour
; field, and the bottom four bits are the physical colour EOR 7. Changing the palette is a
; little more work than you might expect however:
;
; 16 colour MODEs (MODE 2)
; ------------------------
; This is straightforward. Write the logical colour to the top four bits, and the physical
; colour EOR 7 in the bottom four bits.
;
; 2 colour MODEs (MODE 0,3,4,6)
; -----------------------------
; Bit 7 defines the logical colour, but ALL combinations of bits 4-6 must be set individually
; in order to make the change properly. e.g. to change logical colour 1 to physical colour 2:
;
;     LDA #$85
;     STA .videoULAPaletteRegister
;     LDA #$95
;     STA .videoULAPaletteRegister
;     LDA #$A5
;     STA .videoULAPaletteRegister
;     LDA #$B5
;     STA .videoULAPaletteRegister
;     LDA #$C5
;     STA .videoULAPaletteRegister
;     LDA #$D5
;     STA .videoULAPaletteRegister
;     LDA #$E5
;     STA .videoULAPaletteRegister
;     LDA #$F5
;     STA .videoULAPaletteRegister
;
; 4 colour MODEs (MODE 1,5)
; -------------------------
; Bits 5 and 7 define the logical colour. But ALL combinations of bits 4 and 6 must also be
; set to make the change properly. e.g. to change logical colour 1 to physical colour 2:
;
;     LDA #$25
;     STA .videoULAPaletteRegister
;     LDA #$35
;     STA .videoULAPaletteRegister
;     LDA #$65
;     STA .videoULAPaletteRegister
;     LDA #$75
;     STA .videoULAPaletteRegister
;
; More OS friendly ways to set the palette are VDU 19; OSWORD 12 (which is faster than the
; VDU 19 sequence of calls and can be used in interrupts); or OSBYTE 155 (but this only writes
; to the ULA register once, so multiple calls are still needed as above).
;
; If using one of the OS friendly ways above to change the palette then the physical colours
; are:
;                 0 = black             8 = flashing black-white
;                 1 = red               9 = flashing red-cyan
;                 2 = green            10 = flashing green-magenta
;                 3 = yellow           11 = flashing yellow-blue
;                 4 = blue             12 = flashing blue-yellow
;                 5 = magenta          13 = flashing magenta-green
;                 6 = cyan             14 = flashing cyan-red
;                 7 = white            15 = flashing white-black
;
; If writing directly to .videoULAPaletteRegister ($FE21) then the values for the physical
; colour are different:
;
;      value to write = physical colour from table above EOR 7.
;
; ***************************************************************************************
.videoULAPaletteRegister                    = $FE21     ; Video ULA palette register

.romSelectRegister                          = $FE30     ;


; ***************************************************************************************
;
; System VIA, Register B ($FE40)
;
; Notes:
;     The bottom four bits are used for writing, and the top four bits are used for reading.
;     (See .systemVIADataDirectionRegisterB)
;
;     Values 0-15 can be written to System VIA Register B (Output):
;
;         Value   Effect
;         -------------------------
;         0       Enable sound chip
;         1       Enable Read Speech
;         2       Enable Write Speech
;         3       Disable Keyboard auto scanning
;         4       Hardware scrolling - set C0=0 (See below)
;         5       Hardware scrolling - set C1=0 (See below)
;         6       Turn on CAPS LOCK LED
;         7       Turn on SHIFT LOCK LED
;         8       Disable sound chip
;         9       Disable Read Speech
;         10      Disable Write Speech
;         11      Enable Keyboard auto scanning
;         12      Hardware scrolling - set C0=1 (See below)
;         13      Hardware scrolling - set C1=1 (See below)
;         14      Turn off CAPS LOCK LED
;         15      Turn off SHIFT LOCK LED
;
;  The values of C0 and C1 together determine the start scroll address for the screen:
;
;         C0   C1      Screen       Used in
;                      Address   Regular MODEs
;         ------------------------------------
;          0    0      $4000           3
;          0    1      $5800          4,5
;          1    0      $6000           6
;          1    1      $3000         0,1,2
;
; When reading from this address the top four bits are read:
;
; bit 7:    Speech processor 'ready' signal
; bit 6:    Speech processor 'interrupt' signal
; bit 4-5:  joystick buttons (bit is zero when button pressed)
;
; ***************************************************************************************
.systemVIARegisterB                         = $FE40     ; System VIA Register B (Input and Output)

; ***************************************************************************************
;
; System VIA, Register A ($FE41)
;
; This register is not used. The non-handshaking variant is used instead.
; See .systemVIADataDirectionRegisterA for details.
; ***************************************************************************************
.systemVIARegisterA                         = $FE41     ; System VIA Register A (Input and Output)

; ***************************************************************************************
;
; System VIA, Data Direction Register B ($FE42) (aka 'DDRB')
;
; When writing data into Register B (.systemVIARegisterB), the bits that are set on DDRB
; indicate which bits are actually written into Register B. The bits that are clear on DDRB
; are used to read from Register B.
;
; DDRB is only written once on startup where it is initialised to %00001111
; (see .setUpSystemVIA) and the OS expects it to remain that way. Only the bottom four bits
; of .systemVIARegisterB are used when writing, and only the upper four bits are read from
; .systemVIARegisterB. See .systemVIARegisterB.
;
; ***************************************************************************************
.systemVIADataDirectionRegisterB            = $FE42     ; System VIA data direction register B (DDRB)

; ***************************************************************************************
;
; System VIA, Data Direction Register A ($FE43) (aka 'DDRA')
;
; The keyboard, sound and speech systems use Data Direction Register A. Each bit of DDRA
; indicates whether data can be written or read on that bit when data is accessed via
; .systemVIARegisterANoHandshake. This is similar to DDRB. Unlike DDRB, the OS modifies
; DDRA frequently to set the appropriate bits for accessing the device (often in the IRQ
; interrupt code). Once set, data is read or written to .systemVIARegisterANoHandshake as
; needed. See .systemVIARegisterANoHandshake.
;
; Sound:    When outputting sound, DDRA is set to %11111111 meaning all bits of data
;           that are subsequently written to .systemVIARegisterANoHandshake are output bits.
;           (See .sendToSoundChipFlagsAreadyPushed)
;
; Speech:   For speech, DDRA is set to %00000000 (for reading) or %11111111 (for writing) as
;           needed. (See .readWriteSpeechProcessorPushedFlags)
;
; Keyboard: When reading the keyboard, DDRA is set to (%011111111). The key to read is written
;           into bits 0-6 of .systemVIARegisterANoHandshake, and the 'pressed' state of that
;           key is then read from bit 7.
;           (See .interrogateKeyboard)
;           (See .scanKeyboard)
;
; ***************************************************************************************
.systemVIADataDirectionRegisterA            = $FE43     ; System VIA data direction register A (DDRA)

; ***************************************************************************************
;
; System VIA, Timer 1 registers ($FE44-7)
;
; This is a 1Mhz countdown timer. An IRQ is triggered when the timer reaches zero. The OS
; uses this timer as a 100Hz timer to update various parts of the OS. It is expected to
; remain as a 100Hz timer if the OS is to continue working properly. User VIA Timers are
; available for user programs instead.
; See .irq1CheckSystemVIA100HzTimer.
;
; Timer 1 can be configured in one of two modes by writing to the ACR
; (see .systemVIAAuxiliaryControlRegister):
;
; One-shot mode:
;   .systemVIATimer1LatchLow and .systemVIATimer1CounterHigh form a 16 bit countdown value.
;   Write to .systemVIATimer1LatchLow first then writing to .systemVIATimer1CounterHigh
;   starts the timer. When the timer is complete a timer IRQ interrupt is generated. This
;   only happens once.
;
; Free-run mode (aka 'Continuous interrupts'):
;   .systemVIATimer1LatchLow and .systemVIATimer1LatchHigh are initialised to the initial
;   timeout value for the timer. The timer starts when .systemVIATimer1CounterHigh is
;   also written. Unlike one-shot mode, once the timeout interrupt has happened the counter
;   is reset to the values in the latches and the process repeats. The process can be stopped
;   by writing .systemVIATimer1CounterHigh, by reading .systemVIATimer1CounterLow, or by
;   writing to the interrupt flag.
;   This is the mode set by the OS for Timer 1 at startup. See .setUpPage2.
;
; ***************************************************************************************
.systemVIATimer1CounterLow                  = $FE44     ;
.systemVIATimer1CounterHigh                 = $FE45     ;
.systemVIATimer1LatchLow                    = $FE46     ;
.systemVIATimer1LatchHigh                   = $FE47     ;

; ***************************************************************************************
;
; System VIA, Timer 2 registers ($FE48-9)
;
; Timer 2 (like Timer 1) is a 1MHz countdown timer with an IRQ being generated when the
; counter reaches zero. It is used by the OS to update the Speech system if present. It also
; has two modes of operation, selected by writing to the ACR. (See .systemVIAAuxiliaryControlRegister).
;
; One-shot mode:
;   This is similar to Timer 1 (above). Write the low byte of the timer first
;   .systemVIATimer2CounterLow then writing to the high byte of the counter
;   .systemVIATimer2CounterHigh starts the timer. When the timer is countdown reaches zero
;   a timer IRQ interrupt is generated. This only happens once.
;
; Pulse counting mode:
;   This is unlike Timer 1. It counts down the number of negative going pulses applied to
;   System VIA input pin PB6. Firstly write to .systemVIATimer2CounterLow, then writing to
;   .systemVIATimer2CounterHigh will start the countdown. When PB6 is pulsed low for the
;   appropriate number of times then an IRQ interrupt occurs. This only happens once. This
;   is the default mode as initialised at startup.
;
; Timer 2 is started by the Speech system (if present) as needed to time Speech. The timer
; is cleared by the OS when a Timer 2 IRQ is received (see .irq1CheckSystemVIASpeech).
; It is also cleared at startup. See .setUpPage2.
; ***************************************************************************************
.systemVIATimer2CounterLow                  = $FE48     ;
.systemVIATimer2CounterHigh                 = $FE49     ;

; ***************************************************************************************
;
; The System VIA, Shift Register ($FE4A)
;
; This is not used in this OS. It is designed to be used for serial data I/O by shifting
; bits one at a time under the control of an internal modulo-8 counter.
; See NAUG Section 22.4.9, Page 395.
;
; ***************************************************************************************
.systemVIAShiftRegister                     = $FE4A     ;

; ***************************************************************************************
;
; System VIA, Auxiliary Control Register ($FE4B) (aka 'ACR')
;
; bit 0:    PA latch enable
; bit 1:    PB latch enable
; bits 2-4: Shift register mode
; bit 5:    Timer 2 mode: 0=One-shot mode; 1=Pulse counting mode.
; bit 6:    Enable pulsing of System VIA output pin PB7. When enabled, Timer 1 will set
;           PB7 as follows:
;           In One-shot mode:
;               PB7 is cleared when Timer 1 started,
;               PB7 is set when Timer 1 one-shot mode times out.
;           In Free-run mode:
;               PB7 is inverted when Timer 1 times out.
; bit 7:    Timer 1 mode: 0=One shot mode; 1=Free-run mode.
;
; In the reset code (see .setUpPage2) this register is initialised to:
;
;   (a) disable the latches and the shift register,
;   (b) set Timer 2 as an interval timer,
;   (c) set Timer 1 as free-run mode (aka continuous interrupts).
;
; Otherwise this register is not used by the OS.
;
; See NAUG Section 22.4.8, Page 395.
;
; ***************************************************************************************
.systemVIAAuxiliaryControlRegister          = $FE4B     ;

; ***************************************************************************************
;
; System VIA, Peripheral Control Register ($FE4C) (aka 'PCR')
;
; bit 0    = CA1 interrupt control
;            Writing to CA1 means "data taken"
;            0 means negative active edge
;            1 means positive active edge
;
; bits 1-3 = CA2 control mode
;            CA2 signifies "data ready"
;
; bit 4    = CB1 interrupt control
;            Writing to CB1 means "data taken"
;            0 means negative active edge
;            1 means positive active edge
;
; bits 5-7 = CB2 control mode
;            CB2 signifies "data ready"
;
; control mode:
;   000 = negative edges active on input
;   001 = independent interrupt; input negative edge
;   010 = positive edges active on input
;   011 = independent interrupt; input positive edge
;   100 = handshake output mode
;   101 = pulse output mode
;   110 = low output
;   111 = high output
;
; The System VIA PCR initialises like so (See .setUpPage2):
;       CA1 has negative active edge       (vertical sync)
;       CA2 positive edges active on input (keyboard)
;       CB1 has negative active edge       (end of analogue conversion)
;       CB2 negative active edges on input (light pen strobe)
; ***************************************************************************************
.systemVIAPeripheralControlRegister         = $FE4C     ;

; ***************************************************************************************
;
; System VIA, Interrupt Flag Register ($FE4D) (aka 'IFR')
;
;   bit 0 = key pressed interrupt
;   bit 1 = vertical sync occurred
;   bit 2 = shift register timeout (unused)
;   bit 3 = lightpen strobe off screen
;   bit 4 = analogue conversion completed
;   bit 5 = timer 2 has timed out (used for speech)
;   bit 6 = timer 1 has timed out (100Hz signal)
;   bit 7 = (when reading) master interrupt flag (0-6 invalid if clear)
;
; Used in interrupt code:
;
; Reading
; -------
; If bit 7 is set then the System VIA caused the current interrupt. The remaining bits can
; then be checked to see the exact cause.
;
; Writing
; -------
; Clear bit 7 and set a bit 0-6 to clear that interrupt.
;
; ***************************************************************************************
.systemVIAInterruptFlagRegister             = $FE4D     ;

; ***************************************************************************************
;
; System VIA, Interrupt Enable Register ($FE4E) (aka 'IER')
;
; Each bit controls whether an interrupt is enabled or disabled.
;
; bit 0 = key pressed interrupt
; bit 1 = vertical sync occurred
; bit 2 = shift register timeout (unused)
; bit 3 = light pen strobe off screen
; bit 4 = analogue conversion completed
; bit 5 = timer 2 timed out (used for speech)
; bit 6 = timer 1 timed out (100Hz signal)
; bit 7 = enable/disable interrupt value (see below)
;
; Writing:
; --------
; To enable  an interrupt, write a byte with the top bit set   and set the desired bit(s) (0-6).
; To disable an interrupt, write a byte with the top bit clear and set the desired bit(s) (0-6).
;
; Reading:
; --------
; Bits 0-6 are read as expected.
; Bit 7 is always set when read.
;
; ***************************************************************************************
.systemVIAInterruptEnableRegister           = $FE4E     ;

; See .systemVIADataDirectionRegisterA.
.systemVIARegisterANoHandshake              = $FE4F     ; System VIA Register A without handshaking

; ***************************************************************************************
;
; User VIA
;
; Port A is the (Centronics) parallel printer port (output only)
; Port B is the user port (input and output) (unused by the OS)
;
; See .openPrinterChannel for details of how to write to the printer.
;
; The data direction registers work as they do on the System VIA
; (see .systemVIADataDirectionRegisterB)
;
; The User VIA has Timer 1 and Timer 2. They work in the same way as the timers on the
; System VIA. These are not used by the OS so are available for user programs.
; See .systemVIATimer1CounterLow.
; See .systemVIATimer2CounterLow.
;
; The auxiliary control register works the same way as on the System VIA.
; See .systemVIAAuxiliaryControlRegister.
;
; The shift register is unused.
;
; ***************************************************************************************
.userVIARegisterB                           = $FE60     ; Register B (input/output)
.userVIARegisterA                           = $FE61     ; Register A (output)
.userVIADataDirectionRegisterB              = $FE62     ; data direction register B
.userVIADataDirectionRegisterA              = $FE63     ; data direction register A

.userVIATimer1CounterLow                    = $FE64     ; Timer 1 counter (low)
.userVIATimer1CounterHigh                   = $FE65     ; Timer 1 counter (high)
.userVIATimer1LatchLow                      = $FE66     ; Timer 1 latch (low)
.userVIATimer1LatchHigh                     = $FE67     ; Timer 1 latch (high)
.userVIATimer2CounterLow                    = $FE68     ; Timer 2 counter (low)
.userVIATimer2CounterHigh                   = $FE69     ; Timer 2 counter (high)

.userVIAShiftRegister                       = $FE6A     ; shift register
.userVIAAuxiliaryControlRegister            = $FE6B     ; auxiliary control register

; ***************************************************************************************
;
; User VIA, peripheral control register ($FE6C)
;
; This works the same as on the System VIA (See .systemVIAPeripheralControlRegister).
;
; The User VIA PCR initialises like so (See .setUpPage2):
;           CA1 interrupt on -ve edge     (usually printer Acknowledge)
;           CA2 high output               (usually printer strobe)
;           CB1 interrupt on -ve edge     (user port)
;           CB2 negative edge             (user port)
; ***************************************************************************************
.userVIAPeripheralControlRegister           = $FE6C     ; Peripheral control register

; ***************************************************************************************
;
; User VIA, interrupt flag register ($FE6D)
;
; Writing:
; To clear printer interrupts, clear bit 7 and set bit 1
;
; Reading:
; bit 7 set means the current interrupt is from the User VIA
; bit 1 set signifies a parallel printer interrupt.
; (See .irq1CheckUserVIA)
;
; ***************************************************************************************
.userVIAInterruptFlagRegister               = $FE6D     ; Interrupt flag register

; ***************************************************************************************
;
; User VIA, interrupt enable register ($FE6E)
;
; Writing:
; To disable printer interrupts, clear bit 7 and set bit 1
; To  enable printer interrupts,   set bit 7 and set bit 1
;
; Reading:
; bit 1 set signifies the printer interrupt is enabled.
; bit 7 is always set when reading.
; (See .irq1CheckUserVIA)
; ***************************************************************************************
.userVIAInterruptEnableRegister             = $FE6E     ; Interrupt enable register

; ***************************************************************************************
;
; User VIA, Register B no handshake ($FE6F)
;
; ***************************************************************************************
.userVIARegisterBNoHandshake                = $FE6F     ; Register B but no handshake

; ***************************************************************************************
;
; ADC 7002 - Analogue to digital conversion
;
; See .osbyte17EntryPoint
;
; ***************************************************************************************
.adcDataStatusRegister                      = $FEC0     ; For reading the current ADC
                                                        ; conversion state
.adcStartConversionRegister                 = $FEC0     ; For writing when we want to start
                                                        ; an ADC conversion
.adcDataHighByte                            = $FEC1     ; ADC (7002) high data byte
.adcDataLowByte                             = $FEC2     ; ADC (7002) low data byte

; ***************************************************************************************
;
; The Tube - Registers
;
; See NAUG Section 18.3, Page 328
;
; ***************************************************************************************
.tubeULAStatusRegister                      = $FEE0     ; Tube ULA Status Register
.tubeULADataRegister3                       = $FEE5     ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 4: Character definitions and VDU tables
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Character definitions
;
; See font.png
;
; This is the start of the OS, located at $C000.
;
; The shape of each printable character (ASCII codes 32-126) is defined below. They are used
; to draw text in all non-teletext MODEs 0-6 (see .displayACharacter). Character 127 (DELETE)
; is not a printable character, but is given a definition here anyway as a solid block of set
; pixels. It's drawn in the background colour to erase the character at the graphics cursor.
;
; Characters already drawn can be read from the screen, to retrieve the ASCII code from the
; pattern of pixels on screen. The OS itself uses this when in cursor editing mode (the two
; cursor editing with READ and WRITE cursors, as seen in the BASIC line editor and user text
; input in general). See .osbyte135EntryPoint.
;
; Historical note: The BBC Micro was Acorn's first computer to contain a character set in
; ROM, unless you count the seven-segment LED settings for the hex digits 0 to F in the
; tiny Acorn System 1. The System 2 used teletext graphics akin to the BBC's Mode 7, and
; the Atom's rather smaller set of symbols (which lacked lower-case letters) were similarly
; generated directly in the video circuitry rather than being plotted from symbols in ROM.
;
; ***************************************************************************************
* = $C000

.characterDefinitions
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %........

    !byte %.##.##..
    !byte %.##.##..
    !byte %.##.##..
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %..##.##.
    !byte %..##.##.
    !byte %.#######
    !byte %..##.##.
    !byte %.#######
    !byte %..##.##.
    !byte %..##.##.
    !byte %........

    !byte %....##..
    !byte %..######
    !byte %.##.#...
    !byte %..#####.
    !byte %....#.##
    !byte %.######.
    !byte %...##...
    !byte %........

    !byte %.##.....
    !byte %.##..##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##..##.
    !byte %.....##.
    !byte %........

    !byte %..###...
    !byte %.##.##..
    !byte %.##.##..
    !byte %..###...
    !byte %.##.##.#
    !byte %.##..##.
    !byte %..###.##
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %........
    !byte %...##...
    !byte %.######.
    !byte %..####..
    !byte %.######.
    !byte %...##...
    !byte %........
    !byte %........

    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %..##....

    !byte %........
    !byte %........
    !byte %........
    !byte %.######.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %........
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %........
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.###.
    !byte %.######.
    !byte %.###.##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %...##...
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.....##.
    !byte %...###..
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %....##..
    !byte %...###..
    !byte %..####..
    !byte %.##.##..
    !byte %.######.
    !byte %....##..
    !byte %....##..
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.#####..
    !byte %.....##.
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %...###..
    !byte %..##....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.######.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %....##..
    !byte %..###...
    !byte %........

    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %........
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %..##....

    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %........
    !byte %........
    !byte %.######.
    !byte %........
    !byte %.######.
    !byte %........
    !byte %........
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %....##..
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.###.
    !byte %.##.#.#.
    !byte %.##.###.
    !byte %.##.....
    !byte %..####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.######.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.######.
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##.###.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.######.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.######.
    !byte %........

    !byte %..#####.
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %....##..
    !byte %.##.##..
    !byte %..###...
    !byte %........

    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %.###....
    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %........

    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.##...##
    !byte %.###.###
    !byte %.#######
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.##...##
    !byte %.##...##
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.###.##.
    !byte %.######.
    !byte %.##.###.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##.#.#.
    !byte %.##.##..
    !byte %..##.##.
    !byte %........

    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.##..
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %..####..
    !byte %.....##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.######.
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %........

    !byte %.##...##
    !byte %.##...##
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.#######
    !byte %.###.###
    !byte %.##...##
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %.######.
    !byte %.....##.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.##.....
    !byte %.######.
    !byte %........

    !byte %.#####..
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %........

    !byte %........
    !byte %.##.....
    !byte %..##....
    !byte %...##...
    !byte %....##..
    !byte %.....##.
    !byte %........
    !byte %........

    !byte %..#####.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %.....##.
    !byte %..#####.
    !byte %........

    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %.#....#.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %########

    !byte %...###..
    !byte %..##.##.
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.....##.
    !byte %..#####.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.##.....
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %.....##.
    !byte %.....##.
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.######.
    !byte %.##.....
    !byte %..####..
    !byte %........

    !byte %...###..
    !byte %..##....
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %........

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %..####..

    !byte %.##.....
    !byte %.##.....
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %...##...
    !byte %........
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %..####..
    !byte %........

    !byte %...##...
    !byte %........
    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %.###....

    !byte %.##.....
    !byte %.##.....
    !byte %.##..##.
    !byte %.##.##..
    !byte %.####...
    !byte %.##.##..
    !byte %.##..##.
    !byte %........

    !byte %..###...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %..####..
    !byte %........

    !byte %........
    !byte %........
    !byte %..##.##.
    !byte %.#######
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.##...##
    !byte %........

    !byte %........
    !byte %........
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %........

    !byte %........
    !byte %........
    !byte %..####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %........

    !byte %........
    !byte %........
    !byte %.#####..
    !byte %.##..##.
    !byte %.##..##.
    !byte %.#####..
    !byte %.##.....
    !byte %.##.....

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %.....###

    !byte %........
    !byte %........
    !byte %.##.##..
    !byte %.###.##.
    !byte %.##.....
    !byte %.##.....
    !byte %.##.....
    !byte %........

    !byte %........
    !byte %........
    !byte %..#####.
    !byte %.##.....
    !byte %..####..
    !byte %.....##.
    !byte %.#####..
    !byte %........

    !byte %..##....
    !byte %..##....
    !byte %.#####..
    !byte %..##....
    !byte %..##....
    !byte %..##....
    !byte %...###..
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %........

    !byte %........
    !byte %........
    !byte %.##...##
    !byte %.##.#.##
    !byte %.##.#.##
    !byte %.#######
    !byte %..##.##.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %..####..
    !byte %...##...
    !byte %..####..
    !byte %.##..##.
    !byte %........

    !byte %........
    !byte %........
    !byte %.##..##.
    !byte %.##..##.
    !byte %.##..##.
    !byte %..#####.
    !byte %.....##.
    !byte %..####..

    !byte %........
    !byte %........
    !byte %.######.
    !byte %....##..
    !byte %...##...
    !byte %..##....
    !byte %.######.
    !byte %........

    !byte %....##..
    !byte %...##...
    !byte %...##...
    !byte %.###....
    !byte %...##...
    !byte %...##...
    !byte %....##..
    !byte %........

    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %........

    !byte %..##....
    !byte %...##...
    !byte %...##...
    !byte %....###.
    !byte %...##...
    !byte %...##...
    !byte %..##....
    !byte %........

    !byte %..##...#
    !byte %.##.#.##
    !byte %.#...##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########

; ***************************************************************************************
;
; Screen initialisation on reset
;
; [This is an oddity, since there's no real reason for this JMP instruction to be here. The
; only caller (see .skipSpeech) could have equally used 'JSR .initialiseVDUVariablesAndSetMODE'
; instead of 'JSR .initialiseScreenOnReset' saving three bytes and three cycles.]
;
; ***************************************************************************************
.vduBaseAddress
.initialiseScreenOnReset
    JMP .initialiseVDUVariablesAndSetMODE               ;

; ***************************************************************************************
;
; The boot message
;
; See Boot.png
; See startup.mp3
; Here a BBC Micro Model B has booted up, displaying the 32K version of its welcome message.
; The Acorn Disk Filing System, installed on this machine as a sideways ROM, also identifies
; itself, after which the MOS enters the language ROM, BBC BASIC. It's BASIC, not the MOS,
; which displays the ">" prompt and receives commands. The screen is in MODE 7, so the
; text uses Teletext characters rather than being rendered in the raster font above.
;
; The startup sound has random variation in the first tone(s) as the sound chip starts
; playing random data on reset until the audio is silenced (See .resetClearAllSounds), and
; the second tone is the familiar .charBELL sound from the boot message below.
;
; Teletext characters look smoother than the regular raster font, thanks to the hardware's
; diagonal smoothing algorithm, giving them an effective resolution of 10x18 pixels instead
; of 8x8 in other MODEs.
; See https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms#SAA5050_'diagonal_smoothing'.
;
; Historical note: All of Acorn's early computers booted up with brief identifications
; like this, then a skipped line, then a prompt. For the System 2, it was "Acorn Cos",
; referring to its "cassette operating system"; for the Atom, which had only upper case
; characters, the ident was "ACORN ATOM". What is perhaps most notable about the ident on
; the original BBC Micro is that it mentions the BBC, but not Acorn (unless additional
; ROMs such as the disc filing system are also plugged in). Subsequent models did
; not follow this pattern: the BBC Master ident is "Acorn MOS", and the B+ is "Acorn OS"
; plus a RAM size.
;
; See 5050.png
;
; ***************************************************************************************

.bootMessage
    !text .charRETURN, "BBC Computer ", 0

.bootMessageMemory16
    !text "16K", .charBELL, 0

.bootMessageMemory32
    !text "32K", .charBELL, 0

.bootMessageEnding
    !text .charBACKSPACE, .charRETURN, .charRETURN      ; overlaps by one byte into the
                                                        ; following table for the zero
                                                        ; terminator

; ***************************************************************************************
;
; Four colour conversion table
;
; Used when drawing characters to the screen. The index into the table is a pattern of four
; bits (%0000-%1111) representing half of the eight bit text character row definition. The
; value of the array entry is the byte value required to write that pattern of white pixels
; on screen.
;
; ***************************************************************************************
.fourColourMODEByteMaskTable
    !byte $00, $11, $22, $33, $44, $55, $66, $77
    !byte $88, $99, $AA, $BB, $CC, $DD, $EE, $FF

; ***************************************************************************************
;
; Sixteen colour conversion table
;
; Used when drawing characters to the screen. The index into the table is a pattern of two
; bits (%00-%11) representing a quarter of the eight bit text character row definition. The
; value of the array entry is the byte value required to write that pattern of white pixels
; on screen.
;
; ***************************************************************************************
.sixteenColourMODEByteMaskTable
    !byte $00, $55, $AA, $FF

; ***************************************************************************************
;
; Table of addresses (low byte) to handle VDU N
;
; This table stores the low byte of the address of the routine to handle VDU n.
; It holds values for VDU 0-31 and 127.
;
; ***************************************************************************************
.vduEntryPointTableLow
    !byte <.vdu0EntryPoint                              ; Does nothing
    !byte <.vdu1EntryPoint                              ; Send next character to printer only
    !byte <.vdu2EntryPoint                              ; Enable printer
    !byte <.vdu3EntryPoint                              ; Disable printer
    !byte <.vdu4EntryPoint                              ; Write text at text cursor
    !byte <.vdu5EntryPoint                              ; Write text at graphics cursor
    !byte <.vdu6EntryPoint                              ; Enable VDU drivers
    !byte <.vdu7EntryPoint                              ; Make a short beep
    !byte <.vdu8EntryPoint                              ; Move cursor left
    !byte <.vdu9EntryPoint                              ; Move cursor right
    !byte <.vdu10EntryPoint                             ; Move cursor down
    !byte <.vdu11EntryPoint                             ; Move cursor up
    !byte <.vdu12EntryPoint                             ; Clear text window
    !byte <.vdu13EntryPoint                             ; Move cursor to start of current line
    !byte <.vdu14EntryPoint                             ; Paged mode on
    !byte <.vdu15EntryPoint                             ; Paged mode off
    !byte <.vdu16EntryPoint                             ; Clear graphics window
    !byte <.vdu17EntryPoint                             ; Define text colour
    !byte <.vdu18EntryPoint                             ; Define graphics colour
    !byte <.vdu19EntryPoint                             ; Change palette colour
    !byte <.vdu20EntryPoint                             ; Restore default palette
    !byte <.vdu21EntryPoint                             ; Disable VDU drivers / delete line
    !byte <.vdu22EntryPoint                             ; Select screen MODE
    !byte <.vdu23EntryPoint                             ; Define character shape (etc)
    !byte <.vdu24EntryPoint                             ; Define graphics window
    !byte <.vdu25EntryPoint                             ; PLOT
    !byte <.vdu26EntryPoint                             ; Restore default windows
    !byte <.vdu27EntryPoint                             ; Does nothing
    !byte <.vdu28EntryPoint                             ; Define text window
    !byte <.vdu29EntryPoint                             ; Define graphics origin
    !byte <.vdu30EntryPoint                             ; Move text cursor to top left
    !byte <.vdu31EntryPoint                             ; Move text cursor to X,Y
.vduEntryPointTableDelete
    !byte <.vdu127EntryPoint                            ; Delete

; ***************************************************************************************
;
; Table of addresses (high byte) to handle VDU N
;
; The previous table holds the lower byte.
; This table holds values for VDU 0-31 and 127.
;
; If parameters are required then the top bit is clear, (16 - number of parameters) is stored
; in the lower 4 bits, and the remaining three of the top four bits holds the high byte of
; the offset from .vduBaseAddress. We only have three bits to store the offset's high byte,
; so the offset must be less than $800. For this reason, VDU calls with parameters are stored
; near the start of the ROM.
;
; The top bit set indicates that no parameters are required, so the entry just holds the high
; byte of the address directly.
;
; ***************************************************************************************
.vduEntryPointTableHigh
    !byte >.vdu0EntryPoint                                      ; Does nothing
    !byte (>(.vdu1EntryPoint - .vduBaseAddress))*16 + (16 - 1)  ; Send next character to
                                                                ; printer only (1 parameter)
    !byte >.vdu2EntryPoint                                      ; Enable printer
    !byte >.vdu3EntryPoint                                      ; Disable printer
    !byte >.vdu4EntryPoint                                      ; Write text at text cursor
    !byte >.vdu5EntryPoint                                      ; Write text at graphics cursor
    !byte >.vdu6EntryPoint                                      ; Enable VDU drivers
    !byte >.vdu7EntryPoint                                      ; Make a short beep
    !byte >.vdu8EntryPoint                                      ; Move cursor left
    !byte >.vdu9EntryPoint                                      ; Move cursor right
    !byte >.vdu10EntryPoint                                     ; Move cursor down
    !byte >.vdu11EntryPoint                                     ; Move cursor up
    !byte >.vdu12EntryPoint                                     ; Clear text area
    !byte >.vdu13EntryPoint                                     ; Move cursor to start of
                                                                ; current line
    !byte >.vdu14EntryPoint                                     ; Paged mode on
    !byte >.vdu15EntryPoint                                     ; Paged mode off
    !byte >.vdu16EntryPoint                                     ; Clear graphics window
    !byte (>(.vdu17EntryPoint - .vduBaseAddress))*16 + (16 - 1) ; Define text colour
                                                                ; (1 parameter)
    !byte (>(.vdu18EntryPoint - .vduBaseAddress))*16 + (16 - 2) ; Define graphics colour
                                                                ; (2 parameters)
    !byte (>(.vdu19EntryPoint - .vduBaseAddress))*16 + (16 - 5) ; Define palette colour
                                                                ; (5 parameters)
    !byte >.vdu20EntryPoint                                     ; Restore default palette
    !byte >.vdu21EntryPoint                                     ; Disable VDU drivers /
                                                                ; delete current line
    !byte (>(.vdu22EntryPoint - .vduBaseAddress))*16 + (16 - 1) ; Select screen MODE
                                                                ; (1 parameter)
    !byte (>(.vdu23EntryPoint - .vduBaseAddress))*16 + (16 - 9) ; Define character shape (etc)
                                                                ; (9 parameters)
    !byte (>(.vdu24EntryPoint - .vduBaseAddress))*16 + (16 - 8) ; Define graphics window
                                                                ; (8 parameters)
    !byte (>(.vdu25EntryPoint - .vduBaseAddress))*16 + (16 - 5) ; PLOT (5 parameters)
    !byte >.vdu26EntryPoint                                     ; Restore default windows
    !byte >.vdu27EntryPoint                                     ; Does nothing
    !byte (>(.vdu28EntryPoint - .vduBaseAddress))*16 + (16 - 4) ; Define text window
                                                                ; (4 parameters)
    !byte (>(.vdu29EntryPoint - .vduBaseAddress))*16 + (16 - 4) ; Define graphics origin
                                                                ; (4 parameters)
    !byte >.vdu30EntryPoint                                     ; Move text cursor to top left
    !byte (>(.vdu31EntryPoint - .vduBaseAddress))*16 + (16 - 2) ; Move text cursor to X,Y
                                                                ; (2 parameters)
    !byte >.vdu127EntryPoint                                    ; Delete

; ***************************************************************************************
;
; Multiplication tables
;
; Used for calculating screen addresses
;
; ***************************************************************************************
.multiplyBy640Table
    !be16 0 * 640
    !be16 1 * 640
    !be16 2 * 640
    !be16 3 * 640
    !be16 4 * 640
    !be16 5 * 640
    !be16 6 * 640
    !be16 7 * 640
    !be16 8 * 640
    !be16 9 * 640
    !be16 10 * 640
    !be16 11 * 640
    !be16 12 * 640
    !be16 13 * 640
    !be16 14 * 640
    !be16 15 * 640
    !be16 16 * 640
    !be16 17 * 640
    !be16 18 * 640
    !be16 19 * 640
    !be16 20 * 640
    !be16 21 * 640
    !be16 22 * 640
    !be16 23 * 640
    !be16 24 * 640
    !be16 25 * 640
    !be16 26 * 640
    !be16 27 * 640
    !be16 28 * 640
    !be16 29 * 640
    !be16 30 * 640
    !be16 31 * 640

.multiplyBy40Table
    !be16 0 * 40
    !be16 1 * 40
    !be16 2 * 40
    !be16 3 * 40
    !be16 4 * 40
    !be16 5 * 40
    !be16 6 * 40
    !be16 7 * 40
    !be16 8 * 40
    !be16 9 * 40
    !be16 10 * 40
    !be16 11 * 40
    !be16 12 * 40
    !be16 13 * 40
    !be16 14 * 40
    !be16 15 * 40
    !be16 16 * 40
    !be16 17 * 40
    !be16 18 * 40
    !be16 19 * 40
    !be16 20 * 40
    !be16 21 * 40
    !be16 22 * 40
    !be16 23 * 40
    !be16 24 * 40

; ***************************************************************************************
;
; Screen MODE dimensions
;
; The maximum text row and column number in each MODE.
;
; ***************************************************************************************
.textWindowBottomRowTable                               ; Maximum text row number
    !byte 31                                            ; MODE 0 (32 rows)
    !byte 31                                            ; MODE 1 (32 rows)
    !byte 31                                            ; MODE 2 (32 rows)
    !byte 24                                            ; MODE 3 (25 rows)
    !byte 31                                            ; MODE 4 (32 rows)
    !byte 31                                            ; MODE 5 (32 rows)
    !byte 24                                            ; MODE 6 (25 rows)
    !byte 24                                            ; MODE 7 (25 rows)

.textWindowRightColumnTable                             ; Maximum text column number
    !byte 79                                            ; MODE 0 (80 columns)
    !byte 39                                            ; MODE 1 (40 columns)
    !byte 19                                            ; MODE 2 (20 columns)
    !byte 79                                            ; MODE 3 (80 columns)
    !byte 39                                            ; MODE 4 (40 columns)
    !byte 19                                            ; MODE 5 (20 columns)
    !byte 39                                            ; MODE 6 (40 columns)
    !byte 39                                            ; MODE 7 (40 columns)

; ***************************************************************************************
;
; Video Control Register of the VideoULA
;
; bit
;   0 - Flash colour select (which of the flashing colours is displayed)
;   1 - Teletext select
;   2 - } These two bits determine the number of characters per row
;   3 - } from this table:
;       %00 = 10 characters per row
;       %01 = 20 characters per row
;       %10 = 40 characters per row
;       %11 = 80 characters per row
;   4 - CRTC clock rate select:
;        %0 = low frequency clock for MODEs 4-7
;        %1 = high frequency clock for MODEs 0-3
;   5 - } These two bits determine the width of cursor in bytes
;   6 - } from this table:
;       %00 = 1 (MODEs 0,3,4,6)
;       %01 = - undefined
;       %10 = 2 (MODEs 1,5,7)
;       %11 = 4 (MODE 2)
;   7 - Master cursor width. If set, causes a larger cursor to be displayed
;
; ***************************************************************************************
.videoULAVideoControlRegisterDefaultValuesPerMODE
    !byte %10011100                                     ; MODE 0
    !byte %11011000                                     ; MODE 1
    !byte %11110100                                     ; MODE 2
    !byte %10011100                                     ; MODE 3
    !byte %10001000                                     ; MODE 4
    !byte %11000100                                     ; MODE 5
    !byte %10001000                                     ; MODE 6
    !byte %01001011                                     ; MODE 7

.bytesPerCharacter
    !byte 8                                             ; MODE 0
    !byte 16                                            ; MODE 1
    !byte 32                                            ; MODE 2
    !byte 8                                             ; MODE 3
    !byte 8                                             ; MODE 4
    !byte 16                                            ; MODE 5
    !byte 8                                             ; MODE 6
    !byte 1                                             ; MODE 7

; ***************************************************************************************
;
; Pixel tables
;
; A 16 colour MODE (MODE 2) has two pixels per byte. The first table gives the byte
; values required to set each pixel in a byte to white (leaving the remainder black).
; The second table is the equivalent for four colour MODEs (four pixels per byte).
; The third table is the equivalent for two colour MODEs (eight pixels per byte, dual use
; with .fontMaskTable)
;
; ***************************************************************************************
.sixteenColourMODEMaskTable
    !byte %10101010, %01010101                          ; 2 pixels per byte (MODE 2)

.fourColourMODEMaskTable
    !byte %10001000, %01000100, %00100010, %00010001    ; 4 pixels per byte (MODE 1 or 5)

.fontMaskTable                                          ; 8 pixels per byte (MODE 0 or 4)
     ; This array is dual purpose - used both as the 8 pixels per byte MODE mask table and
     ; also to interrogate a particular bit in the vduFontByte.
     !byte $80, $40, $20, $10, $08, $04, $02
     ; The next byte overlaps (being the last byte in this table and the first byte in the next)

.numberOfColoursMinusOneInMODETable
    !byte 1                                             ; MODE 0
    !byte 3                                             ; MODE 1
    !byte 15                                            ; MODE 2
    !byte 1                                             ; MODE 3
    !byte 1                                             ; MODE 4
    !byte 3                                             ; MODE 5
    !byte 1                                             ; MODE 6
    !byte 0                                             ; MODE 7

; ***************************************************************************************
; This table is used when setting .vduGraphicsColourByteOR and .vduGraphicsColourByteEOR
; in .setGraphicsColourMaskXY. This table is used to help implement the GCOL Mode.
;
; GCOL Mode: 0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert
;
; See .setGraphicsColourMaskXY
.gcolPlotOptionsTable
    !byte $FF                                           ; Underflow: The last byte of the
    !byte $00                                           ; previous table (zero) is accessed as
    !byte $00                                           ; part of the calculations.
    !byte $FF                                           ;
    !byte $FF                                           ;
    !byte $FF                                           ;
    !byte $FF                                           ;
    !byte $00                                           ; Overflow: The following byte in the
                                                        ; next table (zero) is accessed as
                                                        ; part of the calculations.

; ***************************************************************************************
;
; Solid colour tables
;
; The following tables hold the byte values required to write a full solid byte of COLOUR N
; on screen (N being the offset into the table). One table for the 2 colour MODEs, one for
; 4 colour MODEs, and one for 16 colour MODEs.
; See .vdu18EntryPoint.
;
; ***************************************************************************************
.twoColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %11111111                                     ;

.fourColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %00001111                                     ;
    !byte %11110000                                     ;
    !byte %11111111                                     ;

.sixteenColourMODEParameterTable
    !byte %00000000                                     ;
    !byte %00000011                                     ;
    !byte %00001100                                     ;
    !byte %00001111                                     ;
    !byte %00110000                                     ;
    !byte %00110011                                     ;
    !byte %00111100                                     ;
    !byte %00111111                                     ;
    !byte %11000000                                     ;
    !byte %11000011                                     ;
    !byte %11001100                                     ;
    !byte %11001111                                     ;
    !byte %11110000                                     ;
    !byte %11110011                                     ;
    !byte %11111100                                     ;
    !byte %11111111                                     ;

.pixelsPerByteMinusOneInMODETable
    !byte 7                                             ; MODE 0
    !byte 3                                             ; MODE 1
    !byte 1                                             ; MODE 2
    !byte 0                                             ; MODE 3
    !byte 7                                             ; MODE 4
    !byte 3                                             ; MODE 5
    ; Overflow: the first two bytes of the next table are accessed as the last two bytes of
    ; this table (zero for MODE 6 and 7 values).

    ; This table describes how much memory each MODE takes. Eight byte table (one byte for
    ; each MODE), overlapping with the next two tables.
.screenDisplayMemoryIndexTable
    !byte 0                                             ; MODE 0

    ; Sound pitch offsets table: Notes played on different sound channels are offset in pitch
    ; slightly from each other (perhaps to reduce phase shift effects when the same note is
    ; played on two or more different channels). This is four bytes long (in the middle of
    ; the previous table!).
.soundPitchOffsetByChannelTable                         ; Dual use:
                                                        ; screen memory   sound pitch offsets
                                                        ; -----------------------------------
    !byte 0                                             ; MODE 1          Channel 0
    !byte 0                                             ; MODE 2          Channel 1
    !byte 1                                             ; MODE 3          Channel 2
    !byte 2                                             ; MODE 4          Channel 3

    !byte 2                                             ; MODE 5
    !byte 3                                             ; MODE 6
                                                        ; Overflow: the first byte of the next
                                                        ; table is accessed for:
                                                        ; MODE 7 - next byte, value 4


; Table of offsets into the VDU variables, used when line plotting
.vduGraphicsWindowBoundariesTable
    !byte .vduGraphicsWindowPixelsRightLow - .vduVariablesStart     ; } offsets into the VDU
    !byte .vduGraphicsWindowPixelsLeftLow - .vduVariablesStart      ; } variables of the
    !byte .vduGraphicsWindowPixelsTopLow - .vduVariablesStart       ; } graphics window edges
    !byte .vduGraphicsWindowPixelsBottomLow - .vduVariablesStart    ; }


; ***************************************************************************************
;
; Hardware scroll tables
;
; Stores which System VIA Register B registers to write, see .systemVIARegisterB
;
; ***************************************************************************************
.systemVIAHardwareScrollTable1                          ;
; Which System VIA register to write to set the hardware scrolling, for each MODE group.
    !byte 13                                            ; 20k (MODE 0,1,2)
    !byte 5                                             ; 16k (MODE 3)
    !byte 13                                            ; 10k (MODE 4,5)
    !byte 5                                             ; 8k  (MODE 6)
                                                        ; Overflows one byte into next table
                                                        ; 1k  (MODE 7)

; Which System VIA register to write to set the hardware scrolling, for each MODE group.
.systemVIAHardwareScrollTable2
    !byte 4                                             ; 20k (MODE 0,1,2)
    !byte 4                                             ; 16k (MODE 3)
    !byte 12                                            ; 10k (MODE 4,5)
    !byte 12                                            ; 8k  (MODE 6)
    !byte 4                                             ; 1k  (MODE 7)

; Low byte of the address to clear the screen in each MODE group
.clearScreenRoutineEntryPointLow
    !byte <.clearScreenRoutineEntryPointMODE012         ; MODE 0,1,2
    !byte <.clearScreenRoutineEntryPointMODE3           ; MODE 3
    !byte <.clearScreenRoutineEntryPointMODE45          ; MODE 4,5
    !byte <.clearScreenRoutineEntryPointMODE6           ; MODE 6
    !byte <.clearScreenRoutineEntryPointMODE7           ; MODE 7

; screen size (high byte) for each MODE group
.screenMemorySizeInBytesHigh
    !byte $50                                           ; MODEs 0,1,2 ($5000 = 20k)
    !byte $40                                           ; MODE  3     ($4000 = 16k)
    !byte $28                                           ; MODEs 4,5   ($2800 = 10k)
    !byte $20                                           ; MODE  6     ($2000 = 8k)
    !byte $04                                           ; MODE  7     ($0400 = 1k)

; screen start address (high byte) for each MODE group
.screenMemoryStartHigh
    !byte $30                                           ; MODEs 0,1,2 ($3000)   %00110000
    !byte $40                                           ; MODE  3     ($4000)   %01000000
    !byte $58                                           ; MODEs 4,5   ($5800)   %01011000
    !byte $60                                           ; MODE  6     ($6000)   %01100000
    !byte $7C                                           ; MODE  7     ($7C00)   %01111100

; number of bytes in each row
.bytesPerRowLow
    !byte <40                                           ; MODE 7          40 bytes per row
    !byte <320                                          ; MODE 4,5,6     320 bytes per row
    !byte <640                                          ; MODE 0,1,2,3   640 bytes per row

; Which multiplication table to use (low byte of address, assumes the multiplication tables are in the same page)
.multiplicationTabletoUseLow
    !byte <.multiplyBy40Table                           ; MODE 7
    !byte <.multiplyBy640Table                          ; MODE 4,5,6
    !byte <.multiplyBy640Table                          ; MODE 0,1,2,3

; Offset to CRTC cursor end register in each MODE group
.crtcCursorEndRegisterTable
    !byte .crtcMODEs012CursorEndRegister - .crtcRegisters0to11ForMODEs012   ; MODEs 0,1,2
    !byte .crtcMODE3CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  3
    !byte .crtcMODE45CursorEndRegister   - .crtcRegisters0to11ForMODEs012   ; MODEs 4,5
    !byte .crtcMODE6CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  6
    !byte .crtcMODE7CursorEndRegister    - .crtcRegisters0to11ForMODEs012   ; MODE  7

; default CRTC register values
.crtcRegisters0to11ForMODEs012
    !byte 127                                           ; R0 = Horizontal total register
    !byte 80                                            ; R1 = Horizontal displayed register
    !byte 98                                            ; R2 = Horizontal sync position register
    !byte $28                                           ; R3 = The sync width register
    !byte 38                                            ; R4 = Vertical total register
    !byte 0                                             ; R5 = Vertical total adjust register
    !byte 32                                            ; R6 = Vertical displayed register (number of visible character rows)
    !byte 34                                            ; R7 = Vertical sync position
    !byte %00000001                                     ; R8 = Interlace and delay register
    !byte 7                                             ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODEs012CursorEndRegister
    !byte 8                                             ; R11 = The cursor end register

.crtcRegisters0to11ForMODE3
    !byte 127                                           ; R0 = Horizontal total register
    !byte 80                                            ; R1 = Horizontal displayed register
    !byte 98                                            ; R2 = Horizontal sync position register
    !byte $28                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1B                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $09                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE3CursorEndRegister
    !byte $09                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODEs45
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $31                                           ; R2 = Horizontal sync position register
    !byte $24                                           ; R3 = The sync width register
    !byte $26                                           ; R4 = Vertical total register
    !byte $00                                           ; R5 = Vertical total adjust register
    !byte $20                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $22                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $07                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE45CursorEndRegister
    !byte $08                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODE6
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $31                                           ; R2 = Horizontal sync position register
    !byte $24                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1B                                           ; R7 = Vertical sync position
    !byte $01                                           ; R8 = Interlace and delay register
    !byte $09                                           ; R9 = Scan lines per character
    !byte $67                                           ; R10 = Cursor start register
.crtcMODE6CursorEndRegister
    !byte $09                                           ; R11 = The cursor end register

.crtcRegisters0to11ForMODE7
    !byte $3F                                           ; R0 = Horizontal total register
    !byte $28                                           ; R1 = Horizontal displayed register
    !byte $33                                           ; R2 = Horizontal sync position register
    !byte $24                                           ; R3 = The sync width register
    !byte $1E                                           ; R4 = Vertical total register
    !byte $02                                           ; R5 = Vertical total adjust register
    !byte $19                                           ; R6 = Vertical displayed register (number of visible character rows)
    !byte $1B                                           ; R7 = Vertical sync position
    !byte $93                                           ; R8 = Interlace and delay register
    !byte $12                                           ; R9 = Scan lines per character
    !byte $72                                           ; R10 = Cursor start register
.crtcMODE7CursorEndRegister
    !byte $13                                           ; R11 = The cursor end register

; ***************************************************************************************
;
; VDU Line Plotting
;
; ***************************************************************************************
.vduPlotLineRoutineAddresses
    !word .plotLineMoveToNextColumnRight                ; if X axis is dominant, move right
    !word .plotLineMoveToNextRowUp                      ; if Y axis is dominant, move up

.vduRoutineBranchVectorAddressesLow
    !byte <.plotLineDominantYAxisSameSign               ;
    !byte <.plotLineDominantYAxisDifferentSign          ;
    !byte <.plotLineDominantXAxisSameSign               ;
    !byte <.plotLineDominantXAxisDifferentSign          ;

.vduRoutineBranchVectorAddressesHigh
    !byte >.plotLineDominantYAxisSameSign               ;
    !byte >.plotLineDominantYAxisDifferentSign          ;
    !byte >.plotLineDominantXAxisSameSign               ;
    !byte >.plotLineDominantXAxisDifferentSign          ;

; ***************************************************************************************
;
; Converting characters in Teletext
;
; See teletext.png
;
; Writing printable characters (32-126) directly to the display memory in MODE 7
; gives different results in three cases to printing via OSWRCH. In particular:
;
; Value     Write to Screen     Write to screen
;           Memory Directly       via OSWRCH
; ----------------------------------------------
;   $23           £                   #
;   $5F           #                   long dash
;   $60           long dash           £
; ----------------------------------------------
;
; ***************************************************************************************
.teletextCharacterConversionTable
    !byte $23                                           ; when writing a character in MODE 7,
                                                        ; replace each byte here with the next
                                                        ; in the table
    !byte $5F                                           ; when reading the character from the
                                                        ; screen, replace each byte with the
                                                        ; previous in the table
    !byte $60                                           ;
    !byte $23                                           ;

; ***************************************************************************************
;
; Soft character table offsets
;
; Converts the OSBYTE 20 parameter 1-6 (how much of the character set to 'explode', i.e.
; which range of character definitions can be redefined) into the offset into the
; .vduFontZoneAddressesHigh1 table, which stores the page addresses used to define characters
; in an 'exploded' soft character set.
; See .osbyte20EntryPoint
;
; ***************************************************************************************
.softCharacterRamAllocationTable
    !byte $04                                           ; 1 -> 4 = range of characters 128-159
    !byte $05                                           ; 2 -> 5 = range of characters 160-191
    !byte $06                                           ; 3 -> 6 = range of characters 192-223
    !byte $00                                           ; 4 -> 0 = range of characters  32-63
    !byte $01                                           ; 5 -> 1 = range of characters  64-95
    !byte $02                                           ; 6 -> 2 = range of characters  96-127

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 5: VDU and OSWORD routines
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Note about the BBC Micro Character Set (it's almost, but not quite 7-bit ASCII)
;
; ***************************************************************************************
; One of the main tasks for OSWRCH is to draw characters to the screen. The VDUCHR routine
; performs this job. In particular, with A in the range 32-126 these are the 'printable'
; characters. They result in a visual character appearing on screen. They almost match the
; standard 7-bit ASCII character set. The exception being ASCII CODE 96 '`' (GRAVE ACCENT)
; which is not available. When this code is used with OSWRCH, a pound sign '£' is displayed
; instead. For character definitions, see Chapter 4.
;
; Additionally, MODE 7 (the TELETEXT mode) has a different character set from ASCII, which
; means 10 of the ASCII printable characters can't be displayed. Substitutions are made
; as follows:
;
;     ASCII CODE 91  '[' is displayed as an arrow pointing left
;     ASCII CODE 92  '\' is displayed as the fraction 1/2
;     ASCII CODE 93  ']' is displayed as an arrow pointing right
;     ASCII CODE 94  '^' is displayed as an arrow pointing up
;     ASCII CODE 95  '_' is displayed as a dash
;     ASCII CODE 96  '`' is displayed as a pound sign
;     ASCII CODE 123 '{' is displayed as the fraction 1/4
;     ASCII CODE 124 '|' is displayed as a double vertical bar
;     ASCII CODE 125 '}' is displayed as the fraction 3/4
;     ASCII CODE 126 '~' is displayed as the divide symbol
;
; Note that when writing directly to the display memory in MODE 7 this gives different
; results in three cases to printing via OSWRCH. See .teletextCharacterConversionTable
;
; The character being output is interpreted as below:
;
; Character Range   Description
;   0-31            Control characters, which are interpreted as a whole range of special
;                   commands. Multiple bytes may need to be output to complete the
;                   command. Each VDU command is described at it's own entry point
;                   which are listed in a table (See .vduEntryPointTableLow).
;   32-126          Printable ASCII(-ish) characters as described above.
;   127             Delete character. Attempts to remove the previous printed character
;                   from the screen at the text or graphics cursor (whichever is active).
;   128-255         Available for users programs as soft characters (see .osbyte20EntryPoint).
;                   In MODE 7 these control the appearance of Teletext characters.
;
; ***************************************************************************************
;
; VDUCHR entry point
;
; This is a limited version of OSWRCH that assumes output is to the display only, not to
; Econet, the printer, RS-423, nor SPOOLed to a file. It assumes the VDU drivers are enabled.
;
; ***************************************************************************************
.vduChrEntryPoint
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ; get the number of items in the VDU queue
    BNE .vduParametersAreOutstanding                    ; if (parameters are still needed) then branch
    BIT .vduStatusByte                                  ; test VDU status byte
    BVC +                                               ; if (cursor editing mode is NOT active) then branch forward

    ; handle cursor editing mode...
    JSR .exchangeTextCursorAndInputCursorValues         ; temporarily swap the text cursor and input cursor coordinates
    JSR .setUpWriteCursor                               ; set up write cursor
    BMI +                                               ; if (display is disabled) then branch forward
    CMP #.charRETURN                                    ;
    BNE +                                               ; if (character is not RETURN) then branch forward
    JSR .terminateEdit                                  ; terminate editing

+
    CMP #.charDELETE                                    ;
    BEQ .handleDeleteCharacter                          ; if (character is DELETE) then branch
    CMP #.charSPACE                                     ;
    BCC .readVDUEntryPointAddressAndParameters          ; if (character less than space, i.e. a VDU control code) then branch
    BIT .vduStatusByte                                  ; test VDU status byte again
    BMI +                                               ; if (screen disabled) then branch forward
    JSR .displayACharacter                              ; display a character
    JSR .vdu9EntryPoint                                 ; and cursor right
+
    JMP .exitVDUCHR                                     ;

; ***************************************************************************************
.handleDeleteCharacter
    LDA #.vduEntryPointTableDelete - .vduEntryPointTableLow ; index to read the vdu entry
                                                            ; point table for DELETE

.readVDUEntryPointAddressAndParameters
    TAY                                                 ; store the VDU number in Y
    LDA .vduEntryPointTableLow,Y                        ; get low byte of entry point address
    STA .vduJumpVectorLow                               ; store it in jump vector
    LDA .vduEntryPointTableHigh,Y                       ; get high byte of entry point address
    BMI .explicitAddressNoParameters                    ; if (a direct access with no parameters) then branch
    TAX                                                 ; X=A
    ORA #%11110000                                      ; set up negated parameter count (set bits in top nybble)
    STA .twosComplimentOfNumberOfBytesInVDUQueue        ; store it back as number of items in VDU queue
    TXA                                                 ; get back A
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } get high nybble into low nybble
    LSR                                                 ; }
    CLC                                                 ; clear carry
    ADC #>.vduBaseAddress                               ; add base address (high byte) to get high byte of VDU entry point address
    STA .vduJumpVectorHigh                              ;
    BIT .vduStatusByte                                  ; check for cursor editing mode enabled
    BVS .reexchangeCursorsAndExit                       ; if (cursor editing mode enabled) then branch (re-exchange cursors)
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
;   VDU 0 / 6 / 27      Empty handlers
;
;   VDU 0  - Does nothing
;   VDU 6  - Enable VDU drivers (re-enabling is handled prior to here, see .checkForVDUReenable)
;   VDU 27 - ESCAPE code, does nothing
;
; ***************************************************************************************
.vdu0EntryPoint
.vdu6EntryPoint
.vdu27EntryPoint
.exit
    RTS                                                 ;

; ***************************************************************************************
.vduParametersAreOutstanding
    STA .vduQueueEndByte-$FF,X                          ; store parameter in vdu queue
                                                        ; (X = 256 - number of parameters
                                                        ; i.e. X=$FF for 1, $FE for 2 etc.)
    INX                                                 ; increment X
    STX .twosComplimentOfNumberOfBytesInVDUQueue        ; store it as number of bytes in VDU queue (2's complement)
    BNE .clearCarryAndExit                              ; if (more parameters are needed) then branch
    BIT .vduStatusByte                                  ; test VDU status byte
    BMI .preVDU1                                        ; if (VDU disabled) then branch to VDU 1 code
    BVS .handleCursorEditing                            ; if (cursor editing mode) then branch
    JSR .executeRequiredVDUFunction                     ; execute required function for VDU command
    CLC                                                 ; clear carry
    RTS                                                 ;

.handleCursorEditing
    JSR .exchangeTextCursorAndInputCursorValues         ; swap values of cursors
    JSR .setUpWriteCursor                               ; set up write cursor
    JSR .executeRequiredVDUFunction                     ; execute required function for VDU command
.reexchangeCursorsAndExit
    JSR .reswapCursorsBack                              ; re-exchange cursors
.clearCarryAndExit
    CLC                                                 ; carry clear
    RTS                                                 ;

.preVDU1
    LDY .vduJumpVectorHigh                              ; check the upper byte of entry point address
    CPY #>.vdu1EntryPoint                               ; check for the default handler
    BNE .clearCarryAndExit                              ; if (not the default handler) then branch (exit)
    ; fall through...


; ***************************************************************************************
;
;   VDU 1       Send next byte to printer only
;
; ***************************************************************************************
.vdu1EntryPoint
    TAX                                                 ; remember A
    LDA .vduStatusByte                                  ; get VDU status byte
    LSR                                                 ; get bit 0 into carry (printer enabled bit)
    BCC .exit                                           ; if (printer not enabled) then branch (exit)
    TXA                                                 ; restore A
    JMP .sendValidByteToPrinter                         ; send byte in A (next byte) to printer

; ***************************************************************************************
.explicitAddressNoParameters
    STA .vduJumpVectorHigh                              ; upper byte of link address
    TYA                                                 ; restore A (the VDU number)

    ; set carry if VDU number is within range 8-13 (cursor movement)
    CMP #8                                              ;
    BCC +                                               ; if (VDU number < 8) then branch (carry clear)
    EOR #$FF                                            ; invert value
    CMP #$F2                                            ; if (VDU number > 13) then clear carry
    EOR #$FF                                            ; re-invert value back again

+
    BIT .vduStatusByte                                  ; test VDU status byte
    BMI .checkForVDUReenable                            ; if (VDU disabled) then branch
    PHP                                                 ; push flags
    JSR .executeRequiredVDUFunction                     ; execute required function
    PLP                                                 ; pull flags back
    BCC +                                               ; if (not VDU 8-13 cursor movement) then branch (skip 'printer enabled' check)
    ; fall through...

; ***************************************************************************************
.exitVDUCHR
    LDA .vduStatusByte                                  ; read VDU status byte
    LSR                                                 ; carry is set if printer is enabled
+
    BIT .vduStatusByte                                  ; test VDU status byte
    BVC .exit                                           ; if (no cursor editing mode) then branch
    ; fall through...

; ***************************************************************************************
.reswapCursorsBack
    JSR .restoreWriteCursor                             ; restore normal write cursor

.exchangeTextCursorAndInputCursorValues
    PHP                                                 ; save flags
    PHA                                                 ; save A
    LDX #.vduTextCursorXPosition        - .vduVariablesStart    ; offset within VDU variables for text cursor position
    LDY #.vduTextInputCursorXCoordinate - .vduVariablesStart    ; offset within VDU variables for text input cursor position
    JSR .exchangeTwoVDUBytes                            ; exchange current text cursor coordinates with text input cursor coordinates
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
    JSR .setHardwareCursorAddress                       ; set cursor position
    LDA .vduStatusByte                                  ; get VDU status byte
    EOR #%00000010                                      ; invert bit 1 to allow or inhibit scrolling
    STA .vduStatusByte                                  ; store VDU status byte
    PLA                                                 ; restore flags
    PLP                                                 ; restore A
    RTS                                                 ;

; ***************************************************************************************
.checkForVDUReenable
    EOR #6                                              ; check for VDU 6 (to reenable output to the display)
    BNE .exit1                                          ; if (not VDU 6) then branch (exit)
    LDA #%01111111                                      ; set A to clear the top bit of the VDU status byte
    BCC .clearVDUStatusByteFlags                        ; ALWAYS branch, clearing the top bit (enabling output to the display again)

; ***************************************************************************************
;
; Check whether the text or graphics cursor is active
;
; On Exit:
;    A = 0   if text cursor is active           (Z flag set)
;    A = $20 otherwise (graphics cursor active) (Z flag clear)
;
; ***************************************************************************************
.isTextCursorActive
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00100000                                      ; test bit 5 of status byte
.exit1
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 14    Set paged mode
;
; ***************************************************************************************
.vdu14EntryPoint
    LDY #0                                              ; Y = 0
    STY .pagedModeCounter                               ; paged mode counter
    LDA #4                                              ; A = 4
    BNE .setVDUStatusByteFlags                          ; ALWAYS branch


; ***************************************************************************************
;
;   VDU 2     Printer On
;
; ***************************************************************************************
.vdu2EntryPoint
    JSR .printerServiceCall                             ; select printer buffer
    LDA #$94                                            ; A=$94 when inverted at next statement this = 1
                                                        ; thereby setting bit 0 of the VDU status byte (printer output enable)
    ; fall through...


; ***************************************************************************************
;
;   VDU 21    Disable VDU drivers
;
; Output to the VDU is disabled (until a VDU 6 is used to re-enable output).
;
; ***************************************************************************************
.vdu21EntryPoint
    EOR #$95                                            ; if A=21  (entry from VDU 21) then A = $80
                                                        ; if A=$94 (entry from VDU 2)  then A = 1
.setVDUStatusByteFlags
    ORA .vduStatusByte                                  ; VDU status byte set bit 0 or bit 7
    BNE .storeVDUStatusByteAndReturn                    ; ALWAYS branch (since A != 0)


; ***************************************************************************************
;
;   VDU 3     Printer off
;
; ***************************************************************************************
.vdu3EntryPoint
    JSR .printerServiceCall                             ; select printer buffer
    LDA #10                                             ;
    ; fall through...


; ***************************************************************************************
;
;   VDU 15    Paged mode off
;
; On Entry:
;       A = 15  paged mode off
;       A = 10  printer off
;
; ***************************************************************************************
.vdu15EntryPoint
    EOR #$F4                                            ; convert to $FB or $FE to clear
                                                        ; bit 2 or 1 respectively
.clearVDUStatusByteFlags
    AND .vduStatusByte                                  ; AND with VDU status byte
.storeVDUStatusByteAndReturn
    STA .vduStatusByte                                  ; store VDU status byte
-
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 4       Select text cursor
;
; At all times either the text cursor is active or the graphics cursor is active
; Characters are either drawn normally in text cells (at the text cursor) or at any pixel
; position (the graphics cursor)
;
; ***************************************************************************************
.vdu4EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte
    BEQ -                                               ; if (not in graphics MODE) then branch (return)
    JSR .setTextCursor                                  ; set text cursor (CRTC hardware)
    LDA #%11011111                                      ; clear bit 5 (graphics cursor bit)
    BNE .clearVDUStatusByteFlags                        ; ALWAYS branch - clear bit 5 and exit


; ***************************************************************************************
;
;   VDU 5       Select graphics cursor
;
; ***************************************************************************************
.vdu5EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte minus one
    BEQ -                                               ; if (not in graphics MODE) then branch (return)
    LDA #32                                             ; cursor setting
    JSR .setCursorOnOrOff                               ; turn off cursor
    BNE .setVDUStatusByteFlags                          ; ALWAYS branch - set bit 5 of VDU status byte and exit


; ***************************************************************************************
;
;   VDU 8       Cursor left (.charBACKSPACE)
;
; ***************************************************************************************
.vdu8EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active
                                                        ;  or A=$20 if graphics cursor
    BNE .moveGraphicsCursorLeftEightPixels              ; if (currently in graphics cursor
                                                        ; mode) then branch (to move cursor
                                                        ; left 8 pixels)
    DEC .vduTextCursorXPosition                         ; decrement text column
    LDX .vduTextCursorXPosition                         ; get new text column
    CPX .vduTextWindowLeft                              ; check against left of text window
    BMI .wrapFromLeftEdgeToRightEdgeOfTextWindow        ; if (less than left edge of text
                                                        ; window) then branch (wrap to right
                                                        ; edge and one line up)
    LDA .vduTextCursorCRTCAddressLow                    ; get text cursor CRTC address (low)
    SEC                                                 ;
    SBC .vduBytesPerCharacter                           ; subtract bytes per character
    TAX                                                 ; put in X
    LDA .vduTextCursorCRTCAddressHigh                   ; get text cursor CRTC address (high)
    SBC #0                                              ; subtract 0 + carry
    CMP .vduStartScreenAddressHighByte                  ; compare with high byte of screen
                                                        ; RAM address
    BCS +                                               ; if (text cursor is not below the
                                                        ; start of the screen address) then
                                                        ; branch forward
    ADC .vduScreenSizeHighByte                          ; add screen RAM size high byte to
                                                        ; wrap back onto screen
+
    TAY                                                 ; Y=A
    JMP .setTextCursorCRTCAddress                       ; A high and X low byte of cursor
                                                        ; address

; ***************************************************************************************
.wrapFromLeftEdgeToRightEdgeOfTextWindow
    LDA .vduTextWindowRight                             ; load text window right edge
    STA .vduTextCursorXPosition                         ; set current text column

.cursorUp
    DEC .pagedModeCounter                               ; paged mode counter
    BPL +                                               ; if (not less than zero) then branch (skip next instruction)
    INC .pagedModeCounter                               ; paged mode counter to restore X=0
+
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowTop                               ; top of text window
    BEQ .cursorAtTopOfTextWindow                        ; if (it's at the top of the text window) then branch
    DEC .vduTextCursorYPosition                         ; decrement current text line
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
.cursorAtTopOfTextWindow
    CLC                                                 ; clear carry
    JSR .moveTextCursorToNextLine                       ; move cursor
    LDA #%00001000                                      ; A=8 to check for software scrolling
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (software scrolling enabled) then branch forward
    JSR .hardwareScrollDown                             ; scroll down
    BNE .skipScrolling                                  ; branch
+
    JSR .scrollTextWindowDownwards                      ; soft scroll 1 line
.skipScrolling
    JMP .clearOneLineAndPositionCursor                  ; clear one line and exit

; ***************************************************************************************
.moveGraphicsCursorLeftEightPixels
    LDX #0                                              ; X = 0 to select horizontal movement (move left)
    ; fall through...

; ***************************************************************************************
;
; Move graphics cursor (left or down)
;
; On Entry:
;       X = 0 to move left or
;       X = 2 to move down
;
; ***************************************************************************************
.moveGraphicsCursorLeftOrDownEightPixels
    STX .vduTempStoreDB                                 ; store X
    JSR .checkGraphicsCursorIsWithinGraphicsWindow      ; check window bounds
    LDX .vduTempStoreDB                                 ; restore X
    SEC                                                 ; set carry
    LDA .vduGraphicsCursorPixelsXLow,X                  ; current graphics cursor (X=2 for vertical movement)
    SBC #8                                              ; subtract 8 to move back/down 1 character
    STA .vduGraphicsCursorPixelsXLow,X                  ; store in current graphics cursor (X=2 for vertical movement)
    BCS +                                               ; if (carry set, no need to adjust high byte) then branch forward
    DEC .vduGraphicsCursorPixelsXHigh,X                 ; decrement high byte of graphics cursor
+
    LDA .vduTempStoreDA                                 ; check the old graphics cursor position
    BNE .setUpExternalGraphicsCoordinates               ; if (old graphics position out of the graphics window bounds) then branch
    JSR .checkGraphicsCursorIsWithinGraphicsWindow      ; check the new graphics cursor position
    BEQ .setUpExternalGraphicsCoordinates               ; if (not out of bounds now) then branch

    ; this is the case where the old coordinates were within the window, but now are not.
    ; when moving left, then move up and clamp to the right edge.
    ; when moving down, clamp to the top edge.
    LDX .vduTempStoreDB                                 ; get back X
    LDA .vduGraphicsWindowPixelsRightLow,X              ; get graphics window right (X=0) or top (X=2)
    CPX #1                                              ;
    BCS +                                               ; if (moving down) then branch forward
    SBC #6                                              ; moving left. A = A - 7 (note carry is clear)
+
    STA .vduGraphicsCursorPixelsXLow,X                  ; current graphics cursor position (X=2 means vertical)
    LDA .vduGraphicsWindowPixelsRightHigh,X             ; graphics window right (X=0) or top (X=2) high byte
    SBC #0                                              ; subtract carry
    STA .vduGraphicsCursorPixelsXHigh,X                 ; current graphics cursor position (X=2 means vertical)
    TXA                                                 ;
    BEQ .graphicsCursorUpEightPixels                    ; if (moving left) then branch
                                                        ; (because we've hit the left edge,
                                                        ; move graphics cursor up)

.setUpExternalGraphicsCoordinates
    JMP .convertPixelGraphicsCoordinatesToExternal      ; set up external coordinates for graphics


; ***************************************************************************************
;
;   VDU 11       Cursor up
;
; ***************************************************************************************
.vdu11EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ .cursorUp                                       ; if (text cursor is active) then branch
.graphicsCursorUpEightPixels
    LDX #2                                              ; set X = 2 for moving graphics cursor UP
    BNE .moveGraphicsCursorUpOrRightEightPixels         ; ALWAYS branch


; ***************************************************************************************
;
;   VDU 9        Cursor right
;
; ***************************************************************************************
.vdu9EntryPoint
    LDA .vduStatusByte                                  ; get VDU status byte
    AND #%00100000                                      ; check bit 5 (graphics cursor)
    BNE .moveGraphicsCursorRightEightPixels             ; if (graphics cursor in use) then branch
    LDX .vduTextCursorXPosition                         ; text column
    CPX .vduTextWindowRight                             ; text window right
    BCS .moveTextCursorToLeftEdgeAndDown                ; if (X exceeds window right) then branch
    INC .vduTextCursorXPosition                         ; text column
    LDA .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address low
    ADC .vduBytesPerCharacter                           ; add bytes per character
    TAX                                                 ; X = new low byte of CRTC address
    LDA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address high
    ADC #0                                              ; add carry. A = new high byte of CRTC address
    JMP .setTextCursorCRTCAddress                       ; use X and A to set new text cursor CRTC address

; ***************************************************************************************
.moveTextCursorToLeftEdgeAndDown
    LDA .vduTextWindowLeft                              ; text window left
    STA .vduTextCursorXPosition                         ; text column
    ; fall through...

; ***************************************************************************************
.moveTextCursorDown
    CLC                                                 ; clear carry
    JSR .handleScrollingInPagedModeInternal             ; check text window bottom edge, X=line count
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowBottom                            ; bottom edge
    BCS +                                               ; if (current text Y position => bottom edge) then branch
    INC .vduTextCursorYPosition                         ; increment current text line
    BCC .setCursorSoftwareAndHardwarePosition           ; ALWAYS branch (set cursor position)
+
    JSR .moveTextCursorToNextLine                       ; move cursor to next line
    LDA #%00001000                                      ; check bit 3 (software scrolling)
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (software scrolling enabled) then branch
    JSR .hardwareScrollUp                               ; perform hardware scroll
    BNE .clearOneLineAndPositionCursor                  ;
+
    JSR .scrollTextWindowUpwards                        ; execute upward software scroll
    ; fall through...

; ***************************************************************************************
.clearOneLineAndPositionCursor
    JSR .clearOneLine                                   ; clear a line
    ; fall through...

; ***************************************************************************************
;
; Set cursor address
;
; Calculates cursor screen addresses and sets the hardware
;
; ***************************************************************************************
.setCursorSoftwareAndHardwarePosition
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
    BCC .setHardwareCursorAddressLocal                  ; ALWAYS branch

; ***************************************************************************************
.moveGraphicsCursorRightEightPixels
    LDX #0                                              ; X=0 for move cursor right
    ; fall through...

; ***************************************************************************************
;
; Move graphics cursor (up or right)
;
; On Entry:
;       X = 0 means move graphics cursor right
;       X = 2 means move graphics cursor up
;
; ***************************************************************************************
.moveGraphicsCursorUpOrRightEightPixels
    STX .vduTempStoreDB                                 ; store X
    JSR .checkGraphicsCursorIsWithinGraphicsWindow      ; check window bounds
    LDX .vduTempStoreDB                                 ; recall X
    CLC                                                 ;
    LDA .vduGraphicsCursorPixelsXLow,X                  ; get current graphics cursor (low)
    ADC #8                                              ; add 8 pixels
    STA .vduGraphicsCursorPixelsXLow,X                  ; set current graphics cursor (low)
    BCC +                                               ;
    INC .vduGraphicsCursorPixelsXHigh,X                 ; set current graphics cursor (high)
+
    LDA .vduTempStoreDA                                 ; A=0 no window violations, 1 or 2 indicates violation
    BNE .setUpExternalGraphicsCoordinates               ; if (outside graphics window) then branch
    JSR .checkGraphicsCursorIsWithinGraphicsWindow      ; check window bounds
    BEQ .setUpExternalGraphicsCoordinates               ; if (within graphics window) then branch

    LDX .vduTempStoreDB                                 ; get back X
    LDA .vduGraphicsWindowPixelsLeftLow,X               ; get left/bottom edge of graphics
                                                        ; window (low) (X=0 means left,
                                                        ; else X=2 means bottom)
    CPX #1                                              ;
    BCC +                                               ; if (X is 0; hit left edge) then branch
    ADC #6                                              ; A = A + 7 (including carry)
+
    STA .vduGraphicsCursorPixelsXLow,X                  ; set current graphics cursor position (low)
    LDA .vduGraphicsWindowPixelsLeftHigh,X              ; get left edge (high)
    ADC #0                                              ; add carry
    STA .vduGraphicsCursorPixelsXHigh,X                 ; set current graphics cursor position (high)
    TXA                                                 ; A=X
    BEQ .graphicsCursorDown                             ; if (X = 0) then branch (move graphics cursor down)
    JMP .convertPixelGraphicsCoordinatesToExternal      ; set up external coordinates for graphics


; ***************************************************************************************
;
;   VDU 10       Cursor down
;
; ***************************************************************************************
.vdu10EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ .moveTextCursorDown                             ; if (text cursor active) then branch
.graphicsCursorDown
    LDX #2                                              ; X = 2 to indicate movement down
    JMP .moveGraphicsCursorLeftOrDownEightPixels        ; move graphics cursor down


; ***************************************************************************************
;
;   VDU 28       Define Text Window
;
; A sub-rectangle on screen can be defined that limits where text can be drawn.
;
; ***************************************************************************************
.vdu28ParamLeftEdge   = .vduQueueEndByte - 3
.vdu28ParamBottomEdge = .vduQueueEndByte - 2
.vdu28ParamRightEdge  = .vduQueueEndByte - 1
.vdu28ParamTopEdge    = .vduQueueEndByte
; Note that last parameter is always in 0323

.vdu28EntryPoint
    LDX .vduCurrentScreenMODE                           ; get current screen MODE
    LDA .vdu28ParamBottomEdge                           ; get bottom edge
    CMP .vdu28ParamTopEdge                              ; compare with top edge
    BCC .exit2                                          ; if (bottom edge exceeds top edge) then branch (return)
    CMP .textWindowBottomRowTable,X                     ; check against text window bottom edge maximum
    BEQ +                                               ; if (on the edge) then branch (it's OK)
    BCS .exit2                                          ; if (outside bounds) then branch (exit)
+
    LDA .vdu28ParamRightEdge                            ; get right edge
    TAY                                                 ; put it in Y
    CMP .textWindowRightColumnTable,X                   ; text window right hand edge maximum
    BEQ +                                               ; if (on the edge) then branch (it's OK)
    BCS .exit2                                          ; if (outside bounds) then branch (exit)
+
    SEC                                                 ; set carry to subtract
    SBC .vdu28ParamLeftEdge                             ; left edge
    BMI .exit2                                          ; if (left edge greater than right) then branch (exit)
    TAY                                                 ; A=Y (window width)
    JSR .calculateBytesPerTextWindowRow                 ; calculate number of bytes in a text window row
    LDA #%00001000                                      ; set bit 3 of .vduStatusByte
    JSR .setVDUStatusByteFlags                          ; indicating that text window is defined
    LDX #.vdu28ParamLeftEdge - .vduVariablesStart       ; point to parameters
    LDY #.vduTextWindowLeft  - .vduVariablesStart       ; point to text window edges
    JSR .copyFourBytesWithinVDUVariables                ; copy 4 parameters into the text window edges
    JSR .validatePositionAndSetupScreenAddress          ; check ok and set up screen address
    BCS .vdu30EntryPoint                                ; home cursor within window
.setHardwareCursorAddressLocal
    JMP .setHardwareCursorAddress                       ; set cursor position


; ***************************************************************************************
;
;   OSWORD 9 - Read a pixel
;
; On Entry:
;       .oswordA = 9
;       .oswordX = low byte of parameter block address
;       .oswordY = high byte of parameter block address
;
;   .oswordX/Y is the address of the four bytes of parameters:
;       byte 0-1: X coordinate
;       byte 2-3: Y coordinate
;
; On Exit:
;       Result stored in byte 4 of parameter block:
;           $FF if point was off screen, or logical colour of point if on screen
;
; ***************************************************************************************
.osword9EntryPoint
    LDY #3                                              ; Y is loop counter
-
    LDA (.oswordX),Y                                    ; get it
    STA .vduWorkspaceA,Y                                ; store it
    DEY                                                 ; decrement counter
    BPL -                                               ; loop back until done
    LDA #.vduWorkspaceA - .vduVariablesStart            ;
    JSR .readPixel                                      ;
    LDY #4                                              ; Y=4
    BNE .storeAInParameterBlock                         ; ALWAYS branch


; ***************************************************************************************
;
;   OSWORD 11 - Read palette
;
; On Entry:
;       Y = 0
;       .oswordA = 11
;       .osWordX = low byte of parameter block address
;       .osWordY = high byte of parameter block address
;
;   .oswordX/Y is the address of the four byte parameter block:
;       byte 0: logical colour to read
;
; On Exit:
;       byte 0: logical colour
;       byte 1: physical colour
;       byte 2: zero
;       byte 3: zero
;
; ***************************************************************************************
.osword11EntryPoint
    AND .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    TAX                                                 ; put it in X
    LDA .vduColourPaletteStart,X                        ; get value from colour palette
-
    INY                                                 ; increment Y to point to byte 1
.storeAInParameterBlock
    STA (.oswordX),Y                                    ; store data
    LDA #0                                              ; issue 0s
    CPY #4                                              ; to next bytes until Y=4
    BNE -                                               ;
.exit2
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 12      Clear text or graphics window
;
; ***************************************************************************************
.vdu12EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BNE .clearGraphicsWindowAndHomeGraphicsCursor       ; if (graphics cursor active) then branch (clear graphics area)
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00001000                                      ; check if software scrolling (text window set)
    BNE +                                               ; if (software scrolling) then branch
    JMP .initializeDisplayAndHomeCursor                 ; initialise screen display and home cursor
+
    LDX .vduTextWindowTop                               ; top of text window
-
    STX .vduTextCursorYPosition                         ; current text line
    JSR .clearOneLine                                   ; clear a line

    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowBottom                            ; bottom edge
    INX                                                 ; X=X+1
    BCC -                                               ; if (not reached bottom edge yet)
                                                        ; then branch (loop back and clear the next row)
    ; fall through...


; ***************************************************************************************
;
;   VDU 30      Home Cursor
;
; Moves the current cursor (text or graphics) to the top left of the defined text or
; graphics window.
;
; ***************************************************************************************
.vdu30EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ .homeTextCursor                                 ; if (text cursor active) then branch
    JMP .graphicsCursorHome                             ; home graphic cursor

.homeTextCursor
    STA .vdu31ParamYCoordinate                          ; store 0 in last two parameters
    STA .vdu31ParamXCoordinate                          ;
    ; fall through...

; ***************************************************************************************
;
;   VDU 31      Position text cursor
;
; ***************************************************************************************
.vdu31ParamXCoordinate = .vduQueueEndByte - 1
.vdu31ParamYCoordinate = .vduQueueEndByte
.vdu31EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BNE .exit2                                          ; if (graphics cursor active) then branch (exit)
    JSR +                                               ; exchange text column/line with workspace .vduWorkspaceA/B
    CLC                                                 ; clear carry
    LDA .vdu31ParamXCoordinate                          ; get X coordinate
    ADC .vduTextWindowLeft                              ; add to text window left
    STA .vduTextCursorXPosition                         ; store as text column
    LDA .vdu31ParamYCoordinate                          ; get Y coordinate
    CLC                                                 ;
    ADC .vduTextWindowTop                               ; add top of text window
    STA .vduTextCursorYPosition                         ; current text line
    JSR .validatePositionAndSetupScreenAddress          ; set up screen address
    BCC .setHardwareCursorAddressLocal                  ; if (carry clear, ie. on screen) then branch (set cursor position)
+
    LDX #.vduTextCursorXPosition  - .vduVariablesStart  ; point to text cursor position (low byte)
    LDY #.vduWorkspaceA - .vduVariablesStart            ; point to vdu workspace (low byte)
    JMP .exchangeTwoVDUBytes                            ; exchange text cursor position with workspace .vduWorkspaceA/B


; ***************************************************************************************
;
;   VDU 13      Carriage Return (.charRETURN)
;
; ***************************************************************************************
.vdu13EntryPoint
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BEQ +                                               ; if (text cursor active) then branch
    JMP .setGraphicsCursorToLeftHandColumn              ; set graphics cursor to left hand columm
+
    JSR .setTextCursorToLeftHandColumn                  ; set text column to left hand column
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
.clearGraphicsWindowAndHomeGraphicsCursor
    JSR .graphicsCursorHome                             ; home graphic cursor
    ; fall through...


; ***************************************************************************************
;
;   VDU 16      Clear graphics window
;
; ***************************************************************************************
.vdu16EntryPoint
    LDA .vduPixelsPerByteMinusOne                       ; pixels per byte
    BEQ .exitNoGraphics                                 ; if (current MODE has no graphics) then branch (exit)
    LDX .vduBackgroundGraphicsColour                    ; background graphics colour
    LDY .vduBackgroundGCOLMode                          ; background graphics plot mode (GCOL n)
    JSR .setGraphicsColourMaskXY                        ; set graphics byte mask in .vduGraphicsColourByteOR/EOR
    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart
                                                        ; source      = graphics window
    LDY #.vduWorkspaceA - .vduVariablesStart            ; destination = workspace A to H
    JSR .copyEightBytesWithinVDUVariables               ; copy graphics window coordinates to workspace
    SEC                                                 ; set carry
    LDA .vduGraphicsWindowPixelsTopLow                  ; graphics window top low
    SBC .vduGraphicsWindowPixelsBottomLow               ; graphics window bottom low
    TAY                                                 ; Y=difference
    INY                                                 ; increment
    STY .vduClearGraphicsWindowLineCount                ; and store in workspace (this is line count)
-
    LDX #.vduWorkspaceE - .vduVariablesStart            ; graphics window right column
    LDY #.vduWorkspaceA - .vduVariablesStart            ; graphics window left column
    JSR .fillRow                                        ; fillRow
    LDA .vduWorkspaceG                                  ; decrement window height in pixels
    BNE +                                               ;
    DEC .vduWorkspaceH                                  ;
+
    DEC .vduWorkspaceG                                  ;
    DEC .vduClearGraphicsWindowLineCount                ; decrement line count
    BNE -                                               ; if (not zero) then branch (do it again)
.exitNoGraphics
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 17      Define text colour
;
; The parameter is the logical colour to use as the current text foreground colour. If the
; top bit is set, then the current text background is changed. This is the equivalent of
; BASIC's COLOUR command.
;
; ***************************************************************************************
.vdu17EntryPoint
    LDY #0                                              ; Y = 0 (to set text foreground colour)
    BEQ .defineTextOrGraphicsColour                     ; ALWAYS branch


; ***************************************************************************************
;
;   VDU 18      Define graphics colour
;
; This sets the current graphics foreground or background colour. It is the equivalent of
; BASIC's GCOL command.
;
; The first parameter is the GCOL mode: 0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert
;
; This signifies how to modify the colour of pixels that will be drawn in the future. This
; can depend on both the current graphics colour and the colour of the current pixel already
; on screen.
;
; The second parameter:
;
;   bits 0-6 is the logical colour to use.
;   bit 7    set indicates that the current background colour should be set, otherwise
;            the current foreground colour is set.
;
; ***************************************************************************************
.vdu18ParameterGCOLNumber           = .vduQueueEndByte-1
.vdu18ParameterLogicalColour        = .vduQueueEndByte

.vdu18EntryPoint
    LDY #2                                              ; Y = 2 (to set graphics foreground colour)

.defineTextOrGraphicsColour
    LDA .vdu18ParameterLogicalColour                    ; get last parameter
    BPL +                                               ; if (not negative, it's a foreground colour) then branch
    INY                                                 ; increment y (to set graphics background colour)
+
    AND .vduNumberOfLogicalColoursMinusOne              ; ensure colour is at most 'number of logical colours less 1'
    STA .vduTempStoreDA                                 ; store it
    LDA .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .exit3                                          ; if (not in a graphics MODE) then branch (exit)
    AND #7                                              ; limit to an available colour (and clear M)
    CLC                                                 ; clear carry
    ADC .vduTempStoreDA                                 ; add last parameter to get pointer to table.
    TAX                                                 ; X is the offset into the tables of colours.
                                                        ; X = (number of logical colours - 1 + logicalColour)
    LDA .twoColourMODEParameterTable-1,X                ; get plot options from table
    STA .vduForegroundTextColour,Y                      ; store current colour:
                                                        ;
                                                        ;       Y=0 means text foreground
                                                        ;       Y=1 means text background
                                                        ;       Y=2 means graphics foreground
                                                        ;       Y=3 means graphics background
    CPY #2                                              ;
    BCS .setGraphicsGCOLColour                          ; if (graphics colour changed) then branch (set graphics colour)
    LDA .vduForegroundTextColour                        ; foreground text colour
    EOR #$FF                                            ; invert
    STA .vduTextColourByteEOR                           ; text colour byte to EOR-ed into memory
    EOR .vduBackgroundTextColour                        ; background text colour
    STA .vduTextColourByteOR                            ; text colour byte to OR-ed into memory
.exit3
    RTS                                                 ;

; ***************************************************************************************
.setGraphicsGCOLColour
    LDA .vdu18ParameterGCOLNumber                       ; get first parameter
    STA .vduForegroundGraphicsColour,Y                  ; text colour Y=0=foreground; 1=background etc.
    RTS                                                 ;

; ***************************************************************************************
.restoreMODE7TextBackgroundColour
    LDA #32                                             ;
    STA .vduBackgroundTextColour                        ; background text colour
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 20      Restore default colours
;
; ***************************************************************************************
.vdu20EntryPoint
    LDX #5                                              ; X = 5, loop counter
    LDA #0                                              ; A = 0
-
    STA .vduForegroundTextColour,X                      ; zero all colours
    DEX                                                 ;
    BPL -                                               ; until X=$FF
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .restoreMODE7TextBackgroundColour               ; if (none, it's MODE 7) then branch
    LDA #$FF                                            ; A=$FF
    CPX #15                                             ;
    BNE +                                               ; if (not 16 colours; ie. not MODE 2) then branch
    LDA #$3F                                            ; A=$3F
+
    STA .vduForegroundTextColour                        ; foreground text colour
    STA .vduForegroundGraphicsColour                    ; foreground graphics colour
    EOR #$FF                                            ; invert A
    STA .vduTextColourByteOR                            ; text colour byte to be OR-ed into memory
    STA .vduTextColourByteEOR                           ; text colour byte to be EOR-ed into memory
    STX .vdu19ParameterLogicalColour                    ; set first parameter of 5
    CPX #3                                              ;
    BEQ .restore4Colours                                ; if (there are 4 colours) then branch
    BCC .restore2Colours                                ; if (there are 2 colours) then branch
.restore16Colours                                       ; there are 16 colours
    STX .vdu19ParameterPhysicalColour                   ; set second parameter
-
    JSR .vdu19EntryPoint                                ; VDU 19 - define logical colour
    DEC .vdu19ParameterPhysicalColour                   ; decrement first parameter
    DEC .vdu19ParameterLogicalColour                    ; and last parameter
    BPL -                                               ;
    RTS                                                 ;

.restore4Colours
    LDX #7                                              ; X = 7
    STX .vdu19ParameterPhysicalColour                   ; set first parameter
-
    JSR .vdu19EntryPoint                                ; and do VDU 19
    LSR .vdu19ParameterPhysicalColour                   ;
    DEC .vdu19ParameterLogicalColour                    ;
    BPL -                                               ;
    RTS                                                 ;

.restore2Colours
    LDX #7                                              ; X = 7
    JSR +                                               ; store physical colour and execute VDU 19
    LDX #0                                              ; X = 0
    STX .vdu19ParameterLogicalColour                    ; store it as
+
    STX .vdu19ParameterPhysicalColour                   ; both parameters
    ; fall through...


; ***************************************************************************************
;
;   VDU 19      Write palette
;
; Map a logical colour to a physical colour
;
;               VDU 19,logical colour,physics colour,0,0,0
;
; Logical colours are numbers stored in memory to represent a colour. Logical colours are
; in the range 0-15.
;
; Physical colours are numbers that represent actual colours:
;
;                 0 = black             8 = flashing black-white
;                 1 = red               9 = flashing red-cyan
;                 2 = green            10 = flashing green-magenta
;                 3 = yellow           11 = flashing yellow-blue
;                 4 = blue             12 = flashing blue-yellow
;                 5 = magenta          13 = flashing magenta-green
;                 6 = cyan             14 = flashing cyan-red
;                 7 = white            15 = flashing white-black
;
; The palette defines which physical colour is displayed for each logical colour.
; The Video ULA hardware stores and manages this palette information.
;
; Flashing colours
; ----------------
; The OS (in the vertical sync interrupt) updates timers to know when to change the current
; appearance of flashing colours. When it's time, the OS signals the VideoULA to flip the
; flashing bit, thereby changing the current appearance.
;
; ***************************************************************************************
.vdu19ParameterLogicalColour  = $031F
.vdu19ParameterPhysicalColour = $0320

.vdu19EntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .vdu19ParameterLogicalColour                    ; get logical colour
    AND .vduNumberOfLogicalColoursMinusOne              ; AND with number of logical colours
                                                        ; less 1 to make legal.
    TAX                                                 ; store logical colour in X
    LDA .vdu19ParameterPhysicalColour                   ; A=physical colour
.writePaletteAX
    AND #15                                             ; make legal
    STA .vduColourPaletteStart,X                        ; store physical in colour palette
    TAY                                                 ; remember physical colour in Y
    LDA .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    STA .tempStoreFA                                    ; store it
    CMP #3                                              ; is it a 4 colour MODE?
    PHP                                                 ; save flags
    TXA                                                 ; recall A = logical colour
-
    ROR                                                 ; rotate the logical colour (A) into
                                                        ; the top bits of .tempStoreFA
    ROR .tempStoreFA                                    ; rotate the (number of colours
                                                        ; in the MODE-1) down by one bit
    BCS -                                               ; if (there are more set bits) then
                                                        ; branch (loop back)
    ASL .tempStoreFA                                    ; the final rotate wasn't needed,
                                                        ; so shift left to rectify
                                                        ; at this point .tempStoreFA holds
                                                        ; the logical colour in the top N bits
                                                        ; where N is the number of bits
                                                        ; required to store a colour in
                                                        ; the current MODE.
    TYA                                                 ; recall physical colour
    ORA .tempStoreFA                                    ; OR in the physical colour into
                                                        ; the bottom bits
    TAX                                                 ; store value in X. This is working
                                                        ; towards being the value to send to
                                                        ; the palette register on the Video ULA.
    LDY #0                                              ; Y=0
-
    PLP                                                 ; recall flags
    PHP                                                 ; store flags
    BNE .notFourColourMODE                              ; if (not a four colour MODE, i.e.
                                                        ; A !=3 earlier) then branch

    ; deal with four colour MODEs
    AND #%01100000                                      ; Test bits 5 and 6
    BEQ +                                               ; if (both bit are clear) then branch
    CMP #%01100000                                      ;
    BEQ +                                               ; if (both bits are set) then branch
    TXA                                                 ; recall X value.
    EOR #%01100000                                      ; invert bits 5 and 6 (one of which
                                                        ; is set and the other clear).
    BNE .notFourColourMODE                              ; ALWAYS branch. A = value to send
                                                        ; to palette register of the Video ULA.

+
    TXA                                                 ; X=A
.notFourColourMODE
    JSR .osbyte155Internal                              ; pass data to palette register
    TYA                                                 ;
    SEC                                                 ;
    ADC .vduNumberOfLogicalColoursMinusOne              ;
    TAY                                                 ; Y = Y + number of logical colours - 1
    TXA                                                 ;
    ADC #16                                             ;
    TAX                                                 ; X = X + 16
    CPY #16                                             ;
    BCC -                                               ; if (Y < 16) then branch (loop back)
    PLP                                                 ; pull flags twice
    PLP                                                 ;
    RTS                                                 ;


; ***************************************************************************************
;
;   OSWORD 12 - Write Palette
;
; On Entry:
;   .oswordX/Y is the address of the five bytes of parameters:
;       byte 0: logical colour
;       byte 1: physical colour
;       byte 2: zero
;       byte 3: zero
;       byte 4: zero
;
; ***************************************************************************************
.osword12EntryPoint
    PHP                                                 ; push flags
    AND .vduNumberOfLogicalColoursMinusOne              ; and with number of logical colours less 1
    TAX                                                 ; X=A
    INY                                                 ; Y=Y+1
    LDA (.oswordX),Y                                    ; get physical colour
    JMP .writePaletteAX                                 ; do VDU19 with parameters in X and A


; ***************************************************************************************
;
;   VDU 22      Select MODE
;
; ***************************************************************************************
.vdu22Parameter = .vduQueueEndByte

.vdu22EntryPoint
    LDA .vdu22Parameter                                 ; get parameter
    JMP .setMODE                                        ; change MODE


; ***************************************************************************************
;
;   VDU 23      Define Character
;
; See guide.png
;
; On Entry:
;   A = 0 sets CRTC 6845 register:
;       VDU 23,0,R,X,0,0,0,0,0,0 - program CRTC register R with value V
;       See Chapter 3 section 'CRTC registers'
;   A = 1 turns the cursor on or off:
;       VDU 23,1,0,0,0,0,0,0,0,0 - turn cursor off
;       VDU 23,1,1,0,0,0,0,0,0,0 - turn cursor on
;   A = 32-255 means define character
;
; ***************************************************************************************
.vdu23ParameterLogicalColour = .vduQueueStartByte
.vdu23Parameter1 = .vduQueueEndByte - 8
.vdu23Parameter2 = .vduQueueEndByte - 7
.vdu23Parameter3 = .vduQueueEndByte - 6
.vdu23Parameter4 = .vduQueueEndByte - 5
.vdu23Parameter5 = .vduQueueEndByte - 4
.vdu23Parameter6 = .vduQueueEndByte - 3
.vdu23Parameter7 = .vduQueueEndByte - 2
.vdu23Parameter8 = .vduQueueEndByte - 1
.vdu23Parameter9 = .vduQueueEndByte

.vdu23EntryPoint
    LDA .vdu23ParameterLogicalColour                    ; get character to define
    CMP #.charSPACE                                     ;
    BCC .vdu23SetCRTCRegisterOrCursorVisibility         ; if (less then SPACE) then branch
                                                        ; (it is an instruction to set a CRT
                                                        ; register or cursor visibility)
    PHA                                                 ; save parameter
    LSR                                                 ; A = A / 32
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    TAX                                                 ; store font zone (1-7) in X
    LDA .fontMaskTable,X                                ; look up single bit representing
                                                        ; the font zone (character / 32)
    BIT .vduFontFlags                                   ; font flag
    BNE +                                               ; if (not zero) then branch (storage
                                                        ; area is established already)
    ORA .vduFontFlags                                   ; OR with font flag to set bit
                                                        ; found to be 0
    STA .vduFontFlags                                   ; font flag
    TXA                                                 ; get back font zone (1-7)
    AND #3                                              ; AND with 3 to clear all but bits
                                                        ; 0 and 1 (A = 1, 2, 3)
    CLC                                                 ;
    ADC #>.characterDefinitions - 1                     ; A=$C0, $C1, $C2 to select a
                                                        ; character page in ROM
    STA .vduTempStoreDF                                 ; store it in the high byte
    LDA .vduFontZoneAddressesHigh1 - 1,X                ; get font address (high byte)
    STA .vduTempStoreDD                                 ; store it in the high byte
    LDY #0                                              ;
    STY .vduTempStoreDC                                 ; store zero in the low bytes
    STY .vduTempStoreDE                                 ;
-
    LDA (.vduTempStoreDE),Y                             ; copy character definition
    STA (.vduTempStoreDC),Y                             ;
    DEY                                                 ;
    BNE -                                               ;
+
    PLA                                                 ; get back A
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDY #7                                              ; Y=loop counter
-
    LDA .vdu23Parameter2,Y                              ; transfer definition parameters
    STA (.vduTempStoreDE),Y                             ; to RAM definition
    DEY                                                 ;
    BPL -                                               ;
    RTS                                                 ;

    PLA                                                 ; [unused. Was used in MOS 0.92]

.exit4
    RTS                                                 ;

; ***************************************************************************************
;
; Plot extension
;
; If calling VDU 25 (PLOT) in a non-graphics mode, or using a plot type that is reserved
; for future expansion, then this routine is called. It calls the VDUV vector which allows
; user programs or Paged ROMs to intercept the call and provide new functionality.
;
; ***************************************************************************************
.vduPlotExtension
    LDA .vdu25Parameter5                                ; A = fifth VDU parameter
    CLC                                                 ; clear carry
-
    JMP (.vectorVDUV)                                   ; jump via VDUV vector

; ***************************************************************************************
;
; VDU 23 with 0-31 as the next byte
;
; VDU 23,0      - set CRTC Register
; VDU 23,1      - turn cursor on or off
; VDU 23,2-31   - call VDUV extension vector
;
; ***************************************************************************************
.vdu23SetCRTCRegisterOrCursorVisibility
    CMP #1                                              ; does A=1
    BCC .vdu23CommaZeroSetCRTCRegister                  ; if (A = 0) then branch (set CRTC register)
    BNE -                                               ; if (A != 1) then branch (to VDUV vector)
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active; A=$20 if graphics cursor
    BNE .exit4                                          ; if (graphics cursor is active) then branch (exit)

    ; handle text cursor...
    LDA #32                                             ;
    LDY .vdu23Parameter2                                ; Y = second VDU parameter
    BEQ .setCursorOnOrOff                               ; if (Y=0) then branch (turn cursor off)

.setTextCursor
    LDA .vduLastCursorStartRegisterValue                ; get last setting of CRTC register

.setCursorOnOrOff
    LDY #.crtcCursorStartRegister                       ; Y = .crtcCursorStartRegister
    BNE .setCRTCRegisterDirect                          ; ALWAYS branch

; ***************************************************************************************
.vdu23CommaZeroSetCRTCRegister
    LDA .vdu23Parameter3                                ; get third parameter (value to write)
    LDY .vdu23Parameter2                                ; get second parameter (CRTC register to set)
.setCRTCRegisterAY
    CPY #.crtcVerticalSyncPositionRegister              ;
    BCC .setCRTCRegisterDirect                          ; if (Y < 7) then set register Y with value A directly
    BNE +                                               ; if (Y > 7) branch

    ; deal with vertical sync position register
    ADC .vduVerticalAdjust                              ; add screen vertical display
                                                        ; adjustment + 1 (carry set)
+
    CPY #.crtcInterlaceAndDelayRegister                 ;
    BNE +                                               ; if (Y != 8) then branch

    ; deal with interlace and delay register
    ORA #0                                              ; test if bit 7 set
    BMI +                                               ; if (bit 7 set) then branch
    EOR .vduInterlaceValue                              ; set interlace value (0 or 1)

+
    CPY #.crtcCursorStartRegister                       ;
    BNE .setCRTCRegisterDirect                          ; if (Y != 10) then branch - set register Y with value A directly

    ; deal with cursor start register
    STA .vduLastCursorStartRegisterValue                ; last setting of CRTC register
    TAY                                                 ; Y=A
    LDA .vduStatusByte                                  ; VDU status byte
    AND #%00100000                                      ; check bit 5 (print at graphics cursor)
    PHP                                                 ; push flags
    TYA                                                 ; A = value to set
    LDY #.crtcCursorStartRegister                       ; Y=10
    PLP                                                 ; pull flags
    BNE +                                               ; if (graphics cursor is active) then branch (return)
    ; fall through...

; ***************************************************************************************
.setCRTCRegisterDirect
    STY .crtcAddressRegister                            ; Y is which CRTC register to write to
    STA .crtcAddressWrite                               ; write value A into register Y
+
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 25      Plot
;
; ***************************************************************************************
.vdu25Parameter5 = $031F
.vdu25EntryPoint
    LDX .vduPixelsPerByteMinusOne                       ; get pixels per byte
    BEQ .vduPlotExtension                               ; if (zero, i.e. no graphics available) then branch (plot extension)
    JMP .vdu25Plot                                      ; jump to main plot routine

; ***************************************************************************************
;
; Hardware screen scroll up/down
;
; Changes the start address of the display
;
; ***************************************************************************************
.hardwareScrollDown
    LDX .vduScreenTopLeftAddressLow                     ; screen top left address low
    LDA .vduScreenTopLeftAddressHigh                    ; screen top left address high
    JSR .subtractNumberOfBytesInARowFromAX              ; subtract bytes per character row from this
    BCS +                                               ; if (no wraparound needed) then branch

    ADC .vduScreenSizeHighByte                          ; screen RAM size high byte to wrap around
    BCC +                                               ;

.hardwareScrollUp
    LDX .vduScreenTopLeftAddressLow                     ; screen top left address low
    LDA .vduScreenTopLeftAddressHigh                    ; screen top left address high
    JSR .addNumberOfBytesInACharacterRowToAX            ; add bytes per character row
    BPL +                                               ;

    SEC                                                 ; wrap around
    SBC .vduScreenSizeHighByte                          ; screen RAM size high byte
+
    STA .vduScreenTopLeftAddressHigh                    ; screen top left address high
    STX .vduScreenTopLeftAddressLow                     ; screen top left address low
    LDY #.crtcStartScreenAddressHighRegister            ; Y = value to change screen address
    BNE .setHardwareScreenOrCursorAddress               ; ALWAYS branch to set screen address


; ***************************************************************************************
;
;   VDU 26      Reset to default windows
;
; ***************************************************************************************
.vdu26EntryPoint
    LDA #0                                              ; A=0
    LDX #.vduWorkspaceE - .vduVariablesStart            ; X=loop counter
-
    STA .vduVariablesStart,X                            ; zero a whole bunch of vdu variables,
    DEX                                                 ; including the text and graphics
    BPL -                                               ; windows

    ; use data for current screen mode
    LDX .vduCurrentScreenMODE                           ; screen MODE

    ; reset text window
    LDY .textWindowRightColumnTable,X                   ; text window right edge maximum
    STY .vduTextWindowRight                             ; store in the text window right
    JSR .calculateBytesPerTextWindowRow                 ; calculate number of bytes in a text
                                                        ; window row
    LDY .textWindowBottomRowTable,X                     ; text window bottom edge maximum
    STY .vduTextWindowBottom                            ; bottom edge

    ; reset graphics window
    LDY #3                                              ;
    STY .vdu24ParameterTopEdgeHigh                      ; top edge high byte    = 3
    INY                                                 ; Y = 4
    STY .vdu24ParameterRightEdgeHigh                    ; right edge high byte  = 4
    DEC .vdu24ParameterTopEdgeLow                       ; top edge low          = $FF
    DEC .vdu24ParameterRightEdgeLow                     ; right edge low        = $FF
                                                        ;
                                                        ; so now top edge = $03FF = 1023
                                                        ; and right edge  = $04FF = 1279
                                                        ;
    JSR .vdu24EntryPoint                                ; do VDU 24 (define graphics
                                                        ; window)

    ; reset scrolling
    LDA #%11110111                                      ; }
    JSR .clearVDUStatusByteFlags                        ; } clear bit 3 of .vduStatusByte
    LDX .vduScreenTopLeftAddressLow                     ; screen start address low
    LDA .vduScreenTopLeftAddressHigh                    ; screen start address high

    ; reset cursor
.setTextCursorCRTCAddress
    STX .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address
    STA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address
    BPL .setHardwareCursorAddress                       ; set cursor position
    SEC                                                 ; }
    SBC .vduScreenSizeHighByte                          ; } screen RAM size high byte
    ; fall through...

; ***************************************************************************************
;
; Set cursor screen address
;
; On Entry:
;       AX holds the screen address
;
; ***************************************************************************************
.setHardwareCursorAddress
    STX .vduWriteCursorScreenAddressLow                 ; set screen address of cursor from AX
    STA .vduWriteCursorScreenAddressHigh                ;
    LDX .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address
    LDA .vduTextCursorCRTCAddressHigh                   ; text cursor CRTC address
    LDY #.crtcCursorPositionHighRegister                ; Y=14
    ; fall through...

; ***************************************************************************************
;
; Set hardware screen or cursor address
;
; On Entry:
;       The screen address or cursor position address is in AX
;       Y holds either .crtcCursorPositionHighRegister to change the cursor position
;                   or .crtcStartScreenAddressHighRegister to change the screen address
; ***************************************************************************************
.setHardwareScreenOrCursorAddress
    PHA                                                 ; store A
    LDA .vduCurrentScreenMODE                           ; screen MODE
    CMP #7                                              ; is it MODE 7?
    PLA                                                 ; restore A
    BCS .setCursorPositionMODE7                         ; if (MODE 7 selected) then branch
    STX .vduTempStoreDA                                 ; store X
    LSR                                                 ; divide X/A by 8
    ROR .vduTempStoreDA                                 ;
    LSR                                                 ;
    ROR .vduTempStoreDA                                 ;
    LSR                                                 ;
    ROR .vduTempStoreDA                                 ;
    LDX .vduTempStoreDA                                 ;
    JMP .setTwoCRTCRegisters                            ; set cursor position AX

.setCursorPositionMODE7
    SBC #$74                                            ; MODE 7 subtract $74
    EOR #$20                                            ; EOR with $20 (See NAUG Section
                                                        ; 13.3.11 - MODE 7 scrolling,
                                                        ; Page 200)
    ; fall through...

; ***************************************************************************************
;
; Write to two sequential registers on the CRTC
;
; On Entry:
;       Y = register number
;       A = First value to write (to register Y)
;       X = Second value to write (to register Y+1)
;
; ***************************************************************************************
.setTwoCRTCRegisters
    STY .crtcAddressRegister                            ; set which CRTC register to write into
    STA .crtcAddressWrite                               ; write A into CRTC register
    INY                                                 ; increment Y to the next CRTC register
    STY .crtcAddressRegister                            ; set which CRTC register to write into
    STX .crtcAddressWrite                               ; write X into CRTC register
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 24      Define graphics window
;
; ***************************************************************************************
.vdu24ParameterLeftEdgeLow      = .vduQueueEndByte - 7
.vdu24ParameterLeftEdgeHigh     = .vduQueueEndByte - 6
.vdu24ParameterBottomEdgeLow    = .vduQueueEndByte - 5
.vdu24ParameterBottomEdgeHigh   = .vduQueueEndByte - 4
.vdu24ParameterRightEdgeLow     = .vduQueueEndByte - 3
.vdu24ParameterRightEdgeHigh    = .vduQueueEndByte - 2
.vdu24ParameterTopEdgeLow       = .vduQueueEndByte - 1
.vdu24ParameterTopEdgeHigh      = .vduQueueEndByte

.vdu24EntryPoint
    JSR .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; exchange graphics cursor position with .vduWorkspaceABCD
                                                            ; will swap them back at the end
    LDX #.vdu24ParameterLeftEdgeLow - .vduVariablesStart    ; src = parameters
    LDY #.vduWorkspaceE - .vduVariablesStart                ; dest = Workspace EFGH
    JSR .coordinateSubtraction                              ; EFGH = (width = right - left,
                                                            ;         height = top - bottom)
                                                            ; Accumulator = height (high byte)
    ORA .vduWorkspaceF                                      ; OR with high byte of width
    BMI .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; if (either width or height is negative) then branch (to exchange back and exit)
    LDX #.vdu24ParameterRightEdgeLow - .vduVariablesStart   ; point X to right edge low
    JSR .plotConvertExternalAbsoluteCoordinatesToPixels     ; scale pointers to MODE
    LDX #.vdu24ParameterLeftEdgeLow - .vduVariablesStart    ; point X to left edge low
    JSR .plotConvertExternalAbsoluteCoordinatesToPixels     ; scale pointers to MODE
    LDA .vdu24ParameterBottomEdgeHigh                       ; check for negative edges
    ORA .vdu24ParameterLeftEdgeHigh                         ;
    BMI .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; if (negative) then branch (to exchange back and exit)
    LDA .vdu24ParameterTopEdgeHigh                          ;
    BNE .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; if (non zero) then branch (to exchange back and exit)
    LDX .vduCurrentScreenMODE                               ; get screen MODE
    LDA .vdu24ParameterRightEdgeHigh                        ; right edge high
    STA .vduTempStoreDA                                     ; store it
    LDA .vdu24ParameterRightEdgeLow                         ; right edge low
    LSR .vduTempStoreDA                                     ;
    ROR                                                     ;
    LSR .vduTempStoreDA                                     ;
    BNE .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; if (negative) then branch (to exchange back and exit)
    ROR                                                     ;
    LSR                                                     ;
    CMP .textWindowRightColumnTable,X                       ; compare with text window right hand edge maximum
    BEQ +                                                   ; if (equal) then branch
    BPL .exchangeGraphicsCursorPositionWithWorkspaceABCD    ; if (non-negative) then branch (to exchange back and exit)
+
    LDY #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart ; destination = graphics window extents
    LDX #.vdu24ParameterLeftEdgeLow - .vduVariablesStart    ; source = parameters
    JSR .copyEightBytesWithinVDUVariables                   ; copy source to destination
    ; fall through...

; ***************************************************************************************
.exchangeGraphicsCursorPositionWithWorkspaceABCD
    LDX #.vduGraphicsCursorPositionXLow - .vduVariablesStart
                                                        ; } swap graphics cursor
    LDY #.vduWorkspaceA - .vduVariablesStart            ; } position with Workspace
    JMP .exchangeFourBytes                              ; } ABCD

; ***************************************************************************************
.calculateBytesPerTextWindowRow
    INY                                                 ; }
    TYA                                                 ; } A = Y + 1
    LDY #0                                              ; Y=0
    STY .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    STA .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    LDA .vduBytesPerCharacter                           ; bytes per character
    LSR                                                 ; divide by 2
    BEQ +                                               ; if (zero) then branch (exit)
-
    ASL .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    ROL .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    LSR                                                 ; divide by 2
    BCC -                                               ; if (carry clear) then branch (loop back)
+
    RTS                                                 ;


; ***************************************************************************************
;
;   VDU 29      Set graphics origin
;
; ***************************************************************************************
.vdu29ParameterStart = $320

.vdu29EntryPoint
    LDX #.vdu29ParameterStart - .vduVariablesStart          ; } copy the four bytes from the
    LDY #.vduGraphicsWindowOriginXLow - .vduVariablesStart  ; } vdu queue parameters to the
    JSR .copyFourBytesWithinVDUVariables                    ; } current graphics origin
    JMP .convertPixelGraphicsCoordinatesToExternal          ; set up external coordinates for graphics


; ***************************************************************************************
;
;   VDU 127     Delete
;
; ***************************************************************************************
.vdu127EntryPoint
    JSR .vdu8EntryPoint                                 ; cursor left
    JSR .isTextCursorActive                             ; set A=0 if text cursor is active
                                                        ;  or A=$20 if graphics cursor
    BNE .deleteCharacterAtGraphicsCursor                ; if (graphics cursor active) then branch
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .deleteCharacterInMODE7                         ; if (MODE 7) then branch
    STA .vduTempStoreDE                                 ; store A (always 0)
    LDA #>.characterDefinitions                         ; A=high byte of characters in ROM
    STA .vduTempStoreDF                                 ; store in .vduTempStoreDF (.vduTempStoreDE)
                                                        ; now points to the first character
                                                        ; definition: the 'space' pattern
    JMP .displayACharacterAtAddress                     ; display a space

; ***************************************************************************************
.deleteCharacterInMODE7
    LDA #.charSPACE                                     ; }
    JMP .displayCharacterMODE7                          ; } display a space

; ***************************************************************************************
.deleteCharacterAtGraphicsCursor
    LDA #.charDELETE                                    ; ASCII code for delete
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDX .vduBackgroundGraphicsColour                    ; background graphics colour
    LDY #0                                              ; normal GCOL mode
    JMP .plotACharacterWithXYAsGraphicsColourAndGCOLMode ; plot character in background colour

; ***************************************************************************************
; On Entry:
;       A = High byte of 16 bit value
;       X = Low byte of 16 bit value
.addNumberOfBytesInACharacterRowToAX
    PHA                                                 ; store A
    TXA                                                 ; A=X
    CLC                                                 ;
    ADC .vduBytesPerCharacterRowLow                     ; add bytes per character row
    TAX                                                 ; put low byte back into X
    PLA                                                 ; recall A
    ADC .vduBytesPerCharacterRowHigh                    ; add bytes per character row high byte (and carry)
    RTS                                                 ;

; ***************************************************************************************
;
; Paged mode scrolling
;
; When paged mode is enabled, listing lots of text stops scrolling when the screen is full
; until the user presses SHIFT to display the next page of text.
;
; Even without paged mode enabled, holding SHIFT and CTRL will inhibit scrolling (pauses)
; until at least one of the keys is released.
;
; ***************************************************************************************
.handleScrollingInPagedMode
    JSR .clearPagedModeCounter                          ; clear paged mode line counter
.handleScrollingInPagedModeInternal
    ; first check for SHIFT and CTRL pressed together - this loops until at least one key is released
    JSR .osbyte118EntryPoint                            ; OSBYTE 118 - set keyboard LEDs based on current keyboard state
    BCC +                                               ; if (CTRL not pressed) then branch
    BMI .handleScrollingInPagedMode                     ; if (SHIFT pressed) then branch back
+

    ; check flags for relevant state
    LDA .vduStatusByte                                  ; VDU status byte
    EOR #%00000100                                      ; invert bit 2 (paged scrolling)
    AND #%01000110                                      ; if (there are 2 cursors, OR paged mode is off, OR not paged scrolling)...
    BNE .exit5                                          ; ...then branch (exit)

    ; check the paged mode counter to see if it has run out of lines
    LDA .pagedModeCounter                               ; paged mode counter
    BMI .incrementPagedModeAndExit                      ; if (negative) then branch (increment paged mode counter and exit)

    ; check if we are at the bottom of the screen (exit if not)
    LDA .vduTextCursorYPosition                         ; current text line
    CMP .vduTextWindowBottom                            ; bottom edge
    BCC .incrementPagedModeAndExit                      ; increment line counter and exit

    ; check if we have shown enough lines to fill the text window vertically
    LSR                                                 ; }
    LSR                                                 ; } A = A / 4
    SEC                                                 ; set carry
    ADC .pagedModeCounter                               ; paged mode counter
    ADC .vduTextWindowTop                               ; top of text window
    CMP .vduTextWindowBottom                            ; bottom edge
    BCC .incrementPagedModeAndExit                      ; increment line counter and exit

    CLC                                                 ; clear carry
-
    JSR .osbyte118EntryPoint                            ; OSBYTE 118 - set keyboard LEDs based on current keyboard state
    SEC                                                 ; set carry
    BPL -                                               ; if (SHIFT not pressed) then branch (loop back)
    ; fall through...

; ***************************************************************************************
.clearPagedModeCounter
    LDA #255                                            ;
    STA .pagedModeCounter                               ; set paged mode counter
.incrementPagedModeAndExit
    INC .pagedModeCounter                               ; increment paged mode counter
.exit5
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 6: Changing MODEs
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Initialise VDU variables and change MODE
;
; This is called at reset time
;
; On Entry:
;       A = screen MODE number
;
; ***************************************************************************************
.initialiseVDUVariablesAndSetMODE
    PHA                                                 ; save A (screen mode number)

    ; Clear all VDU variables (0-126)
    LDX #.vduVariablesEnd - .vduVariablesStart          ; loop counter
    LDA #0                                              ; A=0
    STA .vduStatusByte                                  ; VDU status byte to set default conditions (zero)
-
    STA .vduVariablesStart-1,X                          ; zero VDU variables (0-126)
    DEX                                                 ; with this loop
    BNE -                                               ;

    ; implode character definitions
    JSR .osbyte20EntryPoint                             ; implode character definitions (A = 0)
    PLA                                                 ; get back A (screen mode number)

    ; Set teletext cursor
    LDX #$7F                                            ; X=$7F
    STX .vduTeletextCharacterForCursor                  ; set mode 7 cursor character
    ; fall through...

; ***************************************************************************************
;
; Set MODE
;
; On Entry:
;       A = screen MODE number
;
; ***************************************************************************************
.setMODE
    BIT .systemAvailableRAM                             ; test available RAM pages ($40 = 16k; $80 = 32k)
    BMI +                                               ; if (32k available) then branch
    ORA #4                                              ; ensure only modes 4-7 are available
+
    AND #7                                              ; X = A AND 7 (to ensure a legal mode)
    TAX                                                 ; X = mode

    ; Set characteristic vdu variables for the new mode
    STX .vduCurrentScreenMODE                           ; set screen mode
    LDA .numberOfColoursMinusOneInMODETable,X           ; get number of colours -1 in mode from table
    STA .vduNumberOfLogicalColoursMinusOne              ; set number of logical colours less 1
    LDA .bytesPerCharacter,X                            ; get number of bytes /character from table
    STA .vduBytesPerCharacter                           ; set bytes per character
    LDA .pixelsPerByteMinusOneInMODETable,X             ; get display mode pixels/byte from table
    STA .vduPixelsPerByteMinusOne                       ; set pixels per byte-1
    BNE +                                               ; if (in a graphics mode) then branch
    LDA #7                                              ; this is a text mode; set A = 7
+
    ASL                                                 ; A = A * 2
    TAY                                                 ; Y = 2 * (pixels per byte-1), index into a table of colour masks
    LDA .sixteenColourMODEMaskTable - 1,Y               ; mask table
    STA .vduColourMaskRight                             ; store as colour mask right
-
    ASL                                                 ; shift A left
    BPL -                                               ; until the top bit becomes set
    STA .vduColourMaskLeft                              ; store as colour mask left

    LDY .screenDisplayMemoryIndexTable,X                ; screen display memory index table
    STY .vduCurrentScreenMODEGroup                      ; MODE group = screen memory size:
                                                        ;       0 = 20k (MODE 0,1,2)
                                                        ;       1 = 16k (MODE 3)
                                                        ;       2 = 10k (MODE 4,5)
                                                        ;       3 = 8k (MODE 6)
                                                        ;       4 = 1k (MODE 7)

    LDA .systemVIAHardwareScrollTable2,Y                ; get system VIA parameter for setting hardware scrolling value
    JSR .writeAToSystemVIARegisterB                     ; write hardware scrolling value to System VIA
    LDA .systemVIAHardwareScrollTable1,Y                ; get system VIA parameter for setting hardware scrolling value
    JSR .writeAToSystemVIARegisterB                     ; write hardware scrolling value to System VIA

    LDA .screenMemorySizeInBytesHigh,Y                  ; screen RAM size high byte table
    STA .vduScreenSizeHighByte                          ; screen RAM size high byte

    LDA .screenMemoryStartHigh,Y                        ; screen ram address high byte
    STA .vduStartScreenAddressHighByte                  ; high byte of screen RAM address

                                                        ; A=Y=the screen memory type
    TYA                                                 ; A = Y           A = 0 1 2 3 4
    ADC #2                                              ; A = A + 2       A = 2 3 4 5 6
    EOR #7                                              ; A = A EOR 7     A = 5 4 3 2 1
    LSR                                                 ; A = A / 2       A = 2 2 1 1 0

    TAX                                                 ; X=A Index into multiplication table
                                                        ; (0 = MODE 7
                                                        ;  1 = MODE 4,5,6
                                                        ;  2 = MODE 0,1,2,3)

    LDA .multiplicationTabletoUseLow,X                  ; load the low byte of the multiplication table to use
    STA .vduMultiplicationTableLow                      ; store
    LDA #>.multiplyBy640Table                           ; high byte of multiplication tables
    STA .vduMultiplicationTableHigh                     ; store. Now (.vduMultiplicationTableLow) points to 640x multiplication table or 40x.
    LDA .bytesPerRowLow,X                               ; get number of bytes per row (low byte) from table

    STA .vduBytesPerCharacterRowLow                     ; store bytes per character row
    STX .vduBytesPerCharacterRowHigh                    ; bytes per character row (high byte)
    LDA #%01000011                                      ;
    JSR .clearVDUStatusByteFlags                        ; clear bits 2,3,4,5,7 in .vduStatusByteFlags:
                                                        ; bit 2 = paged scrolling selected
                                                        ; bit 3 = software scrolling (text window)
                                                        ; bit 4 = not used
                                                        ; bit 5 = graphics cursor enabled (VDU 5)
                                                        ; bit 7 = VDU disabled


    LDX .vduCurrentScreenMODE                           ; screen mode
    LDA .videoULAVideoControlRegisterDefaultValuesPerMODE,X ; get video ULA control setting
    JSR .setVideoULA                                    ; set video ULA using OSBYTE 154

    ; Set CRTC registers for the current mode
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDX .crtcCursorEndRegisterTable,Y                   ; get cursor end register data from table
    LDY #11                                             ; Y = 11
-
    LDA .crtcRegisters0to11ForMODEs012,X                ; get entry from CRTC table
    JSR .setCRTCRegisterAY                              ; set CRTC Register Y to A
    DEX                                                 ; reduce pointers
    DEY                                                 ;
    BPL -                                               ; if (still >=0) then branch (loop back)
    PLP                                                 ; pull flags
    JSR .vdu20EntryPoint                                ; set default colours
    JSR .vdu26EntryPoint                                ; set default windows

.initializeDisplayAndHomeCursor
    LDX #0                                              ; X = 0
    LDA .vduStartScreenAddressHighByte                  ; high byte of screen RAM address
    STX .vduScreenTopLeftAddressLow                     ; screen start address low
    STA .vduScreenTopLeftAddressHigh                    ; screen start address high
    JSR .setTextCursorCRTCAddress                       ; use X and Y to set new cursor address
    LDY #.crtcStartScreenAddressHighRegister            ;
    JSR .setTwoCRTCRegisters                            ; set registers 12 and 13 in CRTC
    LDA .vduBackgroundTextColour                        ; background text colour
    LDX .vduCurrentScreenMODEGroup                      ; MODE group = screen memory size
                                                        ; 0=20k (MODE 0,1,2)
                                                        ; 1=16k (MODE 3)
                                                        ; 2=10k (MODE 4,5)
                                                        ; 3=8k (MODE 6)
                                                        ; 4=1k (MODE 7)
    LDY .clearScreenRoutineEntryPointLow,X              ; get section control number
    STY .vduJumpVectorLow                               ; set it in jump vector low
    LDY #>.clearScreenRoutineEntryPointMODE012          ; high byte of address of screen clearing routine
    STY .vduJumpVectorHigh                              ; upper byte of link address
    LDX #0                                              ; X = 0
    STX .pagedModeCounter                               ; paged mode counter
    STX .vduTextCursorXPosition                         ; text column
    STX .vduTextCursorYPosition                         ; current text line
    JMP (.vduJumpVectorLow)                             ; jump indirect - this calls the screen clearing routine

; ***************************************************************************************
;
; OSWORD 10 - Read character definition
;
; On Entry:
;       A          = character to read
;       .oswordX/Y = address of buffer to store the eight bytes of results
; ***************************************************************************************
.osword10EntryPoint
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    LDY #0                                              ; Y=0
-
    LDA (.vduTempStoreDE),Y                             ; get first byte
    INY                                                 ; Y=Y+1
    STA (.oswordX),Y                                    ; store it in YX
    CPY #8                                              ; until Y=8
    BNE -                                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; Screen clear routine
;
; On Entry:
;       A contains byte for the background colour which is set in every byte of the screen
;
; To visualise the pattern of bytes that are cleared see cls.ssd
;
; ***************************************************************************************
.clearScreenRoutineEntryPointMODE012
    STA $3000,X                                         ;
    STA $3100,X                                         ;
    STA $3200,X                                         ;
    STA $3300,X                                         ;
    STA $3400,X                                         ;
    STA $3500,X                                         ;
    STA $3600,X                                         ;
    STA $3700,X                                         ;
    STA $3800,X                                         ;
    STA $3900,X                                         ;
    STA $3A00,X                                         ;
    STA $3B00,X                                         ;
    STA $3C00,X                                         ;
    STA $3D00,X                                         ;
    STA $3E00,X                                         ;
    STA $3F00,X                                         ;

.clearScreenRoutineEntryPointMODE3
    STA $4000,X                                         ;
    STA $4100,X                                         ;
    STA $4200,X                                         ;
    STA $4300,X                                         ;
    STA $4400,X                                         ;
    STA $4500,X                                         ;
    STA $4600,X                                         ;
    STA $4700,X                                         ;
    STA $4800,X                                         ;
    STA $4900,X                                         ;
    STA $4A00,X                                         ;
    STA $4B00,X                                         ;
    STA $4C00,X                                         ;
    STA $4D00,X                                         ;
    STA $4E00,X                                         ;
    STA $4F00,X                                         ;
    STA $5000,X                                         ;
    STA $5100,X                                         ;
    STA $5200,X                                         ;
    STA $5300,X                                         ;
    STA $5400,X                                         ;
    STA $5500,X                                         ;
    STA $5600,X                                         ;
    STA $5700,X                                         ;

.clearScreenRoutineEntryPointMODE45
    STA $5800,X                                         ;
    STA $5900,X                                         ;
    STA $5A00,X                                         ;
    STA $5B00,X                                         ;
    STA $5C00,X                                         ;
    STA $5D00,X                                         ;
    STA $5E00,X                                         ;
    STA $5F00,X                                         ;

.clearScreenRoutineEntryPointMODE6
    STA $6000,X                                         ;
    STA $6100,X                                         ;
    STA $6200,X                                         ;
    STA $6300,X                                         ;
    STA $6400,X                                         ;
    STA $6500,X                                         ;
    STA $6600,X                                         ;
    STA $6700,X                                         ;
    STA $6800,X                                         ;
    STA $6900,X                                         ;
    STA $6A00,X                                         ;
    STA $6B00,X                                         ;
    STA $6C00,X                                         ;
    STA $6D00,X                                         ;
    STA $6E00,X                                         ;
    STA $6F00,X                                         ;
    STA $7000,X                                         ;
    STA $7100,X                                         ;
    STA $7200,X                                         ;
    STA $7300,X                                         ;
    STA $7400,X                                         ;
    STA $7500,X                                         ;
    STA $7600,X                                         ;
    STA $7700,X                                         ;
    STA $7800,X                                         ;
    STA $7900,X                                         ;
    STA $7A00,X                                         ;
    STA $7B00,X                                         ;

.clearScreenRoutineEntryPointMODE7
    STA $7C00,X                                         ;
    STA $7D00,X                                         ;
    STA $7E00,X                                         ;
    STA $7F00,X                                         ;
    INX                                                 ;
    BEQ .exit7                                          ; if (all done) then branch (exit)
    ; fall through...

; ***************************************************************************************
.executeRequiredVDUFunction
    JMP (.vduJumpVectorLow)                             ; loop back (using the jump vector
                                                        ; set up previously) to the
                                                        ; appropriate address for the current
                                                        ; MODE.

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 7: Graphics cursor and soft character definitions
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Subtract the number of bytes in a row from AX
;
; On Entry:
;       A = High byte of 16 bit value
;       X = Low byte of 16 bit value
;
; ***************************************************************************************
.subtractNumberOfBytesInARowFromAX
    PHA                                                 ; store A
    TXA                                                 ; A=X
    SEC                                                 ; set carry for subtraction
    SBC .vduBytesPerCharacterRowLow                     ; bytes per character row
    TAX                                                 ; result goes into X
    PLA                                                 ; recall A
    SBC .vduBytesPerCharacterRowHigh                    ; bytes per character row
    CMP .vduStartScreenAddressHighByte                  ; high byte of screen RAM address
.exit6
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 20 - 'Explode' soft character definitions
;
; This sets how much RAM is reserved for custom ('soft') character definitions. These areas
; of memory are sometimes known as 'font zones'.
;
; On Entry:
;       X   memory assigned          character range   notes
;       0   $0C00->$0CFF               $80-$8F         minimum memory assigned ('imploded')
;       1   OSHWM->OSHWM+$FF           $A0-$BF         includes allocations above
;       2   OSHWM+$100->OSHWM+$1FF     $C0-$DF         includes allocations above
;       3   OSHWM+$200->OSHWM+$2FF     $E0-$FF         includes allocations above
;       4   OSHWM+$300->OSHWM+$3FF     $20-$3F         includes allocations above
;       5   OSHWM+$400->OSHWM+$4FF     $40-$5F         includes allocations above
;       6   OSHWM+$500->OSHWM+$5FF     $60-$7F         includes allocations above
;
; Here OSHWM refers to the value of .defaultOSHWM, which holds the value of OSHWM before any
; font explosions.
;
; ***************************************************************************************
.osbyte20EntryPoint
    LDA #%00001111                                      ;
    STA .vduFontFlags                                   ; characters 160-255 have soft character definitions
    LDA #>.softCharacterDefinitions                     ; page for software character definitions
    LDY #.vduFontZoneAddressesHigh7 - .vduFontZoneAddressesHigh1     ; set loop counter
-
    STA .vduFontZoneAddressesHigh1,Y                    ; set all font zone addresses (high byte) to $0C
    DEY                                                 ; to indicate the page available
    BPL -                                               ; for user character definitions

    CPX #7                                              ;
    BCC +                                               ; if (X < 7, i.e. parameter is in range) then branch
    LDX #6                                              ; X=6
+
    STX .softCharacterDefinitionsSwitch                 ; character definition explosion switch
    LDA .defaultOSHWM                                   ; A = initial OSHWM value, before font
                                                        ;     explosions.
    LDX #0                                              ; X = 0, loop counter
-
    CPX .softCharacterDefinitionsSwitch                 ; character definition explosion switch
    BCS +                                               ;
    LDY .softCharacterRamAllocationTable,X              ; Y = RAM allocation offset
    STA .vduFontZoneAddressesHigh1,Y                    ; store in relevant font zone address
    ADC #1                                              ; add 1 page (carry clear)
    INX                                                 ; X=X+1
    BNE -                                               ; if (X is not zero) then branch (loop back)
+
    STA .currentOSHWM                                   ; store new value of PAGE (OSHWM)
    TAY                                                 ; Y=A
    BEQ .exit6                                          ; if (zero) then branch (return)

    LDX #.romServiceCallFontImplosionExplosionWarning   ; } issue ROM service call to let ROMs
                                                        ; } know of the font explosion and
    JMP .osbyte143EntryPoint                            ; } to let languages know OSHWM
                                                        ; } is changing. Y is new PAGE number

; ***************************************************************************************
.moveTextCursorToNextLine
    LDA #2                                              ; A=2 to check if scrolling disabled
    BIT .vduStatusByte                                  ; test VDU status byte
    BNE +                                               ; if (scrolling is disabled) then branch
    BVC .exit8                                          ; if (cursor editing mode is disabled) then return
+
    LDA .vduTextWindowBottom                            ; bottom edge of text window
    BCC +                                               ; if (carry clear on entry) then branch
    LDA .vduTextWindowTop                               ; get top of text window
+
    BVS .moveTextCursorToNextLineCursorEditing          ; if (cursor editing mode enabled) then branch
    STA .vduTextCursorYPosition                         ; set current text line
    PLA                                                 ; pull return link from stack
    PLA                                                 ;
    JMP .setCursorSoftwareAndHardwarePosition           ; set cursor position

; ***************************************************************************************
.moveTextCursorToNextLineCursorEditing
    PHP                                                 ; push flags
    CMP .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
    BEQ .pullAndExit                                    ; if (A = line count) then branch (exit)
    PLP                                                 ; get back flags
    BCC .incYCoordinate                                 ;
    DEC .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
.exit7
    RTS                                                 ;

; ***************************************************************************************
.incYCoordinate
    INC .vduTextInputCursorYCoordinate                  ; Y coordinate of text input cursor
    RTS                                                 ;

; ***************************************************************************************
;
; Set up a write cursor
;
; When entering a line of text, if the user presses a cursor key then two cursors are shown:
; The WRITE cursor is shown at the point of text entry (looks like a solid block character),
; and is the position at which new characters will be input.
; The READ cursor (shown as a flashing underline) is positioned by the cursor keys.
; The COPY key reads the character under the READ cursor and enters it at WRITE cursor.
;
; Editing finishes when RETURN is pressed.
;
; ***************************************************************************************
.setUpWriteCursor
    PHP                                                 ; save flags
    PHA                                                 ; save A
    LDY .vduBytesPerCharacter                           ;
    DEY                                                 ; Y = bytes per character - 1
    BNE .restoreWriteCursorNonMODE7                     ; if (not MODE 7) then branch
    LDA .vduMODE7CursorCharacter                        ; get MODE 7 write character
                                                        ; cursor character $7F
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it at top scan line of current
                                                        ; character
.pullTwiceAndExit
    PLA                                                 ; pull A
.pullAndExit
    PLP                                                 ; pull flags
.exit8
    RTS                                                 ;

; ***************************************************************************************
;
; Restore a normal cursor
;
; ***************************************************************************************
.restoreWriteCursor
    PHP                                                 ; push flags
    PHA                                                 ; push A
    LDY .vduBytesPerCharacter                           ;
    DEY                                                 ; Y = bytes per character - 1
    BNE .restoreWriteCursorNonMODE7                     ; if (not MODE 7) then branch
    LDA (.vduWriteCursorScreenAddressLow),Y             ; read from cursor screen address
    STA .vduMODE7CursorCharacter                        ; store it
    LDA .vduTeletextCharacterForCursor                  ; MODE 7 write cursor character
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it in MODE 7 screen address
    JMP .pullTwiceAndExit                               ; and exit

; ***************************************************************************************
.restoreWriteCursorNonMODE7
    LDA #$FF                                            ; A=$FF (cursor byte mask)
    CPY #31                                             ; check bytes per character
    BNE +                                               ; if (not MODE 2) then branch
    LDA #$3F                                            ; A=$3F (cursor byte mask)
+
    STA .vduTempStoreDA                                 ; store it
-
    LDA (.vduWriteCursorScreenAddressLow),Y             ; get scan line byte
    EOR .vduTempStoreDA                                 ; invert it
    STA (.vduWriteCursorScreenAddressLow),Y             ; store it on scan line
    DEY                                                 ; decrement scan line counter
    BPL -                                               ; do it again
    BMI .pullTwiceAndExit                               ; ALWAYS branch (pull and exit)

; ***************************************************************************************
;
; Software scroll text window downwards
;
; ***************************************************************************************
.scrollTextWindowDownwards
    JSR .checkVerticalTextWindowBoundsAndMoveToLeftColumn   ;
    LDA .vduTextWindowBottom                            ; bottom edge
    STA .vduTextCursorYPosition                         ; current text line
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
.loopBackScrollDown
    JSR .subtractNumberOfBytesInARowFromAX              ; subtract bytes per character row
    BCS +                                               ;
    ADC .vduScreenSizeHighByte                          ; screen RAM size high byte
+
    STA .vduTempStoreDB                                 ; store A
    STX .vduTempStoreDA                                 ; X
    STA .vduTempStoreDC                                 ; A again
    BCS .noWraparound                                   ; if (C set; there was no wraparound) then branch
-
    JSR .copyCharacterLineOfTextWindow                  ; copy line to new position
                                                        ; using (.vduTempStoreDA) for read and
                                                        ; (.vduWriteCursorScreenAddressLow)
                                                        ; for write
    JMP +                                               ;

.noWraparound
    JSR .subtractNumberOfBytesInARowFromAX              ; subtract bytes per character row
    BCC -                                               ; if (outside screen RAM) then branch
    JSR .copyCharacterRow                               ; copy a character row of the text window
+
    LDA .vduTempStoreDC                                 ; set write pointer from read pointer
    LDX .vduTempStoreDA                                 ;
    STA .vduWriteCursorScreenAddressHigh                ;
    STX .vduWriteCursorScreenAddressLow                 ;
    DEC .vduTempStoreDE                                 ; decrement window height
    BNE .loopBackScrollDown                             ; if (not zero) then branch (loop back)

.exchangeTextCursorPositionWithWorkspaceAB
    LDX #.vduWorkspaceA - .vduVariablesStart            ; point to workspace

    LDY #.vduTextCursorXPosition - .vduVariablesStart   ; point to text column/line
    ; fall through...

; ***************************************************************************************
.exchangeTwoVDUBytes
    LDA #2                                              ; number of bytes to swap
    BNE .exchangeABytes                                 ; ALWAYS branch. Exchange
                                                        ; (.vduWorkspaceA/B)+Y with (.workspaceA/B)+X

; ***************************************************************************************
.exchangeGraphicsCursorWithOldPosition
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart     ; point to graphics cursor
.exchangeOldGraphicsCursorPositionWithVariableX
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart  ; point to last graphics cursor
    ; fall through...

; ***************************************************************************************
.exchangeFourBytes
    LDA #4                                              ; A = 4
    ; fall through...

; ***************************************************************************************
.exchangeABytes
    STA .vduTempStoreDA                                 ; store it as loop counter
-
    LDA .vduVariablesStart,X                            ; get byte
    PHA                                                 ; store it
    LDA .vduVariablesStart,Y                            ; get byte pointed to by Y
    STA .vduVariablesStart,X                            ; put it in 300+X
    PLA                                                 ; get back A
    STA .vduVariablesStart,Y                            ; put it in 300+Y
    INX                                                 ; increment pointers
    INY                                                 ;
    DEC .vduTempStoreDA                                 ; decrement loop counter
    BNE -                                               ; if (not zero) then branch (loop back and do it again)
    RTS                                                 ;

; ***************************************************************************************
;
; Software scroll text window upwards
;
; ***************************************************************************************
.scrollTextWindowUpwards
    JSR .checkVerticalTextWindowBoundsAndMoveToLeftColumn   ;
    LDY .vduTextWindowTop                               ; top of text window
    STY .vduTextCursorYPosition                         ; current text line
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
.loopBackScrollUp
    JSR .addNumberOfBytesInACharacterRowToAX            ; add bytes per character row
    BPL +                                               ;
    SEC                                                 ;
    SBC .vduScreenSizeHighByte                          ; screen RAM size high byte
+
    STA .vduTempStoreDB                                 ; (.vduTempStoreDA)=X/A
    STX .vduTempStoreDA                                 ;
    STA .vduTempStoreDC                                 ; .vduTempStoreDC=A
    BCC +                                               ;
-
    JSR .copyCharacterLineOfTextWindow                  ; copy line to new position
                                                        ; using (.vduTempStoreDA) for read
                                                        ; and (.vduWriteCursorScreenAddressLow) for write
    JMP .finishScroll                                   ;

+
    JSR .addNumberOfBytesInACharacterRowToAX            ; add bytes per char. row
    BMI -                                               ; if (outside screen RAM) then branch
    JSR .copyCharacterRow                               ; copy a character row of the text window
.finishScroll
    LDA .vduTempStoreDC                                 ;
    LDX .vduTempStoreDA                                 ;
    STA .vduWriteCursorScreenAddressHigh                ;
    STX .vduWriteCursorScreenAddressLow                 ;
    DEC .vduTempStoreDE                                 ; decrement window height
    BNE .loopBackScrollUp                               ; if (not zero) then branch (loop back)
    BEQ .exchangeTextCursorPositionWithWorkspaceAB      ; ALWAYS branch - swap text cursor position with workspace


; ***************************************************************************************
;
; Copy bytes of one character row of the text window
;
; On Entry:
;       .vduTempStoreDA/DB                   is address to copy from
;       .vduWriteCursorScreenAddressLow/High is the destination address
;       .vduTextWindowWidthInBytesLow/High   is number of bytes to copy
; ***************************************************************************************
.copyCharacterRow
    LDX .vduTextWindowWidthInBytesHigh                  ; text window width high (bytes)
    BEQ +                                               ; if (no more than 256 bytes to copy) then branch

    LDY #0                                              ; Y=0 to set loop counter
-
    LDA (.vduTempStoreDA),Y                             ; } copy 256 bytes
    STA (.vduWriteCursorScreenAddressLow),Y             ; }
    INY                                                 ; }
    BNE -                                               ; } loop till Y=0 again
    INC .vduWriteCursorScreenAddressHigh                ; increment high bytes
    INC .vduTempStoreDB                                 ;
    DEX                                                 ; decrement window width
    BNE -                                               ; if (not done yet) then branch (loop back)
+
    LDY .vduTextWindowWidthInBytesLow                   ; text window width low (bytes)
    BEQ +                                               ; if (text window is zero bytes wide) then branch (return)
-
    DEY                                                 ; Y=Y-1
    LDA (.vduTempStoreDA),Y                             ; copy Y bytes
    STA (.vduWriteCursorScreenAddressLow),Y             ;
    TYA                                                 ; A=Y
    BNE -                                               ; if (not done yet) then branch (loop back)
+
    RTS                                                 ;


; ***************************************************************************************
.checkVerticalTextWindowBoundsAndMoveToLeftColumn
    JSR .exchangeTextCursorPositionWithWorkspaceAB      ; exchange text cursor position with workspaceAB
    SEC                                                 ; set carry
    LDA .vduTextWindowBottom                            ; bottom edge
    SBC .vduTextWindowTop                               ; top of text window
    STA .vduTempStoreDE                                 ; store height of text area
    BNE .setTextCursorToLeftHandColumn                  ; set text column to left hand column
    PLA                                                 ; get back return address (to exit caller routine early)
    PLA                                                 ;
    JMP .exchangeTextCursorPositionWithWorkspaceAB      ; exchange text cursor position with workspaceAB

; ***************************************************************************************
.setTextCursorToLeftHandColumn
    LDA .vduTextWindowLeft                              ; text window left
    BPL .storeTextCursorXSetCarryAndReturn              ; ALWAYS branch (set X window position)

; ***************************************************************************************
.copyCharacterLineOfTextWindow
    LDA .vduTempStoreDA                                 ; get back A
    PHA                                                 ; push A
    SEC                                                 ; set carry
    LDA .vduTextWindowRight                             ; text window right
    SBC .vduTextWindowLeft                              ; text window left
    STA .vduTempStoreDF                                 ; store text window width
--
    LDY .vduBytesPerCharacter                           ; bytes per character to set loop counter
    DEY                                                 ; copy loop
-
    LDA (.vduTempStoreDA),Y                             ; source: copy from .vduTempStoreDA/DB
    STA (.vduWriteCursorScreenAddressLow),Y             ; destination: store to screen
    DEY                                                 ;
    BPL -                                               ; keep copying for one character
    LDX #2                                              ; X=2 loop counter
-
    CLC                                                 ; clear carry
    LDA .vduWriteCursorScreenAddressLow,X               ;
    ADC .vduBytesPerCharacter                           ; move screen pointer on by bytes per character
    STA .vduWriteCursorScreenAddressLow,X               ; and (when X=0) do the same with .vduTempStoreDA/DB
    LDA .vduWriteCursorScreenAddressHigh,X              ;
    ADC #0                                              ;
    BPL +                                               ; if (this remains in screen RAM OK) then branch
    SEC                                                 ; wrap around screen
    SBC .vduScreenSizeHighByte                          ; take off screen RAM size high byte
+
    STA .vduWriteCursorScreenAddressHigh,X              ; store high byte
    DEX                                                 ; X = X - 2
    DEX                                                 ;
    BEQ -                                               ; if (X = 0) then branch (loop back
                                                        ; to adjust second set of pointers)
    DEC .vduTempStoreDF                                 ; decrement text window width counter
    BPL --                                              ; if (still +ve) then branch (loop
                                                        ; back and do it all again)
    PLA                                                 ; get back A
    STA .vduTempStoreDA                                 ; and store it
    RTS                                                 ;

; ***************************************************************************************
.clearOneLine
    LDA .vduTextCursorXPosition                         ; text column
    PHA                                                 ; save it
    JSR .setTextCursorToLeftHandColumn                  ; set text column to left hand column
    JSR .setTextCursorScreenAddresses                   ; set cursor screen addresses
    SEC                                                 ; set carry
    LDA .vduTextWindowRight                             ; text window right
    SBC .vduTextWindowLeft                              ; text window left
    STA .vduTempStoreDC                                 ; as window width
--
    LDA .vduBackgroundTextColour                        ; background text colour
    LDY .vduBytesPerCharacter                           ; bytes per character
-
    DEY                                                 ; Y=Y-1 decrementing loop counter
    STA (.vduWriteCursorScreenAddressLow),Y             ; store background colour at this
                                                        ; point on screen
    BNE -                                               ; if (Y is not zero) then branch
                                                        ; (loop back)
    TXA                                                 ; A=X
    CLC                                                 ; clear carry to add
    ADC .vduBytesPerCharacter                           ; bytes per character
    TAX                                                 ; X=A restoring it
    LDA .vduWriteCursorScreenAddressHigh                ; get high byte
    ADC #0                                              ; add carry if any
    BPL +                                               ; if (+ve) then branch
    SEC                                                 ; wrap around
    SBC .vduScreenSizeHighByte                          ; screen RAM size high byte
+
    STX .vduWriteCursorScreenAddressLow                 ; restore values
    STA .vduWriteCursorScreenAddressHigh                ;
    DEC .vduTempStoreDC                                 ; decrement window width
    BPL --                                              ; and if not 0 do it all again
    PLA                                                 ; get back A

.storeTextCursorXSetCarryAndReturn
    STA .vduTextCursorXPosition                         ; restore text column
.setCarryAndReturn
    SEC                                                 ; set carry
    RTS                                                 ;

; ***************************************************************************************
.validatePositionAndSetupScreenAddress
    LDX .vduTextCursorXPosition                         ; get text cursor X position
    CPX .vduTextWindowLeft                              ; test against left edge of text window
    BMI .setCarryAndReturn                              ; if (less than left edge) then branch (return with carry set)
    CPX .vduTextWindowRight                             ; test against right edge of text window
    BEQ +                                               ; if (equal to right edge) then branch (thats OK)
    BPL .setCarryAndReturn                              ; if (greater than right edge) then branch (return with carry set)
+
    LDX .vduTextCursorYPosition                         ; current text line
    CPX .vduTextWindowTop                               ; test against top edge of text window
    BMI .setCarryAndReturn                              ; if (less than top edge) then branch (return with carry set)
    CPX .vduTextWindowBottom                            ; test against bottom edge of text window
    BEQ .setTextCursorScreenAddresses                   ; if (equal to bottom edge) then branch (ok to set cursor screen addresses)
    BPL .setCarryAndReturn                              ; if (greater than bottom edge) then branch (return with carry set)
    ; fall through...

; ***************************************************************************************
;
; Set text cursor screen addresses from X,Y position
;
; Let X,Y be the text cursor position (in absolute character cells from top left corner)
;
;     MODE 0: address = screen_start + Y*640 + X* 8
;     MODE 1: address = screen_start + Y*640 + X*16
;     MODE 2: address = screen_start + Y*640 + X*32
;     MODE 3: address = screen_start + Y*640 + X* 8
;     MODE 4: address = screen_start + Y*320 + X* 8
;     MODE 5: address = screen_start + Y*320 + X*16
;     MODE 6: address = screen_start + Y*320 + X* 8
;     MODE 7: address = screen_start + Y* 40 + X
;
; Given the text cursor X,Y position, use the multiplication table and other characteristic
; values for the current MODE to calculate the address on screen.
;
; On Entry:
;       .vduTextCursorX/YPosition stores the X,Y coordinates of the text cursor
;
; On Exit:
;       Carry clear
;       Stores the result in .vduTextCursorCRTCAddressLow/High, then wraps the address back on
;       screen if beyond the bottom of the screen. Store the new wrapped result in
;       .vduWriteCursorScreenAddressLow/High.
;
; ***************************************************************************************
.setTextCursorScreenAddresses
    LDA .vduTextCursorYPosition                         ; current text line
    ASL                                                 ; multiply by two to get table offset
    TAY                                                 ; Y=A
    LDA (.vduMultiplicationTableLow),Y                  ; get CRTC multiplication table pointer
    STA .vduWriteCursorScreenAddressHigh                ; .vduWriteCursorScreenAddressHigh=A
    INY                                                 ; Y=Y+1
    LDA #2                                              ; A=2
    AND .vduCurrentScreenMODEGroup                      ; AND with MODE group:
                                                        ;   0 = 20k (MODE 0,1,2)
                                                        ;   1 = 16k (MODE 3)
                                                        ;   2 = 10k (MODE 4,5)
                                                        ;   3 = 8k (MODE 6)
                                                        ;   4 = 1k (MODE 7)
    PHP                                                 ; save flags
    LDA (.vduMultiplicationTableLow),Y                  ; get CRTC multiplication table pointer
    PLP                                                 ; pull flags
    BEQ +                                               ; branch if MODE 0,1,2,3 or 7
    LSR .vduWriteCursorScreenAddressHigh                ; MODE 4,5,6: Halve value from multiplication table (high and low bytes)
    ROR                                                 ; A = A / 2 + (128*carry)
+
    ADC .vduScreenTopLeftAddressLow                     ; add start of screen (low)
    STA .vduWriteCursorScreenAddressLow                 ; store
    LDA .vduWriteCursorScreenAddressHigh                ; get offset from start of screen (high)
    ADC .vduScreenTopLeftAddressHigh                    ; add start of screen (high)
    TAY                                                 ; store in Y
    LDA .vduTextCursorXPosition                         ; text column
    LDX .vduBytesPerCharacter                           ; bytes per character
    DEX                                                 ; X=X-1
    BEQ .mode7Cursor                                    ; if (in MODE 7) then branch
    CPX #15                                             ; is it mode 1 or mode 5? (four colour modes = 16 bytes per character)
    BEQ .mode1or5Cursor                                 ; if (mode 1 or 5) then branch (with carry set)
    BCC .mode0346Cursor                                 ; if (mode 0,3,4, or 6) then branch (with carry clear)
    ASL                                                 ; A=A*16 if entered here (MODE 2)
.mode1or5Cursor
    ASL                                                 ; A=A*8 if entered here
.mode0346Cursor
    ASL                                                 ; A=A*4 if entered here
    ASL                                                 ;
    BCC .skipIncs                                       ; if (carry clear) then branch
    INY                                                 ; Y=Y+2
    INY                                                 ; Y is the high byte of the address
.skipIncs
    ASL                                                 ; A=A*2
    BCC .skipInc                                        ; if (carry clear) branch (to add to .vduWriteCursorScreenAddressLow)
    INY                                                 ; Y=Y+1
.mode7Cursor
    CLC                                                 ; clear carry
.skipInc
    ADC .vduWriteCursorScreenAddressLow                 ; add to .vduWriteCursorScreenAddressLow
    STA .vduWriteCursorScreenAddressLow                 ; and store it
    STA .vduTextCursorCRTCAddressLow                    ; text cursor CRTC address
    TAX                                                 ; X=A
    TYA                                                 ; A=Y
    ADC #0                                              ; add carry if set
    STA .vduTextCursorCRTCAddressHigh                   ; store the text cursor CRTC address (before any wraparound)
    BPL +                                               ; if (not negative) then branch
    SEC                                                 ; wrap around...
    SBC .vduScreenSizeHighByte                          ; ...subtract the screen size (high byte)
+
    STA .vduWriteCursorScreenAddressHigh                ; store in high byte
    CLC                                                 ; clear carry
    RTS                                                 ;

; ***************************************************************************************
;
; Display a character at the current graphics cursor
;
; ***************************************************************************************
.plotACharacterAtGraphicsCursor
    LDX .vduForegroundGraphicsColour                    ; foreground graphics colour
    LDY .vduForegroundGCOLMode                          ; foreground graphics GCOL mode
.plotACharacterWithXYAsGraphicsColourAndGCOLMode
    JSR .setGraphicsColourMaskXY                        ; set graphics byte mask in .vduGraphicsColourByteOR/EOR
    JSR .copyGraphicsCursorPixelPositionToWorkspaceABCD ; copy graphics cursor in pixels to workspace (.vduWorkspaceA-D)
    LDY #0                                              ; Y=0
.displayNextRowOfCharacter
    STY .vduTempStoreDC                                 ; .vduTempStoreDC=Y
    LDY .vduTempStoreDC                                 ; Y=.vduTempStoreDC [redundant instruction]
    LDA (.vduTempStoreDE),Y                             ; get pattern byte
    BEQ .characterPatternZero                           ; if (A=0) then branch
    STA .vduTempStoreDD                                 ; .vduTempStoreDD = 1 bit character pattern byte
-
    BPL +                                               ; if (pattern's top bit is clear) then branch (nothing to draw)
    JSR .plotAPixelInACharacter                         ; display a pixel
+
    INC .vduGraphicsCursorPixelsXLow                    ; current horizontal graphics cursor
    BNE +                                               ;
    INC .vduGraphicsCursorPixelsXHigh                   ; current horizontal graphics cursor
+
    ASL .vduTempStoreDD                                 ; shift the bit pattern left to draw next pixel
    BNE -                                               ; if (there's still something left to draw) then branch (loop back)
.characterPatternZero
    LDX #.vduWorkspaceA - .vduVariablesStart            ; source is workspace
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart
                                                        ; destination is horizontal graphics cursor pixel position
    JSR .copyTwoBytesWithinVDUVariables                 ; copy two bytes
    LDY .vduGraphicsCursorPixelsYLow                    ; }
    BNE +                                               ; }
    DEC .vduGraphicsCursorPixelsYHigh                   ; } decrement graphics cursor Y pixel position
+                                                       ; }
    DEC .vduGraphicsCursorPixelsYLow                    ; }
    LDY .vduTempStoreDC                                 ; loop counter
    INY                                                 ;
    CPY #8                                              ;
    BNE .displayNextRowOfCharacter                      ; if (Y<8) then branch (loop back)
    LDX #.vduWorkspaceA - .vduVariablesStart            ; source: workspaceA-D
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart
                                                        ; destination: graphics cursor position
    JMP .copyFourBytesWithinVDUVariables                ; copy to graphics cursor position

; ***************************************************************************************
.graphicsCursorHome
    LDX #.vduGraphicsWindowPixelsTopLow - .vduVariablesStart ; source bytes (graphics window top)
    LDY #.vduGraphicsCursorPixelsYLow - .vduVariablesStart   ; destination bytes (graphics cursor Y)
    JSR .copyTwoBytesWithinVDUVariables                      ; copy two bytes
    ; fall through...

; ***************************************************************************************
.setGraphicsCursorToLeftHandColumn
    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart ; source: left edge of graphics
                                                              ; window
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart    ; destination: graphics cursor
                                                              ; X coordinate
    JSR .copyTwoBytesWithinVDUVariables                       ; copy two bytes
    JMP .convertPixelGraphicsCoordinatesToExternal            ; set up external coordinates for graphics

; ***************************************************************************************
.displayACharacter
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    BEQ .displayCharacterMODE7                          ; if (MODE 7) then branch
    JSR .getCharacterDefinitionAddress                  ; set up character definition pointers
    ; fall through...

; ***************************************************************************************
.displayACharacterAtAddress
    LDX .vduNumberOfLogicalColoursMinusOne              ; number of logical colours less 1
    LDA .vduStatusByte                                  ; VDU status byte
    AND #$20                                            ; and check bit 5 (printing at graphics cursor)
    BNE .plotACharacterAtGraphicsCursor                 ; if (set) then branch
    LDY #7                                              ; Y=7
    CPX #3                                              ;
    BEQ .displayACharacter4ColourMODE                   ; if (X = 3) then branch to handle 4 colour MODEs
    BCS .displayACharacter16ColourMODE                  ; if (X > 3) then branch to deal with 16 colours

    ; display a character in a 2 colour MODE
-
    LDA (.vduTempStoreDE),Y                             ; get pattern byte
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    DEY                                                 ; Y=Y-1
    BPL -                                               ; if (still +ve) then branch (loop back)
    RTS                                                 ;

; ***************************************************************************************
.displayCharacterMODE7
    LDY #2                                              ; Y=2, loop counter/index into the teletext conversion table
-
    CMP .teletextCharacterConversionTable,Y             ; compare with teletext conversion table
    BEQ .convertMODE7Character                          ; if (found character to convert) then branch
    DEY                                                 ; Y=Y-1
    BPL -                                               ; loop back until done
.writeByteToMODE7Screen
    STA (.vduWriteCursorScreenAddressLow,X)             ; write byte to screen
    RTS                                                 ;

; ***************************************************************************************
.convertMODE7Character
    LDA .teletextCharacterConversionTable + 1,Y         ; convert with teletext conversion table
    BNE .writeByteToMODE7Screen                         ; ALWAYS branch back to write it

; ***************************************************************************************
.displayACharacter4ColourMODE
    LDA (.vduTempStoreDE),Y                             ; get pattern byte
    PHA                                                 ; save it
    LSR                                                 ; move high nybble to low
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    TAX                                                 ; X=A
    LDA .fourColourMODEByteMaskTable,X                  ; convert 4 bits of the character
                                                        ; definition into bytes to write
                                                        ; to the screen
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    TYA                                                 ; A=Y
    CLC                                                 ; clear carry
    ADC #8                                              ; add 8 to move screen RAM pointer 8 bytes
    TAY                                                 ; Y=A
    PLA                                                 ; get back A
    AND #%00001111                                      ; clear high nybble
    TAX                                                 ; X=A
    LDA .fourColourMODEByteMaskTable,X                  ; 4 colour MODE byte mask look up table
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; write to screen
    TYA                                                 ; A=Y
    SBC #8                                              ; A=A-9
    TAY                                                 ; Y=A
    BPL .displayACharacter4ColourMODE                   ; if (not negative) then branch (loop back)
.exit9
    RTS                                                 ;

; ***************************************************************************************
.nextPatternByte
    TYA                                                 ; Y=Y-$21
    SBC #$21                                            ;
    BMI .exit9                                          ; if (Y is negative) then branch (return)
    TAY                                                 ; A=Y
    ; fall through...

; ***************************************************************************************
.displayACharacter16ColourMODE
    LDA (.vduTempStoreDE),Y                             ; get pattern byte
    STA .vduTempStoreDC                                 ; store it
    SEC                                                 ; set carry
.iloop
    LDA #0                                              ; A=0
    ROL .vduTempStoreDC                                 ; carry now occupies bit 0 of DC
    BEQ .nextPatternByte                                ; when DC=0 again branch to deal
                                                        ; with next pattern byte
    ROL                                                 ; get bit 7 from .vduTempStoreDC into A bit 0
    ASL .vduTempStoreDC                                 ; rotate again to get second
    ROL                                                 ; bit into A
    TAX                                                 ; and store result in X
    LDA .sixteenColourMODEByteMaskTable,X               ; convert two bits of the character
                                                        ; definition into bytes to write
                                                        ; to the screen
    ORA .vduTextColourByteOR                            ; adjust for current foreground and background colour
    EOR .vduTextColourByteEOR                           ; adjust for current foreground and background colour
    STA (.vduWriteCursorScreenAddressLow),Y             ; and store result
    CLC                                                 ; }
    TYA                                                 ; }
    ADC #8                                              ; } Y=Y+8 moving screen RAM pointer on 8 bytes
    TAY                                                 ; }
    BCC .iloop                                          ; branch back to deal with next bit pair
    ; fall through...


; ***************************************************************************************
;
; Get character definition address
;
; On Entry:
;       A is the ascii code for a printable character 32-255 (bit pattern abcdefgh)
; On Exit:
;       .vduTempStoreDE/F is the address of the character definition either from the default
;                      ROM characters or the soft character definitions
; ***************************************************************************************
.getCharacterDefinitionAddress
    ASL                                                 ; bcdefgh0  C=a
    ROL                                                 ; cdefgh0a  C=b
    ROL                                                 ; defgh0ab  C=c
    STA .vduTempStoreDE                                 ; save this pattern (defgh0ab)
    AND #%00000011                                      ; 000000ab
    ROL                                                 ; 00000abc  C=0
    TAX                                                 ; X = soft font zone (1 - 7)
    AND #%00000011                                      ; A = 000000bc (1 - 3)
    ADC #>.characterDefinitions - 1                     ; A = high byte of character definitions ($C0, $C1, $C2)
    TAY                                                 ; Y = high byte of ROM address of character
    LDA .fontMaskTable,X                                ; get single bit set depending on X (1-7)
    BIT .vduFontFlags                                   ; test font flags to see if there are soft character definitions
    BEQ +                                               ; if (hard character definitions) then branch
    LDY .vduFontZoneAddressesHigh1 - 1,X                ; get high byte from table for soft character definitions
+
    STY .vduTempStoreDF                                 ; store Y in high byte of address
    LDA .vduTempStoreDE                                 ; get back pattern (defgh0ab)
    AND #%11111000                                      ; defgh000
    STA .vduTempStoreDE                                 ; and store it. This is 8 times the
                                                        ; ASCII character giving the low
                                                        ; byte of the address
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 8: PLOT
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Plot routine
;
; See plot.png
; The plot routine is a multi-purpose tool for drawing graphics. It renders points,
; lines, dotted lines, filled triangles, and single horizontal line fills. It can also just
; move the current graphics cursor position. The lower three bits of the plot type hold plot
; options:
;
; Plot Options:
;   0         Move relative to last point
;   1         Draw relative to last point in foreground colour
;   2         Draw relative to last point in inverse colour
;   3         Draw relative to last point in background colour
;   4         Move absolute
;   5         Draw absolute in foreground colour
;   6         Draw absolute in inverse colour
;   7         Draw absolute in background colour
;
; ---------------------------------------------------------------------------------------
; PLOT TYPE   RANGE IN BINARY      BITS3-6    DESCRIPTION
; RANGE       abcdefgh-abcdefgh    bcde
; ---------------------------------------------------------------------------------------
; 0-7         00000000-00000111    0000       Move/Draw line with standard options 0-7
; 8-15        00001000-00001111    0001       As 0-7 but with the last point in a line omitted
;                                             when plotting with GCOL mode 3 (EOR) or 4
;                                             (INVERT)
; 16-23       00010000-00010111    0010       As 0-7 but with a dotted line
; 24-31       00011000-00011111    0011       As 0-7 but with a dotted line and the last point
;                                             in a line omitted when plotting with GCOL mode 3
;                                             (EOR) or 4 (INVERT)
; 32-39       00100000-00100111    0100       RESERVED for future expansion
; 40-47       00101000-00101111    0101       RESERVED for future expansion
; 48-55       00110000-00110111    0110       RESERVED for future expansion
; 56-63       00111000-00111111    0111       RESERVED for future expansion
; 64-71       01000000-01000111    1000       As 0-7 but only a single point is plotted
; 72-79       01001000-01001111    1001       As 0-7 but fill one line horizontally left and
;                                             right
; 80-87       01010000-01010111    1010       As 0-7 but fill a triangle
; 88-95       01011000-01011111    1011       As 0-7 but fill one line horizontally right
; 96-103      01100000-01100111    1100       RESERVED for future expansion
; 104-111     01101000-01101111    1101       RESERVED for future expansion
; 112-119     01110000-01110111    1110       RESERVED for future expansion
; 120-127     01111000-01111111    1111       RESERVED for future expansion
; 128-255     10000000-11111111    xxxx       RESERVED for future expansion
; ---------------------------------------------------------------------------------------
;
; Coordinate Systems
;
; The standard graphics coordinate system ranges from (0,0) at the bottom left of the screen
; to (1280 x 1024) at the top right. This coordinate range represents the entire screen
; regardless of the actual number of pixels available on screen.
;
; The graphics window origin can be changed to specify where a pixel drawn at (0,0) actually
; appears on the screen. This is a translation of the coordinate system.
;
; These resolution independent coordinates are called 'external' coordinates in this document.
;
; When calling the OS, external coordinates can optionally be specified 'relative' to the last
; point plotted. Coordinates are also always specified relative to the current graphics window
; origin. When translated into full screen coordinates these are known here as 'absolute'
; coordinates.
;
; Within OS routines absolute coordinates are scaled down to a pixel based scale. These are
; called 'pixel' coordinates. Pixel coordinates are never 'relative' coordinates in the sense
; above, but that doesn't stop OS routines temporarily storing the difference between two
; pixel based coordinates as part of its calculations of course.
;
; Conversions between the coordinate systems are done via:
;
;       .plotConvertExternalAbsoluteCoordinatesToPixels
;       .plotConvertExternalRelativeCoordinatesToPixels
;       .convertPixelGraphicsCoordinatesToExternal
;
; ***************************************************************************************
.vdu25ParameterPlotType = .vduQueueEndByte - 4
.vdu25ParameterXLow     = .vduQueueEndByte - 3
.vdu25ParameterXHigh    = .vduQueueEndByte - 2
.vdu25ParameterYLow     = .vduQueueEndByte - 1
.vdu25ParameterYHigh    = .vduQueueEndByte
.vdu25Plot
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; X is offset to X Coordinate (low)
    JSR .plotConvertExternalRelativeCoordinatesToPixels ; translate coordinates

    LDA .vdu25ParameterPlotType                         ; get plot type
    CMP #4                                              ; check for plot type four (move absolute)
    BEQ .plotMoveGraphicsCursorInAbsolutePixels         ; if (plot type is four) then branch (move absolute)
    LDY #5                                              ; Y=5
    AND #3                                              ; mask only bits 0 and 1
    BEQ +                                               ; if (result is 0) then branch (it's a move operation)
    LSR                                                 ; check bit zero
    BCS .plotWithGraphicsColour                         ; if (plot option needs foreground or background graphics colour) then branch
    DEY                                                 ; Y=4 ('inverse' plot option)
    BNE +                                               ; ALWAYS branch. The logic inverse colour must be wanted

; ***************************************************************************************
;
; Plot with graphics character
;
; On Entry:
;       A=0 it's a foreground colour
;       A=1 it's a background colour
;
; ***************************************************************************************
.plotWithGraphicsColour
    TAX                                                 ;
    LDY .vduForegroundGCOLMode,X                        ; get foreground or background graphics PLOT mode (into Y)
    LDA .vduForegroundGraphicsColour,X                  ; }
    TAX                                                 ; } get foreground or background graphics colour (into X)
+
    JSR .setGraphicsColourMaskXY                        ; set up colour masks in .vduGraphicsColourByteOR/EOR

    LDA .vdu25ParameterPlotType                         ; get plot type
    BMI .plotExtensionLocal                             ; if (128-255) then branch (it's RESERVED for future expansion)

    ; deal with plot 0-127
    ASL                                                 ; bcdefgh0
    BPL .plotType0to63                                  ; if (bit 7 is now 0, i.e. plot type is 0-63) then branch

    ; deal with plot 64-127
    AND #%11110000                                      ; bcde0000
    ASL                                                 ; cde00000
    BEQ .plotPointAndMove                               ; if (zero) then branch (plot type 64-71 was called, single point plot)

    ; deal with plot 72-127
    EOR #%01000000                                      ; cDe00000 (inverted bit d)
    BEQ .plotFillTriangleLocal                          ; if (bit 'D' clear; i.e. bit 'd' set) then branch (plot type 80-87, fill triangle)

    ; deal with plot 72-79 or 88-127
    PHA                                                 ; push cDe00000
    JSR .copyPlotParametersToGraphicsCursorPixelPosition ; copy parameters, setting XY in current graphics
                                                        ; coordinates
    PLA                                                 ; get back cDe00000
    EOR #%01100000                                      ; cdE00000 (invert bit D back to d, and invert bit e)
    BEQ .storeAndLateralFillLeftRight                   ; if (cdE00000 == 00000000) (ie.
                                                        ; cde == 001) then branch (type
                                                        ; is 72-79, it's a lateral fill
                                                        ; left/right)

    ; deal with plot 88-127
    CMP #%01000000                                      ; if (cdE00000 == 01000000) (ie.
                                                        ; cde == 011) then type is 88-95
                                                        ; (it's a lateral fill right)
    BNE .plotExtensionLocal                             ; otherwise branch (RESERVED for
                                                        ; future expansion)

    ; deal with plot 88-95
.plotLateralFillRight                                   ;
    LDA #2                                              ; A=2
    STA .vduTempStoreDC                                 ; .vduTempStoreDC = 2
    JMP .lateralFillRight                               ; lateral fill right

; ***************************************************************************************
.plotFillTriangleLocal
    JMP .plotFillTriangle                               ; to fill triangle routine

; ***************************************************************************************
.plotExtensionLocal
    JMP .vduPlotExtension                               ; VDU extension access entry

; ***************************************************************************************
.storeAndLateralFillLeftRight
    STA .vduTempStoreDC                                 ; .vduTempStoreDC = 0
    JMP .lateralFillLeftRight                           ; lateral fill left and right

; ***************************************************************************************
;
; Set graphics colour and GCOL mode bytes
;
; When writing graphics pixels to the screen, two bytes are used to adjust the byte to write
; based on the current colour and GCOL mode.
; This routine sets these two bytes .vduGraphicsColourByteOR and .vduGraphicsColourByteEOR
;
; GCOL Mode
; ---------
; 0 = Normal Mode: Sets the pixel to the current colour
; 1 =     OR Mode: Sets the pixel to the current colour  OR-ed with the colour on screen
; 2 =    AND Mode: Sets the pixel to the current colour AND-ed with the colour on screen
; 3 =    EOR Mode: Sets the pixel to the current colour EOR-ed with the colour on screen
; 4 = Invert Mode: Inverts the colour already on screen
;
; Suppose 'C' is the byte that when written to the screen sets each pixel of the byte to
; the current graphics colour.
;
; Then the two bytes are set as follows:
;       ------------------------------------------------------------------------
;       0=Normal Mode  | .vduGraphicsColourByteOR  = (C OR $FF) EOR $00 = $FF
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $FF = C EOR $FF
;       ------------------------------------------------------------------------
;       1=OR Mode      | .vduGraphicsColourByteOR  = (C OR $00) EOR $00 = C
;                      | .vduGraphicsColourByteEOR = (C OR $FF) EOR $FF = 0
;       ------------------------------------------------------------------------
;       2=AND Mode     | .vduGraphicsColourByteOR  = (C OR $00) EOR $FF = C EOR $FF
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $FF = C EOR $FF
;       ------------------------------------------------------------------------
;       3=EOR Mode     | .vduGraphicsColourByteOR  = (C OR $FF) EOR $FF = 0
;                      | .vduGraphicsColourByteEOR = (C OR $00) EOR $00 = C
;       ------------------------------------------------------------------------
;       4=Invert Mode  | .vduGraphicsColourByteOR  = (C OR $FF) EOR $FF = 0
;                      | .vduGraphicsColourByteEOR = (C OR $FF) EOR $00 = $FF
;       ------------------------------------------------------------------------
;
; When writing a pixel, start with a byte 'B', just the bits required to set one pixel to
; white. Then the pixel is written like so:
;
;            temp = (B AND .vduGraphicsColourByteOR) OR (current screen byte)
; new screen byte = (.vduGraphicsColourByteEOR AND B) EOR temp
;
; [A quirk: This routine is called with Y=5 for a relative move PLOT operation, but as
;           there's nothing to draw, the results are unused in this case.]
;
; On Entry:
;       X = colour byte to set
;       Y = GCOL Mode (0=Normal, 1=OR, 2=AND, 3=EOR, 4=Invert)
;
; On Exit:
;       .vduGraphicsColourByteOR / EOR hold the appropriate mask values
;
; ***************************************************************************************
.setGraphicsColourMaskXY
    TXA                                                 ; A=X
    ORA .gcolPlotOptionsTable,Y                         ; OR with GCOL plot options table byte
    EOR .gcolPlotOptionsTable + 1,Y                     ; EOR with following byte
    STA .vduGraphicsColourByteOR                        ; and store it
    TXA                                                 ; A=X
    ORA .gcolPlotOptionsTable - 1,Y                     ;
    EOR .gcolPlotOptionsTable + 4,Y                     ;
    STA .vduGraphicsColourByteEOR                       ; masks are stored in .vduGraphicsColourByteOR/EOR
    RTS                                                 ;

; ***************************************************************************************
; Continue processing of a PLOT command, where the plot type is in the range 0-63
.plotType0to63
    ASL                                                 ; cdefgh00
    BMI .plotExtensionLocal                             ; if (options are in range 32-63) then branch (not implemented)
    ASL                                                 ; defgh000
    ASL                                                 ; efgh0000
    BPL +                                               ; if (still +ve; type is 0-7 or 16-23) then branch (skips plot point)

    JSR .plotPoint                                      ; type is 8-15 or 24-31. We want to
                                                        ; omit the last point when drawing
                                                        ; in invert mode, so we do this by
                                                        ; displaying a point, which will get
                                                        ; inverted (erased) again in the
                                                        ; normal course of drawing the line.
+
    JSR .plotLine                                       ; draw a line or dotted line
    JMP .plotMoveGraphicsCursorInAbsolutePixels         ; move the graphics cursor

; ***************************************************************************************
; Plot a single point and move the graphics cursor position
.plotPointAndMove
    JSR .plotPoint                                      ; display a point
    ; fall through...

; ***************************************************************************************
; Move the current graphics cursor position, to new absolute pixel coordinates given by
; the vdu25Parameters.
.plotMoveGraphicsCursorInAbsolutePixels
    JSR .exchangeGraphicsCursorWithOldPosition          ; swap current and last graphics
                                                        ; position. The current position
                                                        ; becomes the previous position.
    ; fall through...

; ***************************************************************************************
.copyPlotParametersToGraphicsCursorPixelPosition
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; destination is the graphics cursor position in pixels
    ; fall through...

; ***************************************************************************************
.copyParameterPointToDestinationY
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; source is the position coordinate on the VDU queue
    JMP .copyFourBytesWithinVDUVariables                ; copy four bytes

; ***************************************************************************************
;
; Plot one pixel of a character
;
; See Characters.png
; When drawing a character at the graphics cursor, this draws an individual pixel
; of that character. It uses the current graphics cursor position as the position to plot.
;
; Each pixel is tested to see if it's within the bounds of the current graphics window,
; so characters can be partially drawn.
; ***************************************************************************************
.plotAPixelInACharacter
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ;
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; calculate position
    BEQ .plotPointWithinBounds                          ; if (within bounds) then branch
    RTS                                                 ;

; ***************************************************************************************
;
; Plots a single point
;
; This checks the point against the graphics window, gets the screen address details, then
; renders the pixel by writing to the screen address, applying the colour masks and plot type.
;
; On Entry:
;       X holds the offset into the VDU variables for four bytes holding the position to plot
;       at.
;
; ***************************************************************************************
.plotPoint
    JSR .checkParameterInBoundsAndSetScreenAddresses    ; check in bounds and set up screen addresses
    BNE +                                               ; if (A is not zero) then branch (return)
.plotPointWithinBounds
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; get current graphics scan line
.plotPointWithinBoundsAtY
    LDA .vduCurrentPlotByteMask                         ;
    AND .vduGraphicsColourByteOR                        ;
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    STA .vduTempStoreDA                                 ;
    LDA .vduGraphicsColourByteEOR                       ;
    AND .vduCurrentPlotByteMask                         ;
    EOR .vduTempStoreDA                                 ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; put it back again
+
    RTS                                                 ;

; ***************************************************************************************
;
; Plots a filled whole byte (as part of a lateral fill)
;
; On Entry:
;       Y is the vertical offset within a character cell (0-7)
; ***************************************************************************************
.plotByte
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    ORA .vduGraphicsColourByteOR                        ;
    EOR .vduGraphicsColourByteEOR                       ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ;
    RTS                                                 ;


; ***************************************************************************************
;
; Check that the graphics cursor is within the graphics window
;
; On Exit:
;   .vduTempStoreDA is zero if the point is within the graphics window, or the four low bits
;                indicate which regions failed:
;
;       %0000   success (point is within window)
;       %0001   graphics cursor X is left of  the left   edge of the graphics window
;       %0010   graphics cursor X is right of the right  edge of the graphics window
;       %0100   graphics cursor Y is below    the bottom edge of the graphics window
;       %1000   graphics cursor Y is above    the top    edge of the graphics window
;
; ***************************************************************************************
.checkGraphicsCursorIsWithinGraphicsWindow
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; X is the offset to check the graphics cursor
.checkPointXIsWithinGraphicsWindow
    LDY #0                                              ;
    STY .vduTempStoreDA                                 ; .vduTempStoreDA is initialised to zero (stores the error code)
    LDY #2                                              ; Y is the index to check the vertical bounds of the graphics window
    JSR .checkPointIsWithinWindowHorizontalOrVertical   ; check graphics cursor is within window vertically
    ASL .vduTempStoreDA                                 ; } Shift up error results two bits to make room for the next horizontal test results
    ASL .vduTempStoreDA                                 ; }
    DEX                                                 ;
    DEX                                                 ; reduce index by two to check the X position
    LDY #0                                              ; Y is the index to check the horizontal bounds of the graphics window
    JSR .checkPointIsWithinWindowHorizontalOrVertical   ; check graphics cursor is within window horizontally
    INX                                                 ; }
    INX                                                 ; } Restore X to initial value
    LDA .vduTempStoreDA                                 ; A = error code (0,1,2,4,5,6,8,9,10) depending on which bounds are exceeded
    RTS                                                 ;


; ***************************************************************************************
;
; Check coordinate of a point is in the window bounds (horizontal or vertical)
;
; On Entry:
;       X is the offset to the coordinate to check minus two bytes
;       Y is the offset to the second variable to check (0 for horizontal or 2 for vertical)
; On Exit:
;       .vduTempStoreDA is the error code (0 = no error, 1 = first check failed, 2 = second check
;       failed)
;       Zero flag set if no error
; ***************************************************************************************
.checkPointIsWithinWindowHorizontalOrVertical
    LDA .vduVariablesStart + 2,X                        ; } Subtract two sixteen bit variables, compare the results.
    CMP .vduVariablesStart + 0,Y                        ; } if var[X+2,X+3] < var[Y,Y+1] then error
    LDA .vduVariablesStart + 3,X                        ; }
    SBC .vduVariablesStart + 1,Y                        ; }
    BMI .oneError                                       ; branch if error

    LDA .vduVariablesStart + 4,Y                        ; } Subtract two sixteen bit variables, compare the results.
    CMP .vduVariablesStart + 2,X                        ; } if var[Y+4,Y+5] < var[X+2,X+3] then error
    LDA .vduVariablesStart + 5,Y                        ; }
    SBC .vduVariablesStart + 3,X                        ; }
    BPL +                                               ; if (no violation) then branch (exit)
    INC .vduTempStoreDA                                 ; increment error code
.oneError
    INC .vduTempStoreDA                                 ; increment error code
+
    RTS                                                 ;


; ***************************************************************************************
;
; Convert external absolute coordinates to pixels
;
; Convert external, absolute coordinates to pixels (horizontal and vertical)
;
; On Entry:
;       X is the offset in vdu variables to the coordinate to convert
;
; ***************************************************************************************
.plotConvertExternalAbsoluteCoordinatesToPixels
    LDA #$FF                                            ; A=$FF to ensure absolute coordinates
    BNE +                                               ; ALWAYS branch


; ***************************************************************************************
;
; Convert external relative coordinates to pixels
;
; Convert pair of external coordinates to pixels (horizontal and vertical)
;
; On Entry:
;       X is the offset in vdu variables to the coordinate to convert
;
; ***************************************************************************************
.plotConvertExternalRelativeCoordinatesToPixels
    LDA .vdu25ParameterPlotType                                     ; get first parameter in plot
+
    STA .vduTempStoreDA                                             ; store in .vduTempStoreDA
    LDY #2                                                          ; Y=2 (for vertical
                                                                    ; coordinate)
    JSR .convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo  ; convert
    JSR .signedDivideCoordinateByTwo                                ; divide by 2 again to
                                                                    ; convert 1023 to 0-255
                                                                    ; for pixels
    LDY #0                                                          ; Y=0 (for horizontal
                                                                    ; coordinate)
    DEX                                                             ;
    DEX                                                             ; X-=2
    JSR .convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo  ; convert

    LDY .vduPixelsPerByteMinusOne                       ; get number of pixels per byte (-1)
                                                        ;     7 for MODE 0
                                                        ;     3 for MODE 1
                                                        ;     1 for MODE 2
                                                        ;     0 for MODE 3
                                                        ;     7 for MODE 4
                                                        ;     3 for MODE 5
                                                        ;     0 for MODE 6
                                                        ;     0 for MODE 7

    CPY #3                                              ;
    BEQ +                                               ; if (MODE 1 or 5) then branch (divide by 2)
    BCS .doneDividing                                   ; if (MODE 0 or 4) then branch (no division needed)
    JSR .signedDivideCoordinateByTwo                    ; if (MODE 2,3,6 or 7) then divide by 4
                                                        ;                   (divide by two twice)
+
    JSR .signedDivideCoordinateByTwo                    ; divide by 2
.doneDividing
    LDA .vduCurrentScreenMODEGroup                      ; MODE group
    BNE .signedDivideCoordinateByTwo                    ; if (MODEs 3-7) then branch (divide by 2 again)
    RTS                                                 ;

; ***************************************************************************************
;
; Converts the vdu queue parameter to absolute coordinates and divides by two
;
; On Entry:
;       X               is the offset to the vdu queue parameter coordinate to convert
;       Y               is 0 or 2 for the horizontal or vertical cursor coordinates
;       .vduTempStoreDA is the plot type (to check for relative coordinate conversion)
;
; ***************************************************************************************
.convertExternalRelativeCoordinateToAbsoluteAndDivideByTwo
    CLC                                                 ; clear carry
    LDA .vduTempStoreDA                                 ; get .vduTempStoreDA
    AND #4                                              ; }
    BEQ .addPreviousCoordinate                          ; } if (relative coordinates) then branch (add previous coordinate)
    LDA .vduGraphicsWindowPixelsBottomLow,X             ; get coordinate
    PHA                                                 ;
    LDA .vduGraphicsWindowPixelsBottomHigh,X            ;
    BCC .addGraphicsOrigin                              ; ALWAYS branch

.addPreviousCoordinate
    LDA .vduGraphicsWindowPixelsBottomLow,X             ; get coordinate
    ADC .vduGraphicsCursorPositionXLow,Y                ; add cursor position
    PHA                                                 ; save it
    LDA .vduGraphicsWindowPixelsBottomHigh,X            ;
    ADC .vduGraphicsCursorPositionXHigh,Y               ; add cursor
    CLC                                                 ; clear carry

.addGraphicsOrigin
    STA .vduGraphicsCursorPositionXHigh,Y               ; save new cursor
    ADC .vduGraphicsWindowOriginXHigh,Y                 ; add graphics origin
    STA .vduGraphicsWindowPixelsBottomHigh,X            ; store it
    PLA                                                 ; get back low byte
    STA .vduGraphicsCursorPositionXLow,Y                ; save it in new cursor low
    CLC                                                 ; clear carry
    ADC .vduGraphicsWindowOriginXLow,Y                  ; add to graphics orgin
    STA .vduGraphicsWindowPixelsBottomLow,X             ; store it
    BCC .signedDivideCoordinateByTwo                    ; if (carry clear) then branch (skip over next statement)
    INC .vduGraphicsWindowPixelsBottomHigh,X            ; increment high byte
    ; fall through...

; ***************************************************************************************
;
; Divides the signed 16 bit coordinate value by two
;
; On Entry:
;       X is the offset to the coordinate from .vduGraphicsWindowPixelsBottomLow
;
; ***************************************************************************************
.signedDivideCoordinateByTwo
    LDA .vduGraphicsWindowPixelsBottomHigh,X            ; get high byte
    ASL                                                 ;
    ROR .vduGraphicsWindowPixelsBottomHigh,X            ; divide by 2
    ROR .vduGraphicsWindowPixelsBottomLow,X             ;
    RTS                                                 ;

; ***************************************************************************************
;
; Convert pixel coordinates to external absolute coordinates
;
; ***************************************************************************************
.convertPixelGraphicsCoordinatesToExternal
    LDY #.vduGraphicsCursorPositionXLow - .vduVariablesStart ; destination: graphics cursor in external coordinates
    JSR .copyGraphicsCursorPixelPosition                ; source is graphics cursor in pixel coordinates.
                                                        ; copy pixel coordinates to external coordinates.
    LDX #2                                              ; X=2 (offset to update the vertical coordinate)
    LDY #2                                              ; Y=2 (shift twice to multiply by four)
    JSR +                                               ; multiply .vduGraphicsCursorPositionY by 4 and subtract graphics origin
                                                        ; this is the external Y coordinate.
    LDX #0                                              ; X=0 (offset to update the horizontal coordinate)
    LDY #4                                              ; Y=4
    LDA .vduPixelsPerByteMinusOne                       ; get number of pixels/byte
-
    DEY                                                 ; Y=Y-1
    LSR                                                 ; divide by 2
    BNE -                                               ; if (result not 0) then branch (loop back)

    ; Pixels                                     Number of
    ; per byte   Screen     Y       MODE       multiplication
    ; minus one   MODE     Now      group      steps (#shifts)
    ; --------------------------------------------------------
    ;    7       MODE 0     1         0              1  (x1)
    ;    3       MODE 1     2         0              2  (x2)
    ;    1       MODE 2     3         0              3  (x4)
    ;    0       MODE 3     -         1              -
    ;    7       MODE 4     1         2              2  (x2)
    ;    3       MODE 5     2         2              3  (x4)
    ;    0       MODE 6     -         3              -
    ;    0       MODE 7     -         4              -
    ; --------------------------------------------------------

    LDA .vduCurrentScreenMODEGroup                      ; MODE group
    BEQ +                                               ; if (zero) then branch
    INY                                                 ; Y holds the number of multiplication steps (1, 2 or 3)
+
-
    ASL .vduGraphicsCursorPositionXLow,X                ; } multiply coordinate by 2
    ROL .vduGraphicsCursorPositionXHigh,X               ; }
    DEY                                                 ; Y-Y-1
    BNE -                                               ; if (Y != 0) then branch (do it again)

    SEC                                                 ; set carry
    JSR +                                               ; do one coordinate
    INX                                                 ; increment X
+
    LDA .vduGraphicsCursorPositionXLow,X                ; get current graphics position in external coordinates
    SBC .vduGraphicsWindowOriginXLow,X                  ; subtract origin
    STA .vduGraphicsCursorPositionXLow,X                ; store in graphics cursor position
    RTS                                                 ;


; ***************************************************************************************
;
; Plot a line or a dotted line
;
; Bresenham's line drawing algorithm is used.
; See https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
;
; In the enclosed BASIC program, we sketch out the ideas behind the assembly that follows.
; The code plots a bunch of random lines on the screen using standard OS line drawing, then
; undraws the same set of lines using a BASIC routine that mimics the OS code. The process
; is slow (it's written in unoptimised BASIC) but it unplots the exact same pixels
; as the OS routine. See lines.ssd.
;
; ***************************************************************************************
.plotLine
    JSR .plotLineInitialiseDeltaValues                  ;

; Now we have set the delta values:
;
;   Set .vduPlotLineDeltaX = graphics cursorX - parameterX  (lets call this dX)
;   Set .vduPlotLineDeltaY = graphics cursorY - parameterY  (lets call this dY)
;
; At this point, the values in .vduPlotLineDeltaX/Y are the delta in pixels for the line.
; The values are 16 bit signed integers. Positive values are to the left and down on screen,
; like so:
;
;                                         |
;                                         |
;                                         |
;                       dX /______________|_____________
;                          \           ###|<-(current graphics
;                                   ###   |   cursor position)
;                                ###      |
;                             ###         |
;        (new parameter -> ###           \|/
;           coordinates)                 dY
;
;
; Now calculate the dominant axis, i.e. which of dx and dy has the largest magnitude.

    LDA .vduPlotLineDeltaYHigh                          ;
    EOR .vduPlotLineDeltaXHigh                          ; check high bytes for different sign bit in dX/dY
    BMI .sectionB                                       ; if (result -ve; then deltas are different in sign) then branch later

; -------------SECTION A-------------
; dX and dY have the same sign
    LDA .vduPlotLineDeltaYLow                           ; }
    CMP .vduPlotLineDeltaXLow                           ; } if (dY >= dX) then A = dY - dX
    LDA .vduPlotLineDeltaYHigh                          ; }               else A = dY - dX - 1
    SBC .vduPlotLineDeltaXHigh                          ; }
                                                        ; } Result: A is positive if dY > dX, A is negative if dY < dX, otherwise A = 0.
                                                        ; }    i.e. A is SIGN(dY - dX), C = carry of difference (^)
; ----------SECTION A ENDS-----------
    JMP .plotLineGotDeltas                              ;

.sectionB
; -------------SECTION B-------------
; dX and dY have different signs
    LDA .vduPlotLineDeltaXLow                           ; } A = (dX + dY) (high byte)
    CLC                                                 ; } (where deltas are different in sign, so really a subtraction)
    ADC .vduPlotLineDeltaYLow                           ; }
    LDA .vduPlotLineDeltaXHigh                          ; } Result: A is positive if (dX > -dY), A is negative if dX < -dY, otherwise A = 0
    ADC .vduPlotLineDeltaYHigh                          ; }    i.e. A is SIGN(dX - dY), C = carry of difference
; ----------SECTION B ENDS-----------


; Table of examples (Part 1)
;         A=   B=  C=  D=           --------SECTION A---------- ----------SECTION B----------
;         dX   dX  dY  dY   signs   Carry= Result                Carry=   Result
;  dX dY  Low  Hi Low  Hi  differ?  (C>=A) D-B-(1-Carry)       (A+C)>255  (B+D+Carry)
; -------------------------------------------------------------------------------------------
;  3   1  $03 $00 $01 $00     no      0    $FF (Result Carry=0)     -     -
;  1   3  $01 $00 $03 $00     no      1    $00 (Result Carry=1)     -     -
; -3   1  $FD $FF $01 $00     yes     -     -                       0     $FF (Result Carry=0)
; -1   3  $FF $FF $03 $00     yes     -     -                       1     $00 (Result Carry=1)
;  3  -1  $03 $00 $FF $FF     yes     -     -                       1     $00 (Result Carry=1)
;  1  -3  $01 $00 $FD $FF     yes     -     -                       0     $FF (Result Carry=0)
; -3  -1  $FD $FF $FF $FF     no      1    $00 (Result Carry=1)     -     -
; -1  -3  $FF $FF $FD $FF     no      0    $FF (Result Carry=0)     -     -
; --------------------------------------------------------------------------------------------

.plotLineGotDeltas
    ; based on the calculations just done, we work out the dominant axis, X=0 for the X-axis
    ; being dominant (dX being at least as large in magnitude as dY), X=2 for the Y-axis
    ; (dY being larger).
    ROR                                                 ; make top bit of A = 'result carry'
                                                        ; from above
    LDX #0                                              ; X = 0
    EOR .vduPlotLineDeltaYHigh                          ; check if carry from result above has
                                                        ; same sign as workspaceD
    BPL +                                               ; if (dY has same sign as A) then branch (with X=0)
    LDX #2                                              ; X=2
+
    STX .vduTempStoreDE                                 ; store X: 0 means dx is the
                                                        ; dominant axis, at least as large
                                                        ; in magnitude as dy; 2 means dy is
                                                        ; dominant

    LDA .vduPlotLineRoutineAddresses,X                  ; } set up the address of one of two
    STA .vduJumpVectorLow                               ; } line drawing routines into
    LDA .vduPlotLineRoutineAddresses+1,X                ; } .vduJumpVectorLow/High (based on
    STA .vduJumpVectorHigh                              ; } X=0 or 2)

    LDA .vduPlotLineDeltaXHigh,X                        ; choose which side of the line
                                                        ; dY = -dX to draw on. (values $00
                                                        ; or $FF)

; Table of examples (Part 2)
;            carry flag
;  dX dY   EOR top bit of D   .vduTempStoreDE  .vduPlotLineDeltaXHigh,X
; -------------------------------------------------------------
;  3   1    0 EOR 0 = 0       0                $00
;  1   3    1 EOR 0 = 1       2 (Y dominant)   $00
; -3   1    0 EOR 0 = 0       0                $FF (dy < -dx)
; -1   3    1 EOR 0 = 1       2 (Y dominant)   $00
;  3  -1    1 EOR 1 = 0       0                $00
;  1  -3    0 EOR 1 = 1       2 (Y dominant)   $FF (dy < -dx)
; -3  -1    1 EOR 1 = 0       0                $FF (dy < -dx)
; -1  -3    0 EOR 1 = 1       2 (Y dominant)   $FF (dy < -dx)
; -------------------------------------------------------------

    BPL +                                                   ; if (dY >=-dX) then branch  (start drawing from the new parameter position)
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart  ; source: current graphics cursor    (start drawing from current cursor position)
    BNE .parametersSet                                      ; ALWAYS branch

+
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; source: vdu queue parameters (start drawing from new cursor position)
.parametersSet
    ;
    ; The line's start point is the point furthest left (when X is the dominant axis) or
    ; nearest the bottom (when Y is the dominant axis). The X register now holds the offset
    ; to the vdu variable for the start point of the line.
    ;
    STX .vduTempStoreDF                                 ; source: (offset to vdu variable for the start point, store in .vduTempStoreDF)
    LDY #.vduPlotLineCurrentPointXLow - .vduVariablesStart ; destination: current point
    JSR .copyFourBytesWithinVDUVariables                ; copy the start point to the current point

    LDA .vduTempStoreDF                                 ; get offset to vdu variable for the start point
    EOR #4                                              ; switch X to point at whichever of (vdu queue parameters / current graphics cursor) wasn't chosen before,
                                                        ; i.e. the end of the line to draw
    STA .vduTempStoreDD                                 ; .vduTempStoreDD = offset to vdu variable for the end of the line
    ORA .vduTempStoreDE                                 ; OR with 0 or 2 (if Y is the dominant axis we offset by 2 to copy the Y coordinate of the end point;
                                                        ; otherwise copy the X coordinate). We will use this later to check for termination on plotting the line.
    TAX                                                 ;
    JSR .copyTwoBytesWithinVDUVariablesToPlotLineTerminationValue ; copy final coordinate to
                                                        ; termination value. We use this later
                                                        ; to check for termination on plotting
                                                        ; the line.

    LDA .vdu25ParameterPlotType                         ; get plot type
    AND #%00010000                                      ; check bit 4 (dotted line)
    ASL                                                 ;
    ASL                                                 ;
    ASL                                                 ; move to bit 7
    STA .vduTempStoreDB                                 ; store whether we want a dotted line ($80) or not ($00)

    LDX #.vduPlotLineCurrentPointXLow - .vduVariablesStart ;
    JSR .checkPointXIsWithinGraphicsWindow              ; check if current point is out of bounds
    STA .vduTempStoreDC                                 ; store error code (which directions we are out of bounds)
    BEQ +                                               ; if (none) then branch
    LDA #%01000000                                      ; }
    ORA .vduTempStoreDB                                 ; } Set bit 6 of .vduTempStoreDB to indicate out of bounds
    STA .vduTempStoreDB                                 ; } (Bit 7 is still set for a dotted line.)
+
    LDX .vduTempStoreDD                                 ;
    JSR .checkPointXIsWithinGraphicsWindow              ; check other end of line for out of bounds
    BIT .vduTempStoreDC                                 ; BIT test (AND) together the bits of the two out of bounds calculations
                                                        ; this checks if the two ends of the line are out of bounds in the same direction
                                                        ; (e.g. both to the right of the right edge)
    BEQ .worthPlottingLine                              ; if (result is zero) then branch
    RTS                                                 ; the line is all off screen, so return

.worthPlottingLine

    ; now we work out if the end point of the line is beyond the graphics window boundary.
    ; if so then we set the termination value to the edge of the graphics window.
    LDX .vduTempStoreDE                                 ; .vduTempStoreDE holds the dominant axis value (0 or 2)
    BEQ +                                               ; if (X=0) then branch (skip the next bit. Bits 0 and 1 of A are the error code results for the X axis)
    LSR                                                 ; } here the Y axis is dominant.
    LSR                                                 ; } shift the error code down twice so that the 'out of bounds' results for the Y axis are in bits 0 and 1
+
    AND #2                                              ; clear all but bit 1
                                                        ; NOTE: bit 1 is set if the end point is either:
                                                        ;                 to the right of the graphics window (when X axis is dominant)
                                                        ;             or above the top of the graphics window (when Y axis is dominant)
    BEQ +                                               ; if (bit 2 clear) then branch (end point is ok, NOT off to the right/above the graphics window)
    TXA                                                 ; } The end point is beyond the right or top of the graphics window, so we set
    ORA #4                                              ; } the termination variable (.vduPlotLineTerminationValue) to the edge of the screen.
                                                        ; } Set bit 3 of X
    TAX                                                 ; } (now X is the offset to
                                                        ; } .vduGraphicsWindowPixelsRightLow
                                                        ; } or .vduGraphicsWindowPixelsTopLow)
    JSR .copyTwoBytesWithinVDUVariablesToPlotLineTerminationValue ; copy final X or Y coordinate to the termination value
+
    JSR .plotLineInitializeVariables                    ; initialise variables (error term and absolute coordinates)

    ; work out which of four plot routines we want to use (calculate X = 0 to 3)
    LDA .vduTempStoreDE                                 ; get the dominant axis (0 or 2)
    EOR #2                                              ; EOR it with 2 to get the non-dominant axis (2 or 0)
    TAX                                                 ; X=A
    TAY                                                 ; Y=A
    LDA .vduPlotLineDeltaXHigh                          ; } compare high bytes of dX and dY
    EOR .vduPlotLineDeltaYHigh                          ; }
    BPL +                                               ; if (signs are the same) then branch
    INX                                                 ; X=X+1 (X is 3 or 1)
+

    ; remember the address of which routine to call
    LDA .vduRoutineBranchVectorAddressesLow,X           ; get address and store at .vduPlotLineRoutineLow/High
    STA .vduPlotLineRoutineLow                          ; routine 0 is for a dominant Y axis, and same signs of dX/dY       (.plotLineDominantYAxisSameSign)
    LDA .vduRoutineBranchVectorAddressesHigh,X          ; routine 1 is for a dominant Y axis, and different signs of dX/dY  (.plotLineDominantYAxisDifferentSign)
    STA .vduPlotLineRoutineHigh                         ; routine 2 is for a dominant X axis, and same signs of dX/dY       (.plotLineDominantXAxisSameSign)
                                                        ; routine 3 is for a dominant X axis, and different signs of dX/dY  (.plotLineDominantXAxisDifferentSign)

    LDA #127                                            ; } set dotted line flag.
    STA .vduPlotLinePlotDottedPixelFlag                 ; } 127 = draw a dot; 128 is skip.
    BIT .vduTempStoreDB                                 ; check bit 6 to see if current point is out of bounds
    BVS .currentPointIsOutOfBounds                      ; if (out of bounds) then branch

    ; get absolute distance to the graphics window edge
    LDA .vduGraphicsWindowBoundariesTable,X             ; get offset to graphics window boundary
    TAX                                                 ; X=offset to VDU variable for edge
                                                        ; of graphics window

    SEC                                                 ; }
    LDA .vduVariablesStart + 0,X                        ; }
    SBC .vduPlotLineCurrentPointXLow,Y                  ; } Y = non-dominant axis
    STA .vduTempStoreDA                                 ; } get distance to edge:
    LDA .vduVariablesStart + 1,X                        ; } graphics window boundary - current point
    SBC .vduPlotLineCurrentPointXHigh,Y                 ; }
    LDY .vduTempStoreDA                                 ; }
    TAX                                                 ; } XY = distance to window edge

    BPL +                                               ; if(distance is positive) then branch
    JSR .negateAY                                       ; negate AY: Make sure distance to edge
                                                        ; is positive (note A=X from above)
+
    TAX                                                 ; } XY = ABS(distance to window edge)

    ; add one to distance in XY
    INY                                                 ; }
    BNE +                                               ; } Increment XY
    INX                                                 ; }
+                                                       ; }
    TXA                                                 ; A = high byte

    BEQ +                                               ; if (A=0) then branch (not out of bounds)
    LDY #0                                              ; Y=0
+
    STY .vduTempStoreDF                                 ; .vduTempStoreDF = low byte of distance,
                                                        ; or zero if high byte is non-zero.
                                                        ; In other words: if this value is
                                                        ; one, then it's the last pixel.
    BEQ +                                               ; ALWAYs branch

.currentPointIsOutOfBounds
    TXA                                                 ; A = X (quadrant 0-3)
    LSR                                                 ; carry = signs differ
    ROR                                                 ; $80 = signs differ, $00 otherwise
    ORA #2                                              ; set bit one
    EOR .vduTempStoreDE                                 ; flip bit one of .vduTempStoreDE (dominant axis)
                                                        ; and flip bit 7 if signs differ
    STA .vduTempStoreDE                                 ; and store

    ; Now .vduTempStoreDE stores:
    ;
    ;   bit 7 = set if signs differ
    ;   bit 1 = set if X axis dominant
    ;
    ; this is used later in .plotLineContinuesOutOfBounds

+
    LDX #.vduPlotLineCurrentPointXLow - .vduVariablesStart  ; } set screen address variables
    JSR .setScreenAddress                                   ; } based on current point

    LDX .vduTempStoreDC                                 ; }
    BNE +                                               ; }
    DEC .vduTempStoreDD                                 ; } Decrement DC/DD
+                                                       ; }
    DEX                                                 ; } (we will store X later)

.plotLineLoop
    LDA .vduTempStoreDB                                 ; bit 7 set if dotted line; bit 6 set if out of bounds
    BEQ .writePointToScreen                             ; if (solid line in bounds) then branch (write to screen)
    BPL .plotLineCheckNowInBounds                       ; if (solid line, but not in bounds) then branch

    ; deal with dotted line
    BIT .vduPlotLinePlotDottedPixelFlag                 ; check top bit: 127 for a dot; 128 for a gap
    BPL +                                               ; if (dot should be drawn) then branch
    DEC .vduPlotLinePlotDottedPixelFlag                 ; decrement to 127
    BNE .postWritePointToScreen                         ; ALWAYs branch

+
    INC .vduPlotLinePlotDottedPixelFlag                 ; increment to 128
    ASL                                                 ; push bit 6 (out of bounds flag) into bit 7
    BPL .writePointToScreen                             ; if (not out of bounds) then branch

.plotLineCheckNowInBounds
    STX .vduTempStoreDC                                 ; store/remember X
    LDX #.vduPlotLineCurrentPointXLow - .vduVariablesStart  ;
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; check in bounds (and if so calculate screen addresses)
    LDX .vduTempStoreDC                                 ; recall X

    ORA #0                                              ; recall flags for A
    BNE .postWritePointToScreen                         ; if (not in bounds) then branch

    ; At last, we get to actually draw a point
.writePointToScreen
    LDA .vduCurrentPlotByteMask                         ; byte mask for current graphics point
    AND .vduGraphicsColourByteOR                        ; and with graphics colour OR byte
    ORA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; or  with curent graphics cell line
    STA .vduTempStoreDA                                 ; store result
    LDA .vduGraphicsColourByteEOR                       ; same again with colour EOR byte
    AND .vduCurrentPlotByteMask                         ;
    EOR .vduTempStoreDA                                 ;
    STA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; then store it in current graphics row

.postWritePointToScreen
    SEC                                                 ; }
    LDA .vduPlotLineErrorTermLow                        ; }
    SBC .vduPlotLineAbsNonDominantAxisDeltaLow          ; }
    STA .vduPlotLineErrorTermLow                        ; } error_term = error_term - non-dominant axis delta
    LDA .vduPlotLineErrorTermHigh                       ; }
    SBC .vduPlotLineAbsNonDominantAxisDeltaHigh         ; }

    BCS +                                               ; if (error_term >= 0, i.e. error still ok) then branch (forwards)

    STA .vduTempStoreDA                                 ; }
    LDA .vduPlotLineErrorTermLow                        ; }
    ADC .vduPlotLineAbsDominantAxisDeltaLow             ; }
    STA .vduPlotLineErrorTermLow                        ; } error_term = error_term + dominant axis delta
    LDA .vduTempStoreDA                                 ; }
    ADC .vduPlotLineAbsDominantAxisDeltaHigh            ; }
    CLC                                                 ; }
+                                                       ; }
    STA .vduPlotLineErrorTermHigh                       ; }

    PHP                                                 ; store flags (carry clear if we will move in both axes)
    BCS .jumpVectorMoveOnePixelInDominantAxis           ; if (error term still ok) then branch
                                                        ; (indirectly
                                                        ;  to .plotLineMoveToNextColumnRight
                                                        ;  or .plotLineMoveToNextRowUp
                                                        ;  which moves along the dominant axis
                                                        ;  right or up one pixel)

    JMP (.vduPlotLineRoutineLow)                        ; jump to one of the next four line
                                                        ; routines below, which move the
                                                        ; sub-dominant axis one pixel in the
                                                        ; appropriate direction, and then
                                                        ; updates in the dominant axis: move
                                                        ; up or right one pixel.

; ***************************************************************************************
;
; Move up one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantXAxisSameSign                          ;
    DEY                                                 ; Y=Y-1 (moving one row up the screen)
    BPL .jumpVectorMoveOnePixelInDominantAxis           ; if (still in same character cell) then branch
    JSR .moveGraphicsCursorAddressUpOneCharacterCell    ; call subroutine to advance cursor address to the next cell up
.jumpVectorMoveOnePixelInDominantAxis
    JMP (.vduJumpVectorLow)                             ; jump to update dominant axis
                                                        ; moving up or right one pixel

; ***************************************************************************************
;
; Move down one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantXAxisDifferentSign                     ;
    INY                                                 ; Y=Y+1 (moving down one row in the character cell)
    CPY #8                                              ; }
    BNE .jumpVectorMoveOnePixelInDominantAxis           ; } if (still in the same character cell) then branch

    CLC                                                 ; }
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    ADC .vduBytesPerCharacterRowLow                     ; } add a row onto the graphic cursor address
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ; }
    ADC .vduBytesPerCharacterRowHigh                    ; }
    BPL +                                               ; if (result +ve) then branch (we are within screen RAM)
    SEC                                                 ; we are above screen RAM
    SBC .vduScreenSizeHighByte                          ; subtract screen memory size high
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store it (this wraps around point to screen RAM)
    LDY #0                                              ; Y=0
    JMP (.vduJumpVectorLow)                             ; jump to update dominant axis

; ***************************************************************************************
;
; Move right one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantYAxisSameSign
    LSR .vduCurrentPlotByteMask                             ; shift byte mask right
    BCC .jumpVectorMoveOnePixelInDominantAxis               ; if (still in the same byte) then branch
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask   ; update address and mask
    JMP (.vduJumpVectorLow)                                 ; jump to update dominant axis

; ***************************************************************************************
;
; Move left one pixel (in the non-dominant axis)
;
; This is moving in the non-dominant axis. Then jump to update the dominant axis.
;
; ***************************************************************************************
.plotLineDominantYAxisDifferentSign
    ASL .vduCurrentPlotByteMask                             ; shift byte mask left
    BCC .jumpVectorMoveOnePixelInDominantAxis               ; if (still in the same byte) then branch
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask    ; move graphics cursor address left and update mask value
    JMP (.vduJumpVectorLow)                                 ; jump to update dominant axis

; ***************************************************************************************
;
; Move up one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextRowUp
    DEY                                                 ; decrement row within character cell
    BPL .plotLineCheckForTermination                    ; if (still in cell) then branch
    JSR .moveGraphicsCursorAddressUpOneCharacterCell    ; move up one cell
    BNE .plotLineCheckForTermination                    ; ALWAYS branch

; ***************************************************************************************
;
; Move right one pixel (in the dominant axis)
;
; ***************************************************************************************
.plotLineMoveToNextColumnRight
    LSR .vduCurrentPlotByteMask                             ; shift byte mask
    BCC .plotLineCheckForTermination                        ; if (still in the same byte) branch
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask   ; update address and mask
    ; fall through...

; ***************************************************************************************
.plotLineCheckForTermination
    PLP                                                 ; pull flags (carry clear if we moved in both axes)
    INX                                                 ; X (also in .vduTempStoreDC) holds the
                                                        ; low byte of the loop counter
    BNE +                                               ; if (X > 0) then branch
    INC .vduTempStoreDD                                 ; .vduTempStoreDD holds the high byte
                                                        ; of the loop counter
    BEQ .plotLineFinished                               ; if (loop counter is zero) then branch (finished)
+
    BIT .vduTempStoreDB                                 ; top bit set if dotted line,
                                                        ; bit 6 set if out of bounds
    BVS .plotLineContinuesOutOfBounds                   ; if (out of bounds) then branch (line is not on screen yet)
    BCS .plotLineLoopLocal                              ; if (only moved in dominant axis) then branch (keep going)
    DEC .vduTempStoreDF                                 ; set to one only if it's the last pixel at the graphics window edge
    BNE .plotLineLoopLocal                              ; if (not at edge of window) then branch (keep going)

.plotLineFinished
    RTS                                                 ;

.plotLineContinuesOutOfBounds
    ; increment the actual pixel coordinate along then loop back
    LDA .vduTempStoreDE                                 ; A=.vduTempStoreDE
    STX .vduTempStoreDC                                 ; Remember X
    AND #2                                              ; clear all but bit 1
    TAX                                                 ; X=2 if X axis is dominant; 0 otherwise
    BCS ++                                              ; if (moved in dominant axis only) then branch
    BIT .vduTempStoreDE                                 ; check bit 7 of .vduTempStoreDE
    BMI +                                               ; if (signs of dx,dy differ) then branch (decrement value)
    INC .vduPlotLineCurrentPointXLow,X                  ; }
    BNE ++                                              ; } Increment .vduPlotLineCurrentPointX (Y axis dominant)
    INC .vduPlotLineCurrentPointXHigh,X                 ; }        or .vduPlotLineCurrentPointY (X axis dominant)
    BCC ++                                              ; } ALWAYs branch
+
    LDA .vduPlotLineCurrentPointXLow,X                  ; }
    BNE +                                               ; }
    DEC .vduPlotLineCurrentPointXHigh,X                 ; } Decrement .vduPlotLineCurrentPointX (Y axis dominant)
+                                                       ; }        or .vduPlotLineCurrentPointY (X axis dominant)
    DEC .vduPlotLineCurrentPointXLow,X                  ; }
++
    TXA                                                 ; }
    EOR #2                                              ; } invert bit 2 of X
    TAX                                                 ; } X=0 if X axis dominant; 2 if Y axis dominant

    INC .vduPlotLineCurrentPointXLow,X                  ; }
    BNE +                                               ; } increment .vduPlotLineCurrentPointX (X axis dominant)
    INC .vduPlotLineCurrentPointXHigh,X                 ; }        or .vduPlotLineCurrentPointY (Y axis dominant)
+
    LDX .vduTempStoreDC                                 ; Restore X

.plotLineLoopLocal
    JMP .plotLineLoop                                   ; jump back to continue plotting the line


; ***************************************************************************************
.moveGraphicsCursorAddressUpOneCharacterCell
    SEC                                                 ;
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    SBC .vduBytesPerCharacterRowLow                     ; }
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; } subtract number of bytes per line
    LDA .vduScreenAddressOfGraphicsCursorCellHigh       ; } from address
    SBC .vduBytesPerCharacterRowHigh                    ; }
    CMP .vduStartScreenAddressHighByte                  ; compare with bottom of screen memory
    BCS +                                               ; if (inside screen RAM) then branch
    ADC .vduScreenSizeHighByte                          ; add screen memory size to wrap it
                                                        ; around
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store in current address of graphics
                                                        ; cell top line
    LDY #7                                              ; Y=7
    RTS                                                 ;


; ***************************************************************************************
;
; Update the mask value, and move graphics cursor address on to next cell to the right
;
; On Entry:
;       Carry always SET
;
; ***************************************************************************************
.moveGraphicsCursorAddressTotheRightAndUpdateMask
    LDA .vduColourMaskLeft                              ; get current left colour mask
    STA .vduCurrentPlotByteMask                         ; store it
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; }
    ADC #7                                              ; } get current graphics cursor
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; } address and add 8 to move to
    BCC +                                               ; } next cell to the right
    INC .vduScreenAddressOfGraphicsCursorCellHigh       ; }
+
    RTS                                                 ;

; ***************************************************************************************
;
; Update the mask value, and move graphics cursor address on to previous cell to the left
;
; On Entry:
;       Carry always SET
;
; ***************************************************************************************
.moveGraphicsCursorAddressTotheLeftAndUpdateMask
    LDA .vduColourMaskRight                             ; get right colour mask
    STA .vduCurrentPlotByteMask                         ; store it
    LDA .vduScreenAddressOfGraphicsCursorCellLow        ; A=top line graphics cell low
    BNE +                                               ; if (not zero) then branch
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement high byte
+
    SBC #8                                              ; subtract 8 (carry is always SET)
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; and store in low byte
    RTS                                                 ;

; ***************************************************************************************
;
; Initialise delta values to (current cursor - params position)
;
; Called at the start of the line drawing, this function takes the current graphics cursor
; position, subtracts the desired graphics cursor position (two 16 bit values on the VDU
; queue), and stores the result in workspace A/B/C/D.
;
; ***************************************************************************************
.plotLineInitialiseDeltaValues
    LDY #.vduPlotLineDeltaXLow - .vduVariablesStart     ; destination: .vduPlotLineDeltaX/Y
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; source: four parameters on the VDU queue
                                                        ; and the graphics cursor position
    ; fall through...

; ***************************************************************************************
;
; Coordinate subtraction
;
; On Entry:
;       X = source offset into vdu variables      (we read offsets 0-7)
;       Y = destination offset into vdu variables (we write offsets 0-3)
;
; On Exit:
;   Stores 16 bit width and height based on the difference of four
;   16 bit source coordinates (left, bottom, right, top)
;       width  = right - left
;       height = top - bottom
;   i.e.
;       let src  = .vduVariablesStart + X
;       let dest = .vduVariablesStart + Y
;       dest[0,1] = src[4,5] - src[0,1] = width
;       dest[2,3] = src[6,7] - src[2,3] = height
;
;   A = height (high byte)
;
; ***************************************************************************************
.coordinateSubtraction
    JSR +                                               ; first calculate width
    INX                                                 ; }
    INX                                                 ; } add 2 to X and Y
    INY                                                 ; } i.e. move offsets on for Y values
    INY                                                 ; }
                                                        ; finally calculate height
+
    SEC                                                 ; set carry
    LDA .vduVariablesStart + 4,X                        ; subtract coordinates
    SBC .vduVariablesStart + 0,X                        ;
    STA .vduVariablesStart + 0,Y                        ;
    LDA .vduVariablesStart + 5,X                        ;
    SBC .vduVariablesStart + 1,X                        ;
    STA .vduVariablesStart + 1,Y                        ;
    RTS                                                 ;

; ***************************************************************************************
;
; Initialise line drawing variables
;
; Swaps the delta coordinates to make the non-dominant axis first. Stores absolute values of
; the deltas in .vduPlotLineAbsNonDominantAxisDeltaLow/High
;        and in .vduPlotLineAbsDominantAxisDeltaLow/High
; Initialises the loop counter (-ve of the number of pixels to draw along the dominant axis)
; Initialises the error term.
;
; In steps:
;   1. Make sure the dominant axis is stored second, by swapping coordinates if needed.
;   2. Both coordinates are then made positive and stored in:
;           .vduPlotLineAbsNonDominantAxisDeltaLow/High
;           .vduPlotLineAbsDominantAxisDeltaLow/High
;   3. .vduTempStoreDC/DD stores the negative of the number of steps to take along the dominant axis.
;   4. .vduPlotLineErrorTermLow/High stores half .vduPlotLineAbsDominantAxisDelta. This is the error variable.
;
; On Entry:
;       The original signed (dX, dY) delta values are stored at:
;           (.vduPlotLineDeltaXLow/High, .vduPlotLineDeltaYLow/High)
;
; On Exit:
;       .vduPlotLineAbsNonDominantAxisDeltaLow/High initialised
;       .vduPlotLineAbsDominantAxisDeltaLow/High initialised
;       .vduPlotLineErrorTermLow/High initialised
;
; ***************************************************************************************
.plotLineInitializeVariables
    LDA .vduTempStoreDE                                 ; get the dominant axis (0 or 2)
    BNE +                                               ; if (Y axis is dominant) then branch
    LDX #.vduPlotLineDeltaXLow - .vduVariablesStart     ; X is workspace A
    LDY #.vduPlotLineDeltaYLow - .vduVariablesStart     ; Y is workspace C
    JSR .exchangeTwoVDUBytes                            ; exchange the X and Y variables.
                                                        ; So the dominant axis is now the
                                                        ; first coordinate.
+
    LDX #.vduPlotLineDeltaXLow - .vduVariablesStart     ; source: .workspaceABCD (the start
                                                        ; coordinates)
    LDY #.vduPlotLineAbsNonDominantAxisDeltaLow - .vduVariablesStart ; destination: absolute
                                                        ; deltas in X and Y with the
                                                        ; non-dominant axis first
    JSR .copyFourBytesWithinVDUVariables                ; copy four bytes
    SEC                                                 ; set carry
    LDX .vduTempStoreDE                                 ; get the dominant axis (0 or 2)
    LDA .vduPlotLineTerminationValueLow                 ; }
    SBC .vduPlotLineCurrentPointXLow,X                  ; }     AY = .vduPlotLineTerminationValue - .vduPlotLineCurrentPointX or Y
    TAY                                                 ; } ie. AY = finalPoint - start point (in dominant axis)
    LDA .vduPlotLineTerminationValueHigh                ; }
    SBC .vduPlotLineCurrentPointXHigh,X                 ; }
    BMI +                                               ; if (startPoint > finalPoint) then branch
    JSR .negateAY                                       ; negate value stored in A and Y
+
    STA .vduTempStoreDD                                 ; store high byte of negative value     } this is the -ve of the number of steps we
    STY .vduTempStoreDC                                 ; store low byte of negative value      } need to take when plotting the line.
    LDX #.vduPlotLineErrorTermLow - .vduVariablesStart  ;

; fall through to do:
;   .vduPlotLineAbsDominantAxisDelta    = ABS(.vduPlotLineAbsDominantAxisDelta)
;   .vduPlotLineAbsNonDominantAxisDelta = ABS(.vduPlotLineAbsNonDominantAxisDelta)
;   .vduPlotLineErrorTerm               = .vduPlotLineAbsDominantAxisDelta / 2

; fall through...

; ***************************************************************************************
;
; Line Initialisation
;
; This is used in both line drawing and triangle filling to initialise the variables needed
; to track along the edge. Sets the deltas to absolute values, and initialises an error
; term to half the absolute delta in Y.
;
;   Let src  = .vduVariablesStart + X
;   src[4,5] = ABS(src[4,5])
;   src[2,3] = ABS(src[2,3])
;   src[0,1] = src[4,5] / 2
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;
; On Exit:
;       AY = absolute value of src[2,3]
;
; ***************************************************************************************
.lineInitialisation
    JSR .absoluteValue                                  ; make src[4,5] positive
    LSR                                                 ; }
    STA .vduVariablesStart + 1,X                        ; }
    TYA                                                 ; } src[0,1] = src[4,5] / 2
    ROR                                                 ; }
    STA .vduVariablesStart,X                            ; }
    DEX                                                 ; point to src[0,1]
    DEX                                                 ; and fall through to make src[2,3] positive
    ; fall through...

; ***************************************************************************************
;
; Absolute value
;
; Make sure that the 16 bit coordinate at (vduVariablesStart + 4 + X)
; is not negative, by negating it if necessary.
;
; On Entry:
;       X is offset to vdu variable i.e.:
;       (vduVariablesStart + 4 + X) has the low byte of the coordinate
;       (vduVariablesStart + 5 + X) has the high byte of the coordinate
;
; On Exit:
;       A is the high byte of the result (also stored in .vduVariablesStart + 5 + X)
;       Y is the low byte of the result  (also stored in .vduVariablesStart + 4 + X)
;       X is preserved
;
; ***************************************************************************************
.absoluteValue
    LDY .vduVariablesStart + 4,X                        ;
    LDA .vduVariablesStart + 5,X                        ;
    BPL +                                               ; if (A is +ve) then branch (return)
    JSR .negateAY                                       ; negate AY
    STA .vduVariablesStart + 5,X                        ; store back again
    PHA                                                 ;
    TYA                                                 ;
    STA .vduVariablesStart + 4,X                        ;
    PLA                                                 ; get back A
+
    RTS                                                 ;

; ***************************************************************************************
;
; Copy eight bytes (four coordinates) of VDU variables
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyEightBytesWithinVDUVariables
    LDA #8                                              ; A = 8
    BNE .copyABytesWithinVDUVariables                   ; ALWAYS branch - copy 8 bytes

; ***************************************************************************************
; On Entry:
;       X = source (offset from .vduVariablesStart)
.copyTwoBytesWithinVDUVariablesToPlotLineTerminationValue
    LDY #.vduPlotLineTerminationValueLow - .vduVariablesStart ; Y = destination offset from .vduVariablesStart
    ; fall through...

; ***************************************************************************************
;
; Copy two bytes (one coordinate) of VDU variables
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyTwoBytesWithinVDUVariables
    LDA #2                                              ; A = 2
    BNE .copyABytesWithinVDUVariables                   ; ALWAYS branch - copy 2 bytes

; ***************************************************************************************
.copyGraphicsCursorPixelPositionToWorkspaceABCD
    LDY #.vduWorkspaceA - .vduVariablesStart            ; destination = offset to workspaceA
    ; fall through...

; ***************************************************************************************
; On Entry:
;       Y = destination (offset from .vduVariablesStart)
.copyGraphicsCursorPixelPosition
    LDX #.vduGraphicsCursorPixelsXLow  - .vduVariablesStart     ; source = offset to graphics cursor position
    ; fall through...

; ***************************************************************************************
;
; Copy four bytes (e.g. one pair of coordinates) of VDU variables
;
; On Entry:
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyFourBytesWithinVDUVariables
    LDA #4                                              ; number of bytes to copy
    ; fall through...

; ***************************************************************************************
;
; Copy a number of bytes in VDU variables
;
; On Entry:
;       A = number of bytes to copy
;       X = source (offset from .vduVariablesStart)
;       Y = destination (offset from .vduVariablesStart)
;
; ***************************************************************************************
.copyABytesWithinVDUVariables
    STA .vduTempStoreDA                                 ; store A as a loop counter
-
    LDA .vduVariablesStart,X                            ; load value from source address
    STA .vduVariablesStart,Y                            ; store value in destination address
    INX                                                 ; move index forwards
    INY                                                 ; move index forwards
    DEC .vduTempStoreDA                                 ; decrement loop counter
    BNE -                                               ; loop back until done
    RTS                                                 ;


; ***************************************************************************************
;
; Negate the sixteen bit value in A and Y
;
; On Entry:
;       A = high byte
;       Y = low byte
;
; On Exit:
;       A = high byte of negated value
;       Y = low byte of negated value
;       Preserves X
;
; ***************************************************************************************
.negateAY
    PHA                                                 ; save A
    TYA                                                 ;
    EOR #$FF                                            ;
    TAY                                                 ; Y=255 - Y
    PLA                                                 ; restore A
    EOR #$FF                                            ; A=255 - A
    INY                                                 ; Y=Y+1 (effectively making Y = 256 - initialY)
    BNE +                                               ; if (Y != 0) then branch (exit)
    CLC                                                 ;
    ADC #1                                              ; A+=1
+
    RTS                                                 ;

; ***************************************************************************************
.checkPixelIsBackgroundColour
    JSR .checkParameterInBoundsAndSetScreenAddresses    ; check window boundaries and set up screen addresses
    BNE .outsideBoundaries                              ; if (outside) then branch
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get byte from current graphics cell
    EOR .vduBackgroundGraphicsColour                    ; compare with current background colour
    STA .vduTempStoreDA                                 ; store it
    RTS                                                 ;

; ***************************************************************************************
.outsideBoundaries
    PLA                                                 ; remove one return address from the
    PLA                                                 ; stack to early out of the lateral
                                                        ; fill
-
    INC .vduGraphicsCursorPixelsYLow                    ; increment current graphics cursor y pixel position
    JMP .setNextPixelPosition                           ; exit having pushed the cursor up one

; ***************************************************************************************
;
; Lateral fill left and right
;
; Fill to the left and right of the current parameter coordinate until a non-background
; colour is found. Fills in the foreground colour using the current GCOL mask settings.
;
; ***************************************************************************************
.lateralFillLeftRight
    JSR .checkPixelIsBackgroundColour                   ; check pixel is background colour
    AND .vduCurrentPlotByteMask                         ; check just the bits for the current pixel
    BNE -                                               ; if (non-background pixel found) then branch

    ; fill left
    LDX #0                                              ; X=0 (check width in pixels to the left)
    JSR .lateralFillGetWidthToWindowEdge                ; Find distance to edge of window:
                                                        ; On exit, X and .vduTempStoreDB=negated
                                                        ; distance to edge of window
    BEQ .lateralFillLeftDone                            ; if (zero width) then branch
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; Y = row within character cell
    ASL .vduCurrentPlotByteMask                         ; shift mask for next pixel left
    BCS .lateralFillLeftLoop                            ; if (next character cell left reached) then branch
    JSR .lateralFillLeftPartialByte                     ; fill the partial first byte
    BCC .lateralFillLeftDone                            ; if (finished) then branch

.lateralFillLeftLoop
    JSR .moveGraphicsCursorAddressTotheLeftAndUpdateMask ; move cursor left and reset mask
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get byte from screen
    EOR .vduBackgroundGraphicsColour                    ; EOR with background colour
    STA .vduTempStoreDA                                 ; and store
    BNE .lateralFillLeftNearlyDone                      ; if (not background colour) then branch

    ; found byte with background colour
    SEC                                                 ; set carry
    TXA                                                 ; A=X=negated distance to edge of window (low byte)
    ADC .vduPixelsPerByteMinusOne                       ; add pixels/byte (including carry)
    BCC +                                               ; if (carry clear) then branch
    INC .vduTempStoreDB                                 ; increment high byte of distance to left edge of window
    BPL .lateralFillLeftNearlyDone                      ; if (reached edge of window) then branch
+
    TAX                                                 ; X=A=negated distance to edge of window (low byte)

    ; plot a byte in the foreground colour using GCOL options
    JSR .plotByte                                       ; plot a byte

    ; loop back
    SEC                                                 ; set carry
    BCS .lateralFillLeftLoop                            ; ALWAYS branch (loop back)

; ***************************************************************************************
.lateralFillLeftNearlyDone
    JSR .lateralFillLeftPartialByte                     ; fill the final pixels in the last (leftmost byte) of the row

.lateralFillLeftDone
    LDY #0                                              ; Y=0
    JSR .lateralFillSetParamAtGivenDistanceFromEdge     ; Restore original position
    LDY #.vdu25ParameterXLow - .vduVariablesStart       ;    }
    LDX #.vduGraphicsCursorPixelsXLow - .vduVariablesStart ; } swap parameter with graphics cursor position
    JSR .exchangeFourBytes                              ;    }

    ; fill right
.lateralFillRight
    JSR .checkPixelIsBackgroundColour                   ; check screen pixel
    LDX #4                                              ; X=4 (right hand edge of graphics window)
    JSR .lateralFillGetWidthToWindowEdge                ; get distance to right hand edge of graphics window
    TXA                                                 ; }
    BNE +                                               ; }
    DEC .vduTempStoreDB                                 ; } subtract one from distance to right edge
+                                                       ; }
    DEX                                                 ; }

.lateralFillRightFirstByteLoop
    JSR .lateralFillRightPartialByte                    ;
    BCC .lateralFillRightDone                           ;

.lateralFillRightLoop
    JSR .moveGraphicsCursorAddressTotheRightAndUpdateMask ;
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get byte from graphics line
    EOR .vduBackgroundGraphicsColour                    ; EOR with background colour
    STA .vduTempStoreDA                                 ; and store it
    LDA .vduTempStoreDC                                 ;
    BNE .lateralFillRightFirstByteLoop                  ; if (A is not zero) then branch (loop back)

    LDA .vduTempStoreDA                                 ; A=.vduTempStoreDA
    BNE .lateralFillRightNearlyDone                     ; if (A is not zero) then branch

    ; found byte with background colour
    SEC                                                 ; }
    TXA                                                 ; }
    ADC .vduPixelsPerByteMinusOne                       ; }
    BCC +                                               ; }
    INC .vduTempStoreDB                                 ; } (X, .vduTempStoreDB) +=
                                                        ; } pixels per byte
    BPL .lateralFillRightNearlyDone                     ; }
+                                                       ; }
    TAX                                                 ; }

    ; plot a byte in the foreground colour using GCOL options
    JSR .plotByte                                       ; plot a byte

    SEC                                                 ; set carry
    BCS .lateralFillRightLoop                           ; ALWAYS branch (loop back)

; ***************************************************************************************
.lateralFillRightNearlyDone
    JSR .lateralFillRightPartialByte                    ;

.lateralFillRightDone
    LDY #4                                              ;
    JSR .lateralFillSetParamAtGivenDistanceFromEdge     ;
    ; fall through...

; ***************************************************************************************
.setNextPixelPosition
    JSR .plotMoveGraphicsCursorInAbsolutePixels         ; set graphics cursor position
    JMP .convertPixelGraphicsCoordinatesToExternal      ; scale positions

; ***************************************************************************************
.lateralFillRightPartialByte
    LDA .vduCurrentPlotByteMask                         ; get byte mask
    PHA                                                 ; save it
    CLC                                                 ; clear carry
    BCC .lateralFillRightGetMask                        ; ALWAYS branch

; ***************************************************************************************
.lateralFillRightGetMaskLoop
    PLA                                                 ; get back A
    INX                                                 ; X=X+1
    BNE +                                               ; if (not zero) then branch
    INC .vduTempStoreDB                                 ;
    BPL .lateralFillSaveMaskAndPlotPoint                ; if (+ve) then branch

+
    LSR .vduCurrentPlotByteMask                         ; shift mask
    BCS .lateralFillSaveMaskAndPlotPoint                ; if (carry set) then branch
    ORA .vduCurrentPlotByteMask                         ; OR with mask
    PHA                                                 ; save result
    ; fall through...

; ***************************************************************************************
.lateralFillRightGetMask
    LDA .vduCurrentPlotByteMask                         ; A=.vduCurrentPlotByteMask
    BIT .vduTempStoreDA                                 ; test bits of .vduTempStoreDA
    PHP                                                 ; }
    PLA                                                 ; }
    EOR .vduTempStoreDC                                 ; } flags = flags EOR .vduTempStoreDC
    PHA                                                 ; }
    PLP                                                 ; }
    BEQ .lateralFillRightGetMaskLoop                    ;
    PLA                                                 ;
    EOR .vduCurrentPlotByteMask                         ; A=A EOR .vduCurrentPlotByteMask (byte mask)

.lateralFillSaveMaskAndPlotPoint
    STA .vduCurrentPlotByteMask                         ; store it
    JMP .plotPointWithinBounds                          ; and display a pixel

; ***************************************************************************************
.lateralFillLeftPartialByte
    LDA #0                                              ; A=0
    CLC                                                 ; Clear carry
    BCC .lateralFillLeftGetMask                         ; ALWAYS branch

; ***************************************************************************************
.lateralFillLeftGetMaskLoop
    INX                                                 ; X=X+1
    BNE +                                               ; if (X is not zero) then branch
    INC .vduTempStoreDB                                 ; inc .vduTempStoreDB
    BPL .lateralFillSaveMaskAndPlotPoint                ; if (+ve) then branch
+
    ASL                                                 ; A=A*2
    BCS .lateralFillLeftGotMaskNowPlotPoint             ; if (C set) then branch

.lateralFillLeftGetMask
    ORA .vduCurrentPlotByteMask                         ; A=A OR (.vduCurrentPlotByteMask)
    BIT .vduTempStoreDA                                 ;
    BEQ .lateralFillLeftGetMaskLoop                     ;
    EOR .vduCurrentPlotByteMask                         ; A=A EOR .vduCurrentPlotByteMask
    LSR                                                 ; divide by 2
    BCC .lateralFillSaveMaskAndPlotPoint                ; if (carry clear) then branch

.lateralFillLeftGotMaskNowPlotPoint
    ROR                                                 ; A=A/2 (final step to get mask)
    SEC                                                 ; set carry
    BCS .lateralFillSaveMaskAndPlotPoint                ; ALWAYS branch

; ***************************************************************************************
;
; Get width of parameter point to graphics window edge
;
; On Entry:
;       X = 0 (left edge) or 4 (right edge)
;
; On Exit:
;       .vduTempStoreDB is the negation of the width (high byte)
;       X = Y =         the negation of the width (low byte)
;       A = 0 (and Z=0) if there is zero width
;
; ***************************************************************************************
.lateralFillGetWidthToWindowEdge
    LDA .vduGraphicsWindowPixelsLeftLow,X               ; }
    SEC                                                 ; }
    SBC .vdu25ParameterXLow                             ; }
    TAY                                                 ; } AY = window left/right - paramX
    LDA .vduGraphicsWindowPixelsLeftHigh,X              ; }
    SBC .vdu25ParameterXHigh                            ; }

    BMI +                                               ; }
    JSR .negateAY                                       ; } make sure AY is negative
+
    STA .vduTempStoreDB                                 ; store A (high coordinate)
    TYA                                                 ; A = low coordinate
    TAX                                                 ; X = low coordinate
    ORA .vduTempStoreDB                                 ; A = low OR high coordinate (checking for zero width?)
    RTS                                                 ;

; ***************************************************************************************
;
; Set parameter X coordinate to the given distance from the left/right edge of the window
;
; On Entry:
;       X, .vduTempStoreDB is negated distance to left/right edge of window
;       Y is 0 (left edge of graphics window)
;         or 4 (right edge of graphics window)
;
; ***************************************************************************************
.lateralFillSetParamAtGivenDistanceFromEdge
    STY .vduTempStoreDA                                 ; Y=.vduTempStoreDA
    TXA                                                 ; A=X
    TAY                                                 ; Y=A=X
    LDA .vduTempStoreDB                                 ; A=.vduTempStoreDB
    BMI +                                               ; if (-ve) then branch
    LDA #0                                              ; A=0

    ; at this point AY = width to add to edge of window
    ; but if we are looking at the left edge, then negate AY first
+
    LDX .vduTempStoreDA                                 ; X=.vduTempStoreDA
    BNE +                                               ; if (X is not zero) then branch
    JSR .negateAY                                       ; negate
+
    PHA                                                 ; }
    CLC                                                 ; }
    TYA                                                 ; }
    ADC .vduGraphicsWindowPixelsLeftLow,X               ; } paramX = AY + window left/right edge
    STA .vdu25ParameterXLow                             ; }
    PLA                                                 ; }
    ADC .vduGraphicsWindowPixelsLeftHigh,X              ; }
    STA .vdu25ParameterXHigh                            ; }
    RTS                                                 ;


; ***************************************************************************************
;
; OSWORD 13 - Read last two graphic cursor positions
;
; On Entry:
;       .oswordX/Y is the address of the eight bytes of parameters for the result
;
; On Exit:
;       The eight bytes at .oswordX/Y hold the result:
;           byte 0: Previous X (low byte)
;           byte 1: Previous X (high byte)
;           byte 2: Previous Y (low byte)
;           byte 3: Previous Y (high byte)
;           byte 4: Current X (low byte)
;           byte 5: Current X (high byte)
;           byte 6: Current Y (low byte)
;           byte 7: Current Y (high byte)
;
; ***************************************************************************************
.osword13EntryPoint
    LDA #3                                              ; A=3 (offset into oswordX block)
    JSR +                                               ;
    LDA #7                                              ; A=7 (offset into oswordX block)
+
    PHA                                                 ; Save A
    JSR .exchangeGraphicsCursorWithOldPosition          ; exchange old graphics cursor position with current
    JSR .convertPixelGraphicsCoordinatesToExternal      ; convert to external coordinates
    LDX #3                                              ; X=3
    PLA                                                 ; save A
    TAY                                                 ; Y=A
-
    LDA .vduGraphicsCursorPositionXLow,X                ; get graphics coordinate
    STA (.oswordX),Y                                    ; store it in OS buffer
    DEY                                                 ; decrement Y and X
    DEX                                                 ;
    BPL -                                               ; if (+ve) then branch (loop back)
    RTS                                                 ;


; ***************************************************************************************
;
; Fill triangle
;
; A filled triangle is drawn. It is drawn in rows from the bottom of the triangle to the top.
;
; Here we define the 'main line' as the edge of the triangle from the bottommost vertex
; to the topmost vertex. The other two edges are the lower and upper 'minor lines'.
;
; The triangle is drawn in two 'halves'. The first 'half' is for the rows of lower minor line,
; and the second 'half' is for the rows of upper minor line. See the diagram below.
;
; On Entry:
;       .vdu25ParameterLow/High             }
;       .vduGraphicsCursorPixels            } three points that define the triangle
;       .vduOldGraphicsCursorPixels         }
;
; ***************************************************************************************
.plotFillTriangle
    ; store variables
    LDX #.vdu25ParameterXLow - .vduVariablesStart              ; X = source: parameter
    LDY #.vduPlotTriStorageForCoordinates - .vduVariablesStart ; Y = destination: storage
    JSR .copyEightBytesWithinVDUVariables               ; remember the parameter position and
                                                        ; the current graphics cursor
                                                        ; position.

    ; sort the three points of the triangle into order vertically
    JSR .sortParameterPointAndOldPosition                     ; }
    LDX #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart ; }
    LDY #.vduGraphicsCursorPixelsXLow - .vduVariablesStart    ; } sort positions by Y
    JSR .sortCoordinatesXY                                    ; } coordinate
    JSR .sortParameterPointAndOldPosition                     ; }

    ; The three points of the triangle (now sorted from lowest to highest) are:
    ;
    ;                                               ##  <-.vduGraphicsCursorPixels
    ;                                             ###      /|\
    ;                                           ##  #       |
    ;                     upper minor line->  ##   #        |
    ;                                       ##     #        | second 'half' of triangle
    ;                                     ##      #         | to draw
    ;                                   ##        #         |
    ;                                 ##         #         \|/
    ; .vduOldGraphicsCursorPixels->  #           #         /|\
    ;                                 #         #           |
    ;                                 #         #  <-main   |
    ;                                  #       #     line   |
    ;                                  #       #            |
    ;               lower minor line->  #     #             | first 'half' of triangle
    ;                                   #     #             | to draw
    ;                                    #   #              |
    ;                                    #   #              |
    ;                                     # #               |
    ;                                     # #               |
    ;                                      #               \|/
    ;                                      #  <-.vdu25Parameter
    ;

    ; get the dX, dY for the main line
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; X = source (parameter and graphics
                                                        ;             cursor)
                                                        ;  offset 0,1,2,3 = parameter
                                                        ;  offset 4,5,6,7 = graphics cursor
    LDY #.vduPlotTriMainLineDeltaXLow - .vduVariablesStart ; Y = destination (main line delta)
    JSR .coordinateSubtraction                          ; maindelta = (graphics cursor-param)

    LDA .vduPlotTriMainLineDeltaXHigh                   ;
    STA .vduPlotTriMainLineXDirectionFlag               ; store high byte of delta X to
                                                        ; use as a flag when updating our
                                                        ; position.
                                                        ; See .fillTriangleUpdateLinePosition

    ; initialise variables for the main line
    LDX #.vduPlotTriMainLineErrorTermLow - .vduVariablesStart ;
    JSR .lineInitialisation                             ; Initialise variables for the main
                                                        ; line. This makes the deltas positive
                                                        ; and initialises the error term.

    ; copy .vdu25Parameter to current main edge point
    LDY #.vduPlotTriMainLineCurrentPointXLow - .vduVariablesStart ; }
    JSR .copyParameterPointToDestinationY                         ; } main edge point = parameter point

    ; swap graphics cursor points
    JSR .exchangeGraphicsCursorWithOldPosition          ;

    ; fill the bottom half of the triangle
    CLC                                                 ; clear carry
    JSR .plotFillTriangleHalf                           ; fill bottom 'half' of triangle

    ; swap graphics cursor points back
    JSR .exchangeGraphicsCursorWithOldPosition          ;

    ; swap parameter point with old graphics cursor
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ;
    JSR .exchangeOldGraphicsCursorPositionWithVariableX ;

    ; Now our triangle looks like this:
    ;                                               ##  <-.vduGraphicsCursorPixels
    ;                                             ###      /|\
    ;                                           ##  #       |
    ;                     upper minor line->  ##   #        |
    ;                                       ##     #        | second 'half' of triangle
    ;                                     ##      #         | to draw
    ;                                   ##        #         |
    ;                                 ##         #         \|/
    ;             .vdu25Parameter->  #############         /|\
    ;                                 ###########           |
    ;                                 ###########  <-main   |
    ;                                  #########     line   |
    ;                                  #########            |
    ;               lower minor line->  #######             | first 'half' of triangle
    ;                                   #######             | is filled
    ;                                    #####              |
    ;                                    #####              |
    ;                                     ###               |
    ;                                     ###               |
    ;                                      #               \|/
    ;                                      #  <-.vduOldGraphicsCursorPixels
    ;
    ; It is now half filled, and the parameters of the vertices have been swapped ready for
    ; filling the second half.

    ; fill the top half of the triangle
    SEC                                                 ; set carry
    JSR .plotFillTriangleHalf                           ; fill top 'half' of triangle

    ; restore parameter point and graphics cursor variables back to where they started.
    LDX #.vduPlotTriStorageForCoordinates - .vduVariablesStart ; X = source
    LDY #.vdu25ParameterXLow - .vduVariablesStart              ; Y = destination
    JSR .copyEightBytesWithinVDUVariables               ; restore original parameter position
                                                        ; and graphics cursor position

    ; move the graphics cursor to the new parameter point, and return
    JMP .plotMoveGraphicsCursorInAbsolutePixels         ;


; ***************************************************************************************
;
; Sort the parameter point and the old graphics cursor point, sorting by Y coordinate
;
; if (parameter point is higher or level with old graphics cursor) then swap points in place
;
; ***************************************************************************************
.sortParameterPointAndOldPosition
    LDX #.vdu25ParameterXLow - .vduVariablesStart               ; } Sort paramX and old
    LDY #.vduOldGraphicsCursorPixelsXLow - .vduVariablesStart   ; } graphics position X
    ; fall through...

; ***************************************************************************************
;
; Sort one point with another, sorting by Y coordinate
;
; given two pairs of coordinates (one indexed by register X the other by register Y), sort
; them by their Y coordinates (lowest first)
;
; if (point X is higher or level with point Y) then swap points in place
;
; ***************************************************************************************
.sortCoordinatesXY
    LDA .vduVariablesStart + 2,X                        ; Y coordinate low byte
    CMP .vduVariablesStart + 2,Y                        ; Y coordinate low byte
    LDA .vduVariablesStart + 3,X                        ; Y coordinate high byte
    SBC .vduVariablesStart + 3,Y                        ; Y coordinate high byte
    BMI .exit10                                         ; if (Y coordinates of variable indexed by Y > Y coordinate of variable indexed by X) then branch (return)
    JMP .exchangeFourBytes                              ; swap coordinates


; ***************************************************************************************
;
; OSBYTE 134 - Read text cursor position
;
; ***************************************************************************************
.osbyte134EntryPoint
    LDA .vduTextCursorXPosition                         ; read current text cursor X position
    SEC                                                 ; }
    SBC .vduTextWindowLeft                              ; } subtract text window left position
    TAX                                                 ; X = text cursor X - text window left
    LDA .vduTextCursorYPosition                         ; get current text cursor Y position
    SEC                                                 ; }
    SBC .vduTextWindowTop                               ; } subtract text window top position
    TAY                                                 ; Y = text cursor Y - text window top
.exit10
    RTS                                                 ;


; ***************************************************************************************
;
; Fill half a triangle
;
; Draws rows of a triangle from bottom to top following the main line and the minor line
; as edges, until we reach the top of the minor line. See .plotFillTriangle. The minor line
; starts at the parameter point and moves up the screen to the current graphics point.
;
; On Entry:
;       Carry clear = first half of triangle is being drawn
;       Carry set = second half of triangle is being drawn
;
; ***************************************************************************************
.plotFillTriangleHalf
    PHP                                                 ; store flags

    ; find the dX, dY for the minor line
    LDX #.vdu25ParameterXLow - .vduVariablesStart           ; X = src (offset 4=graphics cursor)
    LDY #.vduPlotTriMinorLineDeltaXLow - .vduVariablesStart ; Y = destination (minor delta)
    JSR .coordinateSubtraction                          ; minor delta = graphics cursor - param

    ; Get and store the sign of the delta in X, so we know which way to update in X later.
    ; See .fillTriangleUpdateLinePosition.
    LDA .vduPlotTriMinorLineDeltaXHigh                  ; get high byte of deltaX
    STA .vduPlotTriMinorLineXDirectionFlag              ; store as flag

    ; initialise the minor line variables:
    ;       .vduPlotTriMinorLineDeltaX = ABS(.vduPlotTriMinorLineDeltaX)
    ;       .vduPlotTriMinorLineDeltaY = ABS(.vduPlotTriMinorLineDeltaY)
    ;       .vduPlotTriMinorLineErrorTerm = .vduPlotTriMinorLineDeltaY / 2
    LDX #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart ;
    JSR .lineInitialisation

    ; initialise current point on the minor line
    LDY #.vduPlotTriMinorLineCurrentPointXLow - .vduVariablesStart ;
    JSR .copyParameterPointToDestinationY               ; current minor line point = parameter point

    ; calculate triangle fill 'height' = parameter point Y - graphics cursor height
    ; this is actually the negative of the height to fill, which we use as a loop counter
    SEC                                                 ; }
    LDA .vdu25ParameterYLow                             ; }
    SBC .vduGraphicsCursorPixelsYLow                    ; }
    STA .vduTriangleFillHeightLow                       ; }
    LDA .vdu25ParameterYHigh                            ; } height = paramY - cursorY
    SBC .vduGraphicsCursorPixelsYHigh                   ; }
    STA .vduTriangleFillHeightHigh                      ; }
    ORA .vduTriangleFillHeightLow                       ; check number of rows to draw
    BEQ +                                               ; if (no rows to draw) then branch (finish up)

    ; loop to fill each row (.vduTriangleFillHeight is the loop counter, counting up)
.plotFillTriangleHalfLoop
    JSR .fillRowLeftToRightBetweenMainAndMinorLines     ; fill one row

    ; update the minor line position
    LDX #.vduPlotTriMinorLineErrorTermLow - .vduVariablesStart  ;
    JSR .fillTriangleUpdateLinePosition                         ;

    ; update the main line position
    LDX #.vduPlotTriMainLineErrorTermLow - .vduVariablesStart   ;
    JSR .fillTriangleUpdateLinePosition                         ;

    ; increment the loop counter until we hit zero
    INC .vduTriangleFillHeightLow                       ; update loop counter (low)
    BNE .plotFillTriangleHalfLoop                       ; if (counter not done yet) then branch (loop back and do it again)
    INC .vduTriangleFillHeightHigh                      ; increment loop counter (high)
    BNE .plotFillTriangleHalfLoop                       ; if (counter not done yet) then branch (loop back and do it again)

    ; finish up
+
    PLP                                                 ; pull flags
    BCC .exit10                                         ; if (carry clear) then branch (exit)

    ; At this point carry is set (we are drawing the top half of the triangle). We draw the
    ; final row at top of the triangle...

.fillRowLeftToRightBetweenMainAndMinorLines
    LDX #.vduPlotTriMinorLineCurrentPointXLow - .vduVariablesStart  ;
    LDY #.vduPlotTriMainLineCurrentPointXLow - .vduVariablesStart   ;
    ; fall through...

; ***************************************************************************************
;
; Fill a single horizontal row
;
; Used as part of clearing the graphics window or filling a triangle.
;
; On Entry:
;       X = offset into VDU variables for one extreme graphics pixel X coordinate
;       Y = offset into VDU variables for the other extreme graphics pixel X coordinate
;
; ***************************************************************************************
.fillRow
    STX .vduTempStoreDE                                 ;
    LDA .vduVariablesStart,X                            ; }
    CMP .vduVariablesStart,Y                            ; }
    LDA .vduVariablesStart + 1,X                        ; } if (leftmost <= rightmost) then branch
    SBC .vduVariablesStart + 1,Y                        ; }
    BMI +                                               ; }

    TYA                                                 ; }
    LDY .vduTempStoreDE                                 ; }
    TAX                                                 ; } swap X and Y so (leftmost < rightmost)
    STX .vduTempStoreDE                                 ; }
+
    STY .vduTempStoreDF                                 ; .vduTempStoreDF=offset to leftmost coordinate
    LDA .vduVariablesStart,Y                            ;
    PHA                                                 ;
    LDA .vduVariablesStart + 1,Y                        ;
    PHA                                                 ; push graphics window left edge coordinate
    LDX .vduTempStoreDF                                    ; check leftmost coordinate
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds
    BEQ +                                               ; if (within bounds) then branch

    ; out of bounds. Work out what to do.
    CMP #2                                              ; }
    BNE .donePlottingPoints                             ; } if (reason for being out of bounds
                                                        ; } is not just that it's too far
                                                        ; } right) then branch (finish up)

    ; out of bounds (point is right of the right hand edge of the graphics window)
    LDX #.vduGraphicsWindowPixelsRightLow - .vduVariablesStart ; source = right edge of graphics window
    LDY .vduTempStoreDF                                 ; destination = leftmost pixel coordinate
    JSR .copyTwoBytesWithinVDUVariables                 ; copy coordinate
    LDX .vduTempStoreDF                                 ; X = offset to leftmost pixel coordinate
+
    JSR .setScreenAddress                               ; set a screen address
    LDX .vduTempStoreDE                                 ; X=offset to rightmost pixel X coordinate
    JSR .checkPointXIsWithinGraphicsWindow              ; check window bounds

    LSR                                                 ; A = reason for being offscreen / 2
                                                        ; (checks for offscreen to the right / up / down)
    BNE .donePlottingPoints                             ; if (point is offscreen to the right, up or down) then branch (finish up)
    BCC +                                               ; if (not outside bounds to the left of the graphics window) then branch

    ; out of bounds (point is left of the graphics window left edge)
    LDX #.vduGraphicsWindowPixelsLeftLow - .vduVariablesStart  ; outside the left edge, leftmost = left edge instead.
+
    LDY .vduTempStoreDF                                 ; Y = offset to leftmost pixel coordinate
    SEC                                                 ;
    LDA .vduVariablesStart,Y                            ; }
    SBC .vduVariablesStart,X                            ; }
    STA .vduTempStoreDC                                 ; } tempStoreDC/DD = width of row to fill (rightmost - leftmost)
    LDA .vduVariablesStart + 1,Y                        ; }
    SBC .vduVariablesStart + 1,X                        ; }
    STA .vduTempStoreDD                                 ; }

    ; First calculate leftmost byte to write
    LDA #0                                              ;
-
    ASL                                                 ; shift current mask left
    ORA .vduCurrentPlotByteMask                         ; OR in the mask for a pixel
    LDY .vduTempStoreDC                                 ; } get low byte (as decremented by .calculateLeftmostByte)
    BNE .calculateLeftmostByte                          ; } check to see if we are done yet (check if width = 0)
    DEC .vduTempStoreDD                                 ; } decrement high byte if needed
    BPL .calculateLeftmostByte                          ; } if (width > 0, i.e. not done yet) then branch

    ; we get here if width is now zero, i.e. the leftmost byte is all we needed to draw
    STA .vduCurrentPlotByteMask                         ;
    JSR .plotPointWithinBounds                          ; display final byte

.donePlottingPoints
    ; we get here when we are done drawing all the pixels
    LDX .vduTempStoreDF                                 ; restore X = offset to leftmost coordinate
    PLA                                                 ; pull A
    STA .vduVariablesStart + 1,X                        ; restore left edge of graphics window
    PLA                                                 ; pull A
    STA .vduVariablesStart,X                            ; restore left edge of graphics window
    RTS                                                 ;

; ***************************************************************************************
;
; Calculate leftmost byte
;
; ***************************************************************************************
.calculateLeftmostByte
    DEC .vduTempStoreDC                                 ; decrement width
    TAX                                                 ; check the pixel mask
    BPL -                                               ; loop back until mask has bit set in bit 7

    STA .vduCurrentPlotByteMask                         ; store the full mask
    JSR .plotPointWithinBounds                          ; display a point (write leftmost byte to screen)

    LDX .vduTempStoreDC                                 ; }
    INX                                                 ; } increment width (was decremented
    BNE +                                               ; } one too many times)
    INC .vduTempStoreDD                                 ; }

    ; we are going to write a line of completely filled bytes.
    ; first calculate the number of bytes we need to fill (= width in pixels / pixels per byte)
+
    TXA                                                 ; A = X = width low byte
    PHA                                                 ; Push width (low)
    LSR .vduTempStoreDD                                 ; }
    ROR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two
    LDY .vduPixelsPerByteMinusOne                       ; get number of pixels/byte
    CPY #3                                              ; check for four colour MODEs
    BEQ +                                               ; if (four colour MODE) then branch (only divide by 2 once more)
    BCC .finishedGettingByteCount                       ; if (>four colour mode, i.e. MODE 2) then branch

    ; two colour mode
    LSR .vduTempStoreDD                                 ; }
    ROR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two

    ; four colour mode
+
    LSR .vduTempStoreDD                                 ; }
    LSR                                                 ; } divide .vduTempStoreDD (high byte) and Accumulator (low byte) by two


    ; finished getting the number of bytes to fill. At this point the accumulator holds the
    ; number of filled bytes we need to draw
.finishedGettingByteCount
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; Y=line in current graphics cell containing current point
    TAX                                                 ; X=number of bytes to fill
    BEQ .finalByte                                      ; if (no full bytes to write) then branch (plot final byte)

    ; loop to fill all the complete bytes we can
.loopPlotBytes
    TYA                                                 ; }
    SEC                                                 ; }
    SBC #8                                              ; } Y=Y-8, move to next cell left
    TAY                                                 ; }

    BCS +                                               ;
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement high byte of current graphics cursor
+
    JSR .plotByte                                       ; display a filled byte
    DEX                                                 ;
    BNE .loopPlotBytes                                  ; if (more bytes to fill) then branch (loop back)

    ; now we may need to plot some pixels into the final byte
.finalByte
    PLA                                                 ; restore pixel width
    AND .vduPixelsPerByteMinusOne                       ; check modulo pixels per byte
    BEQ .donePlottingPoints                             ; if (no remainder, i.e. no more pixels to write) then branch
    TAX                                                 ; remainder = loop counter
    LDA #0                                              ; A=0

-
    ASL                                                 ; shift A
    ORA .vduColourMaskRight                             ; OR with right colour mask
    DEX                                                 ;
    BNE -                                               ; if (not done shifting the right colour mask) then branch (loop back)

    STA .vduCurrentPlotByteMask                         ; store as byte mask
    TYA                                                 ; }
    SEC                                                 ; }
    SBC #8                                              ; } Y=Y-8
    TAY                                                 ; }
    BCS +                                               ; if (carry set) then branch
    DEC .vduScreenAddressOfGraphicsCursorCellHigh       ; decrement byte of top line off current graphics cursor cell
+
    JSR .plotPointWithinBoundsAtY                       ; display final point
    JMP .donePlottingPoints                             ; jump to next point

; ***************************************************************************************
;
; Update one edge when filling a triangle
;
; Update the variables of one edge, looping if needed to move the position up by one row.
; We update either the 'main line' or the 'minor line'. See .plotFillTriangle.
;
; On Entry:
;       X = .vduPlotTriMainLineErrorTermLow  - .vduVariablesStart    to update the main edge
;       X = .vduPlotTriMinorLineErrorTermLow - .vduVariablesStart    to update the minor edge
;
; Offsets 0-10 from X are used in the code below and refer to:
;
;       0,1 = error term
;       2,3 = delta X
;       4,5 = delta Y
;       6,7 = current point X
;       8,9 = current point Y
;       10  = X direction flag (top bit set means decrement X, otherwise increment X)
;
; See .vduPlotTriMainLineErrorTermLow for the variables.
;
; ***************************************************************************************
.fillTriangleUpdateLinePosition
    INC .vduVariablesStart + 8,X                        ; }
    BNE +                                               ; } Increment current Y position
    INC .vduVariablesStart + 9,X                        ; }
+
    SEC                                                 ; }
    LDA .vduVariablesStart,X                            ; }
    SBC .vduVariablesStart + 2,X                        ; }
    STA .vduVariablesStart,X                            ; } error -= delta X
    LDA .vduVariablesStart + 1,X                        ; }
    SBC .vduVariablesStart + 3,X                        ; }
    STA .vduVariablesStart + 1,X                        ; }
    BPL .exit11                                         ; if (error >=0) then branch (exit)

.fillTriangleUpdatePositionLoop
    LDA .vduVariablesStart + 10,X                       ;
    BMI .fillTriangleMoveLeft                           ; if (X direction flag set) then branch

.fillTriangleMoveRight
    INC .vduVariablesStart + 6,X                        ; }
    BNE .updateErrorTerm                                ; } increment current X
    INC .vduVariablesStart + 7,X                        ; }
    JMP .updateErrorTerm                                ; jump forward

.fillTriangleMoveLeft
    LDA .vduVariablesStart + 6,X                        ; }
    BNE +                                               ; }
    DEC .vduVariablesStart + 7,X                        ; } decrement current X
+                                                       ; }
    DEC .vduVariablesStart + 6,X                        ; }

.updateErrorTerm
    CLC                                                 ; }
    LDA .vduVariablesStart,X                            ; }
    ADC .vduVariablesStart+4,X                          ; }
    STA .vduVariablesStart,X                            ; } error += deltaY
    LDA .vduVariablesStart+1,X                          ; }
    ADC .vduVariablesStart+5,X                          ; }
    STA .vduVariablesStart+1,X                          ; }
    BMI .fillTriangleUpdatePositionLoop                 ; if (still on same row) then branch (loop back)

.exit11
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 9: Cursor editing mode
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE 135 - Read character at text cursor position
;
; ***************************************************************************************
.osbyte135EntryPoint
    LDY .vduNumberOfLogicalColoursMinusOne              ; get number of logical colours for current MODE
    BNE .nonMODE7ReadCharacter                          ; if (MODE is not 7) then branch
    LDA (.vduWriteCursorScreenAddressLow),Y             ; read MODE 7 character from screen
    LDY #2                                              ; Y=2
-
    CMP .teletextCharacterConversionTable + 1,Y         ; compare with conversion table
    BNE +                                               ; if (not equal) then branch
    LDA .teletextCharacterConversionTable,Y             ; get previous byte from table
    DEY                                                 ; Y=Y-1
+
    DEY                                                 ; Y=Y-1
    BPL -                                               ; if (+ve) then branch (loop back and do it again)
.finishUpFX135
    LDY .vduCurrentScreenMODE                           ; Y = current screen MODE
    TAX                                                 ; X = character
    RTS                                                 ;

; ***************************************************************************************
.nonMODE7ReadCharacter
    JSR .readCharacterDefinitionMaskFromScreen          ; read from screen, making a one bit
                                                        ; mask of 8 bytes to match against
                                                        ; each character, in workspaceA-H
    LDX #.charSPACE                                     ; Start with the space character (loop counter)
.readCharLoop
    TXA                                                 ; Loop through each character in turn looking to see if it matches workspaceA-H
    PHA                                                 ; Save character
    JSR .getCharacterDefinitionAddress                  ; get character definition address for character A
    PLA                                                 ; recall character
    TAX                                                 ; move to X
-
    LDY #7                                              ; Y=7
--
    LDA .vduWorkspaceA,Y                                ; get byte in workspaceA-H copy
    CMP (.vduTempStoreDE),Y                             ; check against character definition
    BNE +                                               ; if (not the same) then branch (to skip to next character)
    DEY                                                 ; Y--
    BPL --                                              ; if (still non-negative) then branch (back to loop eight times, to check each row of the character)
    TXA                                                 ; At this point the character matches
    CPX #.charDELETE                                    ; but if it's the DELETE character then pretend we didn't match and carry on
    BNE .finishUpFX135                                  ; if (we are NOT the DELETE character) then branch (to finish up)
+
    INX                                                 ; no match on this character so increment to next character
    LDA .vduTempStoreDE                                 ; }
    CLC                                                 ; } Add 8 to address of character definition to move on to the next character
    ADC #8                                              ; } Affects low byte only as we check one page of characters at a time
    STA .vduTempStoreDE                                 ; }
    BNE -                                               ; if (we have not reached the end of the page) then branch (back to check the character)

    TXA                                                 ; A=X
    BNE .readCharLoop                                   ; if (character number not zero) then branch (loop back)
    BEQ .finishUpFX135                                  ; ALWAYS branch (finish up)

; ***************************************************************************************
;
; Read character from screen pixels
;
; Reads 8x8 cell of pixels from the screen. This will be compared against each of the
; character definitions to determine which character is on screen. This is for the
; cursor editing mode feature.
;
; ***************************************************************************************
.readCharacterDefinitionMaskFromScreen
    LDY #7                                              ; Y=7
.setupPatternLoop
    STY .vduTempStoreDA                                 ; .vduTempStoreDA=Y (loop counter)
    LDA #1                                              ; A=1
    STA .vduTempStoreDB                                 ; .vduTempStoreDB=A
--
    LDA .vduColourMaskLeft                              ; A=left colour mask
    STA .vduTempStoreDC                                 ; store in .vduTempStoreDC
    LDA (.vduWriteCursorScreenAddressLow),Y             ; get a byte from current text character
    EOR .vduBackgroundTextColour                        ; EOR with text background colour
    CLC                                                 ; clear carry
-
    BIT .vduTempStoreDC                                 ; and check bits of colour mask
    BEQ +                                               ; if (result = 0) then branch (this becomes a zero bit in our mask)
    SEC                                                 ; set carry. This becomes a one bit in our mask
+
    ROL .vduTempStoreDB                                 ; Rotate left and add the carry in the low bit
    BCS +                                               ; if (carry now set; bit 7 originally set) then branch (because we are done:
                                                        ;               the initial value of 1 has rotated through the 8 bits and into the carry)
    LSR .vduTempStoreDC                                 ; shift mask right one place for the next pixel
    BCC -                                               ; if (carry clear; nothing shifted off the left) then branch (loop back)
    TYA                                                 ; }
    ADC #7                                              ; } Y = Y + 8 (Carry is set, so adding 7 + carry = 8)
    TAY                                                 ; }
    BCC --                                              ; if (no overflow from the add) then branch (loop back, move on to the next cell to read from)
+
    LDY .vduTempStoreDA                                 ; read modified values into Y and A
    LDA .vduTempStoreDB                                 ;
    STA .vduWorkspaceA,Y                                ; store copy
    DEY                                                 ; and do it again
    BPL .setupPatternLoop                               ; until 8 bytes copied
    RTS                                                 ;

; ***************************************************************************************
;
; Read pixel
;
; On Entry:
;       A = VDU variable offset for the graphics coordinates to use.
;
; On Exit:
;       A = current colour at the coordinate specified OR
;       A = $FF if coordinate is out of bounds
; ***************************************************************************************
.readPixel
    PHA                                                 ; store A
    TAX                                                 ; X=A
    JSR .plotConvertExternalAbsoluteCoordinatesToPixels ; set up positional data
    PLA                                                 ; get back A
    TAX                                                 ; X=A
    JSR .checkPointXInBoundsAndSetScreenAddresses       ; set a screen address after checking for window bounds
    BNE ++                                              ; if (out of bounds) then branch (exit with A=$FF)
    LDA (.vduScreenAddressOfGraphicsCursorCellLow),Y    ; get row of current graphics cell
-
    ASL                                                 ; A=A*2, Carry=bit 7
    ROL .vduTempStoreDA                                 ; .vduTempStoreDA=.vduTempStoreDA+2 +Carry,
                                                        ; Carry=bit 7 of .vduTempStoreDA
    ASL .vduCurrentPlotByteMask                         ; byte mask=byte mask*2 + Carry
    PHP                                                 ; save flags
    BCS +                                               ; if (carry set) then branch
    LSR .vduTempStoreDA                                 ; restore .vduTempStoreDA with bit 7=0
+
    PLP                                                 ; pull flags
    BNE -                                               ; if (Z set) then branch
    LDA .vduTempStoreDA                                 ; A=.vduTempStoreDA AND number of colours in current MODE -1
    AND .vduNumberOfLogicalColoursMinusOne              ;
    RTS                                                 ;

++
    LDA #$FF                                            ; A=$FF
-
    RTS                                                 ;


; ***************************************************************************************
;
; Check the graphics point on the VDU queue is within the graphics window
;
; ***************************************************************************************
.checkParameterInBoundsAndSetScreenAddresses
    LDX #.vdu25ParameterXLow - .vduVariablesStart       ; X is the offset to the desired parameter for the point in graphics coordinates
    ; fall through...

; ***************************************************************************************
;
; Check the given point is within the graphics window
;
; Takes the graphics coordinates pointed to by X, checks whether they are in the bounds of
; the graphics window, and if so sets up screen addresses.
;
; On Entry:
;       X is the vdu variables offset to the graphics point to check
; On Exit:
;       .vduScreenAddressOfGraphicsCursorCellLow/High is the screen address
;       Y is the vertical offset within the character cell (0-7)
;       Z is clear (i.e. BNE will branch) if coordinates are outside the graphics area
; ***************************************************************************************
.checkPointXInBoundsAndSetScreenAddresses
    JSR .checkPointXIsWithinGraphicsWindow              ;
    BNE -                                               ; if (point is not in graphics window) then branch (exit)
.setScreenAddress
    LDA .vduGraphicsWindowPixelsBottomLow,X             ; read low byte of Y coordinate
    EOR #$FF                                            ; Flip the coordinates to be from the top of the screen
    TAY                                                 ; Remember in Y
    AND #7                                              ; A = row within a character cell
    STA .vduGraphicsCursorVerticalOffsetInCell          ; store row (0-7)
    TYA                                                 ; A=Y
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } divide by 8
    ASL                                                 ; Multiply by two to give the offset in the multiplication table
    TAY                                                 ; Y = offset into multiplication table
    LDA (.vduMultiplicationTableLow),Y                  ; Get high byte of offset from screen RAM start
    STA .vduTempStoreDA                                 ; store it
    INY                                                 ; Y=Y+1
    LDA (.vduMultiplicationTableLow),Y                  ; get low byte
    LDY .vduCurrentScreenMODEGroup                      ; check MODE group
    BEQ +                                               ; if (zero, i.e. MODEs 0,1,2) then branch (skip this next bit)
    LSR .vduTempStoreDA                                 ; } divide the offset by two
    ROR                                                 ; }
+
    ADC .vduScreenTopLeftAddressLow                     ; add the screen top left address (low)
    STA .vduScreenAddressOfGraphicsCursorCellLow        ; store it
    LDA .vduTempStoreDA                                 ; get high byte
    ADC .vduScreenTopLeftAddressHigh                    ; add with carry the screen top left address (high)
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store it
    LDA .vduGraphicsWindowPixelsLeftHigh,X              ;
    STA .vduTempStoreDA                                 ; store x coordinate of point (high)
    LDA .vduGraphicsWindowPixelsLeftLow,X               ; get x coordinate of point (low)
    PHA                                                 ; remember it
    AND .vduPixelsPerByteMinusOne                       ; get the horizontal X offset within the range of pixelsPerByte
    ADC .vduPixelsPerByteMinusOne                       ; add the pixels per byte minus one,
                                                        ; which offsets to (one more than) the
                                                        ; start of the MODE mask table for the
                                                        ; current MODE
    TAY                                                 ; Y=A
    LDA .sixteenColourMODEMaskTable - 1,Y               ; read byte mask
    STA .vduCurrentPlotByteMask                         ; store it
    PLA                                                 ; get back A
    LDY .vduPixelsPerByteMinusOne                       ; Y=number of pixels per byte minus one
    CPY #3                                              ; compare with 3
    BEQ +                                               ; if (MODE 1 or 5) then branch forward
    BCS ++                                              ; if (MODE 0 or 4) then branch forward
    ASL                                                 ; }
    ROL .vduTempStoreDA                                 ; } (A,.vduTempStoreDA) *= 2
+
    ASL                                                 ; }
    ROL .vduTempStoreDA                                 ; } (A,.vduTempStoreDA) *= 2
++
    AND #$F8                                            ; clear bits 0-2
    CLC                                                 ; clear carry
    ADC .vduScreenAddressOfGraphicsCursorCellLow        ; add A/.vduTempStoreDA to screen address
    STA .vduScreenAddressOfGraphicsCursorCellLow        ;
    LDA .vduTempStoreDA                                 ;
    ADC .vduScreenAddressOfGraphicsCursorCellHigh       ;
    BPL +                                               ; if (result +ve) then branch
    SEC                                                 ; set carry
    SBC .vduScreenSizeHighByte                          ; and subtract screen memory size making it wrap round
+
    STA .vduScreenAddressOfGraphicsCursorCellHigh       ; store it
    LDY .vduGraphicsCursorVerticalOffsetInCell          ; get line in graphics cell containing current graphics
.zeroAReturn
    LDA #0                                              ; A=0 to set Z flag (valid result)
    RTS                                                 ;

; ***************************************************************************************
.splitIntoTwoCursors
    PHA                                                 ; Push A
    LDA #$A0                                            ; A=$A0
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ; X=number of items in VDU queue
    BNE .pullAndReturn2                                 ; if (not 0) then branch
    BIT .vduStatusByte                                  ; check VDU status byte
    BNE .pullAndReturn2                                 ; if (either VDU is disabled, or plot to graphics cursor enabled) then branch (exit)
    BVS +                                               ; if (cursor editing mode enabled) then branch
    LDA .vduLastCursorStartRegisterValue                ; get CRTC register start setting
    AND #%10011111                                      ; clear bits 5 and 6
    ORA #%01000000                                      ; set bit 6 to modify last cursor size setting
    JSR .setCursorOnOrOff                               ; change cursor format
    LDX #.vduTextCursorXPosition - .vduVariablesStart          ; source = text cursor
    LDY #.vduTextInputCursorXCoordinate - .vduVariablesStart   ; destination = text input cursor
    JSR .copyTwoBytesWithinVDUVariables                 ; set text input cursor from text output cursor
    JSR .restoreWriteCursor                             ; modify character at cursor position
    LDA #2                                              ;
    JSR .setVDUStatusByteFlags                          ; bit 1 of VDU status is set to bar scrolling
+
    LDA #%10111111                                      ;
    JSR .clearVDUStatusByteFlags                        ; bit 6 of VDU status (separated cursors) is set to zero
    PLA                                                 ; Pull A
    AND #%01111111                                      ; clear high bit (7)
    JSR .vduChrEntryPoint                               ; call VDU routine
    LDA #%01000000                                      ; set bit six (separate cursors)
    JMP .setVDUStatusByteFlags                          ; set separated cursors and return

; ***************************************************************************************
.readCharacterFromScreenAndCursorRight
    LDA #%00100000                                      ; A=$20
    BIT .vduStatusByte                                  ;
    BVC .zeroAReturn                                    ; if (bit 6 clear; not in cursor editing mode) then branch (exit)
    BNE .zeroAReturn                                    ; if (bit 5 set; graphics cursor enabled) then branch (exit)
    JSR .osbyte135EntryPoint                            ; read a character from the screen
    BEQ .exit12                                         ; if (A = 0, i.e. failed to read) then branch (exit)
    PHA                                                 ; store A
    JSR .vdu9EntryPoint                                 ; perform cursor right
.pullAndReturn2
    PLA                                                 ; restore A
.exit12
    RTS                                                 ;

; ***************************************************************************************
; When editing a line with two cursors, pressing return terminates the edit.
; This clears the VDU status flags and restores the text cursor to normal.
.terminateEdit
    LDA #%10111101                                      ; }
    JSR .clearVDUStatusByteFlags                        ; } clear bits 2 and 6 of VDU status (page scrolling; separated cursors)
    JSR .setTextCursor                                  ; set text cursor (CRTC hardware)
    LDA #.charRETURN                                    ; continue processing as a RETURN character
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 132 - Read HIMEM (start of screen memory)
;
; ***************************************************************************************
.osbyte132EntryPoint
    LDX .vduCurrentScreenMODE                           ; get current screen MODE
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 133 - Read start of screen memory for given MODE
;
; ***************************************************************************************
.osbyte133EntryPoint
    TXA                                                 ; X=MODE number
    AND #7                                              ; keep it in range 0-7
    TAY                                                 ; Y=MODE number
    LDX .screenDisplayMemoryIndexTable,Y                ; X = get screen RAM size index
    LDA .screenMemoryStartHigh,X                        ; A = high byte of start address
    LDX #0                                              ; X = 0 (low byte of result)
    BIT .systemAvailableRAM                             ; get available RAM
    BMI .returnTheScreenAddress                         ; if (32k available) then branch
    AND #$3F                                            ; AND A with $3F to bring into memory range for a 16K BBC Micro
    CPY #4                                              ;
    BCS .returnTheScreenAddress                         ; if (MODE number >= 4) then branch (to return the value)
    TXA                                                 ; return zero (Model A can't display MODEs 0-3)
.returnTheScreenAddress
    TAY                                                 ; Y = high byte of screen address
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 10: Resets
;
; ***************************************************************************************
; ***************************************************************************************


; ***************************************************************************************
;
; Default vector table
;
; Default handlers for vectors, used at RESET time.
;
; ***************************************************************************************
.defaultVectorTable
    ;     value                     name           address      address label
    !word .badCommandError        ; USERV          $0200-1      .vectorUSERV
    !word .brkHandler             ; BRKV           $0202-3      .vectorBRKV
    !word .irq1Handler            ; IRQ1V          $0204-5      .vectorIRQ1V
    !word .irq2Handler            ; IRQ2V          $0206-7      .vectorIRQ2V
    !word .oscliEntryPoint        ; CLIV           $0208-9      .vectorCLIV
    !word .osbyteEntryPoint       ; BYTEV          $020A-B      .vectorBYTEV
    !word .oswordEntryPoint       ; WORDV          $020C-D      .vectorWORDV
    !word .oswrchEntryPoint       ; WRCHV          $020E-F      .vectorWRCHV
    !word .osrdchEntryPoint       ; RDCHV          $0210-1      .vectorRDCHV
.defaultFileSystemVectors
    !word .osfileEntryPoint       ; FILEV          $0212-3      .vectorFILEV
    !word .osargsEntryPoint       ; ARGSV          $0214-5      .vectorARGSV
    !word .osbgetEntryPoint       ; BGETV          $0216-7      .vectorBGETV
    !word .osbputEntryPoint       ; BPUTV          $0218-9      .vectorBPUTV
    !word .return                 ; GBPBV          $021A-B      .vectorGBPBV
    !word .osfindEntryPoint       ; FINDV          $021C-D      .vectorFINDV
    !word .fscEntryPoint          ; FSCV           $021E-F      .vectorFSCV
    !word .return                 ; EVNTV          $0220-1      .vectorEVNTV
    !word .return                 ; UPTV           $0222-3      .vectorUPTV
    !word .return                 ; NETV           $0224-5      .vectorNETV
    !word .return                 ; VDUV           $0226-7      .vectorVDUV
    !word .keyEntryPoint          ; KEYV           $0228-9      .vectorKEYV
    !word .insEntryPoint          ; INSBV          $022A-B      .vectorINSV
    !word .remEntryPoint          ; REMVB          $022C-D      .vectorREMV
    !word .cnpEntryPoint          ; CNPV           $022E-F      .vectorCNPV
    !word .return                 ; IND1V          $0230-1      .vectorIND1V
    !word .return                 ; IND2V          $0232-3      .vectorIND2V
    !word .return                 ; IND3V          $0234-5      .vectorIND3V
.defaultVectorTableEnd

; ***************************************************************************************
;
; MOS Variables Default Values
;
; Read/written by OSBYTEs 166-252
;
; ***************************************************************************************

    !word .mosVariablesMinus166   ; MOS variables address (add OSBYTE number)     $0236-7   *FX 166/7
    !word .extendedVectorSpace    ; Address of ROM pointer table                  $0238-9   *FX 168/9
    !word .romTypeTable           ; ROM information table address                 $023A-B   *FX 170/1
    !word .keyDataTable1 - 16     ; Key translation table address                 $023C-D   *FX 172/3
    !word .vduVariablesStart      ; VDU variables start                           $023E-F   *FX 174/5
    !byte 0                       ; vertical sync counter                         $0240     *FX 176
    !byte 0                       ; current input buffer number                   $0241     *FX 177
    !byte $FF                     ; keyboard interrupt enable flag ($FF=enabled)  $0242     *FX 178
    !byte 0                       ; primary OSHWM (default PAGE)                  $0243     *FX 179
    !byte 0                       ; current OSHWM (PAGE)                          $0244     *FX 180
    !byte 1                       ; RS-423 Mode                                   $0245     *FX 181
    !byte 0                       ; character definition explosion state          $0246     *FX 182
    !byte 0                       ; Filing system flag ROM=2; tape=0              $0247     *FX 183
    !byte 0                       ; current Video ULA control register            $0248     *FX 184
    !byte 0                       ; current palette setting                       $0249     *FX 185
    !byte 0                       ; number of ROM enabled at last BRK             $024A     *FX 186
    !byte $FF                     ; number of BASIC ROM                           $024B     *FX 187
    !byte 4                       ; current ADC channel number                    $024C     *FX 188
    !byte 4                       ; maximum ADC channel number                    $024D     *FX 189
    !byte 0                       ; ADC conversion type: 0 or $0C=12 bit; 8=8 Bit $024E     *FX 190
    !byte $FF                     ; RS-423 busy flag (bit 7 clear=busy)           $024F     *FX 191
    !byte $56                     ; curent ACIA control register setting          $0250     *FX 192
    !byte $19                     ; flash counter                                 $0251     *FX 193
    !byte $19                     ; mark period count                             $0252     *FX 194
    !byte $19                     ; space period count                            $0253     *FX 195
    !byte 50                      ; keyboard Auto-repeat delay                    $0254     *FX 196
    !byte 8                       ; keyboard Auto-repeat rate                     $0255     *FX 197
    !byte 0                       ; *EXEC file handle  (0 -not allocated)         $0256     *FX 198
    !byte 0                       ; *SPOOL file handle (0 -not allocated)         $0257     *FX 199
    !byte 0                       ; bit 0 Escape enable/disable                   $0258     *FX 200
                                  ; bit 1 BREAK normal/clear memory
    !byte 0                       ; Econet disable keyboard flag                  $0259     *FX 201
    !byte %00100000               ; keyboard status    bit 3=1 SHIFT pressed      $025A     *FX 202
                                  ;                    bit 4=0 CAPS LOCK
                                  ;                    bit 5=0 SHIFT LOCK
                                  ;                    bit 6=1 CTRL pressed
                                  ;                    bit 7=1 SHIFT enabled
    !byte 9                       ; buffer space left at buffer full signal       $025B     *FX 203
    !byte 0                       ; RS-423 input suppression flag                 $025C     *FX 204
    !byte 0                       ; cassette/RS-423 flag (0=tape, $40=RS-423)     $025D     *FX 205
    !byte 0                       ; Econet OS call interception flag (bit 7)      $025E     *FX 206
    !byte 0                       ; Econet OSRDCH interception flag (bit 7)       $025F     *FX 207
    !byte 0                       ; Econet OSWRCH interception flag (bit 7)       $0260     *FX 208
    !byte $50                     ; speech enable/disable flag ($50/$20)          $0261     *FX 209
    !byte 0                       ; sound output disable flag                     $0262     *FX 210
    !byte 3                       ; BELL channel number                           $0263     *FX 211
    !byte $90                     ; BELL amplitude (or envelope number)           $0264     *FX 212
    !byte 100                     ; BELL pitch (approx Treble C, 523.013Hz)       $0265     *FX 213
    !byte 6                       ; BELL duration (in 20ths of a second)          $0266     *FX 214
    !byte $81                     ; bit 7=0 ignore start up message               $0267     *FX 215
                                  ; bit 0=1 lock up if !BOOT error from *disc* and no language set
    !byte 0                       ; length of KEY string                          $0268     *FX 216
    !byte 0                       ; PRINT line counter                            $0269     *FX 217
    !byte 0                       ; 2s compliment of number of items in VDU queue $026A     *FX 218
    !byte 9                       ; TAB key value                                 $026B     *FX 219
    !byte $1B                     ; ESCAPE Character                              $026C     *FX 220

    ; The following four bytes are how characters are interpreted when placed into an input buffer

    !byte $01                     ; C0-CF                                         $026D     *FX 221
    !byte $D0                     ; D0-DF                                         $026E     *FX 222
    !byte $E0                     ; E0-EF                                         $026F     *FX 223
    !byte $F0                     ; F0-FF                                         $0270     *FX 224

    ; The next four bytes are the key status (soft key or codes) for:
    ;
    ;            function key
    ;      SHIFT-function key
    ;       CTRL-function key
    ; CTRL-SHIFT-function key
    ;
    ; 0 means ignore key
    ; 1 means expand as the normal soft key number
    ; 2-$FF means expand as the normal soft key number + this value

    !byte $01                     ; 80-8F                                         $0271     *FX 225
    !byte $80                     ; 90-9F                                         $0272     *FX 226
    !byte $90                     ; A0-AF                                         $0273     *FX 227
    !byte $00                     ; B0-BF                                         $0274     *FX 228

    !byte $00                     ; ESCAPE key status (0=ESC, 1=ASCII)            $0275     *FX 229
    !byte $00                     ; ESCAPE action                                 $0276     *FX 230
.allBitsSet
    !byte $FF                     ; User VIA 6522 Bit IRQ mask                    $0277     *FX 231
    !byte $FF                     ; ACIA 6850 Bit IRQ bit mask                    $0278     *FX 232
    !byte $FF                     ; System VIA 6522 IRQ bit mask                  $0279     *FX 233
    !byte $00                     ; Tube presence flag                            $027A     *FX 234
    !byte $00                     ; speech processor presence flag                $027B     *FX 235
    !byte $00                     ; character destination status                  $027C     *FX 236
    !byte $00                     ; cursor editing state                          $027D     *FX 237

.softResetHWM
; ************************* SOFT reset high water mark **********************************

    !byte $00                     ; unused                                        $027E     *FX 238
    !byte $00                     ; unused                                        $027F     *FX 239
    !byte $00                     ; country code (0=UK,1=US)                      $0280     *FX 240
    !byte $00                     ; user flag                                     $0281     *FX 241
    !byte $64                     ; serial ULA control register setting           $0282     *FX 242
    !byte $05                     ; current system clock store pointer            $0283     *FX 243
    !byte $FF                     ; soft key status (inconsistent)                $0284     *FX 244
    !byte $01                     ; printer destination (parallel printer)        $0285     *FX 245
    !byte 10                      ; printer ignore character (line feed)          $0286     *FX 246

.hardResetHWM
; ************************* HARD reset high water mark **********************************

    !byte $00                     ; user BREAK routine address JMP                $0287     *FX 247
    !byte $00                     ; user BREAK routine address low                $0288     *FX 248
    !byte $00                     ; user BREAK routine address high               $0289     *FX 249
    !byte $00                     ; unused                                        $028A     *FX 250
    !byte $00                     ; unused                                        $028B     *FX 251
    !byte $FF                     ; current language ROM number                   $028C     *FX 252

.powerOnResetHWM
; ********************** RESET High Water mark for Power on *****************************

; ***************************************************************************************
;
; Reset entry point
;
; Called on:
;       * Power on
;       * when a HARD BREAK occurs      (CTRL BREAK keys)
;       * when a SOFT BREAK occurs      (BREAK key)
;
; On Entry:
;       On power on: 6522 System VIA IER bits 0 to 6 will all be clear
;       On BREAK   : 6522 System VIA IER bits 0 to 6 at least one bit will be set
;
; This code runs through a list of steps:
;
;     * Store an RTI instruction at $0D00 (to stop executing any more NMI routines)
;     * Disable interrupts (stop executing any more IRQs)
;     * Clear decimal flag (decimal mode is never used within the OS. IRQ interrupts turn
;       it off while they run. Decimal mode must be off before calling any OS routine)
;     * Reset the stack pointer
;     * Clear RAM if needed (also detect amount of RAM present, either 16k or 32k, and
;       record this)
;     * Initialise System VIA registers
;     * Read keyboard
;     * Initialise OS vectors and variables ($0200 upwards, amount depending on type of
;       reset)
;     * Initialise JIM (which gives access to an optional 64k or more of Paged Memory)
;     * Enable some interrupts
;     * Clear sounds
;     * Initialise ROMs
;     * Initialise speech system if present
;     * Clear the screen
;     * Insert F10 key code into keyboard buffer if needed (implements effect of *KEY 10)
;     * Execute user boot code if present
;     * Set cassette options
;     * Initialise Tube
;     * Initialise ROMs (post Tube initialisation)
;     * Show 'BBC Computer 32K' message (or "16K", or no memory number on a SOFT BREAK)
;     * Initialise keyboard LEDs
;     * Select Filing System ROM
;     * Execute !BOOT if needed
;     * Find best language to enter, and enter it
;
; ***************************************************************************************
.resetEntryPoint
    LDA #$40                                            ; the numerical value of the RTI opcode
    STA .nmiEntryPoint                                  ; store RTI instruction at the start of the NMI routine

    SEI                                                 ; disable interrupts just in case
    CLD                                                 ; clear decimal flag
    LDX #$FF                                            ; reset stack to where it should be
    TXS                                                 ; ($01FF)
    LDA .systemVIAInterruptEnableRegister               ; read interupt enable register of the system VIA
    ASL                                                 ; shift bit 7 (reading IER always returns 1 in bit 7) into carry
    PHA                                                 ; save what's left (for use later when setting page 2: just before .setUpPage2)
    BEQ .clearRAM                                       ; if (power on) then branch
    LDA .escapeAndBreakEffect                           ; read BREAK Action flags (set by *FX200,n)
    LSR                                                 ; divide by 2 to get the break action
    CMP #1                                              ;
    BNE .setUpSystemVIA                                 ; if (break action says we don't need to clear RAM) then branch
    LSR                                                 ; set A=0 (since A=1 at this point)
    ; fall through...

; ***************************************************************************************
; Clears all of RAM except the first byte in each Page. This avoids overwriting the RTI instruction at $0D00.
.clearRAM
    LDX #4                                              ; start clearing memory from page 4 ($0400)
    STX $01                                             ; store a non-zero number at $01
    STA $00                                             ; store A (currently zero) at $00

    TAY                                                 ; and set Y (loop counter) to zero
-
    STA ($00),Y                                         ; clear RAM
    CMP $01                                             ; check high byte of address
    BEQ +                                               ; if (zero) then branch:

    ; This happens when we clear byte $4001 on a 16k machine the RAM memory addressing loops
    ; it around to write a zero into $0001. We are done at this point and branch out to avoid
    ; overwriting the rest of zero page.

    INY                                                 ; increment loop counter
    BNE -                                               ; if (not zero) then branch (loop back)
    INY                                                 ; increment again (Y=1) this avoids overwriting RTI instruction at $D00
    INX                                                 ; increment X
    INC $01                                             ; increment high byte of address
    BPL -                                               ; loop until A=$80 then exit

+
    STX .systemAvailableRAM                             ; writes marker for available RAM ($40=16k; $80=32k)
    STX .softKeyConsistencyFlag                         ; write non-zero value in soft key consistency flag
    ; fall through...

; ***************************************************************************************
.setUpSystemVIA
    LDX #%00001111                                      ; set System VIA PORT B to output on bits 0-3; input on bits 4-7
    STX .systemVIADataDirectionRegisterB                ;

; The next loop writes 14, 13, 12, 11, 10, 9, 8 in turn to System VIA Register B which:
;       - turns CAPS LOCK off;
;       - sets the hardware scroll address to $3000;
;       - enables keyboard auto scanning;
;       - enable read/write speech;
;       - disable sound;
;
; (See .systemVIARegisterB)
-
    DEX                                                 ; loop counter
    STX .systemVIARegisterB                             ; write system VIA register B
    CPX #9                                              ;
    BCS -                                               ; if (X>=9) then branch (loop back and do it again)
    ; fall through...

; ***************************************************************************************
;
; Read the keyboard 8 times with internal key numbers 9-1
;
; This reads the state of the CTRL key and the 'keyboard links', a set of DIP switches next
; to the keyboard. See .scanKeyboard for internal key numbers.
;
; These are rotated into the 8 bits of .interruptAccumulator for further processing
;
; ***************************************************************************************
    INX                                                 ; X=9 (loop counter)
-
    TXA                                                 ; Start of loop to interrogate keyboard
    JSR .interrogateKeyboard                            ; with A = 9...1 which reads keyboard links 9-2 and CTRL key
    CPX #$80                                            ; set carry if the 'key' or 'link' is 'pressed' or 'set'
    ROR .interruptAccumulator                           ; rotate carry into MSB into bit 7 of .interruptAccumulator
    TAX                                                 ; get back value of X for loop
    DEX                                                 ; decrement it
    BNE -                                               ; if (not zero) then branch (do loop again)

    ; At this point Carry(C) and .interruptAccumulator holds:
    ; C = }
    ; 0 = } screen MODE on startup
    ; 1 = }
    ; 2 = if clear reverse SHIFT BREAK action
    ; 3 = }
    ; 4 = } set disc drive timings
    ; 5 = not used
    ; 6 = not used
    ; 7 = CTRL key

    STX .lastResetType                                  ; set last reset type = 0
    ROL .interruptAccumulator                           ;

    ; At this point .interruptAccumulator holds keyboard links:
    ; 0 = }
    ; 1 = } screen MODE on startup
    ; 2 = }
    ; 3 = if clear reverse SHIFT BREAK action
    ; 4 = }
    ; 5 = } set disc drive timings
    ; 6 = not used
    ; 7 = not used
    ; C = CTRL key

    ; fall through...

; ***************************************************************************************
;
; Initialise keyboard lights, Work out what variables to reset
;
; ***************************************************************************************
    JSR .keyboardIndicators                             ; set LEDs. carry flag (CTRL key) is put into bit zero of A
    ROR                                                 ; put bit zero of A (CTRL key) into carry flag

    ; set up page 2 based on reset type
    LDX #<.softResetLWM                                 ; X = low water mark for setting OS variables (writes to range $200+X -> $2FF)
    LDY #.powerOnResetHWM - .defaultVectorTable         ; Y = high water mark for writing default values into OS variables (writes to range $200+Y -> $0200)
    PLA                                                 ; get back A (which is .systemVIAInterruptEnableRegister shifted left once)
    BEQ +                                               ; if (A=0) then branch (power on reset, with X=$9C Y=$8D)
    LDY #.softResetHWM - .defaultVectorTable            ; set value for soft reset HWM
    BCC .setUpPage2                                     ; if (soft reset) then branch
    LDY #.hardResetHWM - .defaultVectorTable            ; hard reset
    INC .lastResetType                                  ; reset type=1
+
    INC .lastResetType                                  ; 'power on' or hard reset
    LDA .interruptAccumulator                           ; get keyboard links set
    EOR #%11111111                                      ; invert all bits
    STA .startUpOptions                                 ; and record as start up options
    LDX #<.hardResetLWM                                 ;
    ; fall through...

; ***************************************************************************************
;
; Reset OS Variables
;
; On Entry:
;       .lastResetType is reset type:
;
;        0    Soft reset    X=<.softResetLWM    Y=.softResetHWM    - .defaultVectorTable
;        1    Power on      X=<.hardResetLWM    Y=.powerOnResetHWM - .defaultVectorTable
;        2    Hard reset    X=<.hardResetLWM    Y=.hardResetHWM    - .defaultVectorTable
;
;   - Set variables at $200+X and up to zero or 255
;   - Copy default values for variables into $0200+Y-1 and below from .defaultVectorTable
;
; ***************************************************************************************
.setUpPage2
    LDA #0                                              ; A=0
-
    CPX #$CE                                            ; this loop writes zero into the addresses in range $0290/C to $02CD...
    BCC +                                               ;
    LDA #$FF                                            ; ... and writes 255 into addresses in range $02CE to $02FF
+
    STA .page2Start,X                                   ;
    INX                                                 ;
    BNE -                                               ;
                                                        ; At this point A=$FF and X=0
    STA .userVIADataDirectionRegisterA                  ; set port A of user VIA to all outputs (printer out)
    TXA                                                 ; A=0
    LDX #$E2                                            ; loop counter
-
    STA $00,X                                           ; }
    INX                                                 ; } this loop stores zero in zero-page memory locations $E2 to $FF
    BNE -                                               ; }
    ; fall through...

; ***************************************************************************************
;
; Copy the default vectors and MOS variables
;
; Y is the loop counter (set up above, depending on boot type).
; ***************************************************************************************
-
    LDA .defaultVectorTable - 1,Y                       ; read data from default table+Y
    STA .page2Start - 1,Y                               ; write data to $0200+Y
    DEY                                                 ; decrement loop counter
    BNE -                                               ; branch back
    ; fall through...

; ***************************************************************************************
;
; Put a SPACE in the first key pressed variable
;
; ***************************************************************************************
    LDA #.internalKeyNumberSPACEBAR                     ; }
    STA .firstKeyPressedInternal                        ; } store SPACE in .firstKeyPressedInternal
    JSR .setupACIA                                      ; set up ACIA
                                                        ; X=0
    ; fall through...

; ***************************************************************************************
;
; Set system and user VIA registers
;
; ***************************************************************************************
    LDA #$7F                                            ; Disable interrupts (top bit clear and all others set means disable all interrupts)
    INX                                                 ; X=1
-
    STA .systemVIAInterruptFlagRegister,X               ; Set .systemVIAInterruptEnableRegister and .systemVIAInterruptFlagRegister
    STA .userVIAInterruptFlagRegister,X                 ; Set   .userVIAInterruptEnableRegister and   .userVIAInterruptFlagRegister
    DEX                                                 ; X--
    BPL -                                               ; loop back if X >= 0
    ; fall through...

; ***************************************************************************************
;
; Check for initialising JIM device
;
; ***************************************************************************************
    CLI                                                 ; briefly allow interrupts to clear anything pending
    SEI                                                 ; then disallow again (N.B. All VIA IRQs are disabled)
    BIT .interruptAccumulator                           ; check bit 6=1 (keyboard link 2)
    BVC +                                               ; if (keyboard link 2 clear) then branch over next instruction
    JSR .jimPagedEntryJumper                            ; This calls the JIM paged entry point (to initialise JIM based hardware)
+
    ; fall through...

; ***************************************************************************************
;
; Enable interrupts
;
; Initialises System VIA registers to enable a default set of interrupts:
;
;       The Vertical sync interrupt (50Hz)
;       The Analogue to Digital Converter complete interrupt
;       A timer interrupt for Speech
;       The 100Hz timer
;
; Initialises the 100Hz timer to $270E = 9998 uS (close enough for most purposes to 100Hz)
; Initialises other devices to default settings (light pen strobe, printer, user port)
;
; ***************************************************************************************
    LDX #%11110010                                      ; enable some System VIA interrupts:
    STX .systemVIAInterruptEnableRegister               ;   1   Vertical sync
                                                        ;   4   Analogue conversion finished
                                                        ;   5   Timer 2 counter (for speech)
                                                        ;   6   Timer 1 counter (100Hz)
    LDX #%00000100                                      ; set system VIA PCR
    STX .systemVIAPeripheralControlRegister             ; set the PCR:
                        ; CA1 has negative active edge       (vertical sync)
                        ; CA2 positive edges active on input (keyboard)
                        ; CB1 has negative active edge       (end of analogue conversion)
                        ; CB2 negative active edges on input (light pen strobe)

    LDA #%01100000                                      ; set system VIA ACR
    STA .systemVIAAuxiliaryControlRegister              ; Disable latches and shift register
                                                        ; (bits 0-4 = %00000)
                                                        ; timer 2 countdown (for Speech)
                                                        ; with pulses on input pin PB6
                                                        ; (bit 5 = %1)
                                                        ; timer 1 free-run mode (100Hz timer)
                                                        ; with PB7 disabled
                                                        ; (bit 6-7 = %01)

    LDA #$0E                                            ; set system VIA Timer 1 counter (Low)
    STA .systemVIATimer1LatchLow                        ; this becomes effective when Timer 1 Counter High set

    STA .userVIAPeripheralControlRegister               ; set user VIA PCR:
                        ; CA1 interrupt on -ve edge     (usually printer Acknowledge)
                        ; CA2 high output               (usually printer strobe)
                        ; CB1 interrupt on -ve edge     (user port)
                        ; CB2 negative edge             (user port)

    STA .adcStartConversionRegister                     ; Start analogue to digital conversion
                                                        ; A=%1110, meaning channel 2 of range 0-3,
                                                        ; twelve bit conversion.

    CMP .userVIAPeripheralControlRegister               ; check user VIA PCR
    BEQ +                                               ; if (printer present) then branch
    INC .userVIAIRQBitMask                              ; increment user VIA mask to 0 to ignore all user VIA interrupts
+
    LDA #$27                                            ; set Timer 1 (high byte) to $27.
                                                        ; this sets Timer 1 to $270E (=9998 uS)
    STA .systemVIATimer1LatchHigh                       ; so interrupt occurs approximately
                                                        ; every 100th of a second
    STA .systemVIATimer1CounterHigh                     ; set counter (high byte) which
                                                        ; actually starts the timer
    ; fall through...

; ***************************************************************************************
;
; Clear all sounds; Initialise the Serial ULA; Reset soft key definitions
;
; ***************************************************************************************
.resetClearAllSounds
    JSR .clearSoundChannels                             ; clear the sound channels

    ; Initialise the serial ULA
    LDA .serialULARegisterCopy                          ; read serial ULA control register (OS copy)
    AND #$7F                                            ; zero bit 7
    JSR .setSerialULADirectly                           ; and set up serial ULA

    ; reset function keys
    LDX .softKeyConsistencyFlag                         ; get soft key status flag
    BEQ .selectROMLoop                                  ; if (keys OK) then branch
    JSR .osbyte18EntryPoint                             ; reset function keys
    ; fall through...

; ***************************************************************************************
;
; Read ROM Types
;
; Check each sideways ROM (aka Paged ROM) and make a catalogue of their types X = 0...15
;
; Note that the OS itself is not a Paged ROM. As originally shipped, BASIC is the only
; Paged ROM present. The OS supports 16 Paged ROMS (0-15). There are only five slots in
; the original machine, so extra hardware is required to support more Paged ROMs.
;
; ROM Header
; ----------
; $8000 = language entry point      (.romLanguageEntry)
; $8003 = service entry point       (.romServiceEntry)
; $8006 = ROM Type byte (see below) (.romTypeByte)
; $8007 = copyright message         (.romCopyrightOffsetPointer)
; $8009 = offset to title string    (.romTitleString)
;
; ROM Type Byte
; -------------
; bits 0-3  Processor Type (see below)
; bit 4     not used (Electron only)
; bit 5     Language ROM has a relocation address provided. The ROM can only run on the second
;           processor when located at that address.
; bit 6     If set, this is a language ROM (and can be chosen on RESET). Otherwise this is
;           a utility or Filing System ROM.
; bit 7     ROM has a service entry. All ROMs should have this bit set. (The BASIC ROM is the
;           exception, it does not have this bit set).
;
; Processor Type
; --------------
; Language ROMs can be copied across to a second processor and run there. Processor codes
; have been assigned:
;
;  0 = 6502 BASIC
;  1 = 6502 Turbo code
;  2 = 6502 machine code
;  3 = 68000 code
;  4 = -
;  5 = -
;  6 = -
;  7 = PDP-11 code
;  8 = Z80 code
;  9 = 32016 code
; 10 = -
; 11 = 80186 code
; 12 = 80286 code
; 13 = ARM code
; 14 = -
; 15 = -
;
; ***************************************************************************************
.selectROMLoop
    JSR .selectROM                                      ; select ROM X
    LDX #3                                              ; set X to point to offset in table
    LDY .romCopyrightOffsetPointer                      ; get copyright offset from ROM
-
    LDA .romStartAddress,Y                              ; get first byte
    CMP .copyrightString,X                              ; compare it with table byte
    BNE .noCopyright                                    ; if (no copyright) then branch
    INY                                                 ; point to next byte in ROM
    DEX                                                 ; point to previous byte in ")C(",0 string
    BPL -                                               ; if (still +ve) then branch (go back to check next byte)
                                                        ; this point is reached if 4 bytes indicate valid ROM

    ; Check the first 1K of each ROM against higher priority ROMs to ensure that
    ; there are no matches. If a match is found, ignore the lower priority ROM
    LDX .currentlySelectedROM                           ; get RAM copy of ROM number in X
    LDY .currentlySelectedROM                           ; and Y

.nextROM
    INY                                                 ; increment Y to check
    CPY #16                                             ; check ROM number against 16
    BCS .romComparisonDone                              ; if (ROM number is 16 or more) then branch (done checking each ROM, store catalogue byte)
    TYA                                                 ; put Y in A
    EOR #$FF                                            ; invert it
    STA .tempStoreFA                                    ; and store at .tempStoreFA
    LDA #$7F                                            ; }
    STA .tempStoreFB                                    ; } store $7F at .tempStoreFB to get address $7FFF-Y

.nextByteInROM
    STY .romSelectRegister                              ; switch the ROM into the memory map
    LDA (.tempStoreFA),Y                                ; get byte
    STX .romSelectRegister                              ; switch the original ROM into the memory map
    CMP (.tempStoreFA),Y                                ; and compare with previous byte called
    BNE .nextROM                                        ; if (not the same) then branch (go back and do it again with next ROM)
    INC .tempStoreFA                                    ; increment .tempStoreFA to point to new location
    BNE .nextByteInROM                                  ; if (.tempStoreFA is not zero) then branch (check next byte)
    INC .tempStoreFB                                    ; increment tempStoreFB (high byte of address)
    LDA .tempStoreFB                                    ; load it
    CMP #$84                                            ; check if it has reached $84 = $80 + (4*256 bytes), i.e. 1k checked
    BCC .nextByteInROM                                  ; if (not checked 1k yet) then branch (check next 256 bytes)

.noCopyright
    LDX .currentlySelectedROM                           ; X=current ROM
    BPL +                                               ; if (+ve) then branch

.romComparisonDone
    LDA .romTypeByte                                    ; get rom type byte
    STA .romTypeTable,X                                 ; store it in catalogue
    AND #$8F                                            ; check for BASIC
    BNE +                                               ; if (not BASIC) then branch
    STX .basicROMNumber                                 ; store X at BASIC pointer
+
    INX                                                 ; increment X to point to next ROM
    CPX #16                                             ; check X against 16
    BCC .selectROMLoop                                  ; if (15 or less) then branch (back for next ROM)
    ; fall through...

; ***************************************************************************************
;
; Check for speech system
;
; ***************************************************************************************
    BIT .systemVIARegisterB                             ; check for speech system
    BMI .skipSpeech                                     ; if (bit 7 set) then branch (no speech system fitted)

    DEC .speechSystemPresentFlag                        ; .speechSystemPresentFlag set to $FF to indicate speech present

-
    LDY #$FF                                            ; Y=$FF (speech 'reset' command)
    JSR .osbyte159EntryPoint                            ; initialise speech generator
    DEX                                                 ; loop counter X from 16 to zero
    BNE -                                               ; branch back unless zero

    STX .systemVIATimer2CounterLow                      ;
    STX .systemVIATimer2CounterHigh                     ; clear Timer 2 to zero (used for Speech)
    ; fall through...

; ***************************************************************************************
;
; Initialise screen, execute any BOOT interception code
;
; ***************************************************************************************
.skipSpeech
    LDA .startUpOptions                                 ; get back start up options (bits 0-2 are MODE)
    JSR .initialiseScreenOnReset                        ; then jump to screen initialisation

    ; *KEY 10 facility (insert the *KEY 10 character code into the keyboard buffer)
    LDY #.charKEY10                                     ; }
    JSR .insertByteIntoKeyboardBuffer                   ; } enter $CA in keyboard buffer. This activates the *KEY 10 facility.

    ; execute any user BOOT interception code, if present (with carry clear)
    JSR .osbyte247EntryPoint                            ; call user boot routine if present, with carry clear
                                                        ; it's called again later with carry set

    JSR .setupTapeOptions                               ; set up cassette options [normally
                                                        ; at 300 baud, but if the user BOOT
                                                        ; interception code sets Z then
                                                        ; 1200 baud]
    ; fall through...

; ***************************************************************************************
;
; Initialise Tube
;
; ***************************************************************************************
    LDA #%10000001                                      ; test for Tube to FIFO buffer 1
    STA .tubeULAStatusRegister                          ;
    LDA .tubeULAStatusRegister                          ; test for Tube presence
    ROR                                                 ; put bit 0 into carry
    BCC +                                               ; if (no Tube present) then branch
    LDX #.romServiceCallTubeMainInitialisation          ; }
    JSR .osbyte143EntryPoint                            ; } initialise Tube system (issue ROM service call)
    BNE +                                               ; if (Tube not initialised) then branch
    DEC .tubePresentFlag                                ; set Tube flag to show it's active
    ; fall through...

; ***************************************************************************************
;
; Initialize ROMs, claim memory from OSHWM
;
; Note that OSBYTE 143 issues the service call to all ROMs in turn (in slot order 15-0).
;
; ***************************************************************************************
+
    LDY #>.initialOSHWM                                 ; set default value of PAGE: $0E00
    LDX #.romServiceCallAbsoluteWorkspaceClaim          ; issue claim absolute workspace call
    JSR .osbyte143EntryPoint                            ; via .osbyte143EntryPoint
    LDX #.romServiceCallPrivateWorkspaceClaim           ; send private workspace claim call
    JSR .osbyte143EntryPoint                            ; via .osbyte143EntryPoint
    STY .defaultOSHWM                                   ; set primary OSHWM
    STY .currentOSHWM                                   ; set current OSHWM
    LDX #.romServiceCallTubeSystemPostInitialisation    ; send to the Tube with the 'post
                                                        ; initialisation' reason (e.g.
                                                        ; second processor can decide to
                                                        ; explode the character set etc.)
    LDY .tubePresentFlag                                ; Y=$FF if Tube present else Y=0
    JSR .osbyte143EntryPoint                            ; and make call via .osbyte143EntryPoint
    ; fall through...

; ***************************************************************************************
;
; Show bootup message
;
; The startup message can only be suppressed if a ROM requests it on initialisation. Otherwise
; the .startupMessageSuppressionAndBootOptions variable was reset to its default value when
; resetting MOS variables above.
;
; ***************************************************************************************
    AND .startupMessageSuppressionAndBootOptions        ; check (result of post-init AND bit 7
                                                        ; of .startupMessageSuppressionAndBootOptions)
    BPL .skipStartupMessage                             ; if (result clear) then branch (skip
                                                        ; startup message)
    LDY #.bootMessage - .vduBaseAddress - 1             ;
    JSR .displayString                                  ; output 'BBC Computer ' message
    LDA .lastResetType                                  ; 0=soft reset, anything else continue
    BEQ .outputTwoNewlines                              ; if (soft reset) then branch (skip
                                                        ; forward)
    LDY #.bootMessageMemory32 - .vduBaseAddress - 1     ; set to point to 32k message
    BIT .systemAvailableRAM                             ; read available RAM ($40 = 16k
                                                        ; $80 = 32k)
    BMI +                                               ; if (32k RAM available) then branch
    LDY #.bootMessageMemory16 - .vduBaseAddress - 1     ; set to point to 16K message
+
    JSR .displayString                                  ; write message with '16K' or '32K'

.outputTwoNewlines
    LDY #.bootMessageEnding  - .vduBaseAddress - 1      ; and two newlines
    JSR .displayString                                  ;
    ; fall through...

; ***************************************************************************************
;
; Execute user BREAK intercept, set keyboard LEDs
;
; ***************************************************************************************
.skipStartupMessage
    SEC                                                 ;
    JSR .osbyte247EntryPoint                            ; call user break intercept if present
                                                        ; (with carry set)
    JSR .osbyte118EntryPoint                            ; set up keyboard LEDs to reflect
                                                        ; current keyboard status
    ; fall through...

; ***************************************************************************************
;
; Get !BOOT options, and ask ROMs to handle it
;
; Note that OSBYTE 143 issues the service call to all ROMs in turn (in slot order 15-0).
; This stops when one of the ROMs returns zero, indicating it will accept the auto-boot.
;
; ***************************************************************************************
    PHP                                                 ; remember flags
    PLA                                                 ; and recall flags in A = nvbdizc
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ;
    LSR                                                 ; A=0000nvbd
    EOR .startUpOptions                                 ; EOR with start up options, in
                                                        ; particular check bit 3 (if clear
                                                        ; reverse SHIFT BREAK action)
    AND #8                                              ; isolate bit 3 only
    TAY                                                 ; Y=0 (execute !BOOT) or 8 (don't
                                                        ; execute !BOOT)
    LDX #.romServiceCallAutoBoot                        ; X = rom service call for auto-boot
    JSR .osbyte143EntryPoint                            ; ask each ROM in turn if they want
                                                        ; to handle it
    BEQ .checkForFindingLanguageROM                     ; if (a ROM accepts this call) then
                                                        ; branch (to enter language ROM)
    TYA                                                 ; put result from ROM (Y register) in
                                                        ; A (to test if it's zero)
    BNE .setTapeFSAndFindLanguageROM                    ; if (Y != 0, i.e. no filing system
                                                        ; accepts it) then branch
    ; fall through...

; ***************************************************************************************
;
; Select the *ROM filing system
;
; ***************************************************************************************
    LDA #141                                            ; }
    JSR .osbyte141EntryPoint                            ; } select ROM filing system
    ; fall through...

; ***************************************************************************************
;
; Execute !BOOT
;
; ***************************************************************************************
    LDX #<.runBootString                                ;
    LDY #>.runBootString                                ;
    DEC .startupMessageSuppressionAndBootOptions        ; decrement boot options
    JSR .OSCLI                                          ; and execute */!BOOT
    INC .startupMessageSuppressionAndBootOptions        ; restore boot options
    BNE .checkForFindingLanguageROM                     ; if (not zero) then branch
    ; fall through...

; ***************************************************************************************
;
; Select TAPE filing system
;
; ***************************************************************************************
.setTapeFSAndFindLanguageROM
    LDA #0                                              ; }
    TAX                                                 ; } set tape filing system
    JSR .setTapeOrROMFS                                 ; }
    ; fall through...

; ***************************************************************************************
;
; Look for language ROM
;
; Looks for the 'best' language ROM (the language with the highest ROM slot number) and
; enters it
;
; ***************************************************************************************
.checkForFindingLanguageROM
    LDA .lastResetType                                  ; get last RESET Type
    BNE .findBestLanguageROM                            ; if (not soft reset) then branch

    LDX .languageROMNumber                              ; get current language ROM number
    BPL .resetAndEnterLanguageROM                       ; if (language available) then branch (initialise and enter ROM)

.findBestLanguageROM
    LDX #15                                             ; set pointer to highest available ROM
-
    LDA .romTypeTable,X                                 ; get ROM type from map
    ROL                                                 ; put bit 6 into bit 7
    BMI .resetAndEnterLanguageROM                       ; if (bit 7 set then ROM has a language entry) then branch (initialise and enter ROM)

    DEX                                                 ;
    BPL -                                               ; search for language until X=255
    ; fall through...

; ***************************************************************************************
;
; No language ROM present, so check for second processor
;
; If present, ask the second processor to copy an appropriate language ROM onto the second
; processor and run there. The Tube interface is implemented by the 'DNFS' ROM. Initialising
; the DNFS ROM copies Tube service code into the current language workspace at $0400-$07FF.
; Calling .tubeCopyLanguageROMToSecondProcessor ($0400) is therefore calling into the Tube
; service code, to find and copy the code of an appropriate language ROM into the second
; processor and run it there. The language ROM identifies the processor type it's designed
; for by the ROM header's processor type byte (See .selectROMLoop).
;
; ***************************************************************************************
    LDA #0                                              ; No language found.
    BIT .tubePresentFlag                                ; check if Tube is present
    BMI .tubeCopyLanguageROMToSecondProcessorLocal      ; if (Tube present) then branch (call into Tube code)
    ; fall through...

; ***************************************************************************************
.brkNoLanguageError
    BRK                                                 ;
    !byte $F9                                           ; error number
    !text "Language?",0                                 ; message

; ***************************************************************************************
.resetAndEnterLanguageROM
    CLC                                                 ;
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 142 - Enter language ROM (at $8000)
;
; On Entry:
;       X = ROM number
;       C set if OSBYTE call;
;       C clear if initialisation
;
; ***************************************************************************************
.osbyte142EntryPoint
    PHP                                                 ; save flags
    STX .languageROMNumber                              ; put X in current ROM number
    JSR .selectROM                                      ; select that ROM
    LDA #>(.romTitleString - 1)                         ; } AY=address of ROM title string
    LDY #<(.romTitleString - 1)                         ; }
    JSR .displayStringAY                                ; display text string held in ROM at .romTitleString
    STY .languageVersionString                          ; save Y on exit (end of language string)
    JSR .OSNEWL                                         ; two line feeds
    JSR .OSNEWL                                         ; are output
    PLP                                                 ; then get back flags
    LDA #1                                              ; A=1 required for language entry
    BIT .tubePresentFlag                                ; check if the Tube is present
    BMI .tubeCopyLanguageROMToSecondProcessorLocal      ; and branch if so
    JMP .romLanguageEntry                               ; enter language at $8000

; ***************************************************************************************
.tubeCopyLanguageROMToSecondProcessorLocal
    JMP .tubeCopyLanguageROMToSecondProcessor           ; enter Tube environment

; ***************************************************************************************
;
; Read a byte from a given ROM
;
; On Entry:
;       Y = ROM number
; $F6/$F7 = address
;
; ***************************************************************************************
.osrdrmEntryPoint
    LDX .currentlySelectedROM                           ; get current ROM number into X
    STY .currentlySelectedROM                           ; store new number
    STY .romSelectRegister                              ; switch the ROM into the memory map
    LDY #0                                              ; get current PHROM address
    LDA (.romAddressLow),Y                              ; and get byte
    ; fall through...

; ***************************************************************************************
;
; Select ROM
;
; On Entry:
;       X = ROM number (0-15)
;
; ***************************************************************************************
.selectROM
    STX .currentlySelectedROM                           ; RAM copy of current ROM
    STX .romSelectRegister                              ; switch the ROM into the memory map
    RTS                                                 ;



; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 11: Interrupt processing
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; IRQ entry point
;
; On Entry:
;       The stack contains status register (flags); high and low bytes of previous program
;       counter.
;
; IRQ and BRK causes execution here. If it was a BRK instruction we branch (see .brkRoutine)
; otherwise we call (indirectly via IRQ1V) the default IRQ1 handler (see .irq1Handler)
;
; ***************************************************************************************
.irqEntryPoint
    STA .interruptAccumulator                           ; save A
    PLA                                                 ; read flags
    PHA                                                 ; store flags again
    AND #%00010000                                      ; check BRK flag
    BNE .brkRoutine                                     ; if (BRK flag set) then branch (to BRK handler)
    JMP (.vectorIRQ1V)                                  ; jump to the IRQ1 vector (by default this will jump to .irq1Handler)

; ***************************************************************************************
.brkRoutine
    TXA                                                 ; }
    PHA                                                 ; } save X on stack
    TSX                                                 ; get stack pointer
    LDA .stackPage + 3,X                                ; get program counter low
    CLD                                                 ;
    SEC                                                 ; set carry
    SBC #1                                              ; subtract 1
    STA .brkAddressLow                                  ; and store
    LDA .stackPage + 4,X                                ; get high byte
    SBC #0                                              ; subtract 1 if necessary
    STA .brkAddressHigh                                 ; and store
    LDA .currentlySelectedROM                           ; get currently active ROM
    STA .romNumberActiveLastBRK                         ; and store it
    STX .stackPointerLastBRK                            ; store stack pointer
    LDX #.romServiceCallBreakInstruction                ; }
    JSR .osbyte143EntryPoint                            ; } issue ROM service call 6 (Break) to ROMs so they get a chance to respond.
                                                        ; at this point .brkAddressLow/High points to the byte after the BRK instruction.
                                                        ; ROMS may use BRK for their own purposes

    LDX .languageROMNumber                              ; get current language
    JSR .selectROM                                      ; and activate it
    PLA                                                 ; get back original value of X
    TAX                                                 ;
    LDA .interruptAccumulator                           ; get back original value of A
    CLI                                                 ; allow interrupts
    JMP (.vectorBRKV)                                   ; and JUMP via BRKV (normally into current language)


; ***************************************************************************************
;
; Default BRK handler
;
; This is the default BRK handler that is used at boot time. When BASIC or other language
; ROM starts it will set up it's own BRK handler instead.
;
; ***************************************************************************************
.brkHandler
    LDY #0                                              ; Y=0 to point to byte after BRK
    JSR .printMessage                                   ; print message

    LDA .startupMessageSuppressionAndBootOptions        ; } bit 0 set means: lock up machine if !BOOT errors from DISC (because e.g. no language found)
    ROR                                                 ; } rotate into carry
-
    BCS -                                               ; if (carry set) then branch (hang the machine!)

    JSR .OSNEWL                                         ; print two newlines
    JSR .OSNEWL                                         ;
    JMP .setTapeFSAndFindLanguageROM                    ; set tape filing system before
                                                        ; entering current language

; ***************************************************************************************
.rs423Handler
    SEC                                                 ; set carry
    ROR .rs423ReadyFlag                                 ; set RS-423 ready
    BIT .rs423ControlRegisterCopy                       ; check bit 7 of current ACIA control register (aka 'CR7' - ACIA interrupts enabled flag)
    BPL .rs423SetRequestToSendInactive                  ; if (ACIA interrupts disabled) then branch
    JSR .getRS423InputBufferFreeBytes                   ; call subroutine to check if serial buffer is full
    LDX #0                                              ; set X to the value (zero) which will clear bit 5 and 6 of ACIA control register
                                                        ; (aka 'CR5' and 'CR6' on the ACIA 6850 datasheet)
                                                        ; which means set the 'Request To Send' pin low and transmit interrupt disabled.
                                                        ; this is the active state.
    BCS .rs423BufferSpaceOK                             ; if (buffer has enough free space) then branch

.rs423SetRequestToSendInactive
    LDX #%01000000                                      ; set X to value which will clear bit 5 and set bit 6 of ACIA control register
                                                        ; (aka CR5 and CR6 on the ACIA 6850 datasheet)
                                                        ; which means set the 'Request To Send' pin high and transmit interrupt disabled.
                                                        ; this is the inactive state.
.rs423BufferSpaceOK
    JMP .writeToACIARequestToSend                       ; write to 'Request To Send' value in ACIA

; ***************************************************************************************
.readFromRS423
    LDY .acia6850DataRegister                           ; read serial data from ACIA
    AND #$3A                                            ; AND %0011 1010
    BNE .rs423ErrorDetected                             ; if (not zero) then branch
    LDX .rs423InputSuppressionFlag                      ; read RS-423 input suppression flag
    BNE +                                               ; if (RS-423 input suppressed) then branch (return)
    INX                                                 ; X=1
    JSR .osbyte153EntryPoint                            ; put byte in RS-423 input buffer
    JSR .getRS423InputBufferFreeBytes                   ; count buffer
    BCC .rs423SetRequestToSendInactive                  ; if (buffer is low on free space) then branch back (to make 'Request To Send' inactive)
+
    RTS                                                 ;

; ***************************************************************************************
;
; IRQ1 default handler
;
; When a hardware device generates an IRQ, this IRQ1 handler is executed (as the default
; handler, see .irqEntryPoint). After saving registers and a suitable return address on
; the stack, we check three hardware devices in turn, to see what needs attention:
;
;  1. Check for ACIA interrupt (see .irq1CheckACIA)
;       1a. updates RS-423 or Cassette then exit
;  2. Check for System VIA interrupt (see .irq1CheckSystemVIA)
;       2a. If VSYNC then update:
;               vsync counter
;               RS-423 counter
;               flashing colours
;               then exit
;       2b. If Timer 2 times out (Speech timer) (see .irq1CheckSystemVIASpeech)
;               update speech system (send speech data from speech buffer as needed)
;               then exit
;       2c. If Timer 1 times out (100Hz timer) (see .irq1CheckSystemVIA100HzTimer)
;           then update:
;               the clock
;               the countdown timer event
;               the INKEY timeout counter
;               sound
;               speech
;               ACIA
;               printer
;               keyboard
;               ADC conversion
;               then exit
;  3. Check for User VIA interrupt (see .irq1CheckUserVIA)
;       3a. updates a parallel printer then exit
;
;  Unrecognised interrupts are passed on to IRQ2V, allowing user code to process it.
;
; ***************************************************************************************
.irq1Handler
    CLD                                                 ; clear decimal flag
    LDA .interruptAccumulator                           ; }
    PHA                                                 ; }
    TXA                                                 ; } push original A,X,Y register onto stack
    PHA                                                 ; }
    TYA                                                 ; }
    PHA                                                 ; }

    LDA #>(.restoreRegistersAndReturnFromInterrupt-1)   ; }
    PHA                                                 ; } push return address onto stack
    LDA #<(.restoreRegistersAndReturnFromInterrupt-1)   ; } RTS will now exit to .restoreRegistersAndReturnFromInterrupt
    PHA                                                 ; }
    CLV                                                 ; clear V flag (meaning: check the ACIA generated the interrupt)
    ; fall through...

; ***************************************************************************************
;
; Check for ACIA Interrupt or Update ACIA
;
; Two modes of operation (V CLEAR and V SET)
;
; On Entry:
;       V CLEAR means check that the ACIA generated the interrupt, and if so then update
;               the RS-423 or cassette as needed
;       V  SET  means just update the RS-423
.irq1CheckACIA
    LDA .acia6850StatusRegister                         ; get the ACIA status register
    BVS +                                               ; if ('V SET') then branch (don't
                                                        ; check the ACIA generated the
                                                        ; interrupt)
    BPL .irq1CheckSystemVIA                             ; if (ACIA didn't generate the
                                                        ; interrupt) then branch (check the
                                                        ; next thing)
+
    LDX .rs423TimeoutCounter                            ; read RS-423 timeout counter
    DEX                                                 ; decrement it
    BMI .rs423HasControl                                ; if (timed out) then branch
    BVS .exit13                                         ; if ('V SET') then branch (return)
    JMP .updateACIA                                     ; update ACIA

; ***************************************************************************************
.rs423ErrorDetectedSetAY
    LDY .acia6850DataRegister                           ; read ACIA data
    ROL                                                 ;
    ASL                                                 ;
    ; fall through...

; ***************************************************************************************
.rs423ErrorDetected
    TAX                                                 ; X=status byte shifted right once
    TYA                                                 ; A=character received
    LDY #.eventRS423ErrorDetected                       ; Y=7
    JMP .eventEntryPoint                                ; check and service EVENT 7 RS-423 error

; ***************************************************************************************
;
; Send to RS-423 / Serial printer as needed
;
; If we have a non-empty RS-423 output buffer, then send the next byte, reset the RS-423
; timeout counter and exit.
;
; If we have a serial printer, update the printer buffer empty flag. If not empty then
; send the byte to the printer (and also reset the RS-423 timeout counter).
;
; ***************************************************************************************
.writeToACIA
    LDX #.bufferNumberRS423Output                       ; }
    JSR .osbyte145EntryPoint                            ; } read from RS-423 output buffer
    BCC +                                               ; if (buffer isn't empty) then branch forward

    ; RS-423 buffer empty
    LDA .printerDestination                             ; read printer destination
    CMP #2                                              ; is it serial printer?
    BNE .rs423Handler                                   ; if (not a serial printer) then branch (it must be RS-423)

    ; serial printer
    INX                                                 ; X=3 (.bufferNumberPrinter)
    JSR .osbyte145EntryPoint                            ; read printer buffer
    ROR .printerBufferEmptyFlag                         ; update the empty flag (put carry into bit 7)
    BMI .rs423Handler                                   ; if (printer buffer is empty) then branch
+
    STA .acia6850DataRegister                           ; pass either printer or RS-423 data to ACIA
    LDA #$E7                                            ; } reset timeout counter to
    STA .rs423TimeoutCounter                            ; } count up 25 vsyncs (0.5 seconds)
.exit13
    RTS                                                 ;

; ***************************************************************************************
;
; Service RS-423 interrupt
;
; See NAUG Section 8.4 - Serial system interrupts, Page 126
;
; On Entry:
;       A = ACIA status byte
;
;       Two modes of operation:
;       V CLEAR - read from RS-423; handle DCD (Data Carrier Detect); write to RS-423;
;                 handle unrecognised interrupt
;       V SET   - handle DCD; write to RS-423
; ***************************************************************************************
.rs423HasControl
    AND .rs423IRQBitMask                                ; AND with ACIA bit mask (normally $FF)
    LSR                                                 ; shift right to put bit 0 of ACIA status (receive interrupt) in carry
    BCC +                                               ; if (not a receive interrupt) then branch (skip read)
    BVS +                                               ; if (V SET mode) then branch (skip read)
    LDY .rs423ControlRegisterCopy                       ; read copy of ACIA control register
    BMI .readFromRS423                                  ; if (ACIA 6850 interrupts enabled) then branch
+
    LSR                                                 ; shift,  put bit 1 of ACIA status into carry
    ROR                                                 ; rotate, put bit 2 of ACIA status into carry
    BCS .rs423ErrorDetectedSetAY                        ; if (Data Carrier Detected interrupt) then branch
    BMI .writeToACIA                                    ; if (ACIA status bit 1 is set) then branch (transmit interrupt)
    BVS .exit13                                         ; if (V SET mode) then branch (exit)
    ; fall through...

; ***************************************************************************************
;
; Unrecognised Interrupt
;
; When we have an interrupt that we don't understand, pass it to the ROMs to see if
; they can handle it. If not, then pass it on to the IRQ2 vector.
; ***************************************************************************************
.unrecognisedInterrupt
    LDX #.romServiceCallUnrecognisedInterrupt           ; }
    JSR .osbyte143EntryPoint                            ; } issue paged ROM service call for 'unrecognised interrupt'
    BEQ .exit13                                         ; if (a ROM recognises it) then branch (exit)
    PLA                                                 ; otherwise remove address from stack
    PLA                                                 ;
    PLA                                                 ; and restore Y, X, and A
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    PLA                                                 ;
    STA .interruptAccumulator                           ; .interruptAccumulator=A
    JMP (.vectorIRQ2V)                                  ; and offer to the user via IRQ2V

; ***************************************************************************************
;
; Check for System VIA interrupt
;
; Check if the System VIA triggered the interrupt and deal with it.
; ***************************************************************************************
.irq1CheckSystemVIA
    LDA .systemVIAInterruptFlagRegister                 ; read system VIA interrupt flag register
    BPL .irq1CheckUserVIA                               ; if (the System VIA has not caused interrupt) then branch (try the next thing)

    AND .systemVIAIRQBitMask                            ; mask with VIA bit mask (normally $FF)
    AND .systemVIAInterruptEnableRegister               ; and interrupt enable register
    ROR                                                 ; }
    ROR                                                 ; } rotate right twice to check for IRQ 1 (vsync)
    BCC .irq1CheckSystemVIASpeech                       ; if (not vsync) then branch (to check for speech)

    ; vsync interrupt
    DEC .verticalSyncCounter                            ; decrement vertical sync counter
    LDA .rs423TimeoutCounter                            ; A = RS-423 Timeout counter
    BPL +                                               ; if (positive) then branch
    INC .rs423TimeoutCounter                            ; increment counter
+
    LDA .videoULAFlashingColourIntervalCount            ; load flash counter
    BEQ .doneFlashingColours                            ; if (flashing system is not in use) then branch
    DEC .videoULAFlashingColourIntervalCount            ; decrement counter
    BNE .doneFlashingColours                            ; if (not time for a colour to flash) then branch (to continue processing)

    ; ready to flash colour
    LDX .videoULAFirstFlashingColourInterval            ; get mark period count in X
    LDA .videoULAVideoControlRegisterCopy               ; current Video ULA control setting in A
    LSR                                                 ; shift bit 0 into C
    BCC .restoreAndFlipBit                              ; if (first colour is in effect) then branch

    LDX .videoULASecondFlashingColourInterval           ; get second colour period count in X
.restoreAndFlipBit
    ROL                                                 ; restore bit
    EOR #1                                              ; and invert it
    JSR .setVideoULA                                    ; then set colour
    STX .videoULAFlashingColourIntervalCount            ; reset the count until the next flash

.doneFlashingColours
    LDY #.eventStartOfVSync                             ; Y=event type: start of vsync
    JSR .eventEntryPoint                                ; call the event
    LDA #%00000010                                      ; A=bit set to clear the vsync interrupt flag
    JMP .storeToSystemVIAIFR                            ; clear interrupt and exit


; ***************************************************************************************
;
; Check for User VIA interrupt
;
; Check if the User VIA triggered the interrupt and deal with it (check for parallel
; printer in particular).
; ***************************************************************************************
.irq1CheckUserVIA
    LDA .userVIAInterruptFlagRegister                   ; check User VIA interrupt flags register
    BPL .unrecognisedInterrupt                          ; if (User VIA did not call interrupt) then branch

    AND .userVIAIRQBitMask                              ; }
    AND .userVIAInterruptEnableRegister                 ; }
    ROR                                                 ; }
    ROR                                                 ; } check for User IRQ bit 1 set (printer interrupt)
    BCC .unrecognisedInterrupt                          ; if (not printer interrupt) then branch
    LDY .printerDestination                             ; get printer type
    DEY                                                 ; decrement
    BNE .unrecognisedInterrupt                          ; if (not a parallel printer) then branch

    ; deal with parallel printer
    LDA #%00000010                                      ; interrupt bit 1 (printer interrupt)
    STA .userVIAInterruptFlagRegister                   ; clear interrupt bit 1
    STA .userVIAInterruptEnableRegister                 ; enable interrupt bit 1
    LDX #.bufferNumberPrinter                           ; }
    JMP .openPrinterChannel                             ; } output data to parallel printer

; ***************************************************************************************
;
; Check to see if the interrupt is a Speech interrupt and deal with it
;
; The speech processor chip has an internal 16 byte buffer to hold incoming data.
;
; When speaking, this buffer will run out every 50 milliseconds. When the buffer becomes
; half full, an interrupt occurs. In fact, a speech interrupt is generated when any of the
; following occur:
;
;   (1) End of speech processing
;   (2) Speech hardware is low on data (half full, i.e. 8 bytes or less), indicating more
;       phrase data needs to be supplied for the Speak External command.
;   (3) Speech hardware is empty of data, indicating the CPU failed to supply phrase data
;       fast enough for the Speak External command.
;   (4) At the start of a Speak External instruction, if speech hardware is not empty of data.
;
; We call .updateSpeech in the 100Hz interrupt to keep the speech hardware regularly supplied
; with data.
;
; On Entry:
;       A = System VIA interrupt flag shifted right twice
; ***************************************************************************************
.irq1CheckSystemVIASpeech
    ROL                                                 ; } rotate left twice to get back to
    ROL                                                 ; } original interrupt flag register
                                                        ; } alignment of bits

    ROL                                                 ; rotate left to get bit 5 into bit 6
    ROL                                                 ; rotate left to get bit 6 into bit 7
    BPL .irq1CheckSystemVIA100HzTimer                   ; if (bit 5 of system via IFR is
                                                        ; clear, i.e. it's not timer 2, used
                                                        ; for the speech interrupt)
                                                        ; then branch

    ; deal with speech
    LDA #%00100000                                      ; } clear bit 5, the timer 2
    LDX #0                                              ; } interrupt
    STA .systemVIAInterruptFlagRegister                 ; }
    STX .systemVIATimer2CounterHigh                     ; clear Timer 2 (write to high byte)

.updateSpeech
    LDX #8                                              ; } loop counter (shifted right on
    STX .tempStoreFB                                    ; } each loop iteration)

    ; on each speech update we loop a maximum of 4 times to feed the speech chip with up to
    ; 4 bytes of new data from the CPU's speech buffer.
.feedSpeechChipWithDataLoop
    ; check our speech buffer, see if there's more data
    JSR .osbyte152EntryPoint                            ; examine buffer status for buffer 8
                                                        ; (the speech buffer), C set if buffer
                                                        ; is empty, otherwise A is byte read.
    ROR .speechBufferEmptyFlag                          ; shift carry into bit 7 - store as
                                                        ; the 'speech buffer empty' bit
    BMI .exit14                                         ; if (top bit is set, i.e. set buffer
                                                        ; is empty) then branch (return)
    TAY                                                 ; Y = A = next byte to be removed
                                                        ; from speech buffer
    BEQ +                                               ;

    ; check if speech chip is ready?
    JSR .osbyte158EntryPoint                            ; read byte from speech chip
    BMI .exit14                                         ; if (top bit set) then branch (exit)

+
    ; read three bytes from the speech buffer: <ROM number> <2 byte address>
    JSR .osbyte145EntryPoint                            ; read a byte from CPU's speech buffer
    STA .currentSpeechPHROMOrROMNumber                  ; store ROM number
    JSR .osbyte145EntryPoint                            ; read another byte
    STA .romAddressHigh                                 ; store ROM address
    JSR .osbyte145EntryPoint                            ; read another byte
    STA .romAddressLow                                  ; store ROM address

    LDY .currentSpeechPHROMOrROMNumber                  ; Y=ROM / PHROM number
    BEQ .writeROMAddressToSpeechProcessor               ; if (current logical speech PHROM
                                                        ; or ROMFS Number is zero) then branch
    BPL .writeCommandAndAddressToSpeechProcessor        ; if (+ve) then branch
    BIT .currentSpeechPHROMOrROMNumber                  ; check bit 6 of PHROM or ROM number
    BVS +                                               ; if (PHROM or ROM number has bit 6
                                                        ; set) then branch
    JSR .writeAddressAndROMNumberToSpeechProcessor      ; continue for more speech processing
    BVC .enableOrDisableSpeech                          ; ALWAYS branch

+
    ASL .romAddressLow                                  ; double ROM address
    ROL .romAddressHigh                                 ;
    JSR .readFromPHROM                                  ; and call .readFromPHROM

.enableOrDisableSpeech
    LDY .speechSuppressionStatus                        ; get speech enable/disable flag
                                                        ; whose values equate to speech
                                                        ; processor commands:
                                                        ; $50 = 'speak'; $20 = 'nop'
    JMP .osbyte159EntryPoint                            ; write to speech processor

.writeCommandAndAddressToSpeechProcessor
    JSR .osbyte159EntryPoint                            ; write ROM number
.writeROMAddressToSpeechProcessor
    LDY .romAddressLow                                  ; get address pointer in Y
    JSR .osbyte159EntryPoint                            ; write address to speech chip
    LDY .romAddressHigh                                 ; get address pointer high in Y
    JSR .osbyte159EntryPoint                            ; write address to speech chip

    LSR .tempStoreFB                                    ; update loop counter
    BNE .feedSpeechChipWithDataLoop                     ; loop back

.exit14
    RTS                                                 ;


; ***************************************************************************************
;
; IRQ1 Interrupt - 100Hz interrupt
;
; ***************************************************************************************
.irq1CheckSystemVIA100HzTimer
    BCC .irq1CheckSystemVIAADCEndConversion             ; bit 6 is in carry. if (there is no bit 6 interrupt) then branch
    LDA #%01000000                                      ; }
    STA .systemVIAInterruptFlagRegister                 ; } clear interrupt 6

    ; Update the 5 byte clock. There are 2 clock stores, at .timeClockA and .timeClockB. These
    ; are updated by adding 1 to the current clock and storing the result in the other, the
    ; direction of transfer being changed each time of update.  This ensures that at least
    ; 1 clock store is valid at any call as the current clock is only read.  Other methods
    ; would cause inaccuracies if a clock was read whilst being updated.
    LDA .timeClockSwitch                                ; get current system clock pointer (5 or 10)
    TAX                                                 ; put old system clock pointer in X
    EOR #$0F                                            ; invert bits so it toggles between 5 and 10
    PHA                                                 ; remember A
    TAY                                                 ; put new system clock pointer in Y
-
    LDA .timeClockA-1,X                                 ; get current system clock value
    ADC #0                                              ; increment it (carry is set on the first iteration of the loop,
                                                        ;     thereafter carry is set as needed based on this increment)
    STA .timeClockA-1,Y                                 ; store result in new copy
    DEX                                                 ; decrement X
    BEQ +                                               ; if (finished) then branch (loop ends)
    DEY                                                 ; decrement Y
    BNE -                                               ; and go back and do next byte
+
    PLA                                                 ; get back new clock pointer
    STA .timeClockSwitch                                ; and store back in clock pointer

    ; Update countdown interval timer. An EVENT is generated when it times out.
    LDX #5                                              ; set loop counter
-
    INC .countdownIntervalTimer - 1,X                   ; increment byte for countdown timer
    BNE +                                               ; if (done updating timer bytes) then branch
    DEX                                                 ; decrement loop counter
    BNE -                                               ; if (not finished looping) do it again

    LDY #.eventIntervalTimerCrossingZero                ; at this point all the interval timer bytes are zero
    JSR .eventEntryPoint                                ; call EVENT 5 interval timer

    ; Update INKEY timeout. Used when reading a key within a time limit.
+
    LDA .inkeyTimeoutCounterLow                         ; get low byte of inkey countdown timer
    BNE +                                               ; if (inkey timer is non-zero) then branch forward
    LDA .inkeyTimeoutCounterHigh                        ; get high byte of inkey countdown timer
    BEQ ++                                              ; if (inkey timer is zero) then branch forward
    DEC .inkeyTimeoutCounterHigh                        ; decrement high byte
+
    DEC .inkeyTimeoutCounterLow                         ; and decrement low byte

    ; Update sound.
++
    BIT .soundIsUpdatingFlag                            ; check bit 7 of sound flag
                                                        ; (this bit is set while processing
                                                        ; sound interrupt. check so we don't
                                                        ; try to process a second sound
                                                        ; interrupt while still processing
                                                        ; the first)
    BPL +                                               ; if (bit clear; still processing)
                                                        ; then branch (skip forward)
    INC .soundIsUpdatingFlag                            ; increment to 0 (to signify that
                                                        ; sound is being processed here)
    CLI                                                 ; allow interrupts briefly
    JSR .processSoundInterrupt                          ; process sound
    SEI                                                 ; disable interrupts
    DEC .soundIsUpdatingFlag                            ; decrement 'sound is updating' flag
                                                        ; back to $FF (this signifies that we
                                                        ; are done processing the sound)

    ; Update speech.
+
    BIT .speechBufferEmptyFlag                          ; check speech buffer empty flag
    BMI +                                               ; if (speech buffer is empty) then
                                                        ; branch (skip speech)
    JSR .osbyte158EntryPoint                            ; read speech processor status register
    EOR #%10100000                                      ; flip two bits
    CMP #%01100000                                      ; check
    BCC +                                               ; if (result < $60) then branch
    JSR .updateSpeech                                   ; process speech

    ; Update ACIA.
+
    BIT .allBitsSet                                     ; set V flag
    JSR .irq1CheckACIA                                  ; update ACIA

    ; Update keyboard.
    LDA .lastKeyPressedInternal                         ; } check if a key is currently
    ORA .firstKeyPressedInternal                        ; } pressed
    AND .enableKeyboardInterruptProcessingFlag          ; ignore key presses if the flag
                                                        ; is zero
    BEQ +                                               ; if (no key pressed or we should
                                                        ; ignore keys pressed) then branch
                                                        ; (ignore keyboard)
    SEC                                                 ; set carry
    JSR .keyboardInterruptRoutine                       ; handle keyboard interrupt

    ; Update printer.
+
    JSR .printerServiceCallIfNotEmpty                   ; check for data in printer buffer

    ; Update ADC conversion.
    BIT .adcDataStatusRegister                          ; check ADC status register
    BVS .handleADCConversionEnds                        ; if (bit 6 is set, i.e. ADC not
                                                        ; busy) then branch

    RTS                                                 ;


; ***************************************************************************************
;
; IRQ1 Interrupt - Analogue to Digital Conversion (End of Conversion)
;
; See .osbyte17EntryPoint
;
; ***************************************************************************************
.irq1CheckSystemVIAADCEndConversion
    ROL                                                 ; put original bit 4 from .systemVIAInterruptFlagRegister into bit 7 of A
    BPL .irq1CheckSystemVIAKeyboard                     ; if (not an ADC conversion interrupt) then branch

.handleADCConversionEnds
    LDX .adcCurrentChannel                              ; get current ADC channel
    BEQ .clearInterrupt4                                ; if (zero) then branch (clear interrupt and exit)

    LDA .adcDataLowByte                                 ; read low data byte
    STA .lowByteLastByteFromADCChannel1 - 1,X           ; store it in memory
    LDA .adcDataHighByte                                ; get high data byte
    STA .highByteLastByteFromADCChannel1 - 1,X          ; and store it in high byte
    STX .adcLastChannelRead                             ; store last ADC channel read
    LDY #.eventADCConversionComplete                    ; handle event 3 conversion complete
    JSR .eventEntryPoint                                ;

    DEX                                                 ; decrement X
    BNE +                                               ; if (X != 0) then branch forward
    LDX .maximumADCChannelNumber                        ; get highest ADC channel present
+
    JSR .startADCConversion                             ; start new conversion
.clearInterrupt4
    LDA #%00010000                                      ; reset interrupt 4
.storeToSystemVIAIFR
    STA .systemVIAInterruptFlagRegister                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; IRQ1 Interrupt - keyboard
;
; ***************************************************************************************
.irq1CheckSystemVIAKeyboard
    ROL                                                 ; get original bit 0 in bit 7 position
    ROL                                                 ;
    ROL                                                 ;
    ROL                                                 ;
    BPL +                                               ; if (not a keyboard interrupt) then branch (skip keyboard processing)
    JSR .keyboardInterruptRoutine                       ; scan keyboard
    LDA #%00000001                                      ; }
    BNE .storeToSystemVIAIFR                            ; } reset interrupt 0 and return
+
    JMP .unrecognisedInterrupt                          ;

; ***************************************************************************************
.restoreRegistersAndReturnFromInterrupt
    PLA                                                 ; restore AXY registers
    TAY                                                 ;
    PLA                                                 ;
    TAX                                                 ;
    PLA                                                 ;
    STA .interruptAccumulator                           ; store A
    ; fall through...

; ***************************************************************************************
;
; Default IRQ2 handler - does nothing
;
; ***************************************************************************************
.irq2Handler
    LDA .interruptAccumulator                           ; get back original value of A
    RTI                                                 ; return

; ***************************************************************************************
;
; OSBYTE 17 - Start ADC conversions
;
; See 7002.png
;
; Analogue to digital conversion is performed by the ADC 7002 chip. It has four channels
; of data that can be read. This is often used to read an analogue joystick. This starts
; the conversion happening. They will keep happening until OSBYTE 16 with X=0 is called.
;
; OSBYTE 16 selects the range of channels to convert (0-4). See .osbyte16EntryPoint.
;
; OSBYTE 190 selects the ADC conversion type (8 or 12 bits). See .adcConversionType.
; Twelve bit conversion is the default (which takes about 10ms). Eight bit conversions are
; faster at around 4ms.
;
; The ADC 7002 generates an interrupt when the conversion is complete, and the IRQ1 handler
; stores the two byte result (in .lowByteLastByteFromADCChannel1 and upwards). It also
; starts the next conversion. See .irq1CheckSystemVIAADCEndConversion.
;
; OSBYTE 128 reads the latest converted ADC value (X=ADC channel 1-4). See .osbyte128EntryPoint.
; OSBYTE 128 can also read the state of the fire buttons. (X=0). See .osbyte128EntryPoint.
; These are encapsulated in the BASIC ADVAL command.
;
; On Entry:
;       X = ADC channel number (1-4)
;       Y = 0
;
; ***************************************************************************************
.osbyte17EntryPoint
    STY .adcLastChannelRead                             ; set last channel to finish conversion (to zero)
.startADCConversion
    CPX #5                                              ;
    BCC +                                               ; if (X < 5) then branch (skip forward)
    LDX #4                                              ; X=4 (maximum)
+
    STX .adcCurrentChannel                              ; store it as current ADC channel
    LDY .adcConversionType                              ; get conversion type
    DEY                                                 ; decrement
    TYA                                                 ; A=Y
    AND #%00001000                                      ; clear to zero except for bit 3 set
                                                        ; indicates a 12 bit conversion
    CLC                                                 ; } add the ADC channel (1-4)
    ADC .adcCurrentChannel                              ; } then subtract one, effectively
    SBC #0                                              ; } adding channel (0-3) into bits 0-2
    STA .adcStartConversionRegister                     ; store value to start ADC conversion
    RTS                                                 ;

; ***************************************************************************************
;
; Display string on screen
;
; Display the boot message (e.g. 'BBC Computer 32K') and language ROM title (e.g. 'BASIC')
;
; On Entry:
;       Y = offset from page of .vduBaseAddress to start of string -1
;
; ***************************************************************************************
.displayString
    LDA #>.vduBaseAddress                               ; Start of string area (high byte)
.displayStringAY
    STA .displayStringAddressHigh                       ; store it
    LDA #0                                              ; Low byte is zero (we use Y to index to correct string)
    STA .displayStringAddressLow                        ; store it and start loop
    ; fall through...

; ***************************************************************************************
.printMessage
    INY                                                 ; print character in string
    LDA (.displayStringAddressLow),Y                    ; pointed to by $FD/E
    JSR .OSASCI                                         ; print it expanding Carriage returns
    TAX                                                 ; store A in X
    BNE .printMessage                                   ; and loop again if not zero
    RTS                                                 ;

; ***************************************************************************************
; On Entry:
;       X/Y holds the time limit
.osbyte129Timed
    STX .inkeyTimeoutCounterLow                         ; store time in INKEY countdown timer
    STY .inkeyTimeoutCounterHigh                        ; which is decremented every 10ms
    LDA #255                                            ;
    BNE .readCharacterTimed                             ; ALWAYS branch

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 12: Command Line Interpreter (star commands)
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Introduction
;
; The Command Line Interpreter is responsible for executing star commands. There are a number
; built in to the system (see .starCommandTable), and more can be added via paged ROMs.
;
; The commands can have parameters as integer decimal, hexadecimal values, and strings.
; These commands have characters in the range 32-126, but can encode control codes and other
; non-printable characters. It uses GSINIT and GSREAD to convert the set of ASCII printable
; string characters into a full 8-bit ASCII converted values. See .gsinitEntryPoint .
;
; This chapter contains integer (in string form) to byte conversion,
; see .parseDecimalNumberFromString. A conversion for a hex digit in string form to a byte,
; see .readHexDigit, which is used to read a wole 32 bit address, see .readOSFILEAddress .
;
; Historical note: Every Acorn computer from the System 2 onwards has a CLI, and the
; asterisk probably derives from the System 2's use of it as a prompt character.
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSRDCH - Read a character
;       This reads from an EXEC file if open, or the current input buffer otherwise
;
; On Entry:
;       A = 0 for reading a key instantly
;       A = 255 for reading a key with a time limit
;
; ***************************************************************************************
.osrdchEntryPoint
    LDA #0                                              ;
.readCharacterTimed
    STA .readCharacterTimedFlag                         ; store A (0 or 255) to indicate if it's a timed read
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } store X and Y
    PHA                                                 ; }
    LDY .execFileHandle                                 ; get *EXEC file handle
    BEQ .readCharacterFromCurrentInputBufferLoop        ; if (zero, i.e. no EXEC file open) then branch

    ; read from an EXEC file
    SEC                                                 ; set carry
    ROR .tapeCritical                                   ; set bit 7 of tape filing system active flag to prevent clashes
    JSR .OSBGET                                         ; get a byte from the file
    PHP                                                 ; push flags to preserve carry
    LSR .tapeCritical                                   ; clear .tapeCritical flag
    PLP                                                 ; get back flags
    BCC .pullAndReturn                                  ; if (character found) then branch (recall values and exit)
    LDA #0                                              ; error reading from file, so close the file
    STA .execFileHandle                                 ; store it in exec file handle
    JSR .OSFIND                                         ; and close file via OSFIND

.readCharacterFromCurrentInputBufferLoop
    BIT .escapeFlag                                     ; check ESCAPE flag
    BMI .setEscapeConditionAndExit                      ; if (ESCAPE flag set) then branch (set escape condition and exit)
    LDX .currentInputBuffer                             ; get current input buffer number
    JSR .readFromEconetOrSoftKeyOrInputBufferA          ; get a byte from current input buffer
    BCC .pullAndReturn                                  ; if (valid character found) then branch (exit)

.checkForTiming
    BIT .readCharacterTimedFlag                         ; check for timed read
    BVC .readCharacterFromCurrentInputBufferLoop        ; if (this is not timed) then branch (go back and read byte from input buffer again)
    LDA .inkeyTimeoutCounterLow                         ; check timers
    ORA .inkeyTimeoutCounterHigh                        ;
    BNE .readCharacterFromCurrentInputBufferLoop        ; if (timer is not zero) then branch (loop back and keep trying to read)
    BCS +                                               ; if (timed out) then branch (exit without storing character read)

.setEscapeConditionAndExit
    SEC                                                 ;
    LDA #.charESCAPE                                    ; ESCAPE character read

.pullAndReturn
    STA .readCharacterTimedFlag                         ; remember character read
+
    PLA                                                 ; }
    TAY                                                 ; } restore X,Y
    PLA                                                 ; }
    TAX                                                 ; }
    LDA .readCharacterTimedFlag                         ; recall character read
    RTS                                                 ;

; ***************************************************************************************
;
; Copyright string
; Only used as part of the check for valid Paged ROM, never printed
;
; ***************************************************************************************
.copyrightString
    !text ")C(",0                                       ; Copyright string (backwards)

; ***************************************************************************************
;
; Star command table
;
; *. <directory>                Synonym of *CAT
; *FX <a>,<x>,<y>               Calls OSBYTE
; *BASIC                        Start BASIC
; *CAT <directory>              Show catalogue from filing system
; *CODE <x>,<y>                 Execute code via USERV with A=0
; *EXEC <filename>              Execute a script file
; *HELP <string>                Get help
; *KEY <n> <string>             Define a soft key definition
; *LINE <string>                Execute code via USERV with A=1
; *LOAD <filename> <addr>       Load file
; *MOTOR <n>                    Turn on/off cassette motor
; *OPT <x>,<y>                  Set filing system options (Equivalent to OSBYTE 139)
; *RUN <filename>               Load and execute a file from the current filing system
; *ROM                          Set ROM filing system
; *SAVE <filename> <start> <end> <exec> <load> Save memory to the current filing system
; *SPOOL <filename>             Save keystrokes to the current filing system
; *TAPE <n>                     Set the TAPE filing system
; *TV <x>,<y>                   Adjust the TV display
;
; Commands can be abbreviated, e.g. *M. for *MOTOR.
;
; This list is not quite alphabetical, so that short abbreviations yield the more common
; commands, so *LOAD comes before *LINE so that *L. becomes *LOAD; and *R. becomes *RUN,
; not *ROM.
;
; The last entry is empty to catch anything else.
;
; After the name and address of each command is a single byte parameter that is passed in
; the accumulator before calling the routine's address. If the parameter has the top bit
; clear (*.; *BASIC; *CAT; *EXEC; *LOAD; *LINE; *RUN; *SAVE; *SPOOL), then the next part of
; the command line is decoded into a string (usually a pathname).
;
; A group of commands (*CODE; *MOTOR; *OPT; *TAPE; *ROM; *TV) are synonyms for *FX calls
; with the parameter being the OSBYTE number.
;
; Historical note: The Acorn System 2 star commands were *BASIC, *CAT, *LOAD, *SAVE, *GO,
; *RUN, *MEM, *MON, *NOMON, *DRIVE, *USE, and *FLOAD, while the Atom provided *CAT, *LOAD,
; *SAVE, *RUN, *MON, *NOMON, *FLOAD, and *DOS. Their CLIs each provide the dot abbreviation
; and have similar command-parsing code. But the System 2 and Atom monitors lack the ability
; to EXEC scripts, and have no comment notation. *FLOAD, "finish loading", allowed part of
; a file to be loaded into memory by ignoring its block numbers -- an ability which was,
; perhaps wisely, dropped from the BBC.
;
; ***************************************************************************************
.starCommandTable
    !text "."                                           ; command name
    !be16 .passToCurrentFilingSystem                    ; address of routine to call
    !byte 5                                             ; parameter to routine (in A)

    !text "FX"
    !be16 .fxEntryPoint
    !byte $FF

    !text "BASIC"
    !be16 .basicEntryPoint
    !byte 0

    !text "CAT"
    !be16 .passToCurrentFilingSystem
    !byte 5

    !text "CODE"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $88

    !text "EXEC"
    !be16 .closeAndOptionallyOpenANewEXECFile
    !byte 0

    !text "HELP"
    !be16 .starHelp
    !byte $FF

    !text "KEY"
    !be16 .starKey
    !byte $FF

    !text "LOAD"
    !be16 .starLoad
    !byte 0

    !text "LINE"
    !be16 .uservJumper
    !byte 1

    !text "MOTOR"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $89

    !text "OPT"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $8B

    !text "RUN"
    !be16 .passToCurrentFilingSystem
    !byte 4

    !text "ROM"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $8D

    !text "SAVE"
    !be16 .starLoadSave
    !byte 0

    !text "SPOOL"
    !be16 .starSpool
    !byte 0

    !text "TAPE"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $8C

    !text "TV"
    !be16 .starCommandsForSpecificOSBYTEs
    !byte $90

    !text ""
    !be16 .passToCurrentFilingSystem
    !byte 3
    !byte 0


; ***************************************************************************************
;
; OSCLI - Command Line Interpreter
;       the default handler for CLIV vector
;
; On Entry:
;       XY is the address of the command line (terminated with a carriage return)
;
; On Exit:
;       A,X,Y,Flags undefined
;
; ***************************************************************************************
.oscliEntryPoint
    STX .stringInputBufferAddressLow                    ; Store XY in .stringInputBufferAddressLow/High
    STY .stringInputBufferAddressHigh                   ;
    LDA #8                                              ;
    JSR .passToCurrentFilingSystem                      ; Inform filing system CLI being processed
    LDY #0                                              ; loop counter
-
    LDA (.stringInputBufferAddressLow),Y                ; Check the line is correctly terminated
    CMP #.charRETURN                                    ; loop until CR is found
    BEQ .stringOK                                       ;
    INY                                                 ; move to next character
    BNE -                                               ; loop back if less than 256 bytes long
    RTS                                                 ; string is > 255 characters, so return

    ; String is terminated ok - now skip prepended spaces and '*'s
.stringOK
    LDY #$FF                                            ; Y = offset into string (which is about to be incremented so it will start at zero)
-
    JSR .incAndSkipSpaces                               ; Skip any spaces
    BEQ .exit15                                         ; if (CR found) then branch (return)
    CMP #.charSTAR                                      ; check for '*'
    BEQ -                                               ; if ('*' found) then branch (Loop back to skip it and skip spaces again)

    JSR .skipSpacesAndCheckForCRInStringInput           ; doesn't need to move forward, but checks if the current character is CR
    BEQ .exit15                                         ; if (CR found) then branch (exit)
    CMP #.charBAR                                       ; check for '|' (a comment)
    BEQ .exit15                                         ; if ('|' found) then branch (exit)
    CMP #.charFORWARDSLASH                              ; check for '/'
    BNE .startLookingForCommand                         ; if (NOT forward slash) then branch forward
    INY                                                 ; Move past the '/'
    JSR .convertStringInputPointerToXY                  ; Convert the address (.stringInputBufferAddressLow/High + Y) into XY
    LDA #2                                              ; 2 = execute "*/" command (See NAUG Section 16.1.7 - FSCV, Page 256-7)
    BNE .passToCurrentFilingSystem                      ; ALWAYS branch (call into current filing system service routine)

; ***************************************************************************************
;
; Start looking for command
;
; Look command up in command table
; ***************************************************************************************
.startLookingForCommand
    STY .currentStringPointer                           ; Store offset to start of command in command line
    LDX #0                                              ; start of command
    BEQ .lookForCommand                                 ; ALWAYS branch

; ***************************************************************************************
;
; Compare character in A in a star command
;
; ***************************************************************************************
.compareCharacterInCommand
    EOR .starCommandTable,X                             ; compare with character from star command table
    AND #%11011111                                      ; ignore case (zero the bit that distinguishes between upper and lower case)
    BNE .namesDontMatch                                 ; if (no match) then branch
    INY                                                 ; increment offset in command line
    CLC                                                 ; test next character

.atEndOfCommandName
    BCS .foundMatchForCommand                           ;
    INX                                                 ; increment offset in star command table
    LDA (.stringInputBufferAddressLow),Y                ; read next character in command line
    JSR .isLetter                                       ; carry clear if letter in A
    BCC .compareCharacterInCommand                      ;

.lookForCommand
    LDA .starCommandTable,X                             ; read byte from command table
    BMI .endOfCommandStringFound                        ; if (top bit set, i.e. end of command name string) then branch
    LDA (.stringInputBufferAddressLow),Y                ; read byte from command line
    CMP #.charDOT                                       ; check for '.'
    BEQ .foundDot                                       ; if (dot character found) then branch

.namesDontMatch
    CLC                                                 ;
    LDY .currentStringPointer                           ;
    DEY                                                 ;

.foundDot
    INY                                                 ;
    INX                                                 ;

-
    INX                                                 ;
    LDA .starCommandTable-2,X                           ;
    BEQ .passCommandToROMs                              ; reached end of table; unrecognised star command
    BPL -                                               ; if (top bit clear, i.e. not yet end of command name) then branch back (move to next character)
    BMI .atEndOfCommandName                             ; ALWAYS branch (loop back)

; ***************************************************************************************
.endOfCommandStringFound
    INX                                                 ;
    INX                                                 ;

.foundMatchForCommand
    DEX                                                 ;
    DEX                                                 ;
    PHA                                                 ; push star command address (high byte)
    LDA .starCommandTable+1,X                           ;  get star command address (low byte)
    PHA                                                 ; push star command address (low byte)
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip over the following spaces
    CLC                                                 ; clear carry
    PHP                                                 ; push flags
    JSR .prepareRegistersForStarCommand                 ; prepare the A,X,Y registers for the call to star command routine

    ; the RTI instruction restores the flags, and jumps to the address we've just put on
    ; the stack. (i.e. jumps to the star command routine.)
    RTI                                                 ; jump to star command routine

; ***************************************************************************************
.prepareRegistersForStarCommand
    LDA .starCommandTable+2,X                           ; Get A parameter from table
    BMI .exit15                                         ; if (top bit set, this implies the
                                                        ; command has no string parameter, but
                                                        ; there may be numeric parameters)
                                                        ; then branch (exit, we are done)
                                                        ; otherwise we set XY to be the rest
                                                        ; of the command line (i.e. string
                                                        ; based)
    ; fall through...

; ***************************************************************************************
;
; Convert string input pointer to XY
;
; On Entry:
;       X is the offset into the starCommandTable at the end of the string
;       Y is the offset into the string at .stringInputBufferAddressLow/High
;
; On Exit:
;       XY = (.stringInputBufferAddressLow/High + A)
;       A = parameter from star command table
;
; ***************************************************************************************
.convertStringInputPointerToXY
    TYA                                                 ; Pass Y line offset to A for later
    LDY .starCommandTable+2,X                           ; Get A parameter from table
    ; fall through...

; ***************************************************************************************
;
; Convert string address to XY
;
; On Entry:
;       A = is offset into string at .stringInputBufferAddressLow/High
;
; On Exit:
;       XY = .stringInputBufferAddressLow/High + A
;       A = original value of Y on entry
;
; ***************************************************************************************
.convertStringAddressToXY
    CLC                                                 ;
    ADC .stringInputBufferAddressLow                    ;
    TAX                                                 ; low byte in X
    TYA                                                 ; remember original Y into A
    LDY .stringInputBufferAddressHigh                   ; }
    BCC .exit15                                         ; } put high byte in Y, increment as needed
    INY                                                 ; }
.exit15
    RTS                                                 ;


; ***************************************************************************************
;
; *BASIC
;
; This command enters the BASIC language environment. The BASIC ROM is unique among Paged ROMs
; in not having a service entry. If it did, then the *BASIC command could be implemented in
; the BASIC ROM instead of here.
;
; ***************************************************************************************
.basicEntryPoint
    LDX .basicROMNumber                                 ; Get BASIC ROM number
    BMI .passCommandToROMs                              ; if (no BASIC found) then branch (pass command on to ROMs)
    SEC                                                 ; Set Carry = not entering from RESET
    JMP .osbyte142EntryPoint                            ; Enter language ROM in X

; ***************************************************************************************
;
; Pass command to ROMs
;
; Pass command on to Paged ROMs and to filing system
;
; ***************************************************************************************
.passCommandToROMs
    LDY .currentStringPointer                           ; Restore pointer to start of command
    LDX #.romServiceCallUnrecognisedCommand             ; 4 = Unrecognised star command
    JSR .osbyte143EntryPoint                            ; Pass to sideways ROMs
    BEQ .exit15                                         ; if (claimed by ROM) then branch (exit)
    LDA .currentStringPointer                           ; Restore pointer to start of command
    JSR .convertStringAddressToXY                       ; Convert .stringInputBufferAddressLow/High+A to XY, ignore returned A
    LDA #3                                              ; 3 = Auto-boot call

.passToCurrentFilingSystem
    JMP (.vectorFSCV)                                   ; call into current filing system
                                                        ; handler (for default handler,
                                                        ; see .fscEntryPoint)

; ***************************************************************************************
;
; OSBYTE 139 - Select file options (*OPT)
;
; See .starOptEntryPoint for parameters
;
; On Entry:
;       X,Y hold the *OPT parameters
;
; ***************************************************************************************
.osbyte139EntryPoint
    ASL                                                 ; Double A (clear bit zero)
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 127 - Check for EOF on open file
;
; On Entry:
;       X = file handle
;
; ***************************************************************************************
.osbyte127EntryPoint
    AND #1                                              ; A = 1 if entry via OSBYTE 127
                                                        ; A = 0 if entry via OSBYTE 139
    BPL .passToCurrentFilingSystem                      ; ALWAYS branch (send *OPT command
                                                        ; to the current filing system).

; ***************************************************************************************
;
; Skip spaces
;
; On Entry:
;       .stringInputBufferAddressLow/High is address of string to test
;       Y is the current offset within the string
;
; On Exit:
;       Y is incremented to the next non-space character
;       Z set if RETURN found (end of string)
;
; ***************************************************************************************
.incAndSkipSpaces
    INY                                                 ; move to next character in string
.skipSpacesAndCheckForCRInStringInput
    LDA (.stringInputBufferAddressLow),Y                ; read character from string
    CMP #.charSPACE                                     ; check for SPACE character
    BEQ .incAndSkipSpaces                               ; if (SPACE) then branch (loop back)
.compareWithReturnAndExit
    CMP #.charRETURN                                    ; set Z flag if charRETURN found
    RTS                                                 ;

; ***************************************************************************************
;
; Skip spaces and comma
;
; Skip past any spaces, and check for CR
;
; On Entry:
;     if carry is clear, then skip SPACEs then look for RETURN
;     if carry is set, then skip SPACEs then skip a comma or look for a RETURN
;
; On Exit:
;       Y incremented past any spaces and comma
;       Z set if RETURN found
;
; ***************************************************************************************
.skipSpacesAndComma
    BCC .skipSpacesAndCheckForCRInStringInput           ; if (carry clear) then branch
.skipSpacesAndCommaValid
    JSR .skipSpacesAndCheckForCRInStringInput           ;
    CMP #.charCOMMA                                     ;
    BNE .compareWithReturnAndExit                       ;
    INY                                                 ; move to next character. Y is not
                                                        ; zero so Z is set.
    RTS                                                 ;

; ***************************************************************************************
;
; Read a number (0-255) from string
;
; On Entry:
;       stringInputBufferAddressLow/High + Y is address of string holding a number
; On Exit:
;       X = result (value 0-255) also stored in .tempWorkspaceE6
;       Carry clear on error
;       Zero set if RETURN found
;
; ***************************************************************************************
.parseDecimalNumberFromString
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip spaces
    JSR .readDigitFromString                            ; read digit
    BCC .errorReadingString                             ; if (error found) then branch (clear carry and exit)

.readingDigits
    STA .tempWorkspaceE6                                ; store temporary result
    JSR .readNextDigitFromString                        ; read next digit 0-9
    BCC .finishedParsingDigits                          ; if (not a digit) then branch (we have finished)
    TAX                                                 ; remember best valid result so far
    LDA .tempWorkspaceE6                                ; recall previous digit P
    ASL                                                 ; A=P*2
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ASL                                                 ; A=P*4
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ADC .tempWorkspaceE6                                ; A=(P*4)+P =P*5
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    ASL                                                 ; A=P*10
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    STA .tempWorkspaceE6                                ; Store temporary result
    TXA                                                 ; recall current digit
    ADC .tempWorkspaceE6                                ; Add previous digit times ten
    BCS .errorReadingString                             ; result too big, return with carry clear (error)
    BCC .readingDigits                                  ; ALWAYS branch back

; ***************************************************************************************
.finishedParsingDigits
    LDX .tempWorkspaceE6                                ; get best valid result
    CMP #.charRETURN                                    ; set Z flag if RETURN found
    SEC                                                 ; set carry (success flag)
    RTS                                                 ;

; ***************************************************************************************
.readNextDigitFromString
    INY
.readDigitFromString
    LDA (.stringInputBufferAddressLow),Y                ; get digit from string
    CMP #.charNINE + 1                                  ; }
    BCS .errorReadingString                             ; } check if digit is in range '0' to '9'
    CMP #.charZERO                                      ; }
    BCC .errorReadingString                             ; }
    AND #$0F                                            ; mask off bits to leave binary value 0-9
    RTS                                                 ;

; ***************************************************************************************
.notAHexByte
    JSR .skipSpacesAndCommaValid                        ;

.errorReadingString
    CLC                                                 ;
    RTS                                                 ;

; ***************************************************************************************
;
; Read hex digit
;
; On Exit:
;       on success, carry is set, A = 0-15, based on ascii digit in string (0-9,A-F)
;       on error, carry clear
;
; ***************************************************************************************
.readHexDigit
    JSR .readDigitFromString                            ; read digit 0-9
    BCS +                                               ; if (digit not in 0-9 range) then branch
    AND #%11011111                                      ; clear bit 5 (converts lower case letters to upper case)
    CMP #.charF + 1                                     ;
    BCS .notAHexByte                                    ; if (higher than 'F') then branch (exit with error)
    CMP #.charA                                         ;
    BCC .notAHexByte                                    ; if (lower than 'A') then branch (exit with error)
    PHP                                                 ; carry set, push flags
    SBC #.charA - 10                                    ; Convert to range 10-15
    PLP                                                 ; restore flags (carry set, for successful result)
+
    INY                                                 ; move on to next byte
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 13: Writing characters; printer; buffers
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSWRCH - write character
;
; This is the main entry point for writing characters to the display and/or to other devices
; such as ECONET, a printer, RS-423 or to a file.
;
; Note: the .characterDestinationsAvailableFlags has the following bits:
;
;   bit 0 - enable RS-423 driver
;   bit 1 - disable VDU driver
;   bit 2 - disable printer driver
;   bit 3 - enable printer, independent of VDU 2/3 (=CTRL B/C)
;   bit 4 - disable SPOOLed output
;   bit 5 - not used, zero
;   bit 6 - disable printer driver (unless preceded by VDU 1)
;   bit 7 - not used, zero
;
; On Entry:
;       A = character to write
; On Exit:
;       A, X, Y are preserved
;
; ***************************************************************************************
.oswrchEntryPoint
    PHA                                                 ; }
    TXA                                                 ; }
    PHA                                                 ; } store A,X,Y registers
    TYA                                                 ; }
    PHA                                                 ; }
    TSX                                                 ; X = stack pointer
    LDA .stackPage + 3,X                                ; peek into stack to get A value back
    PHA                                                 ; push A again
    BIT .econetWriteCharacterInterceptionFlag           ; check OSWRCH interception flag
    BPL .skipEconetProcessing                           ; if (not set) then branch (skip Econet)
    TAY                                                 ; pass character to Y
    LDA #4                                              ; A=4 for OSWRCH service call
    JSR .netvJumper                                     ; call NETV code
    BCS .oswrchFinishUp                                 ; if (claimed) then branch (finish up and exit)

.skipEconetProcessing
    CLC                                                 ; prepare to not send this to printer
    LDA #2                                              ; check output destination
    BIT .characterDestinationsAvailableFlags            ; is VDU driver disabled?
    BNE .skipVDUOutput                                  ; yes, skip past VDU driver
    PLA                                                 ; pull character
    PHA                                                 ; push character
    JSR .vduChrEntryPoint                               ; call VDU driver
                                                        ; on exit, C=1 if character to be sent to printer
.skipVDUOutput
    LDA #8                                              ; check output destination
    BIT .characterDestinationsAvailableFlags            ; is printer separately enabled?
    BNE .printerEnabled                                 ; yes, jump to call printer driver
    BCC .printerDisabled                                ; carry clear, don't sent to printer

.printerEnabled
    PLA                                                 ; pull character
    PHA                                                 ; push character
    JSR .sendCharacterToPrinter                         ; call printer driver

.printerDisabled
    LDA .characterDestinationsAvailableFlags            ; check output destination
    ROR                                                 ; check RS-423 output bit
    BCC .skipRS423Output                                ; if (RS-423 output is disabled) then branch (skip past serial output)

    ; Check for timeout
    LDY .rs423TimeoutCounter                            ; get RS-423 timout counter
    DEY                                                 ; decrease counter
    BPL .skipRS423Output                                ; if (timed out) then branch (skip past serial code)

    ; RS-423 output
    PLA                                                 ; pull character
    PHA                                                 ; push character
    PHP                                                 ; save IRQs
    SEI                                                 ; disable IRQs
    LDX #.bufferNumberRS423Output                       ; X=RS-423 output buffer
    PHA                                                 ; save character
    JSR .osbyte152EntryPoint                            ; examine RS-423 output buffer to see if it's empty
    BCC +                                               ; buffer is not empty, jump to send character
    JSR .clearBusyFlagAndSetRS423Active                 ; set RS-423 Active
+
    PLA                                                 ; get character
    LDX #.bufferNumberRS423Output                       ; X=RS-423 output buffer
    JSR .addByteToBuffer                                ; send character to RS-423 output buffer
    PLP                                                 ; restore IRQs

.skipRS423Output
    LDA #$10                                            ; check output destination
    BIT .characterDestinationsAvailableFlags            ; check SPOOL output
    BNE .oswrchFinishUp                                 ; if (SPOOL output disabled) then branch (skip past SPOOL output)
    LDY .spoolFileHandle                                ; get SPOOL file handle
    BEQ .oswrchFinishUp                                 ; if (not open) then branch (skip past SPOOL output)
    PLA                                                 ; pull character
    PHA                                                 ; push character
    SEC                                                 ; }
    ROR .tapeCritical                                   ; } Set tape critical flag
    JSR .OSBPUT                                         ; write character to SPOOL channel (A=character to write, Y=file handle)
    LSR .tapeCritical                                   ; clear tape critical flag

.oswrchFinishUp
    PLA                                                 ;
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } restore A,X,Y registers
    TAX                                                 ; }
    PLA                                                 ; }
    RTS                                                 ;


; ***************************************************************************************
;
; On Entry:
;       A=character to print
;
; ***************************************************************************************
.sendCharacterToPrinter
    BIT .characterDestinationsAvailableFlags            ; check for bit 6 set
    BVS .exit16                                         ; if (printer is disabled) then branch (exit)
    CMP .printerIgnoreCharacter                         ; compare character against printer ignore character
    BEQ .exit16                                         ; if (the same) then branch (exit)

.sendValidByteToPrinter
    PHP                                                 ; save flags (including IRQ flag)
    SEI                                                 ; disable interrupts
    TAX                                                 ; store byte to send in X
    LDA #%00000100                                      ; }
    BIT .characterDestinationsAvailableFlags            ; } check bit 2 'disable printer driver'
    BNE .pullAndExit14                                  ; if (printer is disabled) then branch (pull flags and exit)
    TXA                                                 ; restore byte to send to A
    LDX #.bufferNumberPrinter                           ; X=printer buffer number
    JSR .addByteToBuffer                                ; put character in printer buffer
    BCS .pullAndExit14                                  ; if (carry set, i.e. unsuccessful) then branch (pull flags and exit)

    BIT .printerBufferEmptyFlag                         ; check buffer empty flag
    BPL .pullAndExit14                                  ; if (printer buffer is not empty) then branch (pull flags and exit)
    JSR .openPrinterChannel                             ; open printer channel
.pullAndExit14
    PLP                                                 ; restore flags (including IRQ flag)
.exit16
    RTS                                                 ;

; ***************************************************************************************
.openPrinterChannel
    LDA .printerDestination                             ; check printer destination
    BEQ .flushBufferX                                   ; if (zero) then branch (clear printer buffer and exit)
    CMP #1                                              ; }
    BNE .checkForSerialPrinter                          ; } if (parallel printer not selected) then branch (check for serial printer)

    ; deal with parallel printer
    JSR .osbyte145EntryPoint                            ; read a byte from the printer buffer
    ROR .printerBufferEmptyFlag                         ; rotate carry into bit 7 of the printer buffer empty flag
    BMI .exit17                                         ; if (printer buffer empty) then branch (return)

    ; To send data to the parallel printer:
    ;
    ; 1. Enable the User VIA interrupt '1'. The printer will trigger an IRQ when it is ready
    ;    for another character.
    ; 2. Write the byte to send to .userVIARegisterA
    ; 3. Set bits 1-3 of the userVIAPeripheralControlRegister to %110
    ; 4. Set bits 1-3 of the userVIAPeripheralControlRegister to %111
    ; This sends a 'STROBE' signal to advise the printer that valid data is waiting.

    LDY #%10000010                                      ; enable interrupt 1 of the user VIA
    STY .userVIAInterruptEnableRegister                 ; this is triggered by the printer
                                                        ; when it is ready to receive a new
                                                        ; character
    STA .userVIARegisterA                               ; pass byte to the Centronics port
    LDA .userVIAPeripheralControlRegister               ; }
    AND #%11110001                                      ; }
    ORA #%00001100                                      ; } pulse CA2 line to generate
    STA .userVIAPeripheralControlRegister               ; } STROBE signal to advise printer
    ORA #%00001110                                      ; } that valid data is waiting
    STA .userVIAPeripheralControlRegister               ; }
    BNE .exit17                                         ; ALWAYS branch (return)
                                                        ; [this could just be an RTS, saving one byte]

; ***************************************************************************************
.checkForSerialPrinter
    CMP #2                                              ; }
    BNE .userPrinter                                    ; } if (serial printer is NOT selected) then branch (check for user printer)

    ; deal with serial printer
    LDY .rs423TimeoutCounter                            ; }
    DEY                                                 ; }
    BPL .flushBufferX                                   ; } if (timeout counter is timed out) then branch (to flush the buffer)
    LSR .printerBufferEmptyFlag                         ; clear printer buffer empty flag

.clearBusyFlagAndSetRS423Active
    LSR .rs423ReadyFlag                                 ; clear RS-423 busy flag
.setRS423Active
    JSR .getRS423InputBufferFreeBytes                   ; }
    BCC .exit17                                         ; } if (free space in buffer is low) then branch (return)
    LDX #%00100000                                      ; set bit 5 on ACIA control register
                                                        ; set 'Request To Send' low (meaning Active)

.writeToACIARequestToSend
    LDY #%10011111                                      ; Mask for setting bits 5 and 6
                                                        ; This writes the 'Request To Send'
                                                        ; value.
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 156 - Update ACIA Control Register and OS Copy
;
; write (current value AND Y) EOR X
; Preserves Y and flags
;
; ***************************************************************************************
.osbyte156EntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    TYA                                                 ; A=Y
    STX .tempStoreFA                                    ; .tempStoreFA=X
    AND .rs423ControlRegisterCopy                       ; A=old value AND Y EOR X
    EOR .tempStoreFA                                    ;
    LDX .rs423ControlRegisterCopy                       ; get old value in X
.storeACIAAndPull
    STA .rs423ControlRegisterCopy                       ; put new value in
    STA .acia6850ControlRegister                        ; and store to ACIA control register
    PLP                                                 ; get back flags
.exit17
    RTS                                                 ;

; ***************************************************************************************
.userPrinter
    CLC                                                 ; clear carry
    LDA #1                                              ; A = 1
    JSR .printerServiceCall                             ;
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 123 - Warn OS about printer going dormant
;
; This call is used by the User Print Routine to indicate to the MOS that it has finished
; its task (The User Print Routine is selected by *FX 5,3).
;
; ***************************************************************************************
.osbyte123EntryPoint
    ROR .printerBufferEmptyFlag                         ; mark printer buffer empty (clear top bit)
-
    RTS                                                 ;

; ***************************************************************************************
; Signal to the printer that there's at least one character in the printer buffer, at a
; rate of 100Hz until the printer driver deals with it.
.printerServiceCallIfNotEmpty
    BIT .printerBufferEmptyFlag                         ; check printer buffer empty flag
    BMI -                                               ; if (buffer is empty) then branch (exit)
    LDA #0                                              ; A=0 (100Hz update when printer is active and buffer is not empty)
    ; fall through...

; ***************************************************************************************
;
; Econet / User printer routines
;
; See NAUG Section 24.2.4, Page 424 for more detail on reason codes
;
; On Entry:
;       A = reason code
;           0 means 100Hz update
;           1 means become active, since printer buffer is no longer empty
;           2 means VDU 2 happened (disable printer output)
;           3 means VDU 3 happened (enable printer output)
;           5 means select new printer driver (entry via OSBYTE 5 to .selectPrinterType)
;
.printerServiceCall
    LDX #.bufferNumberPrinter                           ; X=printer buffer number
.selectPrinterType
    LDY .printerDestination                             ; Y=printer destination (*FX 5 value)
    JSR .netvJumper                                     ; let network have a look (should respond if Y=4 for net printer)
    JMP (.vectorUPTV)                                   ; let user printer routine have a look (can respond if Y=3, or 5-255 for user printer)


; ***************************************************************************************
;
; Flushes the given buffer
;
; For buffer numbers, see .bufferNumberKeyboard.
;
; On Entry:
;       X=buffer number
;
; ***************************************************************************************
.flushBufferX
    CLC                                                 ; clear carry

.flushSoundBufferX
    PHA                                                 ; save A
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    BCS .flushNonSoundBufferX                           ; if (carry set on entry) then branch
    LDA .bufferTypeAndSerialBaudRatesTable,X            ; carry clear so get byte from table
    BPL .flushNonSoundBufferX                           ; if (not sound buffer) then branch
    JSR .clearSoundChannelBuffer                        ; clear sound buffer

.flushNonSoundBufferX
    SEC                                                 ; set carry
    ROR .bufferEmptyFlags,X                             ; rotate buffer flag to show buffer empty
    CPX #2                                              ;
    BCS .skipInputBufferHandling                        ; if (X > 1) then branch (it's not an input buffer)

    LDA #0                                              ; this is an input buffer
    STA .softKeyStringLength                            ; reset length of the *KEY string
                                                        ; currently being decoded (to stop
                                                        ; decoding a soft key, which would
                                                        ; otherwise add more characters into
                                                        ; the input buffer)
    STA .twosComplimentOfNumberOfBytesInVDUQueue        ; reset length of VDU queue

.skipInputBufferHandling
    JSR .purgeBuffer                                    ; purge buffer
    PLP                                                 ; restore flags
    PLA                                                 ; restore A
    RTS                                                 ;


; ***************************************************************************************
;
; Count or Purge Buffer (CNPV) - Default Entry Point
;
; On Entry:
;       X = buffer to access
;       if V set then purge buffer (else count buffer)
;       for count buffer: if C set then get bytes free
;                                  else get bytes used
;
; ***************************************************************************************
.cnpEntryPoint
    BVC .countBuffer                                    ; if (V clear) then branch (count buffer)
    LDA .bufferStartIndices,X                           ; purge buffer by setting
    STA .bufferEndIndices,X                             ; end of buffer = start of buffer
    RTS                                                 ;

.countBuffer
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    PHP                                                 ; push flags
    SEC                                                 ; set carry
    LDA .bufferEndIndices,X                             ; get end of buffer
    SBC .bufferStartIndices,X                           ; subtract start of buffer
    BCS +                                               ; if (carry set) then branch
    SEC                                                 ; set carry
    SBC .emptyBufferStartOffset,X                       ; subtract buffer start offset (i.e. add buffer length)
+
    PLP                                                 ; pull flags
    BCC +                                               ; if (carry clear) then branch (to tidy up and exit)
    CLC                                                 ; clear carry
    ADC .emptyBufferStartOffset,X                       ; adc to get bytes used
    EOR #$FF                                            ; and invert to get space left
+
    LDY #0                                              ; Y=0
    TAX                                                 ; X=A
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
;
; Adds a byte to a buffer.
;
; On failure (e.g. the buffer is full), flash the keyboard lights and keep trying
;
; On Entry:
;       A = byte to write
;       X = buffer to write into
;
; On Exit:
;       Carry clear if successful
;
; ***************************************************************************************
.addByteToBuffer
    SEI                                                 ; prevent interrupts
    JSR .insJumper                                      ; enter a byte in buffer X
    BCC .exit18                                         ; if (successful) then branch (exit)
    JSR .turnOnKeyboardLightsAndTestEscape              ; switch on both keyboard lights

    PHP                                                 ; push flags
    PHA                                                 ; push A
    JSR .keyboardIndicators                             ; switch off unselected LEDs
    PLA                                                 ; recall A
    PLP                                                 ; recall flags

    BMI .exit18                                         ; if (return is -ve, i.e. Escape pressed) then branch (exit)
    CLI                                                 ; allow interrupts
    BCS .addByteToBuffer                                ; if (byte didn't enter buffer) then branch (go back and try again)
.exit18
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 14: Star commands
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Clear four consecutive bytes in the OSFILE block
;
; The data required by the OSFILE call is stored at .osfileBlockStart, is 18 bytes long, and
; is as follows:
;
;       byte      description
;       0-1       address of filename
;       2-5       load address
;       6-9       execution address
;       10-13     start address (or length)
;       14-17     end address (or file attributes)
;
; This call clears one of these 4 byte addresses.
;
; On Entry:
;       X is the start offset within the OSFILE block
; On Exit:
;       Preserves A,X,Y
; ***************************************************************************************
.clearOSFILEAddress
    PHA                                                 ; push A
    LDA #0                                              ; A=0
    STA .osfileBlockStart + 0,X                         ; clear osfile control block workspace
    STA .osfileBlockStart + 1,X                         ;
    STA .osfileBlockStart + 2,X                         ;
    STA .osfileBlockStart + 3,X                         ;
    PLA                                                 ; get back A
    RTS                                                 ;

; ***************************************************************************************
;
; Shift one hex digit into an OSFILE address
;
; Used as part of .readOSFILEAddress
;
; On Entry:
;       A contains hex digit 0-15
;       X contains the offset into the .osfileBlockStart for the address to be updated
; On Exit:
;       The four byte address at .osfileBlockStart+X is shifted four binary bits and the new
;       digit is inserted at the least significant end.
;       Preserves Y
; ***************************************************************************************
.shiftDigitIntoAddress
    STY .tempWorkspaceE6                                ; remember Y
    ROL                                                 ; A=A*2
    ROL                                                 ; *4
    ROL                                                 ; *8
    ROL                                                 ; *16
    LDY #4                                              ; Y=loop counter
-
    ROL                                                 ; A=A*32
    ROL .osfileBlockStart + 0,X                         ; shift bit 7 of A into shift register
    ROL .osfileBlockStart + 1,X                         ; and
    ROL .osfileBlockStart + 2,X                         ; shift
    ROL .osfileBlockStart + 3,X                         ; along
    BCS .brkBadAddress                                  ; if (carry set on exit, i.e. register has overflowed) then branch ('Bad address' error)
    DEY                                                 ; decrement Y
    BNE -                                               ; if (Y > 0) then branch (do another shift)

    LDY .tempWorkspaceE6                                ; recall original Y
    RTS                                                 ;


; ***************************************************************************************
;
;   *LOAD
;
; On Entry:
;       XY = address of rest of command line
;
; ***************************************************************************************
.starLoad
    LDA #$FF                                            ; signal that load is being performed
    ; fall through...

; ***************************************************************************************
;
;   *SAVE Entry (and *LOAD continued)
;
; On Entry:
;       A=0         for *SAVE
;       A=non-zero  for *LOAD
;       XY = address of rest of command line
;
; ***************************************************************************************
.starLoadSave
    STX .stringInputBufferAddressLow                    ; store address of rest of command line
    STY .stringInputBufferAddressHigh                   ;
    STX .osfileFilenameAddressLow                       ; X and Y are stored in OSfile control block
    STY .osfileFilenameAddressHigh                      ;
    PHA                                                 ; Push A
    LDX #.osfileLoadAddressLow - .osfileBlockStart      ; X=2
    JSR .clearOSFILEAddress                             ; clear the load address
    LDY #$FF                                            ; Y=255
    STY .osfileExecAddressLow                           ; store $FF in exec address low byte

    ; For a *LOAD (A=$FF) this byte (.osfileExecAddressLow) is used as a flag (it's available
    ; since we don't need the executable address when just loading a file). Zero means use the
    ; specified load address. Non-zero means use the load address from the file. This is
    ; OSFILE behaviour.

    INY                                                 ; increment Y
    JSR .gsinitForFilenameParsing                       ; and call GSINIT to prepare for reading text line
-
    JSR .gsreadEntryPoint                               ; read a byte from text line
    BCC -                                               ; until end of line reached
    PLA                                                 ; recall original A
    PHA                                                 ;
    BEQ .starSave                                       ; if (A=0, i.e. *SAVE) then branch

    ; loading
    JSR .readOSFILEAddress                              ; read hex byte into start address
    BCS .checkForErrorAndLoadFile                       ; if (success) then branch (load using OSFILE)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line found) then branch
    ; fall through...

; ***************************************************************************************
.brkBadAddress
    BRK                                                 ;
    !byte $FC                                           ;
    !text "Bad address", 0                              ; error


; ***************************************************************************************
;
; OSBYTE 119 - Close Spool / Exec files
;
; ***************************************************************************************
.osbyte119EntryPoint
    LDX #.romServiceCallSpoolExecClosureWarning         ; } let the paged ROMs know about
    JSR .osbyte143EntryPoint                            ; } the closure of SPOOL/EXEC file
    BEQ .exit19                                         ; if (a ROM accepts and closes it) then branch (return)
    JSR .closeSpoolOrExecFile                           ; close the current file
    LDA #0                                              ; A=0
    ; fall through...

; ***************************************************************************************
;
;   *SPOOL
;
; On Entry:
;       A = 0 (and carry clear) to close the currently SPOOLed file, OR
;       A = file handle to start SPOOLing
; On Exit:
;       if closing a spooled file:
;           A, X and Y are preserved
;       if opening a spooled file:
;          A = Y = file handle for spooled file
;
; ***************************************************************************************
.starSpool
    PHP                                                 ; push flags
    STY .tempWorkspaceE6                                ; remember Y
    LDY .spoolFileHandle                                ; get file handle
    STA .spoolFileHandle                                ; store A as file handle
    BEQ +                                               ; if (Y is zero) then branch (skip forward)
    JSR .OSFIND                                         ; close the file using OSFIND
+
    LDY .tempWorkspaceE6                                ; recall Y
    PLP                                                 ; pull flags
    BEQ .exit19                                         ; if (A = 0 on entry) then branch (exit, we are done)
    LDA #$80                                            ; A is value for 'open file for output'
    JSR .OSFIND                                         ; open file XY for output using OSFIND
    TAY                                                 ; Y=A=file handle for *SPOOLed file
    BEQ .badCommandError                                ; if (result is zero) then branch ('Bad command' error)
    STA .spoolFileHandle                                ; store new file handle
.exit19
    RTS                                                 ;

; ***************************************************************************************
.checkForErrorAndLoadFile
    BNE .badCommandError                                ; if (not end of command line) then branch (show 'Bad command' error)
    INC .osfileExecAddressLow                           ; increment execution address low
                                                        ; byte to zero (when A=255 as OSFILE
                                                        ; parameter, zero means use specified
                                                        ; address)

.callOSFILEWithParameterBlockForLoadSave
    LDX #<.osfileBlockStart                             ; }
    LDY #>.osfileBlockStart                             ; } XY = address of OSFILE parameter block
    PLA                                                 ; get back A
    JMP .OSFILE                                         ; and JUMP to OSFILE

; ***************************************************************************************
;
; Read hex bytes into OSFILE address (start / end / load / exec address)
;
; On Entry:
;       X is the offset to the address to write to
;
; On Exit:
;       C set on success
;       Z set if end of line found
; ***************************************************************************************
.readOSFILEAddress
    JSR .skipSpacesAndCheckForCRInStringInput           ; look for NEWline
    JSR .readHexDigit                                   ; carry is set if it finds hex digit
    BCC .exit20                                         ; so exit
    JSR .clearOSFILEAddress                             ; clear start address in OSFILE block
-
    JSR .shiftDigitIntoAddress                          ; shift lower nybble of A into shift register
    JSR .readHexDigit                                   ; then check for Hex digit
    BCS -                                               ; if (found digit) then branch (do it again)
    SEC                                                 ; set carry
.exit20
    RTS                                                 ;


; ***************************************************************************************
.starSave
    LDX #.osfileStartAddressLow - .osfileBlockStart     ; X=offset into OSFILE block to clear start address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (no start address found) then branch (exit via 'Bad command' error)
    CLV                                                 ; clear bit 6

    ;
    ; check for '+' to indicate a length rather than the end address
    ;
    LDA (.stringInputBufferAddressLow),Y                ; read next byte from text line
    CMP #.charPLUS                                      ; is it '+'
    BNE +                                               ; if (not '+') then branch (it's the end address)
    BIT .allBitsSet                                     ; set V flag (it's the length)
    INY                                                 ; increment Y to point to hex group
+

    ;
    ; read file length/end address from command line string
    ;
    LDX #.osfileEndAddressLow - .osfileBlockStart       ; X=offset into OSFILE block for end address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (carry clear, i.e. no hex byte found) then branch ('Bad command' error)
    PHP                                                 ; save flags
    BVC .explicitEndAddressFound                        ; if (V clear; i.e. explicit end address found; i.e. no '+') then branch

    ; add start address and length, and store as end address
    LDX #$FC                                            ; X=loop counter, from $FC incrementing to $00 (4 bytes copied)
    CLC                                                 ; clear carry
-
    LDA .osfileStartAddressLow - $FC,X                  ; Get start address
    ADC .page2Start,X                                   ; add length
    STA .page2Start,X                                   ; store as end address
    INX                                                 ;
    BNE -                                               ; loop until X=0

.explicitEndAddressFound
    LDX #3                                              ; X=loop counter
-
    LDA .osfileStartAddressLow,X                        ; }
    STA .osfileExecAddressLow,X                         ; }
    STA .osfileLoadAddressLow,X                         ; } copy start adddress to load and execution addresses
    DEX                                                 ; }
    BPL -                                               ; }

    PLP                                                 ; get back flag
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of command line reached) then branch to do OSFILE

    ;
    ; read command line for execution address
    ;
    LDX #.osfileExecAddressLow - .osfileBlockStart      ; X=offset into OSFILE block for execution address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line reached) then branch (do OSFILE)

    ;
    ; read command line for load address
    ;
    LDX #.osfileLoadAddressLow - .osfileBlockStart      ; X=offset into OSFILE block for load address
    JSR .readOSFILEAddress                              ;
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    BEQ .callOSFILEWithParameterBlockForLoadSave        ; if (end of line) then branch (do OSFILE)
    ; fall through... (anything else is an error!)

; ***************************************************************************************
.badCommandError
    BRK                                                 ;
    !byte $FE                                           ; error number
    !text "Bad command"                                 ; error string. The following BRK
                                                        ; instruction is also the zero
                                                        ; terminator for this string.

.badKeyError
    BRK                                                 ;
    !byte $FB                                           ; error number
    !text "Bad key",0                                   ; string with zero terminator

; ***************************************************************************************
;
; *KEY
;
; The *KEY <number> <string> command defines one of 16 strings. These strings are associated
; with keys on the keyboard. When the key is pressed, the contents of the string are entered
; into the input buffer ('expanded'). These are also known as 'soft key' definitions.
;
;       *KEY number     Definition
;           0-9         Function keys f0-f9
;            10         When BREAK is pressed, the contents of the string are played
;            11         COPY key
;            12         LEFT key
;            13         RIGHT key
;            14         DOWN key
;            15         UP key
;
; Whether the soft keys are expanded is controlled by OSBYTE 225 (See .functionAndCursorKeyCodes)
; For the COPY key and cursor keys to be expanded, they must also be enabled using OSBYTE 4
; with X = 2 (see .osbyte4EntryPoint) which is translated into a call to OSBYTE 237, which
; updates memory location .cursorEditingType. (See .cursorEditingType)
;
; Memory
; Soft key definitions are stored in $0B00-$0BFF (See .softKeyPage). The first 16 bytes
; ($0B00-$0B0F) are a table of byte offsets from $0B01 to the start of the string definition
; for that soft key.
;
; The seventeenth byte (at $0B10) is the offset from $0B01 to the first free byte after all
; soft key definitions (See .softKeysCurrentEndOffset). If a key has no definition, it's
; offset also points to the first free byte.
;
; The string definitions follow (with no terminators).
;
; When a new key is defined (or undefined using *KEY <number>) the existing strings are
; compacted (shuffled down in memory to leave no gaps) with the old definition removed so the
; new definition can be added on the end. (See .compactStarKeyStrings). Thus the string
; definitions always appear in memory in the order they are defined, with the latest *KEY
; definition showing last.
;
; On Entry:
;   Y = offset to source string of command line
;
; ***************************************************************************************
.starKey
    JSR .parseDecimalNumberFromString                   ; set up key number in A
    BCC .badKeyError                                    ; if (not valid number) then branch ('Bad key' error)
    CPX #16                                             ; compare key number with 16
    BCS .badKeyError                                    ; if (key number is 16 or more) then branch ('Bad key' error)
    JSR .skipSpacesAndCommaValid                        ; skip commas, and check for CR
    PHP                                                 ; save flags for later (remember Z = CR found)
    LDX .softKeysCurrentEndOffset                       ; get pointer to top of existing key strings
    TYA                                                 ; }
    PHA                                                 ; } save Y to preserve text pointer
    JSR .compactStarKeyStrings                          ; compact soft key definitions
    PLA                                                 ; }
    TAY                                                 ; } restore Y
    PLP                                                 ; restore flags (recalls Z = CR found)
    BNE .addStarKeyString                               ; if (CR not found) then branch (to set up new string)
    RTS                                                 ; return (sets empty string)


; ***************************************************************************************
;
; *FX
;
; This is the entry point for the OSCLI call to execute "*FX <A>,<X>,<Y>". We parse the first
; numeric parameter ('A') then fall through to the version that parses a range of other star
; commands with 'X' and 'Y' parameters, each implemented with an OSBYTE call.
;
; ***************************************************************************************
.fxEntryPoint
    JSR .parseDecimalNumberFromString                   ; convert the number to binary
    BCC .badCommandError                                ; if (bad number) then branch ('Bad command' error)
    TXA                                                 ; put the parsed first parameter in A
    ; fall through...

; ***************************************************************************************
;
; Handle a range of star commands
;
; On Entry:
;       A = $88     *CODE
;       A = $89     *MOTOR
;       A = $8B     *OPT
;       A = $8C     *TAPE
;       A = $8D     *ROM
;       A = $90     *TV
;       A = any     *FX     (when falling through from .fxEntryPoint above)
;
; Parses star commands with one or two numeric (0-255) parameters 'X' and 'Y' (space and/or
; comma separated) then calls OSBYTE with A as above.
;
; ***************************************************************************************
.starCommandsForSpecificOSBYTEs
    PHA                                                 ; save A
    LDA #0                                              ; }
    STA .starCommandXParameter                          ; } clear the X/Y parameters for the upcoming OSBYTE call
    STA .starCommandYParameter                          ; }
    JSR .skipSpacesAndComma                             ; skip commas and check for newline (CR)
    BEQ .parsedParameters                               ; if (CR found) then branch (to call appropriate OSBYTE)

    JSR .parseDecimalNumberFromString                   ; parse first parameter (X Parameter for OSBYTE)
    BCC .badCommandError                                ; if (bad character) then branch (to give bad command error)
    STX .starCommandXParameter                          ; store as X parameter for OSBYTE
    JSR .skipSpacesAndCommaValid                        ; skip comma and check CR
    BEQ .parsedParameters                               ; if (CR found) then branch (to call appropriate OSBYTE)

    JSR .parseDecimalNumberFromString                   ; parse second parameter (Y Parameter for OSBYTE)
    BCC .badCommandError                                ; if (error) then branch ('Bad command' error)
    STX .starCommandYParameter                          ; store as Y parameter for OSBYTE
    JSR .skipSpacesAndCheckForCRInStringInput           ; now we must have a CR
    BNE .badCommandError                                ; if (no CR) then branch ('Bad command' error)

.parsedParameters
    LDY .starCommandYParameter                          ; Y = OSBYTE parameter
    LDX .starCommandXParameter                          ; X = OSBYTE parameter
    PLA                                                 ; A = OSBYTE parameter
    JSR .OSBYTE                                         ; call OSBYTE
    BVS .badCommandError                                ; if (V set on return) then branch ('Bad command' error)
    RTS                                                 ;

; ***************************************************************************************
;
; Add a new *KEY string
; See .starKey.
;
; ***************************************************************************************
.addStarKeyString
    SEC                                                 ; set carry (meaning: check for '"' marks around string)
    JSR .gsinitEntryPoint                               ; start reading string

    ; copy string into *KEY buffer
-
    JSR .gsreadEntryPoint                               ; read string
    BCS +                                               ; if (end of string reached) then branch (deal with end of string)
    INX                                                 ; point to first byte of new key definition
    BEQ .badKeyError                                    ; if (X=0, i.e. buffer overflow) then branch (exit with 'Bad Key' error)
    STA .softKeyPage,X                                  ; store character
    BCC -                                               ; if (not end of line) then branch (loop to copy next byte)

+
    BNE .badKeyError                                    ; if (parsing error) then branch (show 'Bad Key' error)
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    JSR .compactStarKeyStrings                          ; compact *KEY definitions with the stored string definition

    ; Update the array of offsets that point to the start of each string
    LDX #$10                                            ; set loop counter
-
    CPX .tempWorkspaceE6                                ; check for key already being defined
    BEQ .skipRestOfLoop                                 ; if (key already being defined) then branch (skip rest of loop)
    LDA .softKeyPage,X                                  ; get start of string X
    CMP .softKeyPage,Y                                  ; compare with start of string Y
    BNE .skipRestOfLoop                                 ; if (not the same) then branch (skip rest of loop)
    LDA .softKeysCurrentEndOffset                       ; store top of string definition
    STA .softKeyPage,X                                  ; in designated key pointer
.skipRestOfLoop
    DEX                                                 ; decrement loop pointer X
    BPL -                                               ; and do it all again
    PLP                                                 ; get back flags
    RTS                                                 ;


; ***************************************************************************************
;
; Get *KEY string length
;
; Get the length of a soft key definition. See .starKey.
;
; On Entry:
;       Y = *KEY number
;
; On Exit:
;       A = string length
;       Preserves X
;
; ***************************************************************************************
.getStarKeyStringLength
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .softKeysCurrentEndOffset                       ; get top of currently defined strings
    SEC                                                 ;
    SBC .softKeyPage,Y                                  ; subtract to get the number of bytes in strings above end of string Y
    STA .tempStoreFB                                    ; store this
    TXA                                                 ; save X
    PHA                                                 ;
    LDX #$10                                            ; and X=16

-
    LDA .softKeyPage,X                                  ; get start offset (from .softKeyPage) of key string X
    SEC                                                 ;
    SBC .softKeyPage,Y                                  ; subtract offset of string we are working on
    BCC +                                               ; if (carry clear, i.e. .softKeyPage+Y > .softKeyPage+X) then branch (forward)
    BEQ +                                               ; if (result in A=0) then branch (forward)
    CMP .tempStoreFB                                    ; check against number of bytes above string we are working on
    BCS +                                               ; if (>= number of bytes above string we are working on) then branch
    STA .tempStoreFB                                    ; store A in .tempStoreFB
+
    DEX                                                 ; point to next lower key offset
    BPL -                                               ; if (not negative) then branch (loop back and do it again)

    PLA                                                 ; get back value of X
    TAX                                                 ;
    LDA .tempStoreFB                                    ; get back latest value of A
    PLP                                                 ; pull flags
    RTS                                                 ;

; ***************************************************************************************
;
; Compact *KEY strings
;
; Remove an existing definition, and move the remaining definitions down in memory (so that
; we can add a new definition on the end).
; See .starKey.
;
; On Entry:
;       .tempWorkspaceE6 = key number
; On Exit:
;       X is preserved
;
; ***************************************************************************************
.compactStarKeyStrings
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    TXA                                                 ; save X
    PHA                                                 ; push A
    LDY .tempWorkspaceE6                                ; get key number
    JSR .getStarKeyStringLength                         ; and set up .tempStoreFB to length of existing string
    LDA .softKeyPage,Y                                  ; get start of string Y
    TAY                                                 ; put it in Y
    CLC                                                 ; clear carry
    ADC .tempStoreFB                                    ; add number of bytes for existing string
    TAX                                                 ; X = new end position
    STA .tempStoreFA                                    ; and store it in .tempStoreFA
    LDA .softKeyStringLength                            ; check to see if we are already defining a *KEY string
    BEQ +                                               ; if (key is not already being defined) branch
.keyInUseError
    BRK                                                 ; definition expanded) so error.  This stops *KEY 1 "*key1 FRED" etc.
    !byte $FA                                           ; error number
    !text "Key in use",0                                ;

+
    DEC .softKeyConsistencyFlag                         ; decrement consistency flag to $FF to warn that key definitions are being changed
    PLA                                                 ; pull A
    SEC                                                 ;
    SBC .tempStoreFA                                    ; subtract .tempStoreFA
    STA .tempStoreFA                                    ; and re store it
    BEQ +                                               ; if (zero) then branch

    ; move string from offset X to offset Y
-
    LDA .softKeyPage + 1,X                              ; read byte from offset X
    STA .softKeyPage + 1,Y                              ; write character to offset Y
    INY                                                 ; increment pointer
    INX                                                 ; increment pointer
    DEC .tempStoreFA                                    ; decrement loop counter
    BNE -                                               ; if (not done yet) then branch (loop back)

+
    TYA                                                 ; store end of moved string(s)
    PHA                                                 ;
    LDY .tempWorkspaceE6                                ; get back key number

    ; adjust the offset to each KEY now we have moved one
    LDX #$10                                            ; point at top of last string
-
    LDA .softKeyPage,X                                  ; get this value
    CMP .softKeyPage,Y                                  ; compare it with start of new or re defined key
    BCC +                                               ; if (less) then branch
    BEQ +                                               ; if (equal) then branch
    SBC .tempStoreFB                                    ; shift key definitions accordingly
    STA .softKeyPage,X                                  ; store new offset to KEY X
+
    DEX                                                 ; point to next lowest string def
    BPL -                                               ; if (X=>0) then branch (loop back and do it again)

    LDA .softKeysCurrentEndOffset                       ; make top of key definitions
    STA .softKeyPage,Y                                  ; the start of our key def
    PLA                                                 ; get new end of strings
    STA .softKeysCurrentEndOffset                       ; and store it
    TAX                                                 ; put A in X
    INC .softKeyConsistencyFlag                         ; reset consistency flag
    PLP                                                 ; restore flags
    RTS                                                 ;


; ***************************************************************************************
.bufferAddressesHigh
    !byte >(.keyboardInputBuffer - .keyboardInputBufferOffset)       ; 0 = Keyboard
    !byte >(.tapeOrRS423InputBuffer - .tapeOrRS423InputBufferOffset) ; 1 = tape/RS-423 Input
    !byte >(.tapeOrRS423OutputBuffer - .rs423OutputBufferOffset)     ; 2 = RS-423 output
    !byte >(.printerBuffer - .printerBufferOffset)                   ; 3 = printer
    !byte >(.soundChannel0Buffer - .soundChannel0BufferOffset)       ; 4 = sound channel 0
    !byte >(.soundChannel1Buffer - .soundChannel1BufferOffset)       ; 5 = sound channel 1
    !byte >(.soundChannel2Buffer - .soundChannel2BufferOffset)       ; 6 = sound channel 2
    !byte >(.soundChannel3Buffer - .soundChannel3BufferOffset)       ; 7 = sound channel 3
    !byte >(.speechBuffer - .speechBufferOffset)                     ; 8 = speech

; ***************************************************************************************
.bufferAddressesLow
    !byte <(.keyboardInputBuffer - .keyboardInputBufferOffset)       ; 0 = Keyboard
    !byte <(.tapeOrRS423InputBuffer - .tapeOrRS423InputBufferOffset) ; 1 = tape/RS-423 Input
    !byte <(.tapeOrRS423OutputBuffer - .rs423OutputBufferOffset)     ; 2 = RS-423 output
    !byte <(.printerBuffer - .printerBufferOffset)                   ; 3 = printer
    !byte <(.soundChannel0Buffer - .soundChannel0BufferOffset)       ; 4 = sound channel 0
    !byte <(.soundChannel1Buffer - .soundChannel1BufferOffset)       ; 5 = sound channel 1
    !byte <(.soundChannel2Buffer - .soundChannel2BufferOffset)       ; 6 = sound channel 2
    !byte <(.soundChannel3Buffer - .soundChannel3BufferOffset)       ; 7 = sound channel 3
    !byte <(.speechBuffer - .speechBufferOffset)                     ; 8 = speech

; ***************************************************************************************
.emptyBufferStartOffset
    !byte .keyboardInputBufferOffset                    ; 0 = Keyboard
    !byte .tapeOrRS423InputBufferOffset                 ; 1 = tape/RS-423 Input
    !byte .rs423OutputBufferOffset                      ; 2 = RS-423 output
    !byte .printerBufferOffset                          ; 3 = printer
    !byte .soundChannel0BufferOffset                    ; 4 = sound channel 0
    !byte .soundChannel1BufferOffset                    ; 5 = sound channel 1
    !byte .soundChannel2BufferOffset                    ; 6 = sound channel 2
    !byte .soundChannel3BufferOffset                    ; 7 = sound channel 3
    !byte .speechBufferOffset                           ; 8 = speech

; ***************************************************************************************
;
; Get buffer address
;
; For buffer numbers, see .bufferNumberKeyboard.
;
; On Entry:
;       X=buffer number
;
; ***************************************************************************************
.getBufferAddress
    LDA .bufferAddressesLow,X                           ; get buffer base address low
    STA .tempStoreFA                                    ; store it
    LDA .bufferAddressesHigh,X                          ; get buffer base address high
    STA .tempStoreFB                                    ; store it
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 152 - Examine buffer status
;
; On Entry:
;       X = buffer number
; On Exit:
;       X preserved
;       if buffer is empty C=1, Y is preserved
;                     else C=0, Y is offset to next character in buffer at $FA/B
;
; ***************************************************************************************
.osbyte152EntryPoint
    BIT .allBitsSet                                     ; set V flag (meaning examine buffer)
    BVS .remJumper                                      ; ALWAYS branch (see .remEntryPoint
                                                        ; for default entry point)

; ***************************************************************************************
;
; OSBYTE 145 - Get byte from buffer
;
; On Entry:
;       X = buffer number
; On Exit:
;       X preserved
;       Y = character extracted
;       if buffer is empty C=1, else C=0
;
; ***************************************************************************************
.osbyte145EntryPoint
    CLV                                                 ; clear V
.remJumper
    JMP (.vectorREMV)                                   ; Jump via REMV. Default destination
                                                        ; is .remEntryPoint below

; ***************************************************************************************
;
; REMV - default entry point for remove from/examine buffer vector
;
; On Entry:
;       X = buffer number
;       V = 1 if only examination is requested
; On Exit:
;       Examination Only:   A = next byte to be removed
;                           X preserved
;                           Y = offset to next character in buffer at $FA/B
;
;       Removal:            A undefined
;                           X preserved
;                           Y = value of the byte removed
;
;       if buffer was already empty C=1
;                              else C=0
;
; Used by: OSBYTE 152 - examine buffer status
;      and OSBYTE 145 - get byte from buffer
;
; ***************************************************************************************
.remEntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .bufferStartIndices,X                           ; get output pointer for buffer X
    CMP .bufferEndIndices,X                             ; compare to input pointer
    BEQ .pullSetCarryAndExit                            ; if (equal, i.e. buffer is empty) then branch (exit)
    TAY                                                 ; Y = buffer start position
    JSR .getBufferAddress                               ; and get buffer pointer into .tempStoreFA/B
    LDA (.tempStoreFA),Y                                ; read byte from buffer
    BVS .pullClearCarryAndExit                          ; if (V is set, i.e. only examination) then branch (exit with CARRY clear)
                                                        ; OSBYTE 152 has been done
    PHA                                                 ; must be OSBYTE 145 so save byte
    INY                                                 ; increment Y
    TYA                                                 ; A=Y
    BNE +                                               ; if (end of buffer not reached) then branch
    LDA .emptyBufferStartOffset,X                       ; get pointer start from offset table
+
    STA .bufferStartIndices,X                           ; set buffer output pointer
    CPX #2                                              ;
    BCC .recallAndExit                                  ; if (buffer is input; 0=keyboard or 1=RS-423 input) then branch

    CMP .bufferEndIndices,X                             ; for output buffers compare with buffer start
    BNE .recallAndExit                                  ; if (not the same, i.e. buffer is not empty) then branch

    LDY #.eventOutputBufferBecomesEmpty                 ; buffer is empty so Y=0
    JSR .eventEntryPoint                                ; and enter EVENT routine to signal EVENT 0 - buffer becoming empty

.recallAndExit
    PLA                                                 ; get back byte from buffer
    TAY                                                 ; put it in Y
.pullClearCarryAndExit
    PLP                                                 ; get back flags
    CLC                                                 ; clear carry to indicate success
    RTS                                                 ;

; ***************************************************************************************
;
; Trigger an event
;
; Events
;
; Events are a slightly simpler way for users to use an interrupt. Events are disabled by
; default, but can be enabled via OSBYTE 14 (see .osbyte14EntryPoint). Different event types
; can be individually enabled or disabled. For the list of different event types,
; see .eventOutputBufferBecomesEmpty.
;
; Most events are generated from the default IRQ handling code. When a relevant interrupt
; happens .eventEntryPoint is called with the event type. If enabled, this calls the EVNTV
; vector with the event type in the accumulator. The default implementation of the EVNTV
; vector does nothing, but the user can intercept this vector and do their own processing.
;
; This provides a simpler (and more limited) interface to handling interrupts than
; intercepting the IRQ1 or IRQ2 vectors directly. Events can't override the default interrupt
; handling, but are executed in addition.
;
; As with regular interrupt code, event handling code must not enable interrupts, and should
; be brief (The Acorn User Guide suggests "one millisecond maximum", 2000 clock cycles,
; whereas the New Advanced User Guide suggests it should "not last for more than about 2ms").
;
; The user can generate their own events by calling .OSEVEN with A=9 (.eventUserEvent)
;
; (See NAUG Section 7, Page 119)
;
; On Entry:
;       A = parameter to pass into EVENV vector in Y
;       X = parameter to pass into EVENV vector in X
;       Y = event type
; On Exit:
;       A is preserved.
;       Flags are preserved except for carry:
;       Carry clear indicates the event was called successfully because it was enabled.
;
; ***************************************************************************************
.eventEntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    PHA                                                 ; push A
    STA .tempStoreFA                                    ; .tempStoreFA = A
    LDA .eventEnabledFlags,Y                            ; get enable event flag
    BEQ .pullTwiceSetCarryAndExit                       ; if (event is not enabled) then branch (exit with carry set)
    TYA                                                 ; Y = event enabled flag
    LDY .tempStoreFA                                    ; Y = original A
    JSR .eventJumper                                    ; call the EVENV vector
    PLA                                                 ; get back A
    PLP                                                 ; get back flags
    CLC                                                 ; clear carry for success
    RTS                                                 ;

; ***************************************************************************************
.generateEventAndPutByteIntoBuffer
    TYA                                                 ; A=Y
    LDY #.eventCharacterEnteringInputBuffer             ; Y=2
    JSR .eventEntryPoint                                ; send event
    TAY                                                 ; Y=A
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 138 - Put byte into buffer
;
; On Entry:
;       X is buffer number
;       Y is character to be written
;
; ***************************************************************************************
.osbyte138EntryPoint
    TYA                                                 ; A=Y
.insJumper
    JMP (.vectorINSV)                                   ; jump to INSV


; ***************************************************************************************
;
; INSV - insert value into buffer - default handler
;
; On Entry:
;       A is value to write
;       X is buffer number
; On Exit:
;       A preserved
;       X preserved
;       C clear on success
;
; ***************************************************************************************
.insEntryPoint
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    PHA                                                 ; save A
    LDY .bufferEndIndices,X                             ; get buffer input pointer
    INY                                                 ; increment Y to next byte
    BNE +                                               ; if (not reached the end index) then branch (skip forward)
    LDY .emptyBufferStartOffset,X                       ; set back to the start index
+
    TYA                                                 ; put it in A
    CMP .bufferStartIndices,X                           ; compare it with input pointer
    BEQ .insertIntoFullBuffer                           ; if (buffer is full) then branch
    LDY .bufferEndIndices,X                             ; get buffer end in Y
    STA .bufferEndIndices,X                             ; set new offset
    JSR .getBufferAddress                               ; and point .tempStoreFA/B at it
    PLA                                                 ; get back value to write
    STA (.tempStoreFA),Y                                ; write it in buffer
    PLP                                                 ; pull flags
    CLC                                                 ; clear carry for success
    RTS                                                 ;

.insertIntoFullBuffer
    PLA                                                 ; get back byte
    CPX #2                                              ; }
    BCS .pullSetCarryAndExit                            ; } if we are working on output buffer then branch

    LDY #.eventInputBufferBecomesFull                   ; input buffer is full
    JSR .eventEntryPoint                                ; to service input buffer full event
    PHA                                                 ; push A

.pullTwiceSetCarryAndExit
    PLA                                                 ; restore A
.pullSetCarryAndExit
    PLP                                                 ; restore flags
    SEC                                                 ; set carry
    RTS                                                 ;

; ***************************************************************************************
;
; Check for a letter (A-Z or a-z)
;
; On Entry:
;       A = character to check
; On Exit:
;       Preserves A
;       Carry clear if character is an upper or lower case letter (A-Z or a-z)
;       otherwise carry set
;
; ***************************************************************************************
.isLetter
    PHA                                                 ; save A
    AND #$DF                                            ; convert lower to upper case
    CMP #.charA                                         ; compare with 'A'
    BCC .noLetter                                       ; if (lower than 'A') then branch (exit routine with carry set)
    CMP #.charZ + 1                                     ; compare with 'Z' + 1
    BCC .yesLetter                                      ; if (no larger than 'Z') then branch (exit with carry clear)
.noLetter
    SEC                                                 ; set carry
.yesLetter
    PLA                                                 ; restore original value of A
    RTS                                                 ;

; [ Alternatively this would use four fewer bytes...
; .isLetter
;    PHA                                                ; Save A
;    AND #$DF                                           ; convert lower to upper case
;    SEC                                                ;
;    SBC #.charA                                        ; 'A'-'Z' maps to 0-25
;    CMP #26                                            ; check if in range 0-25
;    PLA                                                ;
;    RTS                                                ; ]

; ***************************************************************************************
.insertByteIntoKeyboardBuffer
    LDX #0                                              ; X=0 to indicate keyboard buffer
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 153 - Put byte in input buffer
;
; On Entry:
;       X is buffer number:
;           1 is RS-423 input
;           0 is Keyboard
;       Y is character to be written
;
; On Exit:
;       Carry clear
;
; ***************************************************************************************
.osbyte153EntryPoint
    TXA                                                 ; A=buffer number
    AND .rs423Mode                                      ; AND with RS-423 mode:
                                                        ; (0 = treat as keyboard;
                                                        ;  1 = ignore Escapes, no events, no soft keys)
    BNE .osbyte138EntryPoint                            ; if (RS-423 input buffer) AND (RS-423 in normal mode) then branch (enter byte into buffer)
    TYA                                                 ; Y=character to write
    EOR .asciiCodeThatGeneratesESCAPEAction             ; compare with current escape ASCII code (0=match)
    ORA .escapeAction                                   ; or with current ESCAPE status (0=ESC, 1=ASCII)
    BNE .generateEventAndPutByteIntoBuffer              ; if (not ESCAPE character) OR (ESCAPE action says ASCII) then branch (to enter byte in buffer)
    LDA .escapeAndBreakEffect                           ; get ESCAPE/BREAK effect byte
    ROR                                                 ; Rotate to get ESCAPE bit into carry
    TYA                                                 ; get character back in A
    BCS .exitWithCarryClear                             ; if (escape effect disabled) then branch (exit with carry clear)
    LDY #.eventESCAPEConditionDetected                  ; signal event "Escape condition detected"
    JSR .eventEntryPoint                                ;
    BCC .exitWithCarryClear                             ; if (event handles ESCAPE) then branch (exit with carry clear)
    JSR .osbyte125EntryPoint                            ; set ESCAPE flag

.exitWithCarryClear
    CLC                                                 ; clear carry
    RTS                                                 ;

; ***************************************************************************************
;
; Handle cursor, COPY and soft keys for non-zero cursor editing type
;
; On Entry:
;       A = cursor editing type
;           1 = return $87 - $8B (codes for COPY, LEFT, RIGHT, DOWN, UP)
;           2 = use cursor keys as soft keys 11-15
;
; ***************************************************************************************
.handleCursorKeysAndCOPY
    ROR                                                 ; get bit 0 of cursor editing type
                                                        ; into carry

    ; carry is set means cursor keys return codes $87-$8B
    ; carry  clear means cursor keys and COPY key are soft keys 11=COPY,12=LEFT,13=RIGHT,
    ;                                                           14=DOWN,15=UP

    PLA                                                 ; get back character A
    BCS .exitWithCarryClear2                            ; if (carry set) then branch (exit)

    ; cursor keys are 'soft'
.handleFunctionKeyPress
    TYA                                                 ; A=Y get back original key code ($80-$FF)
    PHA                                                 ; PUSH A
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } shift high nybble down into low nybble
    LSR                                                 ; }
                                                        ; A=$08 - $0F
    EOR #4                                              ; invert bit 2
                                                        ; $08 becomes $0C
                                                        ; $09 becomes $0D
                                                        ; $0A becomes $0E
                                                        ; $0B becomes $0F
                                                        ; $0C becomes $08
                                                        ; $0D becomes $09
                                                        ; $0E becomes $0A
                                                        ; $0F becomes $0B
    TAY                                                 ;
    LDA .functionAndCursorKeyCodes - 8,Y                ; read key interpretation

    ; Key interpretation:
    ;
    ;     0 = ignore key
    ;     1 = expand as 'soft' key
    ; 2-$FF = add this to base for 'ASCII' code note that provision is made for keypad
    ; operation as codes $C0-$FF cannot be generated from keyboard but are recognised
    ; by OS

    CMP #1                                              ; is it 1
    BEQ .expandSoftKey                                  ; if (expand as 'soft' key required)
                                                        ; then branch (expand as 'soft' key)
    PLA                                                 ; get back original byte
    BCC .readFromInputBufferX                           ; if (zero, i.e. ignore key) then
                                                        ; branch

    ; add base value to get 'ASCII' code
    AND #$0F                                            ; add ASCII to BASE key number so
                                                        ; clear high nybble
    CLC                                                 ; clear carry
    ADC .functionAndCursorKeyCodes - 8,Y                ; add ASCII base
    CLC                                                 ; clear carry
    RTS                                                 ;

; ***************************************************************************************
.errorOnReadingCharacterFromScreen
    JSR .vdu7EntryPoint                                 ; produce bell
    PLA                                                 ; get back A, buffer number
    TAX                                                 ; X=buffer number
    ; fall through...

; ***************************************************************************************
;
; Read from input buffer X (0 = keyboard; 1 = RS-423)
;
; ***************************************************************************************
.readFromInputBufferX
    JSR .osbyte145EntryPoint                            ; get byte from buffer X
    BCS .exit21                                         ; if (buffer is empty) then branch (return)
    PHA                                                 ; push byte received
    CPX #.bufferNumberRS423Input                        ; check for RS-423 Input buffer
    BNE +                                               ; if (not RS-423 input buffer) then branch

    JSR .setRS423Active                                 ;
    LDX #.bufferNumberRS423Input                        ; X=RS-423 input buffer
    SEC                                                 ; set carry
+
    PLA                                                 ; get back original byte
    BCC +                                               ; if (carry clear, i.e. X=0, the keyboard buffer) then branch forward
    LDY .rs423Mode                                      ; Y=RS-423 mode
                                                        ;   0 means treat RS-423 input same as keyboard
                                                        ;   1 means ESCAPE is ignored; soft keys are not expanded; no events are triggered
    BNE .exitWithCarryClear2                            ; if (normal RS-423 mode) then branch (exit)

+
    TAY                                                 ; Y=original character to add to buffer
    BPL .exitWithCarryClear2                            ; if (code is less than $80) then branch (it's simple, so exit)
    AND #%00001111                                      ; clear high nybble
    CMP #11                                             ; compare with 11
    BCC .handleFunctionKeyPress                         ; if (less than 11, i.e. function key) then branch
    ADC #$7B                                            ; add $7C ($7B+Carry) to convert codes $0B-$0F to $87-$8B
    PHA                                                 ; Push A
    LDA .cursorEditingType                              ; get cursor editing type
    BNE .handleCursorKeysAndCOPY                        ; if (standard cursor key editing is disabled) then branch
    LDA .characterDestinationsAvailableFlags            ; get character destination status

                                                        ; bit 0 - enable RS-423 driver
                                                        ; bit 1 - disable VDU driver
                                                        ; bit 2 - disable printer driver
                                                        ; bit 3 - enable printer, independent of CTRL-B/C
                                                        ; bit 4 - disable SPOOLed output
                                                        ; bit 5 - not used
                                                        ; bit 6 - disable printer driver (unless preceded by VDU 1)
                                                        ; bit 7 - not used

    ROR                                                 ; get bit 1 into carry
    ROR                                                 ;
    PLA                                                 ;
    BCS .readFromInputBufferX                           ; if (carry is set, i.e. VDU disabled) then branch
    CMP #.charCOPY                                      ; check for COPY key
    BEQ .handleCOPYkeyToReadCharacterFromScreen         ; if (COPY key pressed) then branch (handle COPY key)

    TAY                                                 ; Y=A
    TXA                                                 ; A=X
    PHA                                                 ; Push X
    TYA                                                 ; get back Y
    JSR .splitIntoTwoCursors                            ; Split into the WRITE and READ cursors

    PLA                                                 ; restore X
    TAX                                                 ;

.readFromEconetOrSoftKeyOrInputBufferA
    BIT .econetReadCharacterInterceptionFlag            ; check Econet RDCH flag
    BPL .readFromSoftKeyOrInputBufferA                  ; if (not set) then branch
    LDA #6                                              ; Econet function 6
.netvJumper
    JMP (.vectorNETV)                                   ; to the Econet vector

.readFromSoftKeyOrInputBufferA
    LDA .softKeyStringLength                            ; get length of *KEY string
    BEQ .readFromInputBufferX                           ; if (no soft key) then branch (get a character from the buffer)
    LDY .softKeyExpansionPointer                        ; get soft key expansion pointer
    LDA .softKeyPage + 1,Y                              ; get character from string
    INC .softKeyExpansionPointer                        ; increment pointer
    DEC .softKeyStringLength                            ; decrement length
.exitWithCarryClear2
    CLC                                                 ;
.exit21
    RTS                                                 ;

; ***************************************************************************************
;
; Expand Soft Key (*KEY expansion)
;
; On Entry:
;       Y=pointer to string number
;
; ***************************************************************************************
.expandSoftKey
    PLA                                                 ; restore original code
    AND #$0F                                            ; get low nybble (key string number)
    TAY                                                 ; Y=A
    JSR .getStarKeyStringLength                         ; get string length in A
    STA .softKeyStringLength                            ; store it
    LDA .softKeyPage,Y                                  ; get start point
    STA .softKeyExpansionPointer                        ; store it
    BNE .readFromEconetOrSoftKeyOrInputBufferA          ; ALWAYS branch (get byte and exit)

; ***************************************************************************************
.handleCOPYkeyToReadCharacterFromScreen
    TXA                                                 ; A=X
    PHA                                                 ; Push A
    JSR .readCharacterFromScreenAndCursorRight          ; read a character from the screen
    TAY                                                 ; Y=A
    BEQ .errorOnReadingCharacterFromScreen              ; if (A=0, i.e. not valid) then branch (beep)
    PLA                                                 ; restore X
    TAX                                                 ;
    TYA                                                 ; and Y
    CLC                                                 ; clear carry
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 15: OSBYTE and OSWORD
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE/OSWORD lookup table
;
; Valid OSBYTEs are in the arbitrary ranges 0-21, 117-160, 166-255. The range 166-255 reads
; and writes to a contiguous range of memory locations, and are implemented by a single
; routine. Otherwise the reasoning behind these ranges is unclear. Perhaps 0-21 were
; anticipated (erroneously or otherwise) to be the more commonly used OSBYTEs?
;
; Valid OSWORDs are in the range 0-13, and OSWORDs 224-255 are sent through USERV.
;
; ***************************************************************************************
.osbyteAndOSWORDRoutineTable
    !word .osbyte0EntryPoint        ; OSBYTE   0 - Display version number
    !word .osbyte1EntryPoint        ; OSBYTE   1 - Read/Write user flag
    !word .osbyte2EntryPoint        ; OSBYTE   2 - select input stream
    !word .osbyte3EntryPoint        ; OSBYTE   3 - Select output stream
    !word .osbyte4EntryPoint        ; OSBYTE   4 - Enable / disable cursor editing
    !word .osbyte5EntryPoint        ; OSBYTE   5 - Select printer type
    !word .osbyte6EntryPoint        ; OSBYTE   6 - Set printer ignore character
    !word .osbyte7EntryPoint        ; OSBYTE   7 - Set RS-423 baud rate for receiving data
    !word .osbyte8EntryPoint        ; OSBYTE   8 - Set RS-423 baud rate for transmitting data
    !word .osbyte9EntryPoint        ; OSBYTE   9 - Duration of first colour
    !word .osbyte10EntryPoint       ; OSBYTE  10 - Duration of second colour
    !word .osbyte11EntryPoint       ; OSBYTE  11 - Set keyboard autorepeat delay
    !word .osbyte12EntryPoint       ; OSBYTE  12 - Set keyboard autorepeat rate
    !word .osbyte13EntryPoint       ; OSBYTE  13 - Disable events
    !word .osbyte14EntryPoint       ; OSBYTE  14 - Enable events
    !word .osbyte15EntryPoint       ; OSBYTE  15 - Flush selected buffer class
    !word .osbyte16EntryPoint       ; OSBYTE  16 - Select ADC channels
    !word .osbyte17EntryPoint       ; OSBYTE  17 - Start ADC conversions
    !word .osbyte18EntryPoint       ; OSBYTE  18 - Reset soft keys
    !word .osbyte19EntryPoint       ; OSBYTE  19 - Wait for vertical sync
    !word .osbyte20EntryPoint       ; OSBYTE  20 - 'Explode' soft character definitions
    !word .osbyte21EntryPoint       ; OSBYTE  21 - Flush specific buffer

    !word .osbyte117EntryPoint      ; OSBYTE 117 - Read VDU status
    !word .osbyte118EntryPoint      ; OSBYTE 118 - Set keyboard LEDs based on keyboard status
    !word .osbyte119EntryPoint      ; OSBYTE 119 - Close Spool / Exec files
    !word .osbyte120EntryPoint      ; OSBYTE 120 - Write key pressed data
    !word .osbyte121EntryPoint      ; OSBYTE 121 - Keyboard scan from value in X
    !word .osbyte122EntryPoint      ; OSBYTE 122 - Keyboard scan from 16 decimal
    !word .osbyte123EntryPoint      ; OSBYTE 123 - Warn OS about printer going dormant
    !word .osbyte124EntryPoint      ; OSBYTE 124 - Clear ESCAPE condition
    !word .osbyte125EntryPoint      ; OSBYTE 125 - Set ESCAPE condition
    !word .osbyte126EntryPoint      ; OSBYTE 126 - Acknowledge detection of ESCAPE condition
    !word .osbyte127EntryPoint      ; OSBYTE 127 - Check for EOF on open file
    !word .osbyte128EntryPoint      ; OSBYTE 128 - Read ADC Channel / get buffer status
    !word .osbyte129EntryPoint      ; OSBYTE 129 - Read key within time limit
    !word .osbyte130EntryPoint      ; OSBYTE 130 - Read machine high order address
    !word .osbyte131EntryPoint      ; OSBYTE 131 - Read OSHWM (OS High Water Mark)
    !word .osbyte132EntryPoint      ; OSBYTE 132 - Read HIMEM (start of screen memory)
    !word .osbyte133EntryPoint      ; OSBYTE 133 - Read start of screen memory for given MODE
    !word .osbyte134EntryPoint      ; OSBYTE 134 - Read text cursor position
    !word .osbyte135EntryPoint      ; OSBYTE 135 - Read character at text cursor position
    !word .osbyte136EntryPoint      ; OSBYTE 136 - Execute code via User Vector (*CODE)
    !word .osbyte137EntryPoint      ; OSBYTE 137 - Turn on tape motor
    !word .osbyte138EntryPoint      ; OSBYTE 138 - Put byte into buffer
    !word .osbyte139EntryPoint      ; OSBYTE 139 - Select file options (*OPT)
    !word .osbyte140EntryPoint      ; OSBYTE 140 - Select TAPE file system
    !word .osbyte141EntryPoint      ; OSBYTE 141 - Select ROM file system
    !word .osbyte142EntryPoint      ; OSBYTE 142 - Enter language ROM (at $8000)
    !word .osbyte143EntryPoint      ; OSBYTE 143 - Pass service commands to sideways ROMs
    !word .osbyte144EntryPoint      ; OSBYTE 144 - *TV
    !word .osbyte145EntryPoint      ; OSBYTE 145 - Get byte from buffer
    !word .osbyte146EntryPoint      ; OSBYTE 146 - Read a byte from FRED
    !word .osbyte147EntryPoint      ; OSBYTE 147 - Write a byte to FRED
    !word .osbyte148EntryPoint      ; OSBYTE 148 - Read a byte from JIM
    !word .osbyte149EntryPoint      ; OSBYTE 149 - Write a byte to JIM
    !word .osbyte150EntryPoint      ; OSBYTE 150 - Read a byte from SHEILA
    !word .osbyte151EntryPoint      ; OSBYTE 151 - Write a byte to SHEILA
    !word .osbyte152EntryPoint      ; OSBYTE 152 - Examine buffer status
    !word .osbyte153EntryPoint      ; OSBYTE 153 - Put byte in input buffer
    !word .osbyte154EntryPoint      ; OSBYTE 154 - Write to Video ULA's Video Control Register
    !word .osbyte155EntryPoint      ; OSBYTE 155 - Set palette value
    !word .osbyte156EntryPoint      ; OSBYTE 156 - Update ACIA Control Register and OS Copy
    !word .osbyte157EntryPoint      ; OSBYTE 157 - Fast Tube BPUT
    !word .osbyte158EntryPoint      ; OSBYTE 158 - Read byte from speech processor
    !word .osbyte159EntryPoint      ; OSBYTE 159 - Write byte to speech processor
    !word .osbyte160EntryPoint      ; OSBYTE 160 - Read VDU Variable

    !word .osbyte166to255EntryPoint ; OSBYTE 166 to 255 - Implemented via table lookup
    !word .uservJumper              ; OSWORD 224-255 (unknown OSWORDs sent through USERV)

;
; OSWORD lookup table - effectively a continuation of the same table as above
;
    !word .osword0EntryPoint        ; OSWORD   0 - Read line from current input into memory
    !word .osword1EntryPoint        ; OSWORD   1 - Read system clock
    !word .osword2EntryPoint        ; OSWORD   2 - Write system clock
    !word .osword3EntryPoint        ; OSWORD   3 - Read interval timer
    !word .osword4EntryPoint        ; OSWORD   4 - Write interval timer
    !word .osword5EntryPoint        ; OSWORD   5 - Read a byte from I/O memory
    !word .osword6EntryPoint        ; OSWORD   6 - Write a byte to I/O memory
    !word .osword7EntryPoint        ; OSWORD   7 - Make a sound
    !word .osword8EntryPoint        ; OSWORD   8 - Define an envelope
    !word .osword9EntryPoint        ; OSWORD   9 - Read a pixel
    !word .osword10EntryPoint       ; OSWORD  10 - Read character definition
    !word .osword11EntryPoint       ; OSWORD  11 - Read palette
    !word .osword12EntryPoint       ; OSWORD  12 - Write Palette
    !word .osword13EntryPoint       ; OSWORD  13 - Read last two graphic cursor positions


; ***************************************************************************************
;
; OSBYTE 136 - Execute code via User Vector (*CODE)
;
; ***************************************************************************************
.osbyte136EntryPoint
    LDA #0                                              ; A=0
    ; fall through...

; ***************************************************************************************
;
; Jumps to the User vector
;
; This is called in response to *CODE, *LINE, or an OSWORD in the range 224-255. By default
; this does nothing, but user code can intercept the USERV vector to provide new functionality
; for these calls.
;
; On Entry:
;       A=0         called from *CODE / *FX 136         .osbyteX / .osbyteY are parameters
;       A=1         called from *LINE                   XY = address of string
;       A=224-255   called from OSWORD 224-255          .oswordX / .oswordY are parameters
;
; ***************************************************************************************
.uservJumper
    JMP (.vectorUSERV)                                  ; Jump via USERV


; ***************************************************************************************
;
; OSBYTE 126 - Acknowledge detection of ESCAPE condition
;
; If an ESCAPE condition has occurred, then this acknowledges (clears) it, informing the
; second processor of it via the Tube if present.
;
; ***************************************************************************************
.osbyte126EntryPoint
    LDX #0                                              ; X=0
    BIT .escapeFlag                                     ; check for ESCAPE flag
    BPL .osbyte124EntryPoint                            ; if (no ESCAPE flag) then branch
                                                        ; (just clear the ESCAPE condition)
    LDA .escapeEffects                                  ; get ESCAPE effects
    BNE +                                               ; if (escape effects is non-zero)
                                                        ; then branch (no effects)

                                                        ; reset VDU paging counter
                                                        ; close EXEC files
                                                        ; purge all buffers
                                                        ; Clear ESCAPE condition

    CLI                                                 ; allow interrupts
    STA .pagedModeCounter                               ; zero the number of lines printed since last halt in paged mode
    JSR .closeAndOptionallyOpenANewEXECFile             ; close any open EXEC file (A=0, Z=0)
    JSR .flushAllBuffers                                ; clear all buffers
+
    LDX #$FF                                            ; X=$FF to indicate ESCAPE acknowledged
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 124 - Clear ESCAPE condition
;
; ***************************************************************************************
.osbyte124EntryPoint
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 125 - Set ESCAPE condition
;
; On Entry:
;       The regular OSBYTE entry sets carry (meaning set the ESCAPE condition).
;       If falling through from OSBYTE 124 above then carry is clear (meaning clear the ESCAPE
;       condition).
;
; ***************************************************************************************
.osbyte125EntryPoint
    ROR .escapeFlag                                     ; set/clear bit 7 of ESCAPE flag
    BIT .tubePresentFlag                                ; check if Tube is present
    BMI +                                               ; if (Tube present) then branch
    RTS                                                 ;
+
    JMP .tubeCopyESCAPEFlagToSecondProcessor            ; Jumps into a Tube entry point

; ***************************************************************************************
;
; OSBYTE 137 - Turn on/off tape motor
;
; On Entry:
;       X = 0 to turn the motor off; otherwise turn the motor on
;
; ***************************************************************************************
.osbyte137EntryPoint
    LDA .serialULARegisterCopy                          ; get serial ULA control setting
    TAY                                                 ; Y=A
    ROL                                                 ; rotate left (shifts bit 7 into carry)
    CPX #1                                              ; if (X>=1, i.e. turn on motor) then set carry
    ROR                                                 ; rotate carry back in serialULA copy (bit 7)
    BVC .setSerialULADirectly                           ; ALWAYS branch


; ***************************************************************************************
;
; OSBYTE 8 - Set RS-423 baud rate for transmitting data
;
; On Entry:
;       X = baud rate
;
; ***************************************************************************************
.osbyte8EntryPoint
    LDA #%00111000                                      ; Once it's EOR'd with the next instruction,
                                                        ; this value becomes %00000111 (set transmit baud rate)
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 7 - Set RS-423 baud rate for receiving data
;
; On Entry:
;       X = baud rate
;
; ***************************************************************************************
.osbyte7EntryPoint
    EOR #%00111111                                      ; converts 7 -> $38 = %00111000 (set receive baud rate)
                                                        ; converts $38 -> 7 = %00000111 (set transmit baud rate)
    STA .tempStoreFA                                    ; store result
    LDY .serialULARegisterCopy                          ; get serial ULA control register setting
    CPX #9                                              ; }
    BCS .putNewSettingYInXAndReturn                     ; } is it 9 or more then branch (exit)
    AND .bufferTypeAndSerialBaudRatesTable,X            ; and with byte from look up table
    STA .tempStoreFB                                    ; store it
    TYA                                                 ; put Y in A
    ORA .tempStoreFA                                    ; set the transmit or receive baud rate bits to 1
    EOR .tempStoreFA                                    ; zero the transmit or receive baud rate bits to 0
    ORA .tempStoreFB                                    ; set baud rate from value read from table lookup
    ORA #$40                                            ; set bit 6
    EOR .tapeRS423SelectionFlag                         ; clear bit 6 if tape active (0=RS-423 or $40=TAPE)
.setSerialULADirectly
    STA .serialULARegisterCopy                          ; store serial ULA flag
    STA .serialULAControlRegister                       ; and write to control register
.putNewSettingYInXAndReturn
    TYA                                                 ; put Y in A to save old contents
.setXAndReturn
    TAX                                                 ; write new setting to X
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 9 - Duration of first colour
;
; On Entry:
;      Y = 0
;      X = new value (in 1/50 of a second)
;
; ***************************************************************************************
.osbyte9EntryPoint
    INY                                                 ; Y=1
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 10 - Duration of second colour
;
; On Entry:
;       Y = 0 (or 1 if falling through from OSBYTE 9 call above)
;       X = new value (in 1/50 of a second)
;
; ***************************************************************************************
.osbyte10EntryPoint
    LDA .videoULAFirstFlashingColourInterval,Y          ; get mark period count
    PHA                                                 ; push it
    TXA                                                 ; get new count
    STA .videoULAFirstFlashingColourInterval,Y          ; store it
    PLA                                                 ; get back original value
    TAY                                                 ; put it in Y
    LDA .videoULAFlashingColourIntervalCount            ; get value of flash counter
    BNE +                                               ; if (not zero) then branch
    STX .videoULAFlashingColourIntervalCount            ; restore old value
    LDA .videoULAVideoControlRegisterCopy               ; get current video ULA control register setting
    PHP                                                 ; push flags
    ROR                                                 ; rotate bit 0 into carry, carry into bit 7
    PLP                                                 ; get back flags
    ROL                                                 ; rotate back carry into bit 0
    STA .videoULAVideoControlRegisterCopy               ; store it in RAM copy
    STA .videoULAControlRegister                        ; and ULA control register
+
    BVC .putNewSettingYInXAndReturn                     ; ALWAYs branch

; ***************************************************************************************
;
; OSBYTE 2 - Select input stream
;
; On Entry:
;       X contains stream number
;       X = 0 (keyboard selected, RS-423 disabled)
;       X = 1 (RS-423 selected and enabled)
;       X = 2 (keyboard selected, RS-423 enabled)
;
; ***************************************************************************************
.osbyte2EntryPoint
    TXA                                                 ; A=X
    AND #1                                              ; blank out bits 1 - 7
    PHA                                                 ; push A
    LDA .rs423ControlRegisterCopy                       ; and get current ACIA control setting
    ROL                                                 ; Bit 7 into carry
    CPX #1                                              ; }
    ROR                                                 ; } if (X>=1, i.e. RS-423 enabled) then set bit 7 of A, otherwise clear it
    CMP .rs423ControlRegisterCopy                       ; compare this with ACIA control setting
    PHP                                                 ; push flags
    STA .rs423ControlRegisterCopy                       ; put A into ACIA control setting
    STA .acia6850ControlRegister                        ; and write to control register
    JSR .setRS423Active                                 ; set up RS-423 buffer
    PLP                                                 ; get back P
    BEQ +                                               ; if (new setting different from old) then branch
    BIT .acia6850DataRegister                           ; set bit 6 and 7

+
    LDX .currentInputBuffer                             ; get current input buffer number
    PLA                                                 ; get back A
    STA .currentInputBuffer                             ; store it
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 13 - Disable events
;
; For information on Events, see .eventEntryPoint
;
; On Entry:
;       X contains event number 0-9 to disable
;
; ***************************************************************************************
.osbyte13EntryPoint
    TYA                                                 ; Y=0; A=0
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 14 - Enable events
;
; For information on Events, see .eventEntryPoint
;
; On Entry:
;       A contains zero for disabling the event, or non-zero to enable the event.
;           This value is 14 if entry by OSBYTE 14 (which enables the event), or zero if
;           falling through from OSBYTE 13 above (which disables the event).
;       X contains event number 0-9 to enable
; On Exit:
;       Y contains previous value
;
; ***************************************************************************************
.osbyte14EntryPoint
    CPX #10                                             ; }
    BCS .setXAndReturn                                  ; } if X>9 then branch (set X from A and return)
    LDY .eventEnabledFlags,X                            ; get old event enable flag
    STA .eventEnabledFlags,X                            ; store new value in flag
    BVC .putNewSettingYInXAndReturn                     ; and exit


; ***************************************************************************************
;
; OSBYTE 16 - Select ADC channels
;
; Selects the range of channels for analogue to digital conversion (0-4)
; See .osbyte17EntryPoint
;
; On Entry:
;       X contains channel number (1-4) or 0 to disable conversions
;       Y = 0
;
; ***************************************************************************************
.osbyte16EntryPoint
    BEQ +                                               ; if (X=0) then branch
    JSR .osbyte17EntryPoint                             ; start conversion
+
    LDA .maximumADCChannelNumber                        ; get current maximum ADC channel number
    STX .maximumADCChannelNumber                        ; store new value
    TAX                                                 ; put old value in X
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 129 - Read key within time limit
;
; On Entry:
;       X and Y contains either:
;           time limit in centi-seconds (Y=$7F max)
;       or Y=$FF and X=-ve INKEY value for an instant read of a specific key
;       or Y=$FF and X=0 to read the machine type (see NAUG Section 24.4.1 Page 428)
;
; ***************************************************************************************
.osbyte129EntryPoint
    TYA                                                 ; A=Y
    BMI .readNegativeKeyNumber                          ; if (Y negative) then branch
    CLI                                                 ; allow interrupts
    JSR .osbyte129Timed                                 ; and go to timed routine
    BCS +                                               ; if (carry set) then branch
    TAX                                                 ; then X=A
    LDA #0                                              ; A=0
+
    TAY                                                 ; Y=A
    RTS                                                 ;

.readNegativeKeyNumber
    TXA                                                 ; A=X
    EOR #$7F                                            ; convert to keyboard input
    TAX                                                 ; X=A
    JSR .keyJumper                                      ; then scan keyboard
    ROL                                                 ; put bit 7 into carry

    ; if (carry is set) then return $FFFF else return $0000
.setXYAndExit
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 130 - Read 'machine high order address'
;
; Filing systems use 32 bit addresses, where $FF,$FF is used in the top two bytes to
; indicate the address is in the main (I/O processor) memory as opposed to the second
; processor memory. This routine returns the two values used for this purpose, namely $FF,$FF.
;
; On Entry:
;       Carry set if entry is via OSBYTE 130
;       Carry may be clear if falling through from routines above,
;       either reading a key (.readNegativeKeyNumber) or doing an ADC conversion (.setXYAndExit).
;
; ***************************************************************************************
.osbyte130EntryPoint
    LDX #$FF                                            ; X=$FF
    LDY #$FF                                            ; Y=$FF
    BCS +                                               ; if (carry set, depends on entry point) then branch (exit)
    INX                                                 ; X=0
    INY                                                 ; Y=0
+
    RTS                                                 ;


; ***************************************************************************************
;
; Get free space from an input buffer, or used space from an output buffer
;
; For buffer numbers, see .bufferNumberKeyboard.
;
; On Entry:
;       X=255 - buffer number
;
; ***************************************************************************************
.countNegativeBuffer
    TXA                                                 ; buffer number in A
    EOR #$FF                                            ; invert it
    TAX                                                 ; X=A
    CPX #2                                              ; is X>=2 (C set if output buffer, get bytes used)
.countBufferStartup
    CLV                                                 ; clear V flag (meaning count buffer)
    BVC .countOrPurgeBuffer                             ; ALWAYS branch (count buffer)

.purgeBuffer
    BIT .allBitsSet                                     ; set V flag (meaning purge buffer) (N flag also set)
.countOrPurgeBuffer
    JMP (.vectorCNPV)                                   ; See .cnpEntryPoint for default
                                                        ; implementation


; ***************************************************************************************
;
; Get free bytes from RS-423 Input Buffer
;
; On Exit:
;   carry set, all is OK
;   carry clear, free space in buffer is low
;
; ***************************************************************************************
.getRS423InputBufferFreeBytes
    SEC                                                 ; to check for free bytes
    LDX #1                                              ; X=1 to point to RS-423 input buffer
    JSR .countBufferStartup                             ; and count it
    CPY #1                                              ; check the high byte of the length
    BCS +                                               ; if (one or more) then branch (exit)
    CPX .rs423HandshakeExtent                           ; compare with minimum buffer space free
+
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 128 - Read ADC Channel, or get buffer status
;
; On Entry:              On Exit:
; X=0                    Y contains number of last channel converted (1-4); X = fire buttons
; X=channel number (1-4) X,Y contain 16 bit value read from ADC channel (See .osbyte17EntryPoint)
; X<0 Y=$FF              X returns information about various buffers
; X=$FF (keyboard)       X = number of characters in buffer
; X=$FE (RS-423 input)   X = number of characters in buffer
; X=$FD (RS-423 output)  X = number of empty spaces in buffer
; X=$FC (printer)        X = number of empty spaces in buffer
; X=$FB (sound 0)        X = number of empty spaces in buffer
; X=$FA (sound 1)        X = number of empty spaces in buffer
; X=$F9 (sound 2)        X = number of empty spaces in buffer
; X=$F8 (sound 3)        X = number of empty spaces in buffer
; X=$F7 (Speech)         X = number of empty spaces in buffer
;
; ***************************************************************************************
.osbyte128EntryPoint
    BMI .countNegativeBuffer                            ; if (X is -ve) then branch (count space free/used)
    BEQ .lastChannelConverted                           ; if (X is zero) then branch
    CPX #5                                              ; }
    BCS .setXYAndExit                                   ; } if channel is not valid then branch (set X and Y to 255 and exit)
    LDY .highByteLastByteFromADCChannel1 - 1,X          ; get last value read for channel of interest (high byte)
    LDA .lowByteLastByteFromADCChannel1 - 1,X           ; get last value read for channel of interest (low byte)
    TAX                                                 ; X=low byte
    RTS                                                 ;

.lastChannelConverted
    LDA .systemVIARegisterB                             ; read system VIA port B
    ROR                                                 ; move high nybble to low
    ROR                                                 ;
    ROR                                                 ;
    ROR                                                 ;
    EOR #$FF                                            ; and invert it
    AND #3                                              ; isolate the FIRE buttons
    LDY .adcLastChannelRead                             ; read last channel read
    STX .adcLastChannelRead                             ; store zero in last channel read
    TAX                                                 ; A=X bits 0 and 1 indicate fire buttons
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE - default entry point
;
; This entry point is executed for all OSBYTE calls. It routes the call through to one of the
; individual OSBYTE entry points by means of a table (see .osbyteAndOSWORDRoutineTable).
;
; Note: OSBYTEs 0-127 only return a value in the X register, whereas OSBYTEs 128-255 can
; return values in X,Y and carry. This fact is used to speed up access via the Tube.
;
; ***************************************************************************************
.osbyteEntryPoint
    PHA                                                 ; save A
    PHP                                                 ; save Processor flags
    SEI                                                 ; disable interrupts
    STA .osbyteA                                        ; }
    STX .osbyteX                                        ; } copy A,X,Y into zero page
    STY .osbyteY                                        ; }
    LDX #.romServiceCallUnrecognisedOSBYTE              ; set X so that (if necessary) we can signal to ROMs that an unrecognised osbyte is being attempted
    CMP #117                                            ;
    BCC .osbyte0to116                                   ; if (A < 117) then branch
    CMP #161                                            ;
    BCC .osbyte117To160                                 ; if (A < 161) then branch
    CMP #166                                            ;
    BCC .unknownOSBYTEOrOSWORD                          ; if (A < 166) then branch (with carry clear)
    CLC                                                 ; clear carry
    ; at this point OSBYTE number in A >= 166
    ; fall through...

; ***************************************************************************************
.osbyte166to255orOSWORD224to255
    ; NOTE: Entry 161 and 162 in the table have special meanings, which are used here
    ; if entry is via OSBYTE, then carry is clear and we look up entry 161 in table
    ; if entry is via OSWORD, then carry is  set  and we look up entry 162 in table
    LDA #161                                            ; A = 161
    ADC #0                                              ; Add carry

.osbyte117To160
    SEC                                                 ; set carry
    SBC #95                                             ; if OSBYTE, converts A into range
                                                        ; (22-66); if OSWORD then A=67

.indexToTable
    ASL                                                 ; double A to get offset into table
    SEC                                                 ; set carry

.osbyteOrOSWORDTableLookup
    STY .osbyteY                                        ; store Y
    TAY                                                 ; Y=A

    ; check for Econet intercept
    ; [There's a quirk here:
    ;
    ;  The following instruction sets V if bit 6 of .econetOSCallInterceptionFlag is
    ;  set. If bit 7 is clear as well, then we call whatever OSBYTE routine with V set,
    ;  which has some unexpected side effects. A few OSBYTE routines rely on V being clear,
    ;  So for example:
    ;
    ;       *FX 206,64      - sets the .econetOSCallInterceptionFlag to 64
    ;       *FX 10,1        - set the flashing colour time
    ;
    ;  This unexpectedly turns on RS-423 output, meaning you can't type at the keyboard
    ;  any more!
    ;
    ;  However, practically speaking there's no real reason you would need to set
    ;  .econetOSCallInterceptionFlag to anything other than either zero or something with
    ;  the top bit set so this probably never occurs in the wild.
    ; ]
    BIT .econetOSCallInterceptionFlag                   ; check Econet intercept flag (bit 7)
                                                        ; we expect bit 6 to be clear!
    BPL .skipEconetCall                                 ; if (no Econet intercept required) then branch (skip Econet check)

    TXA                                                 ; A=X
    CLV                                                 ; V=0
    JSR .netvJumper                                     ; to JMP via ECONET vector
    BVS .finishUpOSBYTEOrOSWORD                         ; if (returned with V set) then branch (finish up and exit)

.skipEconetCall
    ; read routine address from table and store in .tempStoreFA/B
    LDA .osbyteAndOSWORDRoutineTable + 1,Y              ; get address from table (high byte)
    STA .tempStoreFB                                    ; store as high byte
    LDA .osbyteAndOSWORDRoutineTable,Y                  ; get address from table (low byte)
    STA .tempStoreFA                                    ; store as low byte
    LDA .osbyteA                                        ; restore A
    LDY .osbyteY                                        ; restore Y
    BCS .setCarryXAndJumpOSBYTE                         ; if (carry is set, i.e. an OSBYTE call) then branch

    ; OSWORD call. Set A to the value in the first byte of the parameter block
    LDY #0                                              ;
    LDA (.osbyteX),Y                                    ; read first byte from parameter address block (XY)

.setCarryXAndJumpOSBYTE
    SEC                                                 ; set carry
    LDX .osbyteX                                        ; restore X

    ; Finally, call the OSBYTE / OSWORD routine address
    ;
    ; For an OSBYTE call:
    ;   A,X,Y are set to the three parameters sent to .OSBYTE. These are also stored in
    ;         .osbyteA, .osbyteX and .osbyteY.
    ;   Carry is set.
    ;   Zero flag is set if X is zero.
    ;   Negative flag is set if X has it's top bit set.
    ;   V is clear. (But see .osbyteOrOSWORDTableLookup above for a 'bug')
    ;
    ; For an OSWORD call:
    ;   .oswordA hold the OSWORD number.
    ;   A is set to the first byte of the parameter block at the address held in .oswordX/.oswordY
    ;   X is set to .oswordX, the lower byte of the address
    ;   Y is set to zero.
    ;   Carry is set.
    ;   Zero flag is set if X is zero.
    ;   Negative flag is set if X has it's top bit set.
    ;
    JSR .osbyteOrOSWORDJumper                           ; call OSBYTE/OSWORD routine address
                                                        ; stored in (.tempStoreFA/B)

.finishUpOSBYTEOrOSWORD
    ROR                                                 ; C=bit 0
    PLP                                                 ; get back flags
    ROL                                                 ; bit 0=Carry
    PLA                                                 ; get back A
    CLV                                                 ; clear V
    RTS                                                 ;

; ***************************************************************************************
.osbyte0to116
    LDY #0                                              ; Y=0
    CMP #22                                             ;
    BCC .indexToTable                                   ; if (A < 22) then branch
    ; OSBYTE 22 to 116: these are unknown OSBYTE calls
    ; fall through with carry set...

; ***************************************************************************************
;
; Unknown OSBYTE or OSWORD command. Pass it onto ROMs for servicing.
;
; ***************************************************************************************
.unknownOSBYTEOrOSWORD
    PHP                                                 ; push flags
    PHP                                                 ; push flags

.pullTwiceAndOfferCallToROMs
    PLA                                                 ; pull flags
    PLA                                                 ; pull flags
    JSR .osbyte143EntryPoint                            ; offer paged ROMs service 7/8 unrecognised osbyte/word
    BNE .romsDontRecogniseUnknownCommand                ; if (ROMs don't recognise it) then branch
    LDX .osbyteX                                        ; restore X
    JMP .finishUpOSBYTEOrOSWORD                         ; finish up

.romsDontRecogniseUnknownCommand
    PLP                                                 ; pull flags
    PLA                                                 ; and A
    BIT .allBitsSet                                     ; set N and V flags
    RTS                                                 ;

; ***************************************************************************************
;
; Check if it's ok to print a message
;
; Checks if the cassette filing system is in a critical (busy) state
; Check the catalogue status (are we currently doing a *CAT or equivalent)
; Checks the bits that allow printing short or long messages
;
; On Exit:
;       A = 0  (and therefore Z set)   means don't print messages
;       A != 0 (and therefore Z clear) means messages can be printed
;
; ***************************************************************************************
.shouldPrintMessage
    LDA .tapeCritical                                   ; read cassette critical flag bit 7 = busy
    BMI .zeroAAndExit                                   ; if (tape critically busy) then branch (exit)
    LDA #%00001000                                      ; check current catalogue status bit
    AND .fsStatusByte                                   ; check tape filing system status byte has the catalogue status bit set
    BNE +                                               ; if (catalogue bit set) then branch (exit)
    LDA #%10001000                                      ; A=%10001000 (these are the bits
                                                        ; set if a message is required)
    AND .tapeCurrentOptionsByte                         ; AND with filing system options (short/long message bits)
+
    RTS                                                 ;


; ***************************************************************************************
;
; OSWORD - Default entry point
;
; This entry point is executed for all OSWORD calls. It routes the call through to one of
; the individual OSWORD entry points by means of a table (see .osbyteAndOSWORDRoutineTable,
; at the end of which is the list of OSWORD entry points).
;
; ***************************************************************************************
.oswordEntryPoint
    PHA                                                 ; Push A
    PHP                                                 ; Push flags
    SEI                                                 ; disable interrupts
    STA .oswordA                                        ; store A,X,Y
    STX .oswordX                                        ;
    STY .oswordY                                        ;
    LDX #.romServiceCallUnrecognisedOSWORD              ; set X so that if necessary, we can
                                                        ; signal to ROMs that an unrecognised
                                                        ; OSWORD is being attempted
    CMP #224                                            ;
    BCS .osbyte166to255orOSWORD224to255                 ; if (A >= 224) then branch (OSWORDs
                                                        ; 224-255 call USERV)
    CMP #14                                             ;
    BCS .unknownOSBYTEOrOSWORD                          ; if (A >= 14) then branch (unknown
                                                        ; OSWORD)

    ; OSWORD 0-13
    ADC #68                                             ; add 68 to form pointer to table (68 to 81)
    ASL                                                 ; double it to form low byte of pointer ($88 to $A2)
    BCC .osbyteOrOSWORDTableLookup                      ; ALWAYS branch


; ***************************************************************************************
;
; OSWORD 5 - Read a byte from I/O memory
;
; This allows the second processor to access main (first processor) memory across the Tube.
;
; On Entry:
;       .oswordX/Y is the address of the five bytes of parameters:
;           byte 0-3: 32 bit address of byte
;           byte 4  : on exit byte read
;       A is the LSB of the 32 bit address
;
; ***************************************************************************************
.osword5EntryPoint
    JSR .setUpDataBlock                                 ; set up address of data block
    LDA (.tempStoreFA - 1,X)                            ; get byte
    STA (.oswordX),Y                                    ; store it
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 6 - Write a byte to I/O memory
;
; This allows the second processor to access main (first processor) memory across the Tube.
;
; On Entry:
;       .oswordX/Y is the address of the five bytes of parameters:
;           byte 0-3: 32 bit address of byte
;           byte 4  : byte to be written
;       A is the LSB of the 32 bit address
;
; ***************************************************************************************
.osword6EntryPoint
    JSR .setUpDataBlock                                 ; set up address
    LDA (.oswordX),Y                                    ; get byte to write
    STA (.tempStoreFA - 1,X)                            ; write byte
.zeroAAndExit
    LDA #0                                              ; A=0
    RTS                                                 ;

; ***************************************************************************************
.setUpDataBlock
    STA .tempStoreFA                                    ; .tempStoreFA=A=low byte of address
    INY                                                 ; Y=1
    LDA (.oswordX),Y                                    ; get byte from block
    STA .tempStoreFB                                    ; .tempStoreFB=high byte of address
    LDY #4                                              ; Y=4
.exitWithX1
    LDX #1                                              ; X=1
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 0 - Display version number
;
; See fx0.png
; Shows which version of the OS is installed. [Oddly this is implemented as an error message
; via the BRK mechanism. When running BASIC, BASIC's BRK handler is executed and so we have
; an extra newline and the last error number is set to 247. An alternative would have been
; to use the same printing method as used in *HELP (see .starHelp). Indeed earlier versions
; of the OS did just that.]
;
; ***************************************************************************************
.osbyte0EntryPoint
    BNE .exitWithX1                                     ; if (X is not zero) then branch (exit with X = 1 meaning OS 1.20)
    BRK                                                 ; print error message
    !byte $F7                                           ; error number
    !text "OS 1.20",0                                   ; error string with zero terminator

; ***************************************************************************************
;
; OSWORD 7 - Make a sound
;
; On Entry:
;       .oswordX/Y is the address of eight bytes of parameters:
;           byte 0-1:  Channel ($HSFC as in the BASIC SOUND command)
;           byte 2-3:  Amplitude
;           byte 4-5:  Pitch
;           byte 6-7:  Duration
;
; Channel
; -------
; H = hold bit (0-1) ensures that the existing sound currently playing on the given channel
;     continues until the release phase of the envelope is totally finished before the next
;     sound plays. Otherwise the sound is considered complete at the start of the release
;     phase.
;     The other sound parameters are then ignored.
; S = sync bits (0-2) is the number of future notes to be queued on other channels that are
;     required before all the queued sounds start to play together at the same time.
; F = flush bit (0-1) stops any currently playing sound on the channel, forcing the new sound
;     to play instead.
; C = channel (0-3). Channel 0 is the noise channel.
;
; If the high byte of the channel is $FF, then this is interpreted as a Speech command.
;
; Amplitude
; ---------
; The amplitude (loudness) is specified by a value in the range -15 (loudest) to 0 (silent).
; This is not a linear scale, with larger differences in volume between the louder sounds.
; Alternatively an envelope number can be specified (0-15).
;
; Pitch
; -----
; Given a pitch number in the range 0-255, the range of playable musical notes is from
; B2 to D8 in scientific notation (C4 being middle C). This is a range of 63 notes, over five
; octaves. See https://en.wikipedia.org/wiki/Scientific_pitch_notation.
;
; [Personally, I think one octave lower would have been nice. We basically only have one
; octave below middle C and over four octaves above. The range of notes is a little too
; much on the high end]
;
; The notes on the musical scale can be best approximated by the values in the following
; table. This table is similar to one in the original User Guide, but with more accurate
; values. Be aware that the pitch you hear also depends on the channel you play it on.
; See .soundPitchOffsetByChannelTable. The table below gives the best pitch value to use to
; most accurately achieve the musical note, and for each channel
; (Channel 1 / Channel 2 / Channel 3) where they differ.
;
;                                  Octave
; Note    2     3      4      5               6               7               8
; ---------------------------------------------------------------------------------------
;  C      -     4      52     100             147/148/149     195/196/197     242/244/246
;  C#     -     8      56     104             152/152/153     200/201/202     246/249/251
;  D      -     12     60     108             155/156/157     203/204/206     249/251/254
;  D#     -     16     64     112             160/160/161     207/209/210     -
;  E      -     20     68     115/116/116     163/164/165     211/213/214     -
;  F      -     24     72     120             168/168/169     214/216/217     -
;  F#     -     28     76     124             172/172/173     219/221/222     -
;  G      -     32     80     128             175/176/177     222/224/226     -
;  G#     -     36     84     131/132/132     179/180/181     226/228/229     -
;  A      -     40     88     135/136/136     183/184/185     229/231/233     -
;  A#     -     44     92     139/140/140     187/188/189     233/235/237     -
;  B      0     48     96     144/144/145     192/193/194     237/240/242     -
;
; Pitch is ultimately passed to the sound chip as a 10 bit integer (0-1023), so by directly
; accessing the sound chip more accurate pitch can be achieved. This is done by sending data
; to the System VIA. See NAUG Section 21.2 Page 375 for a detailed description of the format
; required by the sound chip, and example code. Then see .setPitchNotNoise and
; see .sendToSoundChip for code to send the pitch.
;
; See .pitchLookupTableLow for the relationship between the 10-bit pitch and frequency.
;
; The best chip values for each musical note are as below:
;
;         10 bit
;         Chip
;         Value         Frequency           Note = Ideal Frequency       Error
;         ----------------------------------------------------------------------
;           27          4629.63 Hz           D8  = 4698.64 Hz           69.01 Hz
;           28          4464.29 Hz           C#8 = 4434.92 Hz           29.36 Hz
;           30          4166.67 Hz           C8  = 4186.01 Hz           19.34 Hz
;           32          3906.25 Hz           B7  = 3951.07 Hz           44.82 Hz
;           34          3676.47 Hz           A#7 = 3729.31 Hz           52.84 Hz
;           36          3472.22 Hz           A7  = 3520.00 Hz           47.78 Hz
;           38          3289.47 Hz           G#7 = 3322.44 Hz           32.96 Hz
;           40          3125.00 Hz           G7  = 3135.96 Hz           10.96 Hz
;           42          2976.19 Hz           F#7 = 2959.96 Hz           16.24 Hz
;           45          2777.78 Hz           F7  = 2793.83 Hz           16.05 Hz
;           47          2659.57 Hz           E7  = 2637.02 Hz           22.55 Hz
;           50          2500.00 Hz           D#7 = 2489.02 Hz           10.98 Hz
;           53          2358.49 Hz           D7  = 2349.32 Hz            9.17 Hz
;           56          2232.14 Hz           C#7 = 2217.46 Hz           14.68 Hz
;           60          2083.33 Hz           C7  = 2093.00 Hz            9.67 Hz
;           63          1984.13 Hz           B6  = 1975.53 Hz            8.59 Hz
;           67          1865.67 Hz           A#6 = 1864.66 Hz            1.02 Hz
;           71          1760.56 Hz           A6  = 1760.00 Hz            0.56 Hz
;           75          1666.67 Hz           G#6 = 1661.22 Hz            5.45 Hz
;           80          1562.50 Hz           G6  = 1567.98 Hz            5.48 Hz
;           84          1488.10 Hz           F#6 = 1479.98 Hz            8.12 Hz
;           89          1404.49 Hz           F6  = 1396.91 Hz            7.58 Hz
;           95          1315.79 Hz           E6  = 1318.51 Hz            2.72 Hz
;          100          1250.00 Hz           D#6 = 1244.51 Hz            5.49 Hz
;          106          1179.25 Hz           D6  = 1174.66 Hz            4.59 Hz
;          113          1106.19 Hz           C#6 = 1108.73 Hz            2.54 Hz
;          119          1050.42 Hz           C6  = 1046.50 Hz            3.92 Hz
;          127           984.25 Hz           B5  =  987.77 Hz            3.51 Hz
;          134           932.84 Hz           A#5 =  932.33 Hz            0.51 Hz
;          142           880.28 Hz           A5  =  880.00 Hz            0.28 Hz
;          150           833.33 Hz           G#5 =  830.61 Hz            2.72 Hz
;          159           786.16 Hz           G5  =  783.99 Hz            2.17 Hz
;          169           739.64 Hz           F#5 =  739.99 Hz            0.34 Hz
;          179           698.32 Hz           F5  =  698.46 Hz            0.13 Hz
;          190           657.89 Hz           E5  =  659.26 Hz            1.36 Hz
;          201           621.89 Hz           D#5 =  622.25 Hz            0.36 Hz
;          213           586.85 Hz           D5  =  587.33 Hz            0.48 Hz
;          225           555.56 Hz           C#5 =  554.37 Hz            1.19 Hz
;          239           523.01 Hz           C5  =  523.25 Hz            0.24 Hz
;          253           494.07 Hz           B4  =  493.88 Hz            0.19 Hz
;          268           466.42 Hz           A#4 =  466.16 Hz            0.25 Hz
;          284           440.14 Hz           A4  =  440.00 Hz            0.14 Hz
;          301           415.28 Hz           G#4 =  415.30 Hz            0.02 Hz
;          319           391.85 Hz           G4  =  392.00 Hz            0.15 Hz
;          338           369.82 Hz           F#4 =  369.99 Hz            0.17 Hz
;          358           349.16 Hz           F4  =  349.23 Hz            0.07 Hz
;          379           329.82 Hz           E4  =  329.63 Hz            0.19 Hz
;          402           310.95 Hz           D#4 =  311.13 Hz            0.18 Hz
;          426           293.43 Hz           D4  =  293.66 Hz            0.24 Hz
;          451           277.16 Hz           C#4 =  277.18 Hz            0.02 Hz
;          478           261.51 Hz           C4  =  261.63 Hz            0.12 Hz
;          506           247.04 Hz           B3  =  246.94 Hz            0.09 Hz
;          536           233.21 Hz           A#3 =  233.08 Hz            0.13 Hz
;          568           220.07 Hz           A3  =  220.00 Hz            0.07 Hz
;          602           207.64 Hz           G#3 =  207.65 Hz            0.01 Hz
;          638           195.92 Hz           G3  =  196.00 Hz            0.07 Hz
;          676           184.91 Hz           F#3 =  185.00 Hz            0.09 Hz
;          716           174.58 Hz           F3  =  174.61 Hz            0.03 Hz
;          758           164.91 Hz           E3  =  164.81 Hz            0.09 Hz
;          804           155.47 Hz           D#3 =  155.56 Hz            0.09 Hz
;          851           146.89 Hz           D3  =  146.83 Hz            0.05 Hz
;          902           138.58 Hz           C#3 =  138.59 Hz            0.01 Hz
;          956           130.75 Hz           C3  =  130.81 Hz            0.06 Hz
;         1012           123.52 Hz           B2  =  123.47 Hz            0.05 Hz
;
; ***************************************************************************************
.osword7EntryPoint
    INY                                                 ; increment Y to read byte 1 of block
    LDA (.oswordX),Y                                    ; read channel high byte 'HS'
    CMP #$FF                                            ; check if it's $FF
    BEQ .osword7Speech                                  ; if (high byte of channel is $FF) then branch (handle speech command)
    CMP #$20                                            ; if (channel high byte is $20 or more) then set carry
    LDX #.romServiceCallUnrecognisedOSWORD              ; X = paged ROM service request 'unrecognised OSWORD call'
    BCS .pullTwiceAndOfferCallToROMs                    ; if (channel >= $2000) then branch (offer it to ROMs as unknown OSWORD)
    DEY                                                 ; point at start of block
    JSR .getChannelNumberAndFlush                       ; returns with carry set if flush is required, and A=channel number (0-3)
    ORA #4                                              ; convert channel number to buffer number (4-7)
    TAX                                                 ; X = buffer number
    BCC +                                               ; if (carry clear) then branch
    JSR .flushSoundBufferX                              ; flush buffer
    LDY #1                                              ; Y=1
+
    JSR .getSyncNumberAndHold                           ; get sync number (0-3) (carry set if hold is required)
    STA .tempStoreFA                                    ; .tempStoreFA = sync number
    PHP                                                 ; save flags
    LDY #6                                              ; }
    LDA (.oswordX),Y                                    ; } get duration (low byte)
    PHA                                                 ; push it
    LDY #4                                              ; }
    LDA (.oswordX),Y                                    ; } get pitch (low byte)
    PHA                                                 ; push it
    LDY #2                                              ; }
    LDA (.oswordX),Y                                    ; } get amplitude (low byte) in the range -15 to 0 (static volume) or 1 to 4 (envelope controlled)

    ; At this point carry contains the 'hold' bit
    ; and .tempStoreFA contains the two 'sync' bits

    ROL                                                 ; multiply amplitude by two, and add carry into bit zero = hold bit
    SEC                                                 ;
    SBC #2                                              ; subtract 2
    ASL                                                 ; }
    ASL                                                 ; } multiply by 4
    ORA .tempStoreFA                                    ; add sync value (0-3)

    ;
    ; To illustrate the changes made by the last six instructions, here is a table showing
    ; the changes at each step. Each row is a different value for the amplitude (values > 0
    ; are the envelope number 1-4), and the columns show the result after each subsequent
    ; instruction.
    ;
    ; Amplitude   Binary       ROL           SEC;SBC#2    ASL; ASL     ORA .tempStoreFA
    ;                          h=hold bit                              ss=sync bits
    ; ---------------------------------------------------------------------------------
    ;     4       %00000100    %0000100h     %0000011h    %00011h00    %00011hss
    ;     3       %00000011    %0000011h     %0000010h    %00010h00    %00010hss
    ;     2       %00000010    %0000010h     %0000001h    %00001h00    %00001hss
    ;     1       %00000001    %0000001h     %0000000h    %00000h00    %00000hss
    ;     0       %00000000    %0000000h     %1111111h    %11111h00    %11111hss
    ;    -1       %11111111    %1111111h     %1111110h    %11110h00    %11110hss
    ;    -2       %11111110    %1111110h     %1111101h    %11101h00    %11101hss
    ;    -3       %11111101    %1111101h     %1111100h    %11100h00    %11100hss
    ;    -4       %11111100    %1111100h     %1111011h    %11011h00    %11011hss
    ;    -5       %11111011    %1111011h     %1111010h    %11010h00    %11010hss
    ;    -6       %11111010    %1111010h     %1111001h    %11001h00    %11001hss
    ;    -7       %11111001    %1111001h     %1111000h    %11000h00    %11000hss
    ;    -8       %11111000    %1111000h     %1110111h    %10111h00    %10111hss
    ;    -9       %11110111    %1110111h     %1110110h    %10110h00    %10110hss
    ;   -10       %11110110    %1110110h     %1110101h    %10101h00    %10101hss
    ;   -11       %11110101    %1110101h     %1110100h    %10100h00    %10100hss
    ;   -12       %11110100    %1110100h     %1110011h    %10011h00    %10011hss
    ;   -13       %11110011    %1110011h     %1110010h    %10010h00    %10010hss
    ;   -14       %11110010    %1110010h     %1110001h    %10001h00    %10001hss
    ;   -15       %11110001    %1110001h     %1110000h    %10000h00    %10000hss
    ;
    ; At this point:
    ;
    ; bit 7     = 0 for an envelope number
    ; bits 3-6  = envelope number - 1 (0-3), or volume in range (15 to 0)
    ; bit 2     = h, the hold bit
    ; bits 0-1  = ss, the sync bits (0-3)
    ;

    JSR .addByteToBuffer                                ; transfer byte to the sound buffer
    BCC .markAsUsedAndSendToBuffer                      ; if (C set on exit, i.e. succesful transfer) then branch (send to buffer)
.finishUpSound
    PLA                                                 ; }
    PLA                                                 ; } failed to add to buffer, so pull the values off and fall through to exit via OSBYTE 117
    PLP                                                 ; }
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 117 - Read VDU status
;
; ***************************************************************************************
.osbyte117EntryPoint
    LDX .vduStatusByte                                  ; get VDU status byte in X
    RTS                                                 ;

; ***************************************************************************************
;
; VDU 7 (.charBELL)
;
; See beep.mp3
; Generates a short tone.
;
; By default this plays a Treble C as a square wave for 0.3 seconds on channel 3. The
; frequency is as close as the sound chip can get to Treble C. It produces a 523.013Hz tone
; compared to the theoretical ideal 523.251Hz, and so is very close to the ideal pitch.
;
; The 523.013Hz figure for the frequency achieved takes into account that the OS changes the
; pitch slightly depending on the channel number (see .soundPitchOffsetByChannelTable). If
; it were played on channel 1 or 2, the frequency would not be as close to Treble C.
;
; ***************************************************************************************
.vdu7EntryPoint
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .soundBELLChannel                               ; get bell channel number in A
    AND #%00000111                                      ; clear all except bits 0-2
    ORA #%00000100                                      ; set bit 2 (=channel number + 4)
    TAX                                                 ; X=A=channel number+4=buffer number
    LDA .soundBELLAmplitudeEnvelope                     ; get bell amplitude/envelope number
    JSR .insJumper                                      ; store it in buffer X
    LDA .soundBELLDuration                              ; get bell duration
    PHA                                                 ; save it
    LDA .soundBELLPitch                                 ; get bell pitch
    PHA                                                 ; save it
.markAsUsedAndSendToBuffer
    SEC                                                 ; set carry
    ROR .channel0Occupancy - .bufferNumberSound0,X      ; and pass into bit 7 to indicate that channel is active
    BMI .addPitchAndDurationToSoundBuffer               ; ALWAYS branch

; ***************************************************************************************
.osword7Speech
    PHP                                                 ; push flags
    INY                                                 ; Y=2
    LDA (.oswordX),Y                                    ; get byte at offset 2
    PHA                                                 ; store it
    INY                                                 ; Y=3
    LDA (.oswordX),Y                                    ; get byte at offset 3
    PHA                                                 ; store it

    ; The stack now holds the two bytes of the SOUND command that normally specify amplitude
    ; These are the last two of three bytes we are going to add to the buffer. The first
    ; byte is byte 0 from the

    LDY #0                                              ; Y=0
    LDA (.oswordX),Y                                    ; get byte
    LDX #.bufferNumberSpeech                            ; X=8
    JSR .addByteToBuffer                                ; select speech buffer and pass A
    BCS .finishUpSound                                  ; if (carry set, i.e. failed to add to buffer) then branch (restore stack and exit)
    ROR .speechBufferEmptyFlag                          ; clear bit 7 of buffer empty flag to show buffer is not empty
    ; fall through...

; ***************************************************************************************
.addPitchAndDurationToSoundBuffer
    PLA                                                 ; pull pitch
    JSR .insJumper                                      ; enter it in buffer X
    PLA                                                 ; pull duration
    JSR .insJumper                                      ; enter it in buffer X
    PLP                                                 ; pull flags
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 8 - Define an envelope
;
; On Entry:
;       A = envelope number
;       Y = 0
;
;   .oswordX/Y is the address of 14 bytes of parameters:
;       byte 0:   envelope number (also in A)
;       byte 1:   bits 0-6 length of each step in centi-seconds
;                 bit 7 clear means auto repeat
;       byte 2:   change of Pitch per step in section 1 (-128 to +127)
;       byte 3:   change of Pitch per step in section 2 (-128 to +127)
;       byte 4:   change of Pitch per step in section 3 (-128 to +127)
;       byte 5:   number of steps in section 1 (0 to 255)
;       byte 6:   number of steps in section 2 (0 to 255)
;       byte 7:   number of steps in section 3 (0 to 255)
;       byte 8:   change of amplitude per step during attack  phase (-127 to +127)
;       byte 9:   change of amplitude per step during decay   phase (-127 to +127)
;       byte 10:  change of amplitude per step during sustain phase (-127 to +127)
;       byte 11:  change of amplitude per step during release phase (-127 to +127)
;       byte 12:  target level at end of attack phase (0 to 126)
;       byte 13:  target level at end of decay  phase (0 to 126)
;
; ***************************************************************************************
.osword8EntryPoint
    SBC #1                                              ; }
    ASL                                                 ; }
    ASL                                                 ; } set up appropriate displacement to storage area
    ASL                                                 ; } A=(A-1)*16 OR 15
    ASL                                                 ; }
    ORA #%00001111                                      ; }
    TAX                                                 ; X=A (destination offset)
    LDA #0                                              ; A=0 (value to write)
    LDY #16                                             ; Y = loop counter
.copyEnvelopeLoop
    CPY #14                                             ;
    BCS +                                               ; if (Y >= 14) then branch (don't read from block, just store zero in envelope buffer)
    LDA (.oswordX),Y                                    ; get byte from parameter block
+
    STA .envelopeBuffer,X                               ; and store it in appropriate area
    DEX                                                 ; decrement X
    DEY                                                 ; decrement Y
    BNE .copyEnvelopeLoop                               ; if (not zero) then branch (loop back and do it again)
    RTS                                                 ;
    ; Note that envelope number is NOT transferred. The envelope number is not needed in
    ; the buffer since the address in the buffer determines the envelope number.


; ***************************************************************************************
; On Exit:
;   When Y = 0:
;       A = channel number (0-3)
;       C set if channel low byte > 15, i.e. if flush is required
;
;   When Y = 1:
;       A = Sync number (0-3)
;       C set if channel low byte > 15, i.e. if hold is required
;
.getChannelNumberAndFlush
.getSyncNumberAndHold
    LDA (.oswordX),Y                                    ; get byte (channel parameter low byte or sync parameter low byte)
    CMP #$10                                            ; is it greater than 15, if so set carry
    AND #3                                              ; get hardware channel number
    INY                                                 ; increment Y to point to byte 1 of the parameters
    RTS                                                 ;


; ***************************************************************************************
;
; OSWORD 3 - Read interval timer
;
; The interval timer is centi-seconds and 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte result
;
; ***************************************************************************************
.osword3EntryPoint
    LDX #.countdownIntervalTimer - (.timeClockA - 5)    ; X is the offset from (clockA-5) to countdown timer
    BNE .readFiveBytesIntoBlock                         ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 1 - Read system clock
;
; The system clock counts in centi-seconds since boot and is 5 bytes long.
;
; On Entry:
;       .oswordX/Y is the address for the five byte result
;
; ***************************************************************************************
.osword1EntryPoint
    LDX .timeClockSwitch                                ; X=current system clock store pointer
.readFiveBytesIntoBlock
    LDY #4                                              ; Y = loop counter
-
    LDA .timeClockA - 5,X                               ; read byte
    STA (.oswordX),Y                                    ; store it in parameter block
    INX                                                 ; X = X + 1
    DEY                                                 ; Y = Y - 1
    BPL -                                               ; if (Y >= 0) then branch (loop back and do it again)
.exit22
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 4 - Write interval timer
;
; On Entry:
;       .oswordX/Y is the address of the five byte value to set
;
; ***************************************************************************************
.osword4EntryPoint
    LDA #.countdownIntervalTimer - (.timeClockA - 5)    ; A=15 is the offset from clockA to countdown timer
    BNE .writeFiveBytesFromBlock                        ; ALWAYS branch

; ***************************************************************************************
;
; OSWORD 2 - Write system clock
;
; On Entry:
;       .oswordX/Y is the address of the five byte value to set
;
; ***************************************************************************************
.osword2EntryPoint
    LDA .timeClockSwitch                                ; get current clock store pointer
    EOR #15                                             ; and invert to get inactive clock (toggle between 5 and 10)
    CLC                                                 ; clear carry (indicates write system clock)
    ; fall through...

; ***************************************************************************************
;
; Write system clock or interval timer
;
; On Entry:
;       carry clear indicates write system clock
;       carry set indicates write interval timer
;
; ***************************************************************************************
.writeFiveBytesFromBlock
    PHA                                                 ; store A
    TAX                                                 ; X=A
    LDY #4                                              ; Y=loop counter
.writeClockLoop
    LDA (.oswordX),Y                                    ; transfer 5 bytes from out parameter block
    STA .timeClockA - 5,X                               ; to the clock or timer
    INX                                                 ;
    DEY                                                 ;
    BPL .writeClockLoop                                 ; if (Y >= 0) then branch (loop)
    PLA                                                 ; restore A
    BCS .exit22                                         ; if (carry set, i.e. write to interval timer requested) then branch (exit)
    STA .timeClockSwitch                                ; write back current clock (5 or 10) into switch variable
    RTS                                                 ;

; ***************************************************************************************
;
; OSWORD 0 - Read line from current input into memory
;
; On Entry:
;       .oswordX/.oswordY - address of parameter block:
;           byte 0: address of input buffer for result (low)
;           byte 1: address of input buffer for result (high)
;           byte 2: maximum line length
;           byte 3: minimum acceptable ASCII code
;           byte 4: maximum acceptable ASCII code
;
; ***************************************************************************************
.osword0EntryPoint
    LDY #4                                              ; Y=4
-
    LDA (.oswordX),Y                                    ; copy bytes 2,3,4 to absolute addresses .osword0MaxLineLength,+1,+2
    STA .osword0MaxLineLength-2,Y                       ;
    DEY                                                 ; decrement Y
    CPY #2                                              ; until Y=1
    BCS -                                               ;

    LDA (.oswordX),Y                                    ; get address of input buffer (high byte)
    STA .osword0BufferAddressHigh                       ; store it in temporary buffer
    DEY                                                 ; decrement Y
    STY .pagedModeCounter                               ; Y=0 store in print line counter for paged mode
    LDA (.oswordX),Y                                    ; get address of input buffer (low byte)
    STA .osword0BufferAddressLow                        ; and store in temporary buffer
    CLI                                                 ; allow interrupts
    BCC .readInputCharacter                             ; ALWAYS branch

; ***************************************************************************************
.readLineInputBufferFull
    LDA #.charBELL                                      ; A=7
.retryReadWithoutIncrementingPosition
    DEY                                                 ; decrement Y
.retryReadIncrementingPosition
    INY                                                 ; increment Y
.outputCharacterAndReadAgain
    JSR .OSWRCH                                         ; and call OSWRCH
    ; fall through...

; ***************************************************************************************
.readInputCharacter
    JSR .OSRDCH                                         ; read character from input stream
    BCS .exitWithNegativeAndCarryFlagsSet               ; if (error occurred) then branch (exit)
    TAX                                                 ; X=A
    LDA .characterDestinationsAvailableFlags            ; get character destination status
    ROR                                                 ; rotate the status twice to make
    ROR                                                 ; carry reflect the 'disable VDU driver' bit
    TXA                                                 ; restore character read
    BCS +                                               ; if (vdu disabled) then branch (skip forward)
    LDX .twosComplimentOfNumberOfBytesInVDUQueue        ; get number of items in VDU queue
    BNE .outputCharacterAndReadAgain                    ; if (not zero) then branch (output character and read again)
+
    CMP #.charDELETE                                    ;
    BNE +                                               ; if (character is not DELETE) then branch forward
    CPY #0                                              ;
    BEQ .readInputCharacter                             ; if (Y is zero, i.e. first character) then branch (read next character)
    DEY                                                 ; decrement Y (position in buffer decrements)
    BCS .outputCharacterAndReadAgain                    ; ALWAYS branch back to otput the DELETE and read again
+
    CMP #.charDisableVDUOrDeleteLine                    ; is it delete line (CTRL-U)
    BNE +                                               ; if (not CTRL-U) then branch forward
    TYA                                                 ; Y=A
    BEQ .readInputCharacter                             ; if (we are still reading first character) then branch back the read character
    LDA #.charDELETE                                    ;
-
    JSR .OSWRCH                                         ; }
    DEY                                                 ; } output DELETE until Y=0
    BNE -                                               ; }
    BEQ .readInputCharacter                             ; ALWAYS branch (read character again)
+
    STA (.osword0BufferAddressLow),Y                    ; store character in designated buffer
    CMP #.charRETURN                                    ;
    BEQ .outputNewlineAndExit                           ; if (carriage return entered) then branch
    CPY .osword0MaxLineLength                           ; check the line length
    BCS .readLineInputBufferFull                        ; if (buffer full) then branch (loop to ring bell)
    CMP .osword0MinASCIICharacter                       ; check minimum character
    BCC .retryReadWithoutIncrementingPosition           ; if (less than minimum character) then branch (read at existing position)
    CMP .osword0MaxASCIICharacter                       ; check maximum character
    BEQ .retryReadIncrementingPosition                  ; if (equal to maximum character) then accept the character and move on
    BCC .retryReadIncrementingPosition                  ; if (less than maximum character) then accept the character and move on
    BCS .retryReadWithoutIncrementingPosition           ; ALWAYS branch (reject character and continue)

.outputNewlineAndExit
    JSR .OSNEWL                                         ; output CR/LF
    JSR .netvJumper                                     ; call Econet vector
.exitWithNegativeAndCarryFlagsSet
    LDA .escapeFlag                                     ; A=ESCAPE FLAG
    ROL                                                 ; put bit 7 into carry
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 5 - Select printer type
;
; On Entry:
;       X=0       ignore printer output
;       X=1       parallel output
;       X=2       RS-423 output (will act as sink if RS-423 is enabled using OSBYTE with A=3)
;       X=3       user printer
;       X=4       Econet printer
;       X=5-255   user printer
;
; ***************************************************************************************
.osbyte5EntryPoint
    CLI                                                 ; allow interrupts briefly
    SEI                                                 ; disable interrupts
    BIT .escapeFlag                                     ; check if ESCAPE is pending
    BMI .exit23                                         ; if (ESCAPE is pending) then branch (exit)
    BIT .printerBufferEmptyFlag                         ; check bit 7 for printer buffer empty
    BPL .osbyte5EntryPoint                              ; if (bit 7=0, not empty) then branch back and try again (wait until buffer is empty)
    JSR .selectPrinterType                              ; check for user defined routine
    LDY #0                                              ; Y=0
    STY .osbyteY                                        ; F1=0
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 1 - Read/Write user flag; OSBYTE 6 - Set printer ignore character
;
; On Entry:
;       OSBYTE 1:
;           To read the user flag:  Y=$00
;           To write the user flag: X=value to write, Y=$FF
;       OSBYTE 6:
;           X = value to write
; On Exit:
;       X contains the previous value
;
; ***************************************************************************************
.osbyte1EntryPoint
.osbyte6EntryPoint
    ORA #$0280 - .mosVariablesMinus166                  ; A set to read/write locations:

    ; At this point, A depends on the entry point. A is set up to affect a particular
    ; system variable:
    ;
    ; Entry via OSBYTE 1: $0281 (user flag)                - .mosVariablesMinus166
    ; Entry via OSBYTE 5: $0285 (printer destination)      - .mosVariablesMinus166
    ; Entry via OSBYTE 6: $0286 (printer ignore character) - .mosVariablesMinus166
    ;
    BNE .readWriteSystemVariable                        ; ALWAYS branch


; ***************************************************************************************
;
; OSBYTE 12 - Set keyboard autorepeat rate
;
; ***************************************************************************************
.osbyte12EntryPoint
    BNE .osbyte11EntryPoint                             ; if (.osbyteX != 0; i.e. not resetting to defaults) then branch
    LDX #50                                             ; reset default delay and rate
    STX .keyboardAutoRepeatDelay                        ; set keyboard autorepeat delay
    LDX #8                                              ; set X=8 for default autorepeat rate
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 11 - Set keyboard autorepeat delay
;
; ***************************************************************************************
.osbyte11EntryPoint
    ADC #$CF                                            ; A=A+208 (carry set)
                                                        ; So...
                                                        ; A=219 if entered from OSBYTE 11
                                                        ; A=220 if entered from OSBYTE 12
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 3 - Select output stream; OSBYTE 4 - Enable/disable cursor editing
;
; ***************************************************************************************
.osbyte3EntryPoint
.osbyte4EntryPoint
    CLC                                                 ; clear carry
    ADC #$E9                                            ; A = A + 233
                                                        ; So...
                                                        ; A=236 if entered from OSBYTE 3
                                                        ; A=237 if entered from OSBYTE 4
                                                        ; A=196 if entered from OSBYTE 11
                                                        ; A=197 if entered from OSBYTE 12
.readWriteSystemVariable
    STX .osbyteX                                        ; store X
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 166 to 255 - read/write system variable
;
; Set newValue = (oldValue AND .osbyteY) EOR .osbyteX
;
; On Entry:
;       A = offset from .mosVariablesMinus166 of variable to read/write
;       .osbyteX = X parameter from entry to OSBYTE
;       .osbyteY = Y parameter from entry to OSBYTE
; On Exit:
;       X = oldValue
;       Y = value of next system variable
;
; ***************************************************************************************
.osbyte166to255EntryPoint
    TAY                                                 ; Y=A
    LDA .mosVariablesMinus166,Y                         ; read current value
    TAX                                                 ; preserve this in X
    AND .osbyteY                                        ; }
    EOR .osbyteX                                        ; } new value = (old value AND Y) EOR X
    STA .mosVariablesMinus166,Y                         ; store it
    LDA .mosVariablesMinus166+1,Y                       ; get value of next byte into A
    TAY                                                 ; Y=A
.exit23
    RTS                                                 ;


; ***************************************************************************************
;
; Table of buffer types and serial baud rates
;
; This table has dual use. It is used to set the serial baud rate (using bits 0-5), and
; also to identify a buffer as being a sound buffer (bit 7):
;
;   - bit 7 is set if buffer X is a sound buffer
;   - bit 6 is not used (always set)
;   - bits 3,4,5 indicate the serial receive baud rate
;   - bits 0,1,2 indicate the serial transmit baud rate
;
;       111 =    75 baud
;       011 =   150 baud
;       101 =   300 baud
;       001 =  1200 baud
;       110 =  2400 baud
;       010 =  4800 baud
;       100 =  9600 baud
;       000 = 19200 baud
;
; ***************************************************************************************
.bufferTypeAndSerialBaudRatesTable
    !byte %01100100                                     ; Keyboard           9600 baud (default)
    !byte %01111111                                     ; RS-423 Input         75 baud
    !byte %01011011                                     ; RS-423 output       150 baud
    !byte %01101101                                     ; serial printer      300 baud
    !byte %11001001                                     ; sound0             1200 baud
    !byte %11110110                                     ; sound1             2400 baud
    !byte %11010010                                     ; sound2             4800 baud
    !byte %11100100                                     ; sound3             9600 baud
    !byte %01000000                                     ; speech            19200 baud


; ****************************************************************************************
;
; OSBYTE 19 - Wait for vertical sync
;
; ****************************************************************************************
.osbyte19EntryPoint
    LDA .verticalSyncCounter                            ; Read vertical sync counter
-
    CLI                                                 ; allow interrupts briefly
    SEI                                                 ; disable interrupts again
    CMP .verticalSyncCounter                            ; has the vertical sync counter changed yet?
    BEQ -                                               ; if (the values are the same) then branch (loop back)
    ; fall through...

; ****************************************************************************************
;
; OSBYTE 160 - Read VDU Variable
;
; ****************************************************************************************
.osbyte160EntryPoint
    LDY .vduVariablesStart + 1,X                        ; get VDU variable (often the high byte)
    LDA .vduVariablesStart,X                            ; get VDU variable (often the low byte)
    TAX                                                 ;
    RTS                                                 ;

; ****************************************************************************************
;
; OSBYTE 18 - Reset soft keys
;
; ****************************************************************************************
.osbyte18EntryPoint
    LDA #$10                                            ; set consistency flag
    STA .softKeyConsistencyFlag                         ;
    LDX #0                                              ; X=0
-
    STA .softKeyPage,X                                  ; and wipe clean
    INX                                                 ; soft key buffer
    BNE -                                               ; until X=0 again
    STX .softKeyConsistencyFlag                         ; zero consistency flag
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 118 - Set keyboard LEDs based on keyboard status
;
; On Exit:
;       carry is set if CTRL pressed
;       N is set if SHIFT is pressed
;
; ***************************************************************************************
.osbyte118EntryPoint
    PHP                                                 ; remember flags
    SEI                                                 ; disable interrupts
    LDA #$40                                            ; switch on CAPS and SHIFT LOCK lights
    JSR .turnOnKeyboardLightsAndTestEscape              ; via subroutine
    BMI .popRollAndExit                                 ; if (negative, i.e. ESCAPE condition exists) then branch
    CLC                                                 ; clear V and C
    CLV                                                 ; calling main keyboard routine to
    JSR .keyJumper                                      ; switch on lights as required
.popRollAndExit
    PLP                                                 ; recall flags
    ROL                                                 ; and rotate carry into bit 0
    RTS                                                 ;

; ***************************************************************************************
.turnOnKeyboardLightsAndTestEscape
    BCC .skipKeyboardLights                             ; if (carry clear) then branch
    LDY #7                                              ; switch on SHIFT LOCK light
    STY .systemVIARegisterB                             ;
    DEY                                                 ; Y=6
    STY .systemVIARegisterB                             ; switch on CAPS LOCK light

.skipKeyboardLights
    BIT .escapeFlag                                     ; check bit 7 of escape flag indicating
                                                        ; that ESCAPE condition exists
    RTS                                                 ;

; ***************************************************************************************
.writeAToSystemVIARegisterB
    PHP                                                 ; push flags
    SEI                                                 ; disable interupts
    STA .systemVIARegisterB                             ; write register B from Accumulator
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 154 - Write to Video ULA's Video Control Register
;
; bit
;   0 - Flash colour select (which of the flashing colours is displayed)
;   1 - Teletext select
;   2 - } These two bits determine the number of characters per row
;   3 - } from this table:
;        00 = 10 characters per row
;        01 = 20 characters per row
;        10 = 40 characters per row
;        11 = 80 characters per row
;   4 - CRTC clock rate select:
;         0 = low frequency clock for MODEs 4-7
;         1 = high frequency clock for MODEs 0-3
;   5 - } These two bits determine the width of cursor in bytes
;   6 - } from this table:
;        00 = 1 (MODEs 0,3,4,6)
;        01 = - undefined
;        10 = 2 (MODEs 1,5,7)
;        11 = 4 (MODE 2)
;   7 - Master cursor width. If set, causes a larger cursor to be displayed
;
; ***************************************************************************************
.osbyte154EntryPoint
    TXA                                                 ;
.setVideoULA
    PHP                                                 ; save flags
    SEI                                                 ; disable interrupts
    STA .videoULAVideoControlRegisterCopy               ; save RAM copy of new parameter
    STA .videoULAControlRegister                        ; write to control register
    LDA .videoULASecondFlashingColourInterval           ; get second flashing colour interval
    STA .videoULAFlashingColourIntervalCount            ; set flash counter to this value
    PLP                                                 ; get back status
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 155 - Set palette value
;
; On Entry:
;       X contains value to write
;
; ***************************************************************************************
.osbyte155EntryPoint
    TXA                                                 ; A = X
.osbyte155Internal
    EOR #7                                              ; convert to palette format required for video ULA register
    PHP                                                 ; remember flags (including interrupt disable flag)
    SEI                                                 ; prevent interrupts
    STA .videoULAPaletteValue                           ; store as current palette setting
    STA .videoULAPaletteRegister                        ; store actual colour in register
    PLP                                                 ; restore flags (including interrupt disable flag)
    RTS                                                 ;

; ***************************************************************************************
.gsinitForFilenameParsing
    CLC                                                 ; clear carry
    ; fall through...

; ***************************************************************************************
;
; GSINIT - Initialise parsing of a string
;
; Initialises the parsing of a given string (the 'input' string). Usually the string is part
; of an OSCLI command line where a string is expected (e.g. the filename in a *LOAD or the
; definition of a function key in *KEY).
;
; Leading spaces are ignored. The input string can be surrounded by double quotation marks.
; The string is terminated by a carriage return, or the second double quotation mark, or
; (optionally) a space character (useful for filename parsing).
;
; Once initialised, the parsing occurs using multiple calls to GSREAD. Each call produces one
; character result based on the input string.
;
; Control codes are disallowed in the input string. However the bar character '|' can be
; used to introduce control codes into the parsed output of GSREAD, and the '|!' combination
; is used to introduce top bit set characters.
;
; '|' followed by a character (see exceptions below) gives the ASCII value minus 64.
;       e.g. |G = control code 7  (bell)
;            |M = control code 13 (carriage return)
; '|!' adds 128 to the following character.
; '||' is parsed as a single bar character.
; '|"' is parsed as double quotes.
; '|?' is parsed as the DELETE character (character 127).
;
; These can be combined, e.g. '|!|A' results in character 129 being parsed.
;
; On Entry:
;       Address for string stored at .stringInputBufferAddressLow/High
;       Y = offset into string
;       C = 0: string is terminated by a space (used for filename parsing)
;       C = 1: otherwise (used e.g. for defining a soft key with *KEY)
;
; On Exit:
;       .stringInputOptions bit 7 = double-quote character found at start
;                           bit 6 = don't stop on space character
;       Y = offset of the first non-blank character
;       A = first non-blank character
;       Z is set if string is empty
;
; ***************************************************************************************
.gsinitEntryPoint
    ROR .stringInputOptions                             ; Move carry into top bit of options
    JSR .skipSpacesAndCheckForCRInStringInput           ; get character from text
    INY                                                 ; increment Y to point at next character
    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ +                                               ; if (double quotes) then branch
    DEY                                                 ; decrement Y
    CLC                                                 ; clear carry
+
    ROR .stringInputOptions                             ; bit 7 = double quote character found
                                                        ; bit 6 = space is not a terminator
    CMP #.charRETURN                                    ; set Z flag if CR found
    RTS                                                 ;


; ***************************************************************************************
;
; GSREAD - Read one character by parsing the input string
;
; Parses a character from the input string previously set up by GSINIT.
; See .gsinitEntryPoint
;
; On Entry:
;       Address for string stored at .stringInputBufferAddressLow/High
;       Y = offset into string
; On Exit:
;       A = character read
;       X is preserved
;       Y = index of next character to be read
;       Carry is set if end of string reached
;       Overflow (V flag) is set if the character read was interpreted as a control code
;
; ***************************************************************************************
.gsreadEntryPoint
    LDA #0                                              ; A=0
.gsreadInternal
    STA .stringInputPlingFlag                           ; store A ($80 if previous character is '!', zero otherwise)
    LDA (.stringInputBufferAddressLow),Y                ; read first character
    CMP #.charRETURN                                    ; check for CR
    BNE .notRETURN                                      ; if (not CR) then branch

    ; deal with RETURN character
    BIT .stringInputOptions                             ; check options
    BMI .brkBadString                                   ; if (second quotation mark needed) then branch ('Bad string' message)
    BPL .finishedString                                 ; ALWAYS branch (string ok, finished)

.notRETURN
    CMP #.charSPACE                                     ; check for SPACE
    BCC .brkBadString                                   ; if (less then space, i.e. a control character) then branch ('Bad string' message)
    BNE .notSPACE                                       ; if (it's not a space) then branch

    ; Deal with ' ' SPACE character
    BIT .stringInputOptions                             ; check bit 6 and 7 of .stringInputOptions
    BMI .finishUpReadClearV                             ; if (double-quote character found) then branch
    BVC .finishedString                                 ; if (space character is a terminator) then branch (finished string)

.notSPACE
    CMP #.charDOUBLEQUOTE                               ; check for DOUBLE QUOTE
    BNE .notDOUBLEQUOTE                                 ; if (not double quote) then branch

    ; Deal with '"' DOUBLE QUOTE character
    BIT .stringInputOptions                             ; check options
    BPL .finishUpReadClearV                             ; if (string didn't start with a double quote) then branch

    ; We have found a string surrounded by double quotes.
    ; Check the next character isn't also a double quote, as that's an error.
    INY                                                 ; point at next character
    LDA (.stringInputBufferAddressLow),Y                ; get it
    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ .finishUpReadClearV                             ; if (third double quote character found) then branch

.finishedString
    JSR .skipSpacesAndCheckForCRInStringInput           ; skip past any final SPACEs
    SEC                                                 ; carry set
    RTS                                                 ;

.notDOUBLEQUOTE
    CMP #.charBAR                                       ; check for bar '|' character
    BNE .finishUpReadClearV                             ; if (not bar) then branch

    ; deal with '|' vertical BAR character
    INY                                                 ; increase Y to point to next character
    LDA (.stringInputBufferAddressLow),Y                ; get next character
    CMP #.charBAR                                       ; check for '|' again
    BEQ .finishUpReadClearV                             ; if (bar found) then branch

    CMP #.charDOUBLEQUOTE                               ; check for double quotes (") character
    BEQ .finishUpReadClearV                             ; if (double quotes) then branch

    CMP #.charEXCLAMATIONMARK                           ; check for '!' character
    BNE +                                               ; if (not '!') then branch

    ; deal with '|!' characters
    INY                                                 ; increment Y to next character
    LDA #$80                                            ; set bit 7
    BNE .gsreadInternal                                 ; loop back (sets bit 7 in next character)

    ; deal with remaining possible characters after the '|' BAR character
+
    CMP #.charSPACE                                     ; check for ' '
    BCC .brkBadString                                   ; if (less than space, i.e. a control code) then branch ('Bad string' message)

    CMP #.charQUESTIONMARK                              ; check for '|?'
    BEQ +                                               ; if ('|?') then branch (set delete character)

    ; Remaining '|' followed by a character is treated as a control code
    JSR .implementCTRLCodes                             ; modify code as if CTRL pressed
    BIT .allBitsSet                                     ; Set V flag
    BVS .finishUpReadX                                  ; ALWAYS branch (finish up with V set)

+
    LDA #.charDELETE                                    ; delete character

.finishUpReadClearV
    CLV                                                 ; clear V
.finishUpReadX
    INY                                                 ; increment Y
    ORA .stringInputPlingFlag                           ;
    CLC                                                 ; clear carry
    RTS                                                 ;

; ***************************************************************************************
.brkBadString
    BRK                                                 ;
    !byte $FD                                           ; error number
    !text "Bad string",0                                ; message (with zero terminator)

; ***************************************************************************************
;
; Apply SHIFT to character in A
;
; Modify character in A as if the SHIFT key is being pressed
;
; ***************************************************************************************
.implementSHIFT
    CMP #.charZERO                                      ;
    BEQ .exit24                                         ; if ('0' character found) then branch (return) (SHIFT '0' = '0')
    CMP #.charAT                                        ;
    BEQ .exit24                                         ; if ('@' character found) then branch (return) (SHIFT '@' = '@')
    BCC .flipBitFourIfNotCtrlCharacter                  ; if (A < '@') then branch
                                                        ; the branch converts characters
                                                        ;       !"#$%&`()*+,-./ 123456789:;<=>?
                                                        ; into  123456789:;<=>? !"#$%&`()*+,-./
    CMP #.charDELETE                                    ;
    BEQ .exit24                                         ; if (DELETE character found) then branch (return) (SHIFT DELETE = DELETE)
    BCS .flipBitFourOnly                                ; if (greater than $7F) then branch (toggle bit 4 and exit)

    ; At this point A>64 and A<127
    ; The following code converts the following characters:
    ;        ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_£ abcdefghijklmnopqrstuvwxyz{|}~
    ; into   abcdefghijklmnopqrstuvwxyz{|}~£_ ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^

.flipBitsForShift
    EOR #%00110000                                      ; flip bits 4 and 5
    CMP #(.charUNDERSCORE XOR %00110000)                ; }
    BEQ +                                               ; } if (it was originally underscore '_') then branch

    CMP #(.charPOUND XOR %00110000)                     ; }
    BNE .flipBitFourIfNotCtrlCharacter                  ; } if (it was NOT originally pound '£') then branch
+
    EOR #$1F                                            ; EOR for converting pound symbol (which will become
                                                        ; underscore when the EOR at .flipBitFourOnly is done)
.flipBitFourIfNotCtrlCharacter
    CMP #.charSPACE + 1                                 ; }
    BCC .exit24                                         ; } if (control code) then branch (return)
.flipBitFourOnly
    EOR #%00010000                                      ; flip bit 4
.exit24
    RTS                                                 ;

; ***************************************************************************************
;
; Modify character in A as if the CTRL key is being pressed
;
; This is used both when the CTRL key is being pressed, and for parsing strings using
; GSINIT / GSREAD. See .gsinitEntryPoint.
;
;     Input     Output      Notes
;     ASCII      CTRL
;     Code       Code
;     ----------------------------------------------------------------------
;     32-63     32-63       VDU 32-63 (unchanged)
;     '@'         0         VDU 0
;     'A'         1         VDU 1
;           ...
;     'Z'        26         VDU 26
;     '['        27         VDU 27
;     '\'        28         VDU 28
;     ']'        29         VDU 29
;     '^'        30         VDU 30
;     '_'        31         VDU 31
;     '£'        31         VDU 31 this is treated as a special case.
;                                  it would otherwise result in VDU 0 [why the special case?]
;     'a'         1         VDU 1
;           ...
;     'z'        26         VDU 26
;     '{'        27         VDU 27
;     '|'        28         VDU 28
;     '}'        29         VDU 29
;     '~'        30         VDU 30
;     127       127         DELETE
;     128-255   flip bit 5  flip bit 5 [it's not clear why this is useful?]
;
; ***************************************************************************************
.implementCTRLCodes
    CMP #.charDELETE                                    ; check for DELETE
    BEQ ++                                              ; if (DELETE found) then branch (exit)
    BCS .flipBitsForShift                               ; if (greater than $7F) then branch (process top bit characters)
    CMP #.charPOUND                                     ; }
    BNE +                                               ; } if (A is not '£') then branch
    LDA #.charUNDERSCORE                                ; A='_'
+
    CMP #.charAT                                        ; }
    BCC ++                                              ; } if (A < '@') then branch (return unchanged)
    AND #%00011111                                      ; at this point     A is between 64 to 126 inclusive
                                                        ; zero bits 5 to 7  A is between  0 to  31 inclusive
++
    RTS                                                 ;

; ***************************************************************************************
.runBootString
    !text "/!BOOT",13

; ***************************************************************************************
;
; OSBYTE 247 - Intercept BREAK
;
; On Exit:
;           Z clear if no user BREAK intercept code
; otherwise Z is set or cleared by user BREAK code
;
; ***************************************************************************************
.osbyte247EntryPoint
    LDA .breakInterceptJMPInstruction                  ; get first byte of user BREAK code (looking for 'JMP address')
    EOR #$4C                                           ; produces 0 if JMP absolute instruction is present
    BNE +                                              ; if (not zero) then branch (return)
    JMP .breakInterceptJMPInstruction                  ; jump to user BREAK code

; ***************************************************************************************
;
; OSBYTE 144 - *TV
;
; On Entry:
;       X=vertical shift of display
;       Y=interlace disable flag
; On Exit:
;       X=old vertical shift of display
;       Y=old interlace disable flag
;
; ***************************************************************************************
.osbyte144EntryPoint
    LDA .vduVerticalAdjust                              ; VDU vertical adjustment
    STX .vduVerticalAdjust                              ; store new value
    TAX                                                 ; put old value in X
    TYA                                                 ; put interlace flag in A
    AND #1                                              ; maximum value =1
    LDY .vduInterlaceValue                              ; get old value into Y
    STA .vduInterlaceValue                              ; put new value into A
+
    RTS                                                 ;


; ***************************************************************************************
;
; OSBYTE 147 - Write a byte to FRED
;
; X is offset within page
; Y is byte to write;
;
; ***************************************************************************************
.osbyte147EntryPoint
    TYA                                                 ;
    STA .fredPage,X                                     ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 149 - Write a byte to JIM
;
; X is offset within page
; Y is byte to write
;
; ***************************************************************************************
.osbyte149EntryPoint
    TYA                                                 ;
    STA .jimPage,X                                      ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 151 - Write a byte to SHEILA
;
; X is offset within page
; Y is byte to write
;
; ***************************************************************************************
.osbyte151EntryPoint
    TYA                                                 ;
    STA .sheilaPage,X                                   ;
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 16: Sound and Speech
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Introduction
;
; The sound chip has three channels that produce square waves tones, and one noise channel.
; The OS enhances this basic functionality with OSWORD 7 - Make a sound, and OSWORD 8 -
; Define an envelope. These correspond to the BASIC commands SOUND and ENVELOPE. The SOUND
; command simplifies the process of playing regular notes and noises, and adds the ability
; to store a queue of notes to play in advance. The ENVELOPE command allows a wide variety
; of sound effects to be played by varying the pitch and amplitude of a sound every 100th
; of a second as it plays.
; See .osword7EntryPoint.
; See .osword8EntryPoint.
;
; Sound durations are specified in 1/20ths of a second allowing a single byte to sustain a
; long note up to 12.75 seconds.
;
; In addition sound is produced by VDU 7 BELL - a surprisingly accurately pitched Treble C.
; See .vdu7EntryPoint.
;
; Finally, a percussive sound can (in extremis) be produced by setting and resetting the
; cassette relay. See .osbyte137EntryPoint. This is a mechanically generated sound, not
; produced via the internal loudspeaker.
;
; Many games such as Arcadians (Aardvark, 1983) and Zalaga (Acornsoft, 1982) that sought to
; emulate arcade games used the sound capabilities to create 'musical stings' and other
; effects.
; See arcadians.mp3
; See zalaga1.mp3
; See zalaga2.mp3
;
; ***************************************************************************************

; ***************************************************************************************
;
; Silence a sound channel
;
; On Entry:
;       X = buffer number (4-7) for channel (0-3)
;
; ***************************************************************************************
.silenceChannelX
    LDA #4                                              ; mark end of release phase
    STA .channel0PhaseCounter - .bufferNumberSound0,X   ; to channel X
    LDA #$C0                                            ; code for zero volume
    ; fall through...

; ***************************************************************************************
;
; Set volume for channel X
;
; On Entry:
;       A = volume, where $3F (loudest) to $C0 (silent) - see table below
;       X = buffer number (4-7) for channel (0-3)
;
; ***************************************************************************************
.setChannelXVolume
    STA .channel0Volume - .bufferNumberSound0,X         ; store A to give basic sound level
    LDY .soundDisableFlag                               ; get sound output/enable flag
    BEQ +                                               ; if (sound enabled) then branch
    LDA #$C0                                            ; code for zero volume
+
    ; we now convert the input volume into the value required to write to the sound chip
    SEC                                                 ; set carry
    SBC #$40                                            ; subtract $40
    LSR                                                 ; } divide by 8
    LSR                                                 ; }
    LSR                                                 ; }
    EOR #$0F                                            ; invert bits 0-3

;     BASIC SOUND   volume on entry     accumulator
;     volume        .channel0Volume     result now
;      -15                $3F              $10          loudest
;      -14                $37              $11
;      -13                $2F              $12
;      -12                $27              $13
;      -11                $1F              $14
;      -10                $17              $15
;       -9                $0F              $16
;       -8                $07              $17
;       -7                $FF              $18
;       -6                $F7              $19
;       -5                $EF              $1A
;       -4                $E7              $1B
;       -3                $DF              $1C
;       -2                $D7              $1D
;       -1                $CF              $1E
;        0                $C7              $1F          silent
;        -                $C0              $1F          silent

    ORA .soundParameterTable - .bufferNumberSound0,X    ; get encoded value for channel into top nybble
    ORA #$10                                            ; ensure bit 4 set (set volume)

.sendToSoundChip
    PHP                                                 ;
.sendToSoundChipFlagsAreadyPushed
    SEI                                                 ; disable interrupts
    LDY #$FF                                            ; }
    STY .systemVIADataDirectionRegisterA                ; } set data direction to all outputs
    STA .systemVIARegisterANoHandshake                  ; send data byte to sound chip
    INY                                                 ; Y=0
    STY .systemVIARegisterB                             ; set the write enable line low (active)
                                                        ; to let the sound chip know there
                                                        ; is data
    LDY #2                                              ; Y = loop counter
-
    DEY                                                 ; execute a short delay (this is to
    BNE -                                               ; keep the write enable line low for
                                                        ; at least 8 us, 16 cycles. This is
                                                        ; required by the sound chip hardware)
                                                        ;
                                                        ; [An alternative to this loop that
                                                        ; takes the same number of cycles, but
                                                        ; is two bytes shorter would be to JSR
                                                        ; to an (existing) RTS instruction.]

    LDY #8                                              ; }
    STY .systemVIARegisterB                             ; } pull the write enable line high (inactive)

    LDY #4                                              ; Y = loop counter
-
    DEY                                                 ; execute another short delay loop
    BNE -                                               ; [it's longer this time for some
                                                        ; reason? It seems like this loop is
                                                        ; not needed at all to me.]

    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
; Table to convert channel number to the bits required by the chip
.soundParameterTable
    !byte $E0,$C0,$A0,$80

; ***************************************************************************************
.skipToNextChannelLocal
    JMP .skipToNextChannel                              ; go to next channel

; ***************************************************************************************
;
; Update sounds in the 100Hz timer interrupt
;
; ***************************************************************************************
.processSoundInterrupt
    LDA #0                                              ;
    STA .numberOfSoundChannelsOnHold                    ; zero number of channels on hold for sync
    LDA .soundSyncCount                                 ; get sync count
    BNE +                                               ; if (this is not zero) then branch
    INC .numberOfSoundChannelsOnHold                    ; number of channels on hold for sync = 1
    DEC .soundSyncCount                                 ; number of channels required for sync = 255
+
    LDX #8                                              ; set loop counter (X = buffer number 4-7, corresponding to the channel number 0-3)
.processSoundChannelLoop
    DEX                                                 ; loop counter (X=7,6,5,4)
    LDA .channel0Occupancy - .bufferNumberSound0,X      ; get (sound queue occupancy)
    BEQ .skipToNextChannelLocal                         ; if (nothing playing on this channel) then branch (check next channel)
    LDA .bufferEmptyFlags,X                             ; get buffer empty flag
    BMI .chooseNextSound                                ; if (negative, i.e. buffer empty) then branch (choose the next sound to play)
    LDA .channel0Duration - .bufferNumberSound0,X       ; get duration remaining
    BNE .continueExistingSound                          ; if (duration remaining > 0) then branch (continue processing current sound)
.chooseNextSound
    JSR .checkForNextSoundToPlay                        ; check and pick up new sound if required
.continueExistingSound
    LDA .channel0Duration - .bufferNumberSound0,X       ; get duration of current sound
    BEQ .skipUpdateOfCurrentSound                       ; if (duration is zero) then branch (skip update)
    CMP #$FF                                            ; check for $FF duration (infinite duration)
    BEQ .notAtEndOfCurrentSoundDuration                 ; if (infinite duration) then branch (not at end of current sound)

    ; decrement 20Hz counter
    DEC .channel0Countdown20Hz - .bufferNumberSound0,X  ; decrement 10 mS count
    BNE .notAtEndOfCurrentSoundDuration                 ; if (counter not reached zero) then branch (not at end of current sound)

    ; reset 20Hz counter
    LDA #5                                              ; reset to 5
    STA .channel0Countdown20Hz - .bufferNumberSound0,X  ; to give 50 mSec delay

    ; decrement duration at 20Hz
    DEC .channel0Duration - .bufferNumberSound0,X       ; and decrement main counter
    BNE .notAtEndOfCurrentSoundDuration                 ; if (duration is non-zero) then branch (not at end of current sound)

.skipUpdateOfCurrentSound
    JSR .checkForNextSoundToPlay                        ; check and get new sound

.notAtEndOfCurrentSoundDuration
    LDA .channel0StepCountdownProgress - .bufferNumberSound0,X  ; check the step progress
    BEQ +                                                       ; if (step progress counter is zero) then branch (don't decrement step progress)
    DEC .channel0StepCountdownProgress - .bufferNumberSound0,X  ; decrement step progress
    BNE .skipToNextChannelLocal                                 ; if (step progress counter is zero) then branch (check next channel)

+
    LDY .channel0EnvelopeOffset - .bufferNumberSound0,X ; get envelope data offset
    CPY #$FF                                            ; check for no envelope active on this channel
    BEQ .skipToNextChannelLocal                         ; if (no envelope active) then branch (check next channel)

    LDA .envelopeBuffer,Y                               ; get step length (first byte of envelope data)
    AND #%01111111                                      ; clear the repeat bit
    STA .channel0StepCountdownProgress - .bufferNumberSound0,X  ; store it
    LDA .channel0PhaseCounter - .bufferNumberSound0,X   ; get current phase in ADSR
    CMP #4                                              ; check for release phase complete
    BEQ .adjustEnvelopePitch                            ; if (release phase completed) then branch

    ; set target amplitude for new phase
    LDA .channel0PhaseCounter - .bufferNumberSound0,X   ; start new step by getting current phase
    CLC                                                 ;
    ADC .channel0EnvelopeOffset - .bufferNumberSound0,X ; add it to envelope offset
    TAY                                                 ; transfer to Y
    LDA .envelopeBuffer + 11,Y                          ; and get target value at end of current phase
    SEC                                                 ;
    SBC #$3F                                            ;
    STA .targetAmplitude                                ; store modified number as current target amplitude

    ; set amplitude step for new phase
    LDA .envelopeBuffer + 7,Y                           ; get change of amplitude for current phase
    STA .currentAmplitudeStep                           ; store as current amplitude step change

    ; calculate updated volume
    LDA .channel0Volume - .bufferNumberSound0,X         ; get current volume level
    PHA                                                 ; save it
    CLC                                                 ; clear carry
    ADC .currentAmplitudeStep                           ; add current amplitude step change
    BVC .skipToggleBits                                 ; if (no overflow) then branch
    ROL                                                 ; carry = bit 7. If new amplitude is negative (relatively quiet) then set the maximum volume
    LDA #$3F                                            ; A=$3F (loudest volume)
    BCS .skipToggleBits                                 ; if (carry set) then branch
    EOR #$FF                                            ; toggle bits (A=$C0, silent)

.skipToggleBits
    STA .channel0Volume - .bufferNumberSound0,X         ; store in current volume
    ROL                                                 ; }
    EOR .channel0Volume - .bufferNumberSound0,X         ; } take the EOR of bits 6 and 7
    BPL .updateAmplitude                                ; if (bits 6 and 7 of volume are equal) then branch (to update amplitude)
    LDA #$3F                                            ; }
    BCC +                                               ; } if (carry clear) then branch (A=$3F); otherwise A=$C0
    EOR #$FF                                            ; }
+
    STA .channel0Volume - .bufferNumberSound0,X         ; this is stored in current volume

.updateAmplitude
    DEC .currentAmplitudeStep                           ; decrement amplitude change per step
    LDA .channel0Volume - .bufferNumberSound0,X         ; get volume again
    SEC                                                 ; set carry
    SBC .targetAmplitude                                ; subtract target value
    EOR .currentAmplitudeStep                           ; check against step value: a negative result indicates correct trend
    BMI +                                               ; so jump to next part

    ; enter new amplitude phase
    LDA .targetAmplitude                                ;
    STA .channel0Volume - .bufferNumberSound0,X         ; set target amplitude
    INC .channel0PhaseCounter - .bufferNumberSound0,X   ; increment phase counter
+
    PLA                                                 ; get the old volume level
    EOR .channel0Volume - .bufferNumberSound0,X         ; and compare with the new volume
    AND #$F8                                            ; mask out lower bits
    BEQ .adjustEnvelopePitch                            ; if (they are the same) then branch (volume doesn't need changing)
    LDA .channel0Volume - .bufferNumberSound0,X         ; }
    JSR .setChannelXVolume                              ; } set new volume level

.adjustEnvelopePitch
    LDA .channel0Section - .bufferNumberSound0,X        ; get current pitch section (0-2)
    CMP #3                                              ; check if we have reached section 3
    BEQ .skipToNextChannel                              ; if (current section is 3) then branch (skip rest of loop as all sections are finished)
    LDA .channel0SectionCountdownProgress - .bufferNumberSound0,X   ; check progress within current pitch section
    BNE .countdownTimerNotFinished                      ; if (countdown timer is not yet zero) then branch

    ; increment pitch section
    INC .channel0Section - .bufferNumberSound0,X        ; implement a section change
    LDA .channel0Section - .bufferNumberSound0,X        ; check if it's complete
    CMP #3                                              ;
    BNE +                                               ; if (not complete) then branch

    ; reached end of all three pitch sections
    LDY .channel0EnvelopeOffset - .bufferNumberSound0,X ; }
    LDA .envelopeBuffer,Y                               ; } get first envelope byte (top bit = repeat pitch envelope)
    BMI .skipToNextChannel                              ; if (negative, i.e. don't repeat pitch envelope) then branch
    LDA #0                                              ; }
    STA .channel0PitchOffset - .bufferNumberSound0,X    ; } reset to first pitch section
    STA .channel0Section - .bufferNumberSound0,X        ; }

+
    LDA .channel0Section - .bufferNumberSound0,X        ; get number of steps in new section
    CLC                                                 ;
    ADC .channel0EnvelopeOffset - .bufferNumberSound0,X ;
    TAY                                                 ;
    LDA .envelopeBuffer + 4,Y                           ; get envelope byte at offset 4 (number of steps in first pitch section)
    STA .channel0SectionCountdownProgress - .bufferNumberSound0,X   ;
    BEQ .skipToNextChannel                              ; if (zero) then branch (skip forwards)

.countdownTimerNotFinished
    DEC .channel0SectionCountdownProgress - .bufferNumberSound0,X   ; decrement countdown timer
    LDA .channel0EnvelopeOffset - .bufferNumberSound0,X ; get rate of pitch change
    CLC                                                 ;
    ADC .channel0Section - .bufferNumberSound0,X        ; add section number
    TAY                                                 ;
    LDA .envelopeBuffer + 1,Y                           ; get envelope byte 1+section (current change of pitch)
    CLC                                                 ;
    ADC .channel0PitchOffset - .bufferNumberSound0,X    ; add to current pitch offset
    STA .channel0PitchOffset - .bufferNumberSound0,X    ; save updated pitch offset
    CLC                                                 ;
    ADC .channel0BasePitch - .bufferNumberSound0,X      ; add base pitch
    JSR .setPitch                                       ; set new pitch

.skipToNextChannel
    CPX #4                                              ;
    BEQ +                                               ; if (X=4, i.e. last channel) then branch (return)
    JMP .processSoundChannelLoop                        ; do loop again

; ***************************************************************************************
.clearSoundChannels
    LDX #8                                              ; X=8, loop counter
-
    DEX                                                 ; } Loop from X=7 to X=4 inclusive
    JSR .clearSoundChannelBuffer                        ; } clearing each sound buffer
    CPX #4                                              ; }
    BNE -                                               ; }
+
    RTS                                                 ;

; ***************************************************************************************
.checkForNextSoundToPlay
    LDA .channel0PhaseCounter - .bufferNumberSound0,X   ; get current phase counter
    CMP #4                                              ; is it 'release complete' state
    BEQ +                                               ; if (release complete) then branch
    LDA #3                                              ; mark release in progress
    STA .channel0PhaseCounter - .bufferNumberSound0,X   ; store it
+
    LDA .bufferEmptyFlags,X                             ; check buffer empty flag
    BEQ .skipResetAsBufferIsNotEmpty                    ; if (buffer not empty) then branch
    LDA #0                                              ; mark buffer not empty
    STA .bufferEmptyFlags,X                             ; an store it

    LDY #4                                              ; Y = loop counter
-
    STA .channel0SyncFlag - 1,Y                         ; zero sync bytes
    DEY                                                 ;
    BNE -                                               ; until Y=0

    STA .channel0Duration - .bufferNumberSound0,X       ; zero duration count
    DEY                                                 ;
    STY .soundSyncCount                                 ; reset sync count to $FF (no sync)

.skipResetAsBufferIsNotEmpty
    LDA .channel0SyncFlag - .bufferNumberSound0,X       ; get synchronising flag
    BEQ .syncSounds                                     ; if (it's zero) then branch
    LDA .numberOfSoundChannelsOnHold                    ; get number of channels on hold
    BEQ .silenceNonEnvelopeSound                        ; if (it's zero) then branch (silence sound)
    LDA #0                                              ;
    STA .channel0SyncFlag - .bufferNumberSound0,X       ; zero synchronising flag
.readNextSoundFromBufferAndProcessLocal
    JMP .readNextSoundFromBufferAndProcess              ;

; ***************************************************************************************
.clearSoundChannelBuffer
    JSR .silenceChannelX                                ; silence the channel
    TYA                                                 ; Y=0 A=0
    STA .channel0Duration - .bufferNumberSound0,X       ; zero main count
    STA .bufferEmptyFlags,X                             ; mark buffer not empty
    STA .channel0Occupancy - .bufferNumberSound0,X      ; mark channel dormant
    LDY #3                                              ; Y=loop counter
-
    STA .channel0SyncFlag,Y                             ; }
    DEY                                                 ; } zero sync flags
    BPL -                                               ; }

    STY .soundSyncCount                                 ; reset sync to $FF (no sync)
    BMI .setPitchChanged                                ; ALWAYS branch

; ***************************************************************************************
.syncSoundBufferEmpty
    PHP                                                 ; save flags
    SEI                                                 ; and disable interrupts
    LDA .channel0PhaseCounter - .bufferNumberSound0,X   ; get ADSR phase counter
    CMP #4                                              ; check for end of release phase
    BNE +                                               ; if (not end of release phase) then branch
    JSR .osbyte152EntryPoint                            ; examine buffer
    BCC +                                               ; if (not empty, i.e. there's another sound to play) then branch
    LDA #0                                              ; }
    STA .channel0Occupancy - .bufferNumberSound0,X      ; } mark channel as silent
+
    PLP                                                 ; get back flags
    ; fall through...

; ***************************************************************************************
.silenceNonEnvelopeSound
    LDY .channel0EnvelopeOffset - .bufferNumberSound0,X ; this value is $FF if no envelope is defined
    CPY #$FF                                            ;
    BNE .exit25                                         ; if (envelope defined) then branch
    JSR .silenceChannelX                                ; silence channel
.exit25
    RTS                                                 ;

; ***************************************************************************************
.syncSounds
    JSR .osbyte152EntryPoint                            ; examine next byte in buffer (sets carry if buffer empty)
    BCS .syncSoundBufferEmpty                           ; if (buffer empty) then branch
    AND #3                                              ; get just bits 0 and 1
    BEQ .readNextSoundFromBufferAndProcessLocal         ; if (zero) then branch
    LDA .soundSyncCount                                 ; get synchronising count
    BEQ +                                               ; if (zero, i.e. nothing to sync) then branch

    INC .channel0SyncFlag - .bufferNumberSound0,X       ; set sync flag
    BIT .soundSyncCount                                 ; check bit 7 is clear
    BPL ++                                              ; if (sync required) then branch
    JSR .osbyte152EntryPoint                            ; get first byte from buffer
    AND #3                                              ; get just bits 0 and 1
    STA .soundSyncCount                                 ; store result
    BPL +                                               ; ALWAYS branch

++
    DEC .soundSyncCount                                 ;
+
    JMP .silenceNonEnvelopeSound                        ; silence the channel if envelope not in use

; ***************************************************************************************
.setPitch
    CMP .channel0Pitch - .bufferNumberSound0,X          ; check against pitch value
    BEQ .exit25                                         ; if (pitch is equal) then branch (exit)
.setPitchChanged
    STA .channel0Pitch - .bufferNumberSound0,X          ; store new pitch
    CPX #.bufferNumberSound0                            ; check for noise channel
    BNE .setPitchNotNoise                               ; if (X is not noise channel) then branch (not noise)

    ; setting noise
    AND #$0F                                            ; noise value
    ORA .soundParameterTable - .bufferNumberSound0,X    ; convert to chip format, by adding the value required for channel
    PHP                                                 ; save flags
    JMP .localSendToSoundChipFlagsAreadyPushed          ; and pass to chip control routine

; ***************************************************************************************
;
; Set the pitch of a sound
;
; On Entry:
;       A = pitch (0-255).
;
; ***************************************************************************************
.setPitchNotNoise
    PHA                                                 ; remember A = pitch (0-252)
    AND #3                                              ;
    STA .fractionalSemitones                            ; store the fractional amount (0-3) between semitones

    ; calculate the octave
    LDA #0                                              ;
    STA .soundPitchLow                                  ; octave
    PLA                                                 ; get back A = original pitch value
    LSR                                                 ; }
    LSR                                                 ; } divide by 4 (to get semitone count 0-63)
-
    CMP #12                                             ;
    BCC .finishedGettingOctave                          ; if (remainder is less than 12) then branch (we have found the right octave)
    INC .soundPitchLow                                  ; increment octave
    SBC #12                                             ; subtract 12 for each octave
    BNE -                                               ; if (not zero) then branch (loop back)

    ; at this point .soundPitchLow defines the Octave (0-5)
    ; A = the semitone within the octave

    ; get the 10 bit pitch value for the note within the octave from the pitch lookup tables
.finishedGettingOctave
    TAY                                                 ; Y = semitone within octave
    LDA .soundPitchLow                                  ; get octave number into A
    PHA                                                 ; push it
    LDA .pitchLookupTableLow,Y                          ; get semitone byte from first pitch table
    STA .soundPitchLow                                  ; store it
    LDA .pitchLookupTableHigh,Y                         ; get semitone byte from second pitch table
    PHA                                                 ; push second table byte
    AND #3                                              ; keep two least significant bits only
    STA .soundPitchHigh                                 ; save them
    PLA                                                 ; pull original second table byte
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } shift high nybble down into low nybble
    LSR                                                 ; }
    STA .soundFractional                                ; store it (amount to subtract for each fraction (0-3) between semitones)

    ; adjust for any eighth tones (0-3) between semitones
    LDA .soundPitchLow                                  ;
    LDY .fractionalSemitones                            ; loop counter (0-3)
    BEQ ++                                              ;

-
    SEC                                                 ; }
    SBC .soundFractional                                ; } soundFractional is subtracted from A each time around the loop
    BCS +                                               ;
    DEC .soundPitchHigh                                 ; decrement high byte of pitch as needed
+
    DEY                                                 ; decrement loop counter
    BNE -                                               ; if (not done) then branch (loop back)

++
    STA .soundPitchLow                                  ; store result (low byte of pitch)

    ; halve the 10-bit pitch value (.soundPitchLow/High) for each octave
    PLA                                                 ; recall octave number
    TAY                                                 ; Y = loop counter = octave number
    BEQ +                                               ;
-
    LSR .soundPitchHigh                                 ; }
    ROR .soundPitchLow                                  ; } halve soundVariableA/B
    DEY                                                 ;
    BNE -                                               ; if (not done yet) then branch (loop back)

+
    LDA .soundPitchLow                                  ;

    ; Offset the pitch slightly depending on the channel. Perhaps to avoid
    ; phase shift effects when two or more channels play the same pitch?
    CLC                                                 ;
    ADC .soundPitchOffsetByChannelTable - .bufferNumberSound0,X ;
    STA .soundPitchLow                                  ;
    BCC +                                               ;
    INC .soundPitchHigh                                 ;

    ; .soundPitchLow/High now holds the 10 bit pitch we want
    ; we adjust to get the exact bytes to send to the sound chip
+
    AND #$0F                                            ; frequency value (low four bits)
    ORA .soundParameterTable - .bufferNumberSound0,X    ; convert to chip format, by adding
                                                        ; the value required for channel

    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    JSR .sendToSoundChip                                ; send first byte to sound chip

    LDA .soundPitchLow                                  ; calculate the second byte to send
                                                        ; to the sound chip
    LSR .soundPitchHigh                                 ; }
    ROR                                                 ; }
    LSR .soundPitchHigh                                 ; } divide by 4
    ROR                                                 ; }

    LSR                                                 ; }
    LSR                                                 ; } shift byte right twice

    ; now A holds the second byte we want to send to the sound chip
.localSendToSoundChipFlagsAreadyPushed
    JMP .sendToSoundChipFlagsAreadyPushed               ; send second byte to sound chip

; ***************************************************************************************
;
; Read the next sound from the SOUND buffer and act on it
;
; Each entry in the sound buffer is three bytes:
;
;   byte 0: envelope-volume-hold-sync byte:
;               bit 7     = 0 for an envelope number
;               bits 3-6  = envelope number - 1 (0-3), or volume in range (15 to 0)
;               bit 2     = h, the hold bit
;               bits 0-1  = ss, the sync bits (0-3)
;   byte 1: pitch
;   byte 2: duration
;
; See .osword7EntryPoint where these bytes are added to the buffer.
;
; ***************************************************************************************
.readNextSoundFromBufferAndProcess
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    JSR .osbyte145EntryPoint                            ; read first byte from buffer (envelope-volume-hold-sync byte)

    ; check hold bit
    PHA                                                 ; push A
    AND #4                                              ; isolate the hold bit
    BEQ .playNewSound                                   ; if (hold not set) then branch
    PLA                                                 ; get back A

    ; hold required
    LDY .channel0EnvelopeOffset - .bufferNumberSound0,X ; get envelope offset
    CPY #$FF                                            ; check if envelope is in use
    BNE +                                               ; if (envelope in use) then branch

    ; no envelope in use, silence channel
    JSR .silenceChannelX                                ; so call to silence channel

+
    JSR .osbyte145EntryPoint                            ; get (and ignore) pitch byte
    JSR .osbyte145EntryPoint                            ; get the duration
    PLP                                                 ; get back flags
    JMP .setDurationAndExit                             ; set duration, exit

.playNewSound
    PLA                                                 ; get back A
    AND #%11111000                                      ; zero bits 0-2
    ASL                                                 ; put bit 7 into carry
    BCC +                                               ; if (zero, envelope) then branch

    ; extract and set volume
    EOR #$FF                                            ; }
    LSR                                                 ; } convert volume number into
    SEC                                                 ; } an expected value for the
    SBC #$40                                            ; } volume routine
    JSR .setChannelXVolume                              ; and set volume

    ; set no envelope in use
    LDA #$FF                                            ; A=$FF
+
    ; set envelope offset = envelope number * 16 (or $FF for no envelope)
    STA .channel0EnvelopeOffset - .bufferNumberSound0,X ; get envelope number-1 *16 into A

    ; restart the channel's 20Hz timer
    LDA #5                                              ; set duration sub-counter
    STA .channel0Countdown20Hz - .bufferNumberSound0,X  ;

    ; set phase 1, the start of the sound
    LDA #1                                                      ; set phase counter
    STA .channel0StepCountdownProgress - .bufferNumberSound0,X  ;

    ; reset section countdown, phase counter, and pitch offset
    LDA #0                                                          ;
    STA .channel0SectionCountdownProgress - .bufferNumberSound0,X   ; reset pitch section countdown progress
    STA .channel0PhaseCounter - .bufferNumberSound0,X               ; reset pitch phase
    STA .channel0PitchOffset - .bufferNumberSound0,X                ; reset pitch offset

    ; set section to $FF
    LDA #$FF                                            ;
    STA .channel0Section - .bufferNumberSound0,X        ;

    ; store pitch
    JSR .osbyte145EntryPoint                            ; read pitch
    STA .channel0BasePitch - .bufferNumberSound0,X      ; set it

    ; read duration
    JSR .osbyte145EntryPoint                            ; read duration
    PLP                                                 ;
    PHA                                                 ; save duration

    ; set pitch
    LDA .channel0BasePitch - .bufferNumberSound0,X      ; get back pitch value
    JSR .setPitch                                       ; and set it

    ; set duration
    PLA                                                 ; get back duration
.setDurationAndExit
    STA .channel0Duration - .bufferNumberSound0,X       ; set duration
    RTS                                                 ;

; ***************************************************************************************
;
; Pitch tables
;
; These next two tables are used to convert the 8 bit pitch (0-255) of a sound value passed
; to the OS (e.g. via OSWORD 7, see .osword7EntryPoint) into the 10-bit integer pitch value
; required by the sound chip.
;
; When given a 10 bit pitch value, the chip outputs a tone with frequency:
;
;       frequency (in Hz) = 4,000,000 / (32 * pitch)
;
; The first table provides the lower 8 bits and the second table (bits 0-1) provide the two
; high bits:
;
;        low byte      10 bit
;        +bits 0,1     chip      actual      ideal
; note   high byte     pitch     frequency   frequency
; -------------------------------------------------------------------------
;   B    $3F0       =  1008      124.01Hz    123.47Hz
;   C    $3B7       =   951      131.44Hz    130.81Hz
;   C#   $382       =   898      139.20Hz    138.59Hz
;   D    $34F       =   847      147.58Hz    146.83Hz
;   D#   $320       =   800      156.25Hz    155.56Hz
;   E    $2F3       =   755      165.56Hz    164.81Hz
;   F    $2C8       =   712      175.56Hz    174.61Hz
;   F#   $2A0       =   672      186.01Hz    185.00Hz
;   G    $27B       =   635      196.85Hz    196.00Hz
;   G#   $257       =   599      208.68Hz    207.65Hz
;   A    $235       =   565      221.24Hz    220.00Hz
;   A#   $216       =   534      234.08Hz    233.08Hz
;
; The upper nybble (bits 4-7) of the .pitchLookupTableHigh stores the amount to reduce the
; 10 bit pitch value for each quarter (0-3) between two adjacent semitones. Bits 2-3 are
; unused.
;
; ***************************************************************************************
.pitchLookupTableLow
    !byte $F0                                           ; B
    !byte $B7                                           ; C
    !byte $82                                           ; C#
    !byte $4F                                           ; D
    !byte $20                                           ; D#
    !byte $F3                                           ; E
    !byte $C8                                           ; F
    !byte $A0                                           ; F#
    !byte $7B                                           ; G
    !byte $57                                           ; G#
    !byte $35                                           ; A
    !byte $16                                           ; A#

; ***************************************************************************************
.pitchLookupTableHigh
    !byte $E7                                           ; B
    !byte $D7                                           ; C
    !byte $CB                                           ; C#
    !byte $C3                                           ; D
    !byte $B7                                           ; D#
    !byte $AA                                           ; E
    !byte $A2                                           ; F
    !byte $9A                                           ; F#
    !byte $92                                           ; G
    !byte $8A                                           ; G#
    !byte $82                                           ; A
    !byte $7A                                           ; A#

; [ More accurate values for these two tables would be as follows:
;
; .pitchLookupTableLow
;    !byte $F3                                           ; B
;    !byte $BB                                           ; C
;    !byte $85                                           ; C#
;    !byte $52                                           ; D
;    !byte $23                                           ; D#
;    !byte $F5                                           ; E
;    !byte $CB                                           ; F
;    !byte $A3                                           ; F#
;    !byte $7D                                           ; G
;    !byte $59                                           ; G#
;    !byte $37                                           ; A
;    !byte $17                                           ; A#
;
; .pitchLookupTableHigh
;    !byte $E7                                           ; B
;    !byte $D7                                           ; C
;    !byte $DB                                           ; C#   <-- this is the only
;    !byte $C3                                           ; D        change to this table
;    !byte $B7                                           ; D#
;    !byte $AA                                           ; E
;    !byte $A2                                           ; F
;    !byte $9A                                           ; F#
;    !byte $92                                           ; G
;    !byte $8A                                           ; G#
;    !byte $82                                           ; A
;    !byte $7A                                           ; A#
; ]


; ***************************************************************************************
;
; PHROM numbers are $F0-$FF
;
; ***************************************************************************************
.setInitialSpeechPHROMNumber
    LDA #$EF                                            ; first PHROM number is $F0 (A=$EF is one less since it will be incremented before being accessed)
    STA .currentSpeechPHROMOrROMNumber                  ; store it
    RTS                                                 ;


; ***************************************************************************************
.readByteFromROMOrPHROM
    LDX #.romServiceCallROMFilingSystemInitialize       ; X=paged ROM service call for ROM filing system initialise
    INC .currentSpeechPHROMOrROMNumber                  ;
    LDY .currentSpeechPHROMOrROMNumber                  ; get ROM number
    BPL .romServiceCall                                 ; if (non-negative, i.e. it's a Paged ROM) then branch

    ; PHROM found (top bit of ROM number set)
    LDX #0                                              ; }
    STX .romAddressHigh                                 ; }
    INX                                                 ; } set address pointer in PHROM to $0001
    STX .romAddressLow                                  ; }
    JSR .writeAddressAndROMNumberToSpeechProcessor      ; pass info to speech processor

    ; Check that we have a copyright string "(C)" in the PHROM
    LDX #3                                              ; X = loop counter
-
    JSR .readByteFromPHROM                              ; read byte from PHROM
    CMP .copyrightString,X                              ; check if it's the copyright string
    BNE .readByteFromROMOrPHROM                         ; if (no match) then branch (try next ROM)
    DEX                                                 ; decrement loop counter
    BPL -                                               ; loop back until done

    LDA #$3E                                            ; ROM address is $003E, to read the 'end of speech data' address (See Speech User Guide, Page 27)
    STA .romAddressLow                                  ; set low byte of address

.readFromPHROM
    JSR .writeAddressAndROMNumberToSpeechProcessor      ; pass info to speech processor

    LDX #$FF                                            ; X = loop counter (to read two bytes)
.loopNextByte
    JSR .readByteFromPHROM                              ; check for speech proc. etc.

    ; Store the byte read into .romAddressLow/High, reversing all the bits
    LDY #8                                              ; Y = loop counter Y (to read 8 bits)
-
    ASL                                                 ; shift byte from PHROM
    ROR .romAddressHigh,X                               ; rotate into memory, reversing order of the bits
    DEY                                                 ; into .romAddressLow (X=255) and .romAddressHigh (X=0)
    BNE -                                               ; loop eight times

    INX                                                 ; increment X to zero (first loop iteration) or one (second loop iteration)
    BEQ .loopNextByte                                   ; if (X=0, first time around loop) then branch (loop back to read another byte)

    CLC                                                 ;
    BCC .writeAddressAndROMNumberToSpeechProcessor      ; ALWAYS branch

; ***************************************************************************************
; Read from ROM Filing System or Speech PHrase ROM
.readByteFromROMFSorPHROM
    LDX #.romServiceCallROMFilingSystemByteGet          ; X=paged ROM service call to get a byte from the ROM filing system
    LDY .currentSpeechPHROMOrROMNumber                  ; check ROM / PHROM number
    BMI .readByteFromPHROM                              ; if (ROM number is negative, i.e. a PHROM) then branch
    LDY #$FF                                            ; Y=255
.romServiceCall
    PHP                                                 ; store flags
    JSR .osbyte143EntryPoint                            ; paged ROM service call
    PLP                                                 ; restore flags
    CMP #1                                              ; if (A >= 1, i.e. ROM service call
                                                        ; was not claimed) then set carry
                                                        ; [but carry seems to be unused]
    TYA                                                 ; A = Y = byte read
    RTS                                                 ;

; ***************************************************************************************
.readByteFromPHROM
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDY #$10                                            ; Command code to ask speech processor
                                                        ; to read a byte
    JSR .osbyte159EntryPoint                            ; call OSBYTE 159 - write command to speech processor
    LDY #0                                              ; Y=0
    BEQ .readWriteSpeechProcessorPushedFlags            ; ALWAYS branch (read speech processor)


; ***************************************************************************************
;
; OSBYTE 158 - Read byte from speech processor
;
; ***************************************************************************************
.osbyte158EntryPoint
    LDY #0                                              ; Y=0 to set speech proc to read
    BEQ .readWriteSpeechProcessor                       ; ALWAYS branch

; write A (a byte of an address) to speech processor as two nybbles
.writeTwoNybblesOfAddressToSpeechProcessor
    PHA                                                 ; push A
    JSR .writeLoadAddressCommandToSpeechProcessor       ; to write to speech processor
    PLA                                                 ; get back A
    ROR                                                 ; } bring upper nybble to lower nybble
    ROR                                                 ; } by rotate right
    ROR                                                 ; } 4 times
    ROR                                                 ; }
    ; fall through...

; ***************************************************************************************
; Write 'Load address' command to speech processor
; See Speech System Users Guide (Page 21)
.writeLoadAddressCommandToSpeechProcessor
    AND #%00001111                                      ; mask out top nybble
    ORA #%01000000                                      ; set top bits: 'Load address' command
    TAY                                                 ; forming command for speech processor
    ; fall through...

; ***************************************************************************************
;
; OSBYTE 159 - Write to speech processor
;
; On Entry:
;       Y = data or command
; ***************************************************************************************
.osbyte159EntryPoint
    TYA                                                 ; transfer data or command from Y to A
    LDY #1                                              ; to set speech proc to write
    ; fall through...

; ***************************************************************************************
;
; Read or write to the Speech processor
;
; See 'Speech System Users Guide' for details, and data sheets for the chips:
;
; Speech processor is 'Texas Instruments TMS 5220 Voice Synthesis Processor'
; Speech data ROM  is 'Texas Instruments 16K TMS 6100'
;
; On Entry:
;       Y = 0 to read from speech processor
;       Y = 1 to write to speech processor
;       A = value to write (speech op-code or data) if writing
;
; On Exit:
;       Y = byte read (when reading)
;       N flag set if top bit of Y is set
;
; ***************************************************************************************
.readWriteSpeechProcessor
    PHP                                                 ; remember flags
    SEI                                                 ; disable interrupts
.readWriteSpeechProcessorPushedFlags
    BIT .speechSystemPresentFlag                        ; check for speech processor
    BPL .speechProcessingDone                           ; if (speech processor not found)
                                                        ; then branch

    ; read or write to the speech processor
    PHA                                                 ; remember A (value to write)
    LDA .speechDirectionTable,Y                         ; } set data direction to give 8
    STA .systemVIADataDirectionRegisterA                ; } bit input (Y=0) or output (Y=1)
    PLA                                                 ; recall A (value to write)

    ; write byte (only has an effect if the data direction register is set for writing)
    STA .systemVIARegisterANoHandshake                  ; send value to speech chip

    LDA .speechEnableTable,Y                            ; } enable speech read (Y=0)
    STA .systemVIARegisterB                             ; } or write (Y=1)

    ; loop to wait for enable read / write to take effect
-
    BIT .systemVIARegisterB                             ; check result
    BMI -                                               ; loop back until speech processor
                                                        ; reports ready (when bit 7 of Port
                                                        ; B is clear)

    ; read byte (only reads a valid value if the data direction register is set for reading)
    LDA .systemVIARegisterANoHandshake                  ; read speech processor data

    ; disable reading / writing speech
    PHA                                                 ; remember A
    LDA .speechDisableTable,Y                           ; } disable speech read (Y=0)
    STA .systemVIARegisterB                             ; } or write (Y=1)
    PLA                                                 ; recall A

.speechProcessingDone
    PLP                                                 ; get back flags (including restoring
                                                        ; interrupts to what they were before)
    TAY                                                 ; Y = value read from speech processor
    RTS                                                 ;

; ***************************************************************************************
.setROMOrPHROMAddress
    LDA .fsSpareByteA                                   ; set ROM displacement pointer
    STA .romAddressLow                                  ; in .romAddressLow
    LDA .fsSpareByteB                                   ;
    STA .romAddressHigh                                 ; And .romAddressHigh
    LDA .currentSpeechPHROMOrROMNumber                  ; check PHROM / ROMFS number
    BPL .exit26                                         ; if (ROM is selected, not PHROM)
                                                        ; then branch (return)
    ; fall through...

; ***************************************************************************************
;
; Send the given address to the Speech Processor
;
; The speech processor has a command where the CPU can send an address for the speech
; processor together with a ROM/PHROM number. Data is written to the speech processor a
; nybble at a time. Five nybbles are needed in total.
;
; On Entry:
;       .romAddressLow/High contains the 14 bit address (to access anywhere in a 16K ROM)
;       to send to the speech processor.
;       .currentSpeechPHROMOrROMNumber contains the ROM/PHROM number (6 bits) to the speech
;       processor.
;
; ***************************************************************************************
.writeAddressAndROMNumberToSpeechProcessor
    PHP                                                 ; push flags
    SEI                                                 ; disable interrupts
    LDA .romAddressLow                                  ; get ROM address low
    JSR .writeTwoNybblesOfAddressToSpeechProcessor      ; pass it to speech processor
    LDA .currentSpeechPHROMOrROMNumber                  ; }
    STA .tempStoreFA                                    ; } .tempStoreFA = PHROM / ROM number
    LDA .romAddressHigh                                 ; get ROM address high
    ROL                                                 ; }
    ROL                                                 ; }
    LSR .tempStoreFA                                    ; } replace the top two bits with the
    ROR                                                 ; } lower two bits of the ROM/PHROM
    LSR .tempStoreFA                                    ; } number
    ROR                                                 ; }
    JSR .writeTwoNybblesOfAddressToSpeechProcessor      ; pass byte to speech processor
    LDA .tempStoreFA                                    ; .tempStoreFA has the remaining bits
                                                        ; of the ROM/PHROM number
    JSR .writeLoadAddressCommandToSpeechProcessor       ; pass lower nybble to speech processor
    PLP                                                 ; restore flags
.exit26
    RTS                                                 ;


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 17: Keyboard processing
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.tidyUpAfterKeyboardProcessing
    LDX #$FF                                            ; assume enable keyboard interrupt processing
    LDA .lastKeyPressedInternal                         ; }
    ORA .firstKeyPressedInternal                        ; } check for any key pressed
    BNE +                                               ; if (anything pressed) then branch (skip forward, don't ignore keyboard interrupts)
    LDA #%10000001                                      ; enable keyboard interrupt (by writing bit 7 and
    STA .systemVIAInterruptEnableRegister               ; bit 0 of system VIA interrupt enable register)
    INX                                                 ; set X=0 (ignore keyboard interrupts)
+
    STX .enableKeyboardInterruptProcessingFlag          ; set keyboard interrupt processing flag
                                                        ; (0 means ignore keyboard interrupts, 255 means don't ignore keyboard interrupts)
    ; fall through...


; ***************************************************************************************
; write to the keyboard LEDs (SHIFT LOCK and CAPS LOCK)
;
; On Entry:
;       .keyboardStatusFlags contains the SHIFT / CAPS LOCK state to write to the LEDs
;
; On Exit:
;       A contains the value of the flags register on entry
;       Preserves N and V flags
.keyboardIndicators
    PHP                                                 ; save flags
    LDA .keyboardStatusFlags                            ; read keyboard status
                                                        ; Bit 4 = 0 means CAPS LOCK engaged (c)
                                                        ; bit 5 = 0 means SHIFT LOCK engaged (s)
                                                        ; A = %xxscxxxx
    LSR                                                 ; A = %0xxscxxx
    AND #%00011000                                      ; A = %000sc000
    ORA #6                                              ; A = %000sc110
    STA .systemVIARegisterB                             ; write the bottom nybble to turn on or off CAPS LOCK light
    LSR                                                 ; A = %0000sc11
    ORA #7                                              ; A = %0000s111
    STA .systemVIARegisterB                             ; write the bottom nybble to turn on or off SHIFT LOCK light
    JSR .enableKeyboardScanning                         ; enable keyboard scanning
    PLA                                                 ; get back flags
    RTS                                                 ;


; ***************************************************************************************
;
; KEYV - Default main keyboard handling routine
;
; On Entry:
;  Flags
;   C V                                                             Resolved to:
;   0 0 - Test SHIFT and CTRL keys (exit with N=1 if CTRL pressed;
;                                   V=1 if SHIFT pressed)           See .keyTestSHIFTAndCTRLOrTimerInterrupt
;   1 0 - Scan keyboard (as OSBYTE 121)                             See .scanKeyboard
;   0 1 - Key pressed interrupt entry                               See .keyPressedInterrupt
;   1 1 - Timer interrupt entry                                     See .keyboardTimerInterrupt
;
; ***************************************************************************************
.keyEntryPoint
    BVC .keyVClear                                      ; if (V is clear) then branch
    LDA #1                                              ; disable keyboard interrupts
    STA .systemVIAInterruptEnableRegister               ; by writing to VIA interrupt vector
    BCS .keyboardTimerInterrupt                         ; if (timer interrupt) then branch
    JMP .keyPressedInterrupt                            ; jump

; ***************************************************************************************
.keyVClear
    BCC .keyTestSHIFTAndCTRLOrTimerInterrupt            ; if (carry clear) then branch (test SHIFT and CTRL)
    JMP .scanKeyboard                                   ; jump to scan keyboard

; ***************************************************************************************
.keyboardTimerInterrupt
    INC .enableKeyboardInterruptProcessingFlag          ; increment keyboard flag to zero
                                                        ; to stop further key processing
    ; fall through...

; ***************************************************************************************
;
; Test SHIFT and CTRL
;
; On Entry:
;       Carry CLEAR if entered here for testing the SHIFT and CTRL keys
;       Carry SET   if entered via the keyboard timer interrupt
;
; On Exit:
;       N=1 if CTRL pressed
;       V=1 if SHIFT pressed
; ***************************************************************************************
.keyTestSHIFTAndCTRLOrTimerInterrupt
    LDA .keyboardStatusFlags                            ; read keyboard status
                                                        ; Bit 3 = 1 means SHIFT pressed
                                                        ; Bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; Bit 6 = 1 means CTRL pressed
                                                        ; Bit 7 = 1 means SHIFT enabled
    AND #%10110111                                      ; zero bits 3 and 6 (SHIFT and CTRL pressed)
    LDX #0                                              ; zero X to test for SHIFT key pressed
    JSR .interrogateKeyboard                            ; interrogate keyboard. Returns with X=$80 if SHIFT is pressed
    STX .tempStoreFA                                    ; save X (SHIFT key status)
    CLV                                                 ; clear V
    BPL .testCTRL                                       ; if (no key pressed) then branch (check for CTRL key)
    BIT .allBitsSet                                     ; set N and V flags
    ORA #%00001000                                      ; set bit 3 to indicate SHIFT was pressed
.testCTRL
    INX                                                 ; (X=$01 or X=$81 but top bit is ignored by .interrogateKeyboard)
    JSR .interrogateKeyboard                            ; check the CTRL key (key X)
    BCC .keyboardIndicators                             ; if (entered routine just for testing SHIFT and CTRL status) then branch
                                                        ;                        (to turn on keyboard lights as required and exit)

    ; at this point we are here because of a timer interrupt
    BPL +                                               ; if (key not pressed) then branch
    ORA #%01000000                                      ; or set CTRL pressed bit in keyboard status byte in A
+
    STA .keyboardStatusFlags                            ; save the updated status byte

    LDX .lastKeyPressedInternal                         ;
    BEQ .noLastKeyPressed                               ; if (no key pressed) then branch
    JSR .interrogateKeyboard                            ; check to see if last key is still pressed
    BMI .checkForKeyAutorepeat                          ; if (key pressed) then branch (enter repeat routine)
    CPX .lastKeyPressedInternal                         ; compare X (zero) with last key pressed
.storeLastKeyPressed
    STX .lastKeyPressedInternal                         ; store X in last key pressed
    BNE .noLastKeyPressed                               ; if (no key recently pressed) then branch
    LDX #0                                              ; }
    STX .lastKeyPressedInternal                         ; } store zero as the last key pressed

.resetAutorepeatAndContinue
    JSR .resetAutorepeatCounters                        ; and reset repeat system
.noLastKeyPressed
    JMP .keyboardRolloverChecks                         ;

; ***************************************************************************************
; This looks the see if the current key pressed is the same as the previous key pressed
; If so we handle auto-repeat.
.checkForKeyAutorepeat
    CPX .lastKeyPressedInternal                         ;
    BNE .storeLastKeyPressed                            ; if (X is not the same as the last key pressed) then branch back

    ; new key pressed is same as last key pressed, so handle auto-repeat
    LDA .autorepeatCountdownTimer                       ; get auto repeat countdown timer
    BEQ .afterModifiers                                 ; if (auto repeat countdown timer is zero) then branch
    DEC .autorepeatCountdownTimer                       ; decrement timer
    BNE .afterModifiers                                 ; if (not zero) then branch (still waiting for a repeat delay to finish)

    LDA .keyboardFirstAutorepeatCount                   ; get initial autorepeat delay (or repeat interval)
    STA .autorepeatCountdownTimer                       ; store it in countdown timer
    LDA .keyboardAutoRepeatRate                         ; get auto repeat interval
    STA .keyboardFirstAutorepeatCount                   ; store it as next value for countdown timer
    LDA .keyboardStatusFlags                            ; get keyboard status
    LDX .lastKeyPressedInternal                         ; get last key pressed
    CPX #$D0                                            ; check for SHIFT LOCK key
    BNE .testCapsLock                                   ; if (not SHIFT LOCK) then branch (to test CAPS LOCK)

    ; deal with SHIFT LOCK key pressed.
    ; Update keyboard status flags.
    ORA #%10010000                                      ; sets keyboard status flags (enable SHIFT, disengage CAPS LOCK)

                                                        ; Bit 3 = 1 means SHIFT pressed
                                                        ; Bit 4 = 0 means CAPS LOCK engaged
                                                        ; bit 5 = 0 means SHIFT LOCK engaged
                                                        ; Bit 6 = 1 means CTRL pressed
                                                        ; Bit 7 = 1 means SHIFT enabled

    EOR #%10100000                                      ; flip SHIFT enabled, and flip SHIFT LOCK engaged

.resetKeyboardStatusAndTimer
    STA .keyboardStatusFlags                            ; set keyboard status
    LDA #0                                              ; and set timer
    STA .autorepeatCountdownTimer                       ; to 0
.afterModifiers
    JMP .keyboardRolloverChecks                         ;

; ***************************************************************************************
.testCapsLock
    CPX #$C0                                            ; check for CAPS LOCK
    BNE .getASCIICode                                   ; if (not CAPS LOCK) then branch (decode key to ASCII etc)

    ; deal with CAPS LOCK key pressed.
    ; Update keyboard status flags.
    ORA #$A0                                            ; enable shift flag, and disengage SHIFT LOCK
    BIT .tempStoreFA                                    ; check for SHIFT pressed
    BPL +                                               ; if (SHIFT not pressed) then branch
    ORA #$10                                            ; set CAPS LOCK disengaged
    EOR #$80                                            ; flip SHIFT enabled
+
    EOR #$90                                            ; reverse both SHIFT enabled and CAPS LOCK
    JMP .resetKeyboardStatusAndTimer                    ; reset keyboard status and set timer


; ***************************************************************************************
;
; Get ASCII code
;
; Handles the conversion of the internal key number (here with the top bit set) into
; the final ASCII code. It takes into account the current state of CTRL key, SHIFT key,
; the SHIFT LOCK and CAPS LOCK engaged states.
;
; See .scanKeyboard for table of internal key numbers.
;
; On Entry:
;       X = key pressed internal number WITH THE TOP BIT SET
;           X is at least $90, since the internal key number is at least 16 ($10).
;
; ***************************************************************************************
.getASCIICode
    LDA .keyDataTable1 - $90,X                          ; get ASCII code from look up tables
    BNE +                                               ; if (not zero, i.e. TAB not pressed) then branch (skip TAB)

    ; deal with TAB key
    LDA .asciiCodeGeneratedByTABKey                     ; get TAB character (9 by default)

+
    LDX .keyboardStatusFlags                            ; get keyboard status
    STX .tempStoreFA                                    ; store keyboard status in temporary storage
    ROL .tempStoreFA                                    ; rotate to get CTRL pressed into bit 7
    BPL +                                               ; if (CTRL not pressed) then branch (past CTRL processing)

    ; deal with CTRL key pressed
    LDX .firstKeyPressedInternal                        ; get number of previously pressed key
.localResetAutorepeatAndContinue
    BNE .resetAutorepeatAndContinue                     ; if (not zero) then branch (reset autorepeat counters)
    JSR .implementCTRLCodes                             ; perform code changes for CTRL

+
    ROL .tempStoreFA                                    ; move SHIFT LOCK into bit 7
    BMI .testCapsLockEngaged                            ; if (SHIFT LOCK not engaged) then branch (skip SHIFT LOCK processing)

    ; deal with SHIFT LOCK key engaged
    JSR .implementSHIFT                                 ; make code changes for SHIFT

    ROL .tempStoreFA                                    ; move CAPS LOCK into bit 7
    JMP .testShiftEnabled                               ;

; ***************************************************************************************
.testCapsLockEngaged
    ROL .tempStoreFA                                    ; move CAPS LOCK into bit 7
    BMI .testShift                                      ; if (CAPS LOCK not engaged) then branch

    ; deal with CAPS LOCK engaged
    JSR .isLetter                                       ; make changes for CAPS LOCK on, return with C clear for alphabetic codes
    BCS .testShift                                      ; if (not a letter) then branch
    JSR .implementSHIFT                                 ; transform the letter via SHIFT

.testShiftEnabled
    LDX .keyboardStatusFlags                            ; check SHIFT enabled bit
    BPL .testESCAPEcode                                 ; if (SHIFT disabled) then branch

.testShift
    ROL .tempStoreFA                                    ; move SHIFT into bit 7
    BPL .testESCAPEcode                                 ; if (no SHIFT key) then branch

    ; deal with SHIFT key pressed
    LDX .firstKeyPressedInternal                        ; get previous key press
    BNE .localResetAutorepeatAndContinue                ; if (not 0) then branch (reset repeat system etc)
    JSR .implementSHIFT                                 ; make code changes for SHIFT

.testESCAPEcode
    CMP .asciiCodeThatGeneratesESCAPEAction             ; check against ESCAPE action
    BNE +                                               ; if (A is not ESCAPE action) then branch

    ; deal with ESCAPE key
    LDX .escapeAction                                   ; get ESCAPE key action type
    BNE +                                               ; if (ESCAPE returns ASCII code) then branch
    STX .autorepeatCountdownTimer                       ; store zero in auto-repeat countdown timer

+
    TAY                                                 ;
    JSR .enableKeyboardScanningFlippingInterrupts       ; enable keyboard scanning
    LDA .keyboardDisableFlag                            ; read Keyboard disable flag (used by Econet)
    BNE .keyboardRolloverChecks                         ; if (keyboard disabled) then branch

    ; finally put result into keyboard input buffer
    JSR .insertByteIntoKeyboardBuffer                   ; put character in input buffer

    ; Check for two key rollover
.keyboardRolloverChecks
    LDX .firstKeyPressedInternal                        ; get first keypress
    BEQ +                                               ; if (none) then branch
    JSR .interrogateKeyboard                            ; examine to see if key still pressed
    STX .firstKeyPressedInternal                        ; store result
    BMI +                                               ; if (key pressed) then branch
    LDX #0                                              ;
    STX .firstKeyPressedInternal                        ; reset .firstKeyPressedInternal to zero
+
    LDX .firstKeyPressedInternal                        ; get .firstKeyPressedInternal
    BNE .continueKeyProcessing                          ; if (not zero) then branch
    LDY #.lastKeyPressedInternal                        ; get address of last keypress into Y
    JSR .clearCarryKeyboardScan                         ; scan keyboard from $10 (osbyte 122)
    BMI .localTidyUpAfterKeyboardProcessing             ; if (exit is negative) then branch
    LDA .lastKeyPressedInternal                         ; make the last key the
    STA .firstKeyPressedInternal                        ; first key pressed i.e. rollover

.storeKeyAndReset
    STX .lastKeyPressedInternal                         ; save X into .lastKeyPressedInternal
    JSR .resetAutorepeatCounters                        ; set keyboard repeat delay

.localTidyUpAfterKeyboardProcessing
    JMP .tidyUpAfterKeyboardProcessing                  ; finish up


; ***************************************************************************************
;
; Check for key pressed and store
;
; On Entry:
;       X = key
;
; ***************************************************************************************
.keyPressedInterrupt
    JSR .interrogateKeyboard                            ; check if key pressed
.continueKeyProcessing
    LDA .lastKeyPressedInternal                         ; get previous key press
    BNE .localTidyUpAfterKeyboardProcessing             ; if (none) then branch (back to housekeeping routine)
    LDY #.firstKeyPressedInternal                       ;
    JSR .clearCarryKeyboardScan                         ; and scan keyboard
    BMI .localTidyUpAfterKeyboardProcessing             ; if (negative on exit) then branch (back to housekeeping)
    BPL .storeKeyAndReset                               ; ALWAYS branch (back to store X; reset keyboard delay etc)


; ***************************************************************************************
.resetAutorepeatCounters
    LDX #1                                              ; set timer to 1
    STX .autorepeatCountdownTimer                       ;
    LDX .keyboardAutoRepeatDelay                        ; get next timer value
    STX .keyboardFirstAutorepeatCount                   ; and store it
    RTS                                                 ;


; ***************************************************************************************
;
; Read a single key's state from the keyboard
;
; See return.png
;
; On Entry:
;       X = key to test
; On Exit:
;       A is preserved
;       Carry is preserved
;
;       X = $80 if key pressed (N set)
;           $00 otherwise      (N clear)
;
; ***************************************************************************************
.interrogateKeyboard
    LDY #3                                              ; stop keyboard scanning
    STY .systemVIARegisterB                             ; by writing to system VIA
    LDY #%01111111                                      ; input on bit 7, output on bits 0 to 6
    STY .systemVIADataDirectionRegisterA                ;
    STX .systemVIARegisterANoHandshake                  ; write X to Port A system VIA
    LDX .systemVIARegisterANoHandshake                  ; read back ($80 + internal key number) if key pressed (or zero otherwise)
    RTS                                                 ;


; ***************************************************************************************
;
; The seven 'key data' tables
;
; What follows is 7 tables of 10 bytes each, spaced 16 bytes apart, giving the 'ASCII'
; character codes for each internal key number on the keyboard row. In the six bytes between
; each table, small snippets of unrelated code are inserted.
;
; See .scanKeyboard for table of internal key numbers.
;
; ***************************************************************************************
.keyDataTable1
    ;      q , 3 , 4 , 5 , f4, 8 , f7, - , ^ ,LEFT
    !byte $71,$33,$34,$35,$84,$38,$87,$2D,$5E,$8C


; ***************************************************************************************
;
; OSBYTE 120 - Write key pressed data
;
; ***************************************************************************************
.osbyte120EntryPoint
    STY .lastKeyPressedInternal                         ; store Y as latest key pressed
    STX .firstKeyPressedInternal                        ; store X as previous key pressed
    RTS                                                 ;

    !byte 0                                             ; [unused]

; ***************************************************************************************
.keyDataTable2
    ;      f0, w , e , t , 7 , i , 9 , 0 , _ ,DOWN
    !byte $80,$77,$65,$74,$37,$69,$39,$30,$5F,$8E

; ***************************************************************************************
.jimPagedEntryJumper
    JMP (.jimPagedEntryPoint)                           ; Jim paged entry vector

; ***************************************************************************************
.osbyteOrOSWORDJumper
    JMP (.tempStoreFA)                                  ;

; ***************************************************************************************
.keyDataTable3
    ;      1 , 2 , d , r , 6 , u , o , p , [ ,UP
    !byte $31,$32,$64,$72,$36,$75,$6F,$70,$5B,$8F

; ***************************************************************************************
.keyboardInterruptRoutine
    BIT .allBitsSet                                     ; set N and V flags
.keyJumper
    JMP (.vectorKEYV)                                   ; i.e. KEYV

; ***************************************************************************************
.keyDataTable4
    ; CAPS LOCK, a , x , f , y , j , k , @ , : ,RETURN
    !byte   $01,$61,$78,$66,$79,$6A,$6B,$40,$3A,$0D

; ***************************************************************************************
;
; Tables for reading or writing speech
;
; ***************************************************************************************
.speechDirectionTable
    !byte $00,$FF     ; System VIA DDRA       (8 bit Read / 8 bit Write)
.speechEnableTable
    !byte $01,$02     ; System VIA Register B (Enable Read Speech / Enable Write Speech)
.speechDisableTable
    !byte $09,$0A     ; System VIA Register B (Disable Read Speech / Disable Write Speech)

; ***************************************************************************************
.keyDataTable5
    ; SHIFT LOCK, s , c , g , h , n , l , ; , ] ,DELETE
    !byte    $02,$73,$63,$67,$68,$6E,$6C,$3B,$5D,$7F

; ***************************************************************************************
;
; OSBYTE 131 - Read OSHWM (OS High Water Mark)
;
; ***************************************************************************************
.osbyte131EntryPoint
    LDY .currentOSHWM                                   ; read current OSHWM
    LDX #0                                              ;
    RTS                                                 ;

; ***************************************************************************************
.keyDataTable6
    ;      TAB, Z ,SPACE, V , b , m , , , . , / ,COPY
    !byte  $00,$7A,$20  ,$76,$62,$6D,$2C,$2E,$2F,$8B
    ; NOTE: TAB returns 0, and is handled as a special case in the code

; ***************************************************************************************
.flushCurrentInputBuffer
    LDX .currentInputBuffer                             ; get current input buffer
.flushBufferXJumper
    JMP .flushBufferX                                   ; flush it

; ***************************************************************************************
.keyDataTable7
    ;      ESC, f1, f2, f3, f5, f6, f8, f9, \ ,RIGHT
    !byte  $1B,$81,$82,$83,$85,$86,$88,$89,$5C,$8D

.eventJumper
    JMP (.vectorEVNTV)                                  ; jump to eventV handling routine


; ***************************************************************************************
;
; OSBYTE 15 - Flush selected buffer class
;
; On Entry:
;       X = 0       flush all buffers
;       X != 0      flush input buffer
;
; ***************************************************************************************
.osbyte15EntryPoint
    BNE .flushCurrentInputBuffer                        ; if (X is not zero) then branch (flush input buffer only)
.flushAllBuffers
    LDX #.bufferNumberHighest                           ; load highest buffer number (8)
-
    CLI                                                 ; allow interrupts briefly
    SEI                                                 ; disable interrupts
    JSR .osbyte21EntryPoint                             ; flush buffer
    DEX                                                 ; decrement X to point at next buffer
    BPL -                                               ; if (X >= 0) then branch (flush next buffer)
    ; fall through... (at this point X=255)


; ***************************************************************************************
;
; OSBYTE 21 - Flush specific buffer
;
; On Entry:
;       X=buffer number
; ***************************************************************************************
.osbyte21EntryPoint
    CPX #.bufferNumberHighest + 1                       ; test against largest buffer number
    BCC .flushBufferXJumper                             ; if (X < 9) then branch (flush buffer X)
    RTS                                                 ;

; ***************************************************************************************
;
; *HELP
;
; ***************************************************************************************
.starHelp
    LDX #.romServiceCallHelp                            ; } Issue *HELP service request to
    JSR .osbyte143EntryPoint                            ; } paged ROMs. Returns with Y = 0
                                                        ; } if message below is to be
                                                        ; } suppressed
    JSR .printFollowingMessage                          ; print following message routine
    !text .charRETURN                                   ; Carriage return
    !text "OS 1.20"                                     ;
    !text .charRETURN                                   ; Carriage return
    !byte $00                                           ; terminator
    RTS                                                 ;

; ***************************************************************************************
;
; Keyboard scan ignoring SHIFT and CTRL, without KEYV vector
;
; Starts scanning from 16 decimal (row 1 of the internal key table).
;
; On Entry:
;       Y = $EC or $ED, the address of the keyboard table to set:
;
;       .lastKeyPressedInternal  = $EC
;       .firstKeyPressedInternal = $ED
; ***************************************************************************************
.clearCarryKeyboardScan
    CLC                                                 ; clear carry
    ; pass through...

; ***************************************************************************************
;
; OSBYTE 122 - Keyboard scan ignoring SHIFT and CTRL
;
; Ignores the first row of the keyboard (SHIFT, CTRL, and the hardware DIP switches)
; See .scanKeyboard.
;
; ***************************************************************************************
.osbyte122EntryPoint
    LDX #16                                             ; set X to 16 (ignores the first
                                                        ; keyboard row containing SHIFT,
                                                        ; CTRL, and the hardware keyboard
                                                        ; switches)
    ; pass through...

; ***************************************************************************************
;
; OSBYTE 121 - Keyboard scan from value in X
;
; ***************************************************************************************
.osbyte121EntryPoint
    BCS .keyJumper                                      ; if entry is via OSBYTE 121 or OSBYTE
                                                        ; 122 then carry is set. We branch to
                                                        ; jump through the KEYV vector to
                                                        ; .keyEntryPoint.
                                                        ; (Assuming the default vector routine
                                                        ; is in place. If V is set then that
                                                        ; code will jump to .scanKeyboard
                                                        ; below) if entry is via
                                                        ; .clearCarryKeyboardScan above then
                                                        ; carry is clear and we fall
                                                        ; through...
    ; fall through...

; ***************************************************************************************
;
; Scan Keyboard
;
; See keyboard.png
;
; The BBC Micro has 74 keys, and 8 DIP switches. All keys can be read as separate values
; except that the two SHIFT keys cannot be distinguished from each other, and the BREAK key
; is hardwired to RESET the machine.
;
; Internal keyboard numbers:
;                                       column
;        | 0           1      2       3       4       5       6       7       8       9
;    ----+----------------------------------------------------------------------------------
;    $00 | SHIFT       CTRL   bit 7   bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0
;    $10 | Q           3      4       5       f4      8       f7      -       ^       LEFT
; r  $20 | f0          W      E       T       7       I       9       0       _       DOWN
; o  $30 | 1           2      D       R       6       U       O       P       [       UP
; w  $40 | CAPS LOCK   A      X       F       Y       J       K       @       :       RETURN
;    $50 | SHIFT LOCK  S      C       G       H       N       L       ;       ]       DELETE
;    $60 | TAB         Z      SPACE   V       B       M       ,       .       /       COPY
;    $70 | ESCAPE      f1     f2      f3      f5      f6      f8      f9      \       RIGHT
;
; 'bit n' refers to the row of eight hardware DIP switches inside the case at the bottom
; right of the keyboard:
;
; See dips.png
;
;  dip   bit      Internal Key Number   Description
;  ----------------------------------------------------------------------------------
;  8-6   bit 0-2        9,8,7           Together these bits determine the startup MODE
;  5     bit 3            6             Set if the SHIFT-BREAK action is reversed with BREAK
;  4-3   bit 4-5         5,4            Sets disc drive timings (depends on make of drive)
;  2-1   bit 6-7         3,2            unused
;
; The keyboard is scanned by first looping through the columns (see .loopKeyboardColumns
; below). Each time around the loop we check to see if *any* key in that column is pressed.
; If not we skip to the next column. If we find a column with a key pressed, then we must
; check each row in that column to check which specific key is pressed
; (see .loopKeyboardRows).
;
; For the keyboard circuit diagram, See Chapter 25.
;
; On Entry:
;       X is the first key to scan from (if positive)
;       X is the specific key to check (if negative)
;
;       Carry set if entry is via an OSBYTE
;        or clear if via .clearCarryKeyboardScan
;
; ***************************************************************************************
.scanKeyboard
    TXA                                                 ; }
    BPL +                                               ; } if X is positive then branch (to scan all keyboard)
    JSR .interrogateKeyboard                            ; interrogate keyboard for specific key
    BCS .enableKeyboardScanning                         ; if (carry set, i.e. entry via OSBYTE) then branch (finish up)
+
    PHP                                                 ; push flags (to remember carry, whether entry if via OSBYTE)
    BCC +                                               ; if (carry clear, i.e. entry was via .clearCarryKeyboardScan) then branch

    ; entry was via OSBYTE.
    LDY #.keyToIgnoreWhenScanningWithOSBYTE121or122     ; set Y so next instruction saves to .previousKeyPressedWhenReadingOSBYTE
+
    STA .previousKeyPressedWhenReadingLastKey - .keyPressedInternalTable,Y  ; save first possible key number (address can be $02CB, $02CC or $02CD)
    LDX #9                                              ; loop counter: from 9 to 0 to select the keyboard column

    ; outer loop: loop through the columns of the keyboard
.loopKeyboardColumns
    JSR .enableKeyboardScanningFlippingInterrupts       ; enable keyboard scanning
    LDA #%01111111                                      ; }
    STA .systemVIADataDirectionRegisterA                ; } set port A for input on bit 7 (all others are output bits)
                                                        ; } i.e. we write to bits 0-6 of .systemVIARegisterANoHandshake, and get the result by reading bit 7

    LDA #3                                              ; }
    STA .systemVIARegisterB                             ; } stop auto scanning of the keyboard

    LDA #15                                             ; }
    STA .systemVIARegisterANoHandshake                  ; } select a non-existent keyboard column 15 (0-9 only!)

    LDA #1                                              ; }
    STA .systemVIAInterruptFlagRegister                 ; } cancel keyboard interrupts

    STX .systemVIARegisterANoHandshake                  ; select column X (9 max -> 0 min)
    BIT .systemVIAInterruptFlagRegister                 ; check for any key in this column being pressed
    BEQ .tryNextKeyboardColumn                          ; if (bit 0 clear, i.e. there is no key pressed in this column) then branch
    TXA                                                 ; put column number (= first internal key number in column) in A

    ; inner loop: loop through the rows of the keyboard
.loopKeyboardRows
    CMP .previousKeyPressedWhenReadingLastKey - .keyPressedInternalTable,Y  ; compare with first possible pressed key
    BCC .tryNextKeyboardRow                             ; if (current key number is too low) then branch
    STA .systemVIARegisterANoHandshake                  ; write which specific key to test
    BIT .systemVIARegisterANoHandshake                  ; check for specific key being pressed
    BPL .tryNextKeyboardRow                             ; if (bit 7 is zero, i.e. key not pressed) then branch (go to next row)
    PLP                                                 ; at this point key A is pressed. pull and push flags (to read carry)
    PHP                                                 ;
    BCS .finishKeyboardScanning                         ; if (carry set, i.e. entry via OSBYTE 121/122) then branch (finished)
    PHA                                                 ; Push A (key pressed)
    EOR $0000,Y                                         ; EOR with last key pressed (in $EC,$ED, or $EE depending on Y value)
    ASL                                                 ; shift left (to ignore the top bit)
    CMP #1                                              ; set carry if not the same as previous key pressed
    PLA                                                 ; Pull A (key pressed)
    BCS .finishKeyboardScanning                         ; if (carry set, i.e. not the same as previous key pressed) then branch
.tryNextKeyboardRow
    CLC                                                 ; }
    ADC #16                                             ; } add 16 to check for key in next row
    BPL .loopKeyboardRows                               ; and do it again if 0 <= key < 128

    ; goto next column
.tryNextKeyboardColumn
    DEX                                                 ; decrement X
    BPL .loopKeyboardColumns                            ; scan again if greater than 0
    TXA                                                 ;
.finishKeyboardScanning
    TAX                                                 ;
    PLP                                                 ; pull flags

.enableKeyboardScanningFlippingInterrupts
    JSR .enableKeyboardScanning                         ; enable keyboard scanning
    CLI                                                 ; allow interrupts briefly
    SEI                                                 ; disable interrupts

.enableKeyboardScanning
    LDA #11                                             ; }
    STA .systemVIARegisterB                             ; } enable auto scan of keyboard
    TXA                                                 ; Set X = 11
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 18: Tape and ROM Filing systems
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; The tape (and ROM) block format
;
; The cassette filing system uses a variant of the 1976 Kansas City standard.
; See https://en.wikipedia.org/wiki/Kansas_City_standard
;
; Tape signals are a sequence of binary tones, either 2400Hz (representing a set bit) or
; 1200Hz (representing a clear bit). These tones can be recorded and read at a speed of
; either 1200 baud or 300 baud.
;
; Files are stored on tape as a sequence of 'blocks', each holding (up to) 256 bytes of
; program data. The first block is written with a five second carrier tone (2400 Hz) at the
; start. Subsequent blocks start with a shorter carrier tone. Each block continues as
; follows:
;
; $2A               - synchronisation byte (%00101010 alternating ones and zeroes)
;                   - (see .fsSynchronisationByte)
; <1 to 10 bytes>   - filename
; $00               - filename terminator
; <4 bytes>         - load address
; <4 bytes>         - execution address
; <2 bytes>         - block number
; <2 bytes>         - block length
; <1 byte>          - block flag (bit 7 set for the final block; bit 0 means *RUN only)
; <4 bytes>         - TAPE: four $00 bytes (unused)
;                   - ROMFS: address of end byte of file
; <2 bytes>         - CRC on header (all bytes before here except the synchronisation byte)
; <0 to 256 bytes>  - data
; <2 bytes>         - CRC on data (all data bytes)
;
; The ROM filing system uses a similar format of block, but with shortcuts to save ROM
; space. The first block is as above. Subsequent blocks just have a single byte header of
; $23. The end of all the ROM's data is marked with a single byte $2B.
;
; For an example of what the cassette sounds like, see http://playuef.8bitkick.cc
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE 140 - Select TAPE file system, and OSBYTE 141 - Select ROM file system
;
; On Entry:
;       A = 140 to select TAPE filing system
;       A = 141 to select ROM filing system
; ***************************************************************************************
.osbyte140EntryPoint
.osbyte141EntryPoint
    EOR #140                                            ; A=0 for *TAPE; A=1 for *ROM
.setTapeOrROMFS
    ASL                                                 ; double it
    STA .tapeOrROMSwitch                                ; store it in filing system flag store
    CPX #3                                              ; compare with 300 baud
    JMP .setupTapeBaudRate                              ;

; ***************************************************************************************
;
; Setup cassette options
;
; Called after power on, hard or soft BREAK.
;
; See .tapeOptionsByte for the details of the options.
;
; On Entry:
;       Z set for 1200 baud
;       Z clear for 300 baud
;
; ***************************************************************************************
.setupTapeOptions
    PHP                                                 ; save flags
    LDA #%10100001                                      ; set sequential access abort if error, no messages
    STA .tapeOptionsByte                                ; set load/save retry if error, short messages
    LDA #25                                             ; set interblock gap (2.5 seconds)
    STA .tapeSequentialAccessInterBlockGap              ; and store it
    PLP                                                 ; get back flags
    ; fall through...

; ***************************************************************************************
;
; Set tape baud
;
; On Entry:
;       Z set for 300 baud
;       Z clear for 1200 baud
; ***************************************************************************************
.setupTapeBaudRate
    PHP                                                 ; push flags
    LDA #6                                              ; get close files command to FSCV
    JSR .passToCurrentFilingSystem                      ; and FSCV
    LDX #6                                              ;
    PLP                                                 ; get back flags
    BEQ +                                               ; if (Z set on entry) then branch
    DEX                                                 ; decrement X
+
    STX .tapeBaudRate                                   ; set current baud rate: X=5 means 1200 baud; X=6 means 300 baud


    ; Reset the file based vectors (FILEV; ARGSV; BGETV; BPUTV; GBPBV; FINDV; FSCV) to default values
    LDX #14                                             ; Loop counter
-
    LDA .defaultFileSystemVectors - 1,X                 ; }
    STA .vectorFILEV - 1,X                              ; } Reset vectors for file related operations
    DEX                                                 ; }
    BNE -                                               ; }

    STX .fsReadProgressState                            ; progress flag = 0
    LDX #.romServiceCallVectorsClaimed                  ; set X to make a Paged ROM service call 'Vectors Claimed'
                                                        ; used after a new filing system overwrites the current set of vectors.
    ; fall through...


; ***************************************************************************************
;
; OSBYTE 143 - Pass service commands to sideways ROMs
;
; On Entry:
;       X = command number, see .romServiceCallAbsoluteWorkspaceClaim
; On Exit:
;       A = X = zero if a ROM chooses to handle the call; or 255 otherwise
;       Y = result from ROM
;
; ***************************************************************************************
.osbyte143EntryPoint
    LDA .currentlySelectedROM                           ; get current ROM number
    PHA                                                 ; store it
    TXA                                                 ; command in A
    LDX #15                                             ; set X=15
                                                        ; send commands loop
-
    INC .romTypeTable,X                                 ; } read bit 7 of rom type
    DEC .romTypeTable,X                                 ; } which indicates if it has a service routine
                                                        ;   (all user ROMs except BASIC should have a service routine)
    BPL +                                               ; if (not service routine) then branch (skips the BASIC ROM)
    STX .currentlySelectedROM                           ; store ROM number
    STX .romSelectRegister                              ; switch the ROM into the memory map
    JSR .romServiceEntry                                ; and jump to the service entry
    TAX                                                 ; on exit put A in X
    BEQ .romChecksFinished                              ; if (zero, i.e. command recognised by ROM) then branch (restore current ROM selection and exit)
    LDX .currentlySelectedROM                           ; point to next lower ROM
+
    DEX                                                 ;
    BPL -                                               ; and go round loop again

.romChecksFinished
    PLA                                                 ; get back original ROM number
    STA .currentlySelectedROM                           ; store it in Ram copy
    STA .romSelectRegister                              ; switch the original ROM into the memory map
    TXA                                                 ; put X back in A
    RTS                                                 ;


; ***************************************************************************************
;
; OSARGS - Read or write a file's attributes
;
; On Entry:
;       In this default implementation, we only need to cover TAPE and ROM filing systems.
;       We only implement A=0,Y=0, which returns the filing system number in A.
; On Exit:
;       A = 0   no filing system present
;       A = 1   1200 baud tape filing system
;       A = 2   300 baud tape filing system
;       A = 3   ROM filing system
;
; [ Note: Beyond the scope of this OS, implemented by optional Paged ROMs:
;       A = 4   Disc file system
;       A = 5   Econet (Networking) file system
;       A = 6   Telesoftware (Teletext/Prestel) file system
;       A = 7   IEEE filing system
;       A = 8   ADFS filing system
;       A = 9   Host filing system
;       A = 10  Videodisc filing system
;
; See http://www.sprow.co.uk/bbc/library/fsids.txt for more filing system ids.
; ]
; ***************************************************************************************
.osargsEntryPoint
    ORA #0                                              ;
    BNE .exit27                                         ; if (A != 0) then branch (return)
    CPY #0                                              ;
    BNE .exit27                                         ; if (Y != 0) then branch (return)
    LDA .tapeBaudRate                                   ; get current baud rate:
                                                        ;
                                                        ;   1200 ; 300  ;  ROM
                                                        ;   baud ; baud ;
                                                        ;   tape ; tape ;
                                                        ;     5  ;   6  ;   5

    ; [Incidentally, this would do the same thing as below, but using four fewer bytes:
    ; ORA .tapeOrROMSwitch                                    5  ;   6  ;   7
    ; AND #3                                                  1  ;   2  ;   3
    ; RTS]

    AND #$FB                                            ;     1  ;   2  ;   1
    ORA .tapeOrROMSwitch                                ;     1  ;   2  ;   3
    ASL                                                 ;     2  ;   4  ;   6
    ORA .tapeOrROMSwitch                                ;     2  ;   4  ;   6
    LSR                                                 ;     1  ;   2  ;   3
.exit27
    RTS                                                 ;


; ***************************************************************************************
;
; Filing system routine table
;
; The FSC routine (see below) jumps to the relevant address depending on the accumulator.
;
; ***************************************************************************************
.fileSystemControlRoutineTable
    !word .starOptEntryPoint - 1                        ; *OPT
    !word .checkEOFEntryPoint - 1                       ; check EOF
    !word .starRunEntryPoint - 1                        ; */
    !word .badCommandError - 1                          ; 'Bad command' if ROMs and FS don't want it
    !word .starRunEntryPoint - 1                        ; *RUN
    !word .starCatEntryPoint - 1                        ; *CAT
    !word .osbyte119EntryPoint - 1                      ; osbyte 119 (close SPOOL and EXEC files, to get ready for a new FS)

; ***************************************************************************************
;
; FSC - File System Control
;
; On Entry
;       A is reason code. Only values 0-6 are handled:
;
;         A=0    A *OPT command has been issued. X and Y are the 2 parameters
;         A=1    EOF is being checked. On Entry: X=File handle On Exit: X=FF means EOF else 00
;         A=2    A */ command has been issued
;         A=3    An unrecognised OS command has been issued. X,Y point at command
;         A=4    A *RUN command has been issued X,Y point at filename
;         A=5    A *CAT cammand has been issued X,Y point to rest of command
;         A=6    New filing system is about to take over. Close *SPOOL and *EXEC files
;
; Just for reference, these are not implemented in OS (to be implemented by Filing System
; Paged ROMs):
;         A=7    return file handle range (X=minimum; Y=maximum)
;         A=8    OS has received a star command
;         A=9    *EX command
;         A=10   *INFO
;         A=11   *RUN command for library
;         A=12   *RENAME command
;
; See NAUG Section 16.1.7, Page 256-7
;
; ***************************************************************************************
.fscEntryPoint
    CMP #7                                              ; }
    BCS .exit27                                         ; } if A>=7 then branch (exit)
    STX .fsTempStorage                                  ; save X
    ASL                                                 ; A=A*2
    TAX                                                 ; X=A to get offset
    LDA .fileSystemControlRoutineTable + 1,X            ; get high byte of address
    PHA                                                 ; push it
    LDA .fileSystemControlRoutineTable,X                ; get low byte of address
    PHA                                                 ; push it
    LDX .fsTempStorage                                  ; restore X
    RTS                                                 ; this now jumps to (the address
                                                        ; got from the table) + 1

; ***************************************************************************************
;
; *LOAD or *RUN a file
;
; See loading.png
;
; On Entry:
;       A=0     *RUN the file
;       A=$FF   *LOAD the named file and read its catalogue information
;
; See LoadFromTape.pdf
; See LoadFromROM.pdf
;
; ***************************************************************************************
.loadFile
    PHP                                                 ; save flags on stack
    PHA                                                 ; save A on stack
    JSR .claimSerialSystemForLoadSave                   ; claim serial system for cassette
                                                        ; we can't use the cassette and the
                                                        ; RS-423 system at the same time
                                                        ; so we select the cassette here.
    LDA .fsExecutionAddressLow                          ; execution address low
    PHA                                                 ; save A on stack
    JSR .searchForFile                                  ; search for file
    PLA                                                 ; get back A
    BEQ .checkFileAttributes                            ; if (A = 0) then branch
    LDX #3                                              ; X=3, loop counter
    LDA #$FF                                            ; A=$FF
-
    PHA                                                 ; save A on stack
    LDA .fsLoadAddressLow,X                             ; get load address
    STA .loadAddressLow,X                               ; store it as current load address
    PLA                                                 ; get back A
    AND .loadAddressLow,X                               ;
    DEX                                                 ; X=X-1
    BPL -                                               ; until all 4 bytes copied

    ; [peculiarly, the code makes a special point to check for a load
    ;  address of $FFFFFFFF and signals an error if it occurs. Why?]
    CMP #$FF                                            ; check if all the bytes of the load
                                                        ; address are $FF
    BNE .checkFileAttributes                            ; if (address is valid, i.e. not all
                                                        ; four bytes $FF) then branch
                                                        ; (continue)

    ; handle error because load address is $FFFFFFFF
    JSR .beepAndCancelTapeOperation                     ; sound bell, reset ACIA and motor off
    JMP .brkBadAddress                                  ; show 'Bad address' error

; ***************************************************************************************
.checkFileAttributes
    LDA .fsBlockFlagByte                                ; block flag
    LSR                                                 ; set carry from bit 0 (file locked)
    PLA                                                 ; get back A
    BEQ .checkAndSetEscapeEffect                        ; if (A = 0) then branch (entry is from star run)
    BCC .loadOrRun                                      ; if (carry clear, i.e. not locked) then branch
    ; fall through...

; ***************************************************************************************
;
; File locked
;
; A locked file is one with bit zero set on the block flag byte (see .fsBlockFlagByte)
; Locked files can only be *RUN, not *LOADed. This is a form of copy protection on cassette
; tapes.
;
; See Chapter 18 for data format.
;
; ***************************************************************************************
.fileLocked
    JSR .cancelTapeOperationAndMotor                    ;

    BRK                                                 ;
    !byte $D5                                           ; error number
    !text "Locked",0                                    ; 'Locked' error message and zero terminator

; ***************************************************************************************
.checkAndSetEscapeEffect
    BCC .loadOrRun                                      ; if (carry clear) then branch (load)
    LDA #3                                              ; A=3
    STA .escapeAndBreakEffect                           ; store to cause ESCAPE disable and memory clear on break

.loadOrRun
    LDA #%00110000                                      ; check bits 4 and 5

    ; See .tapeCurrentOptionsByte for description of the options
    AND .tapeCurrentOptionsByte                         ; check for 'ignore errors'
    BEQ +                                               ; if (ignore errors) then branch
    LDA .checksumIsValidFlag                            ; get checksum result
    BNE .checksumFail                                   ; if (checksum failed) then branch
+
    TYA                                                 ; A=Y
    PHA                                                 ; save A on stack
    JSR .startSendToSecondProcessor                     ; send to second processor if present
    PLA                                                 ; get back A
    TAY                                                 ; Y=A
    JSR .setStateForLoadingBlockDataOrReset             ; set state to read block data
.checksumFail
    JSR .loadBlock                                      ; load block from tape
    BNE .retryAfterFailure                              ; if (not found) then branch (retry)
    JSR .incrementBlockNumbers                          ; increment current block number

+
    BIT .fsBlockFlagByte                                ; block flag
    BMI .reachedFinalBlock                              ; if (bit 7 set, i.e. this is the final block) then branch
    JSR .incrementLoadOrSaveAddress                     ; increment current load address
    JSR .readBlockHeader                                ; read block header
    BNE .loadOrRun                                      ; if (non zero) then branch (loop back)
    ; fall through...

; ***************************************************************************************
;
; Reached final block
;
; Stores the tape file length (low/high) and two zeros into the OSFILE parameter block. Note
; the bugs below though.
;
; John Kortink found a couple of bugs in this routine.
; See http://mdfs.net/Archive/BBCMicro/2006/10/14/174712.htm
;
; People have unwittingly hit the second of these bugs:
; See https://stardot.org.uk/forums/viewtopic.php?f=54&t=13481
; See http://www.retrosoftware.co.uk/forum/viewtopic.php?p=5687#p7655
;
; The first affects the ROM filing system only. In the previously executed .filenameDone
; routine (See .filenameDone), the length of the file (.tapeFileLengthLow/High) only gets
; set if long messages are enabled, so the length returned from this routine may be wrong.
;
; The second (and more serious) affects both TAPE and ROM filing systems. The parameter block
; address (.osfileBlockAddressLow/High) is normally set up in .osfileEntryPoint
; (see .osfileEntryPoint) but has not been set up if entered via a *RUN command. So four bytes
; of memory at an arbitrary address can be corrupted here! We may just about silently get away
; with it sometimes (cross fingers) if a previous OSFILE operation happens to have set them
; up to a benign value. For example, if we CHAIN a BASIC program first, then *RUN works.
;
; ***************************************************************************************
.reachedFinalBlock
    LDY #10                                             ; Y=10
    LDA .tapeFileLengthLow                              ; file length counter low
    STA (.osfileBlockAddressLow),Y                      ; OSFILE parameter block
    INY                                                 ; Y=Y+1
    LDA .tapeFileLengthHigh                             ; file length counter high
    STA (.osfileBlockAddressLow),Y                      ; OSFILE parameter block
    LDA #0                                              ; A=0
    INY                                                 ; Y=Y+1
    STA (.osfileBlockAddressLow),Y                      ; OSFILE parameter block
    INY                                                 ; Y=Y+1
    STA (.osfileBlockAddressLow),Y                      ; OSFILE parameter block
    PLP                                                 ; get back flags

.beepCancelAndPrintReturn
    JSR .beepAndCancelTapeOperation                     ; bell, reset ACIA and motor

.printReturnSafely
    BIT .currentBlockHasDataErrorFlag                   ; current block flag
    BMI .exit28                                         ;

.saveFlagsPrintCR
    PHP                                                 ; save flags on stack
    JSR .safePrintFollowingMessage                      ; print message following call (in this case a newline character)
    !byte .charRETURN, 0                                ; message
    PLP                                                 ; restore flags from stack
.exit28
    RTS                                                 ;

; ***************************************************************************************
.retryAfterFailure
    JSR .searchForSpecifiedBlock                        ; search for a specified block
    BNE .loadOrRun                                      ; ALWAYS branch (try again)

; ***************************************************************************************
;
; Copy filename from XY
;
; On Entry:
;       X and Y     source filename address (Low/High)
; On Exit:
;       A = 0
;       The filename is copied into the buffer at .filenameToSearchFor
; ***************************************************************************************
.getFilenameFromXY
    STX .stringInputBufferAddressLow                    ; OS filename/command line pointer
    STY .stringInputBufferAddressHigh                   ; OS filename/command line pointer
    LDY #0                                              ; Y=0
    JSR .gsinitForFilenameParsing                       ; initialise string
    LDX #0                                              ; X=0
-
    JSR .gsreadEntryPoint                               ; GSREAD call
    BCS .terminateFilename                              ; if (end of character string) then branch
    BEQ .brkBadStringJumper                             ; if (zero found) then break ('Bad string' error)
    STA .filenameToSearchFor,X                          ; store character in tape filename area
    INX                                                 ; X=X+1
    CPX #11                                             ; check X with 11
    BNE -                                               ; if (X != 11) then branch (loop back)
.brkBadStringJumper
    JMP .brkBadString                                   ; Bad String error


; ***************************************************************************************
.terminateFilename
    LDA #0                                              ; terminate filename with 0
    STA .filenameToSearchFor,X                          ;
    RTS                                                 ;

; ***************************************************************************************
;
; OSFILE
;
; default handling for OSFILE (for cassette and ROM filing system)
;
; parameter block located by XY
;   0-1     Address of Filename terminated by CR
;   2-4     Load Address of File
;   6-9     Execution Address of File
;   10-13   Start address of data for write operations or length of file for read operations
;   14-17   End address of Data (i.e. byte AFTER last byte to be written) or file attributes
;
; On Entry:
;   Action is determined by value in A
;
;   A=0     Save section of memory as named file, write catalogue information
;   A=1     Write catalogue information for named file             (not supported in this FS)
;   A=2     Write the LOAD       address (only) for the named File (not supported in this FS)
;   A=3     Write the EXECUTION  address (only) for the named File (not supported in this FS)
;   A=4     Write the ATTRIBUTES for the named File                (not supported in this FS)
;   A=5     Read the catalogue information and put file type in A  (not supported in this FS)
;   A=6     Delete the named file                                  (not supported in this FS)
;   A=$FF   Load the named file and read its catalogue information
;
;   XY = address of osfile block
;
; See .saveFileToTape for PDF showing the code path and how bytes are written to tape.
; See .loadFile for PDFs showing the code path and how bytes are read from tape and ROM.
;
; ***************************************************************************************
.osfileEntryPoint
    PHA                                                 ; save action on stack
    STX .osfileBlockAddressLow                          ; osfile block pointer low
    STY .osfileBlockAddressHigh                         ; osfile block pointer high
    LDY #0                                              ; Y=0
    LDA (.osfileBlockAddressLow),Y                      ; get address of filename (low byte)
    TAX                                                 ; store in X
    INY                                                 ; Y=1
    LDA (.osfileBlockAddressLow),Y                      ; get address of filename (high byte)
    TAY                                                 ; store in Y
    JSR .getFilenameFromXY                              ; get filename from buffer at XY
    LDY #2                                              ; Y=2

    ; loop to copy load and execution addresses to .loadAddressLow
-
    LDA (.osfileBlockAddressLow),Y                      ; copy parameter block (load and exec
                                                        ; addresses)...
    STA .fsLoadAddressLow-2,Y                           ; ...     to .fsLoadAddressLow
    STA .loadAddressLow-2,Y                             ; ... and to .loadAddressLow
    INY                                                 ; increment y
    CPY #10                                             ; compare with limit
    BNE -                                               ; if (not done yet) then branch (loop back)

    ; get action code, and branch to save if A=0
    PLA                                                 ; get back A (action)
    BEQ .saveFileToTape                                 ; if (A == 0) then branch (save file)

    ; if action is not $FF then exit
    CMP #$FF                                            ; check A with 255
    BNE .exit28                                         ; if (A != 255) then branch (exit,
                                                        ; as cassette / ROM filing systems
                                                        ; have no other options)
    ; load a file from cassette or ROM
    JMP .loadFile                                       ; load file (with A=255; Y=0)

; ***************************************************************************************
;
; Save a file to tape
;
;   See Chapter 18 for Tape/ROM format.
;
; On Entry:
;       A = 0
;       Y = 10 (offset in OSFILE Block)
;
; See SaveToTape.pdf for the code path and steps for writing to tape.
;
; ***************************************************************************************
.saveFileToTape
    STA .fsBlockNumberLow                               ; zero block number low
    STA .fsBlockNumberHigh                              ; zero block number high

    ; copy start address, end address into zero page copy
    ; Note Y=10 (loop counter) at this point
-
    LDA (.osfileBlockAddressLow),Y                      ; read from .OSFILE parameter block
    STA .tapeSaveStartAddressLow-10,Y                   ; store
    INY                                                 ; data start and data end address
    CPY #10 + 8                                         ; check for Y=18
    BNE -                                               ; if (not finished) then branch (loop back)

    TXA                                                 ; A=X
    BEQ .brkBadStringJumper                             ; if (no filename found) then branch ('Bad string' error)

    JSR .claimSerialSystemForLoadSave                   ; claim serial system for load/save on cassette
    JSR .promptToRecordOnTape                           ; prompt to start recording
    LDA #0                                              ; A=0 (meaning read bytes from second processor, aka:
                                                        ;      'multiple single byte transfer: 2nd processor to I/O processor')
    JSR .secondProcessorTransfer                        ; start transfer from 2nd processor (if present)
    JSR .setupForCassetteWrite                          ; set up tape for write operation

.saveToTapeLoop
    ; calculate length to read
    SEC                                                 ; set carry
    LDX #$FD                                            ; X = loop counter (loops three times: X=$FD, $FE, $FF)

    ; loop to work out the amount of file remaining to save, to calculate block length
    ; length = end address - current address
-
    LDA .tapeSaveEndAddressLow - $00FD,X                ; read end address
    SBC .tapeSaveStartAddressLow - $00FD,X              ; subtract current start address
    STA .fsBlockLengthLow - $00FD,X                     ; store at .fsBlockLengthLow/High and
                                                        ; .fsBlockFlagByte.
                                                        ; we don't care about overwriting
                                                        ; .fsBlockFlagByte with a length
                                                        ; calculation since we are about to
                                                        ; set it anyway.
    INX                                                 ; X=X+1
    BNE -                                               ;

    ; at this point X = 0 (meaning by default it's not the last block, unless we overwrite X below)

    ; if high byte of length is non-zero, then save the full block length of $0100
    TAY                                                 ; Y=A (to set the zero flag if zero)
    BNE .setFullBlockLength                             ; if (highest byte of subtracted value is non zero) then branch

    ; check the low and mid bytes of the length to see if this this the last block
    CPX .fsBlockLengthLow                               ; } compare X with zero
    LDA #$01                                            ; } calculate $0100 - block length
    SBC .fsBlockLengthHigh                              ; }
    BCC .setFullBlockLength                             ; if (fsBlockLength >= $0100) then branch

    ; yes, this is the last block
    LDX #$80                                            ; X=$80 (set last block flag)
    BNE .skipSettingBlockLength                         ; ALWAYS branch

.setFullBlockLength
    LDA #1                                              ; }
    STA .fsBlockLengthHigh                              ; } block length = $0100 (X=0 at this point)
    STX .fsBlockLengthLow                               ; }

.skipSettingBlockLength
    STX .fsBlockFlagByte                                ; store the block flag
    JSR .saveABlockToTape                               ; write block to tape
    BMI .exit29                                         ; if (negative) then branch (exit)
    JSR .incrementLoadOrSaveAddress                     ; increment start save address by a page
    INC .fsBlockNumberLow                               ; block number
    BNE .saveToTapeLoop                                 ; if (not 0) then branch (loop back again)
    INC .fsBlockNumberHigh                              ; block number high
    BNE .saveToTapeLoop                                 ; ALWAYS branch (since block number high byte should never wrap around) (loop back again)

; ***************************************************************************************
.starRunEntryPoint
    JSR .getFilenameFromXY                              ; get filename from buffer at XY
    LDX #$FF                                            ; X=$FF
    STX .fsExecutionAddressLow                          ; store in low byte of execution address
    JSR .loadFile                                       ; load file (with A=0)
    BIT .tubePresentFlag                                ; check to see if Tube is present
    BPL +                                               ; if (Tube is not present) then branch
    LDA .fsExecutionAddressMid2                         ; execution address extend
    AND .fsExecutionAddressHigh                         ; execution address extend
    CMP #$FF                                            ; check if all bits set
    BNE .sendExecAddressToRunFromTube                   ; if (top two bytes of exec address
                                                        ; are not both $FF) then branch
                                                        ; (execute on the Tube)
+
    JMP (.fsExecutionAddressLow)                        ; RUN file

; ***************************************************************************************
.sendExecAddressToRunFromTube
    LDX #<.fsExecutionAddressLow                        ; }
    LDY #>.fsExecutionAddressHigh                       ; } point to execution address
    LDA #4                                              ; Tube service call 4
    JMP .secondProcessorCall                            ; and issue to Tube to run file

; ***************************************************************************************
.starCatEntryPoint
    LDA #%00001000                                      ; A=8 (set catalogue state)
    JSR .setTapeStatusBits                              ; set ('OR' in) status bits
    JSR .claimSerialSystemForLoadSave                   ; claim serial system for cassette
    LDA #0                                              ; A=0 (don't match filename and block number)
    JSR .searchForBlockCheckFilingSystem                ; read data from tape/ROMFS
    JSR .cancelTapeOperation                            ;

.clearCatalogueStatus
    LDA #%11110111                                      ; clear bit 3 of file system status
                                                        ; bit (catalogue status)
    ; fall through...

; ***************************************************************************************
;
; Clear tape status bits
;
; On Entry:
;       A has the bits set that are to be cleared from the tape status byte
;
; On Exit:
;       X and Y preserved
;
; ***************************************************************************************
.clearTapeStatusBits
    AND .fsStatusByte                                   ;
.storeTapeStatusByte
    STA .fsStatusByte                                   ;
.exit29
    RTS                                                 ;

; ***************************************************************************************
.setTapeEOFStatus
    LDA #%01000000                                      ; set bit 6 of cassette status (EOF)
    ; fall through...

; ***************************************************************************************
;
; Set tape status bits
;
; On Entry:
;       A has the bits set that are to be set on the tape status byte
;
; On Exit:
;       X and Y preserved
;
; ***************************************************************************************
.setTapeStatusBits
    ORA .fsStatusByte                                   ;
    BNE .storeTapeStatusByte                            ; ALWAYS branch (store status byte)

; ***************************************************************************************
;
; Search for the next block, checking for Tape or ROM
;
; Used when loading a file or cataloguing a directory.
;
; On Entry:
;       A = $FF - must match the current filename and block number
;       A = $00 - match anything (e.g. for catalogue)
;
; On Exit:
;       V clear if final block
;
; ***************************************************************************************
.searchForBlockCheckFilingSystem
    PHA                                                 ; save A on stack
    LDA .tapeOrROMSwitch                                ; filing system flag 0=Tape; 2=ROMFS
    BEQ .searchForBlockReadHeaderAndCompare             ; if (tape filing system active) then branch

    ; deal with search on ROM FS
    JSR .setInitialSpeechPHROMNumber                    ; set current Filing System ROM/PHROM
    JSR .readByteFromROMOrPHROM                         ; get byte from data ROM check type
    BCC .searchForBlockReadHeaderAndCompare             ; if (carry clear) then branch
    CLV                                                 ; clear overflow flag
    BVC .pullAAndReturn                                 ; ALWAYS branch

; ***************************************************************************************
.searchForBlockReadHeaderAndCompare
    JSR .readBlockHeader                                ; read block header
    LDA .fsBlockNumberLow                               ; block number
    STA .currentBlockNumberLow                          ; current block number low
    LDA .fsBlockNumberHigh                              ; block number high
    STA .currentBlockNumberHigh                         ; current block number high
    LDX #$FF                                            ; X=$FF
    STX .fsLastBlockReadFlagsCopy                       ; copy of last read block flag
    INX                                                 ; X=0
    STX .currentBlockHasDataErrorFlag                   ; reset data error flag to zero
    BEQ +                                               ; ALWAYS branch

.searchForBlockLoop
    JSR .incrementBlockNumbers                          ; increment current block number
    JSR .readBlockHeader                                ; read block header

+
    LDA .tapeOrROMSwitch                                ; get filing system flag 0=tape; 2=ROMFS
    BEQ +                                               ; if (tape filing system is active) then branch
    BVC .pullAAndReturn                                 ; if (final block, on ROMFS) then branch (exit)

+
    PLA                                                 ; get back A (match flag)
    PHA                                                 ; save A on stack
    BEQ .finishReadingBlockAndContinue                  ; if (A == 0, i.e. match anything) then branch
    JSR .compareFilenames                               ; check filename header block matches searched Fn
    BNE .messageAndFinishBlock                          ; if (filenames don't match) then branch
    LDA #%00110000                                      ;
    AND .tapeCurrentOptionsByte                         ; check bits 4/5 of current options,
                                                        ; checking for 'ignore errors'
    BEQ .pullAAndReturn                                 ; if (ignore errors) then branch
    LDA .fsBlockNumberLow                               ; block number
    CMP .nextBlockNumberLow                             ; next block number low
    BNE .messageAndFinishBlock                          ;
    LDA .fsBlockNumberHigh                              ; block number high
    CMP .nextBlockNumberHigh                            ; next block number high
    BNE .messageAndFinishBlock                          ;

.pullAAndReturn
    PLA                                                 ; get back A
    RTS                                                 ;

.messageAndFinishBlock
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ .finishReadingBlockAndContinue                  ; if (tape filing system active) then branch

.skipMessaging
    JSR .setROMOrPHROMAddress                           ; set ROM address

.resetBlockNumberAndContinue
    LDA #$FF                                            ; A=$FF to reset block number
    STA .fsBlockNumberLow                               ; block number low
    STA .fsBlockNumberHigh                              ; block number high
    BNE .searchForBlockLoop                             ; ALWAYS branch

; ***************************************************************************************
;
; Finish reading block and continue
;
; On Entry:
;       V set means reset file system state (occurs when reading the last block of a ROMFS file)
;
; ***************************************************************************************
.finishReadingBlockAndContinue
    BVC +                                               ; if (V clear) then branch
    LDA #$FF                                            ; A=$FF (searching)
    JSR .setCharAThenProgressState4OrReset              ; update to progress state 4 (if block length > 0)
+
    LDX #0                                              ; X=0
    JSR .checkForChecksumError                          ; report 'Data?' if necessary
    LDA .tapeOrROMSwitch                                ; get current filing system
    BEQ +                                               ; if (tape filing system) then branch
    BIT .tapeCurrentOptionsByte                         ; check current options (bit 6)
    BVC .skipMessaging                                  ; if (no long messages) then branch (back)
+
    BIT .fsBlockFlagByte                                ; block flag
    BMI .resetBlockNumberAndContinue                    ; if (-ve) then branch
    BPL .searchForBlockLoop                             ; ALWAYS branch (loop back and do it again)


; ***************************************************************************************
;
; OSFIND - Open or close a file
;
; When opening a file, this returns a file handle ('channel') number:
;
;   1 = input file on tape
;   2 = output file on tape
;   3 = input file from ROMFS
;
; On Entry:
;       A determines action
;       Y may contain file handle (channel number)
;       or XY is the address of the filename terminated by $0D
;
;       A=0    closes file in channel Y; if Y = 0 closes all files
;       A=$40  open a file for input  (reading) XY points to filename
;       A=$80  open a file for output (writing) XY points to filename
;       A=$C0  open a file for both input and output (random Access)
;              (not supported by TAPE and ROM filing systems)
;
; On Exit:
;       A = file handle of opened file or zero on error
;       X,Y are preserved
;
; ***************************************************************************************
.osfindEntryPoint
    STA .fsTempStorage                                  ; save action in temporary store
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } save X and Y on the stack
    PHA                                                 ; }
    LDA .fsTempStorage                                  ; recall action
    BNE .openAFile                                      ; if (A is non zero) then branch (open a specific file)

.closeOneFile
    TYA                                                 ; A=Y
    BNE +                                               ; if (A is not zero) then branch (close specified file)
    JSR .osbyte119EntryPoint                            ; close all SPOOL/EXEC files using OSBYTE 119
    JSR .closeFileThatsOpenForOutput                    ; close file open for output
-
    LSR .fsStatusByte                                   ; shift right (bit zero into carry)
    ASL .fsStatusByte                                   ; shift left (clear bit zero)
    BCC .finishWithError                                ; if (carry clear, i.e. no input file open) then branch
+
    LSR                                                 ; A contains file handle so shift bit 0 into carry
    BCS -                                               ; if (carry set) then branch (close input file)
    LSR                                                 ; shift bit 1 into carry
    BCS .closeOutputFile                                ; if (carry set) then branch (close output file)
    JMP .channelError                                   ; report 'Channel error'
                                                        ; as tape filing system can only support one input and one output file

.closeOutputFile
    JSR .closeFileThatsOpenForOutput                    ; close file open for output
.finishWithError
    JMP .restoreRegistersAndExit                        ; and exit

; ***************************************************************************************
;
; Open a file
;
; A file is opened for input or output. The file handle ('channel') is returned in A.
;
; File handles returned:
;   1 = input file on tape
;   2 = output file on tape
;   3 = input file from ROMFS
;
; On Entry:
;       XY = address of zero terminated filename
;       .fsTempStorage - action from .OSFIND (See .osfindEntryPoint)
;           bit 6 set to open for input
;           bit 7 set to open for output
;           (opening both for input and output is not supported on either tape or ROMFS)
;
; On Exit:
;       A = file handle ('channel')
;
; ***************************************************************************************
.openAFile
    JSR .getFilenameFromXY                              ; get filename from buffer at XY
    BIT .fsTempStorage                                  ; get action (OSFIND value of A on entry)
    BVC .openAFileForOutputOnly                         ; if (bit 6 not set, i.e. it's to be an output only file) then branch

    ; open a file for input
    LDA #0                                              ; it's an input file
    STA .bgetBufferOffset                               ; BGET buffer offset for next byte
    STA .nextBGETBlockLow                               ; Expected BGET file block number low
    STA .nextBGETBlockHigh                              ; expected BGET file block number high
    LDA #%00111110                                      ; }
    JSR .clearTapeStatusBits                            ; } clear 'input file open' bit; clear 'EOF reached'; clear 'EOF warning given'
    JSR .claimSerialSystemForSequentialAccess           ; claim serial system and set OPTions
    PHP                                                 ; save flags on stack
    JSR .searchForFile                                  ; search for file
    JSR .checkLockedFlag                                ; check protection bit of block status and respond
    PLP                                                 ; get back flags
    LDX #$FF                                            ; X=loop counter

-
    INX                                                 ; X=X+1
    LDA .fsFilename,X                                   ; copy file name character
    STA .bgetFilename,X                                 ; and store as BGET filename
    BNE -                                               ; until end of filename (zero terminator)

    LDA #%00000001                                      ; A=1 to set bit for 'input file open'
    JSR .setTapeStatusBits                              ; set status bit
    LDA .tapeInputCurrentBlockSizeLow                   ; tape filing system currently resident file block length low
    ORA .tapeInputCurrentBlockSizeHigh                  ; tape filing system currently resident file block length high
    BNE +                                               ; if (block length is no zero) then branch
    JSR .setTapeEOFStatus                               ; set tape filing system status bit 6 (EOF reached)
+
    LDA #1                                              ; }
    ORA .tapeOrROMSwitch                                ; } get input file handle, 1 = tape; 3=ROMFS
    BNE .returnAWithXYRestoredFromStack                 ; ALWAYS branch (restore registers and exit)

; ***************************************************************************************
;
; Open a file for output
;
; On Entry:
;       X is length of filename
; ***************************************************************************************
.openAFileForOutputOnly
    TXA                                                 ; A=X
    BNE +                                               ; if (filename length is non-zero) then branch
    JMP .brkBadString                                   ; output 'Bad String' error

+
    LDX #$FF                                            ; X=$FF
.copyFilenameLoop
    INX                                                 ; X=X+1
    LDA .filenameToSearchFor,X                          ; sought filename
    STA .tapeBlockHeaderStart,X                         ; write it to BPUT file header block
    BNE .copyFilenameLoop                               ; until A=0 (zero terminator at end of filename)

    LDA #$FF                                            ; A=$FF
    LDX #8                                              ; X=8
-
    STA .tapeBlockLoadAddressLow-1,X                    ; set load and exec address to $FF
    DEX                                                 ; X=X-1
    BNE -                                               ;

    TXA                                                 ; A=0
    LDX #.tapeBlockNumberLow - .tapeBlockHeaderStart    ; X=loop counter from $14 to $1E
-
    STA .tapeBlockHeaderStart,X                         ; BPUT file header block
    INX                                                 ; X=X+1
    CPX #.bgetBufferOffset - .tapeBlockHeaderStart      ; this zeros BPUT block
    BNE -                                               ;

    ROL .tapeBlockLengthHigh                            ;
    JSR .claimSerialSystemForLoadSave                   ; claim serial system for cassette load/save
    JSR .promptToRecordOnTape                           ; prompt to start recording
    JSR .cancelTapeOperationAndMotor                    ;
    LDA #%00000010                                      ; } set the tape status bit
    JSR .setTapeStatusBits                              ; } for 'output file open'
    LDA #2                                              ; A=2=file handle of (tape) file open for output

.returnAWithXYRestoredFromStack
    STA .fsTempStorage                                  ; store value of A temporarily

.restoreRegistersAndExit
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } Restore X and Y registers
    TAX                                                 ; }
    LDA .fsTempStorage                                  ; recall temporary store into A
.exit30
    RTS                                                 ;

; ***************************************************************************************
.closeFileThatsOpenForOutput
    LDA #%00000010                                      ; }
    AND .fsStatusByte                                   ; } clear all of tape status byte except bit 1
    BEQ .exit30                                         ; if (output file not open) then branch (exit)

    ; an output file is open
    LDA #0                                              ; A=0
    STA .tapeBlockLengthHigh                            ; setting block length to current value of BPUT offset
    LDA #$80                                            ; A=$80 (last block)
    LDX .bputBufferOffset                               ; get BPUT buffer offset
    STX .tapeBlockLengthLow                             ; setting block length to current value of BPUT offset
    STA .tapeBlockFlagByte                              ; mark current block as last
    JSR .saveSequentialAccessBlockToTape                ; save block to tape
    LDA #%11111101                                      ; }
    JMP .clearTapeStatusBits                            ; } clear bit 1 of the tape status (no file is open for output) and return

; ***************************************************************************************
; Sequential access writes bytes instead of files. (As used by BGET and BPUT in BASIC).
.saveSequentialAccessBlockToTape
    JSR .claimSerialSystemForSequentialAccess           ; claim serial system and set OPTions

    LDX #17                                             ; loop counter
-
    LDA .tapeBlockLoadAddressLow,X                      ; }
    STA .fsLoadAddressLow,X                             ; } copy header block
    DEX                                                 ; X=X-1
    BPL -                                               ; loop back until X=255

    ; set load address to "FFFF0900"
    STX .tapeSaveStartAddressMid2                       ; store $FF
    STX .tapeSaveStartAddressHigh                       ; store $FF
    INX                                                 ; increment X (to zero)
    STX .tapeSaveStartAddressLow                        ; store $00
    LDA #$09                                            ;
    STA .tapeSaveStartAddressMid1                       ; store $09

    ; Copy
    LDX #(.tapeBlockFilename-1) - .vduVariablesStart    ;
    JSR .copyToSoughtFilename                           ; copy filename from .tapeBlockFilename to .filenameToSearchFor
    STA .fsLastBlockReadFlagsCopy                       ; set copy of last read block flag to zero
    JSR .zeroFileHandleAndMotorOn                       ; switch Motor On
    JSR .setupForCassetteWrite                          ; set up tape filing system for write operation
    JSR .saveABlockToTape                               ; write block to tape

    ; increment block number
    INC .tapeBlockNumberLow                             ; block number low
    BNE +                                               ;
    INC .tapeBlockNumberHigh                            ; block number high
+
    RTS                                                 ;

; ***************************************************************************************
;
; OSBGET - get byte from file
;
; On Entry:
;       Y contains channel number (file handle)
; On Exit:
;       X and Y are preserved
;       C=0 indicates valid character
;       A contains character (or error) A=$FE End Of File
;
; See LoadFromTape.pdf
; See LoadFromROM.pdf
;
; ***************************************************************************************
.osbgetEntryPoint
    TXA                                                 ; A=X
    PHA                                                 ; save A on stack
    TYA                                                 ; A=Y
    PHA                                                 ; save A on stack
    LDA #1                                              ; A=1 (check file is open for reading)
    JSR .checkFileIsOpen                                ; check conditions for OSBGET are OK
    LDA .fsStatusByte                                   ; tape/ROM FS status byte
    ASL                                                 ; shift bit 7 into carry (EOF warning given)
    BCS .eofErrorMessage                                ; if (carry set) then branch
    ASL                                                 ; shift bit 6 into carry
    BCC .notEOF                                         ; if (carry clear, i.e. EOF not reached) then branch
    LDA #%10000000                                      ; }
    JSR .setTapeStatusBits                              ; } set bit 7 of status byte ('EOF warning given')
    LDA #$FE                                            ; A = return value = $FE (end of file)
    BCS .storeFileStatus                                ; if (carry set) then branch

.notEOF
    LDX .bgetBufferOffset                               ; BGET buffer offset for next byte
    INX                                                 ; X=X+1
    CPX .tapeInputCurrentBlockSizeLow                   ; tape filing system currently resident file block length low
    BNE .readFromFSBufferAndContinue                    ; if (not end of block) then branch (read a byte from buffer)

    BIT .blockFlagOfCurrentlyResidentBlock              ; block flag of currently resident block
    BMI .setEOF                                         ; if (this is the last block) then branch
    LDA .lastCharacterOfCurrentlyResidentBlock          ; last character of currently resident block
    PHA                                                 ; save A on stack
    JSR .claimSerialSystemForSequentialAccess           ; claim serial system and set OPTions
    PHP                                                 ; save flags on stack
    JSR .bgetReadBlockAndHeader                         ; read in a new block
    PLP                                                 ; get back flags
    PLA                                                 ; get back A
    STA .fsTempStorage                                  ; store return value: last byte of current block
    CLC                                                 ; clear carry flag
    BIT .blockFlagOfCurrentlyResidentBlock              ; block flag of currently resident block
    BPL .incrementAndFinish                             ; if (not last block) then branch
    LDA .tapeInputCurrentBlockSizeLow                   ; get block length
    ORA .tapeInputCurrentBlockSizeHigh                  ; OR with high byte
    BNE .incrementAndFinish                             ; if (block size not zero) then branch
    JSR .setTapeEOFStatus                               ; set tape filing system status bit 6 (EOF reached)
    BNE .incrementAndFinish                             ; if (not EOF) then branch

.setEOF
    JSR .setTapeEOFStatus                               ; set tape filing system status bit 6 (EOF reached)

.readFromFSBufferAndContinue
    DEX                                                 ; X=X-1
    CLC                                                 ; clear carry flag
    LDA .tapeOrRS423InputBuffer,X                       ; read byte from cassette buffer

.storeFileStatus
    STA .fsTempStorage                                  ; store return value temporarily
.incrementAndFinish
    INC .bgetBufferOffset                               ; BGET buffer offset for next byte
    JMP .restoreRegistersAndExit                        ; exit via .restoreRegistersAndExit

; ***************************************************************************************
.eofErrorMessage
    BRK                                                 ;
    !byte $DF                                           ; error number
    !text "EOF",0                                       ; string and zero terminator

; ***************************************************************************************
;
; OSBPUT - Write a byte to file
;
; This is for the TAPE filing system only. The OS supplies filing system code for TAPE and
; ROM filing systems, and obviously you can't write into the ROM filing system.
;
; On Entry:
;       Y contains channel number (file handle)
;       A contains byte to be written
;
; See .saveFileToTape for PDF showing the code path and how bytes are written to tape.
;
; ***************************************************************************************
.osbputEntryPoint
    STA .tapeLastBputValue                              ; store A in temporary store
    TXA                                                 ; }
    PHA                                                 ; } save XY on the stack
    TYA                                                 ; }
    PHA                                                 ; }
    LDA #2                                              ; A=2 (meaning check file is open for writing)
    JSR .checkFileIsOpen                                ; check conditions necessary for OSBPUT are OK
    LDX .bputBufferOffset                               ; BPUT buffer offset for next byte
    LDA .tapeLastBputValue                              ; get back original value of A
    STA .tapeOrRS423OutputBuffer,X                      ; Write into cassette or RS-423 buffer
    INX                                                 ; X=X+1
    BNE +                                               ; if (not zero, buffer is not full) then branch
    JSR .saveSequentialAccessBlockToTape                ; buffer is full so save block to tape
    JSR .cancelTapeOperationAndMotor                    ;
+
    INC .bputBufferOffset                               ; BPUT buffer offset for next byte
    LDA .tapeLastBputValue                              ; get back A
    JMP .returnAWithXYRestoredFromStack                 ; and exit

; ***************************************************************************************
;
; *OPT X,Y
;
; On Entry:
;
;        X,Y
;   *OPT 0,0  restore *OPT default message values
;   *OPT 1,0  turn off filing system messages
;   *OPT 1,1  turn on filing system messages (normal)
;   *OPT 1,2  turn on filing system messages (extended)
;   *OPT 2,0  ignore errors, though messages may be displayed
;   *OPT 2,1  on error prompt for retry
;   *OPT 2,2  on error, abort
;   *OPT 3,n  set interblock gaps to n/10 seconds (for tape SAVE operations)
;             if n>127 then set default value
;
; ***************************************************************************************
.starOptEntryPoint
    TXA                                                 ; A=X
    BEQ .restoreDefaultOPTs                             ; if (*OPT 0) then branch (set defaults)
    CPX #3                                              ;
    BEQ .tapeSetInterblockGap                           ; if (*OPT 3) then branch (to set interblock gap)
    CPY #3                                              ;
    BCS .issueBadCommand                                ; if (Y > 2) then branch ('Bad command' error)
    DEX                                                 ;
    BEQ .opt1                                           ; if (*OPT 1) then branch (set filing system message level)
    DEX                                                 ;
    BEQ .opt2                                           ; if (*OPT 2) then branch (response level to errors)
.issueBadCommand
    JMP .badCommandError                                ; issue 'Bad command' error


; ***************************************************************************************
; Set filing system message level
.opt1
    LDA #%00110011                                      ; set lower two bits of each nybble as a MASK
                                                        ; this allows us to set the top two bits of each nybble (message type) and
                                                        ; still keep the existing values for the bottom two bits
                                                        ; of each nybble (ignore/retry/abort)
    INY                                                 ; }
    INY                                                 ; } Y=Y+3 (offset into .tapeOptByteTable)
    INY                                                 ; }
    BNE .setOptWithMask                                 ; ALWAYS branch

; ***************************************************************************************
; Set error levels
.opt2
    LDA #%11001100                                      ; setting top two bits of each nybble as a MASK
                                                        ; allows us to set the bottom two bits of each nybble (ignore/retry/abort) and
                                                        ; still keep the existing values for the top two bits
                                                        ; of each nybble (message type)
.setOptWithMask
    INY                                                 ; Y=Y+1 (offset into .tapeOptByteTable)
    AND .tapeOptionsByte                                ; keep bits set in MASK for keeping current tape options
.setOPTValueY
    ORA .tapeOptByteTable,Y                             ; OR with table value to set new options
    STA .tapeOptionsByte                                ; store it
    RTS                                                 ;

; ***************************************************************************************
.tapeSetInterblockGap
    TYA                                                 ; A=Y (interblock gap)
    BMI +                                               ; if (A > 127) use default value
    BNE .useGapDontUseDefaultValue                      ; if (A != 0) then branch (don't use default value)
+
    LDA #25                                             ; A=25 (2.5 seconds by default)
.useGapDontUseDefaultValue
    STA .tapeSequentialAccessInterBlockGap              ; sequential block gap
    RTS                                                 ;

; ***************************************************************************************
.restoreDefaultOPTs
    TAY                                                 ; Y=A=0
    BEQ .setOPTValueY                                   ; ALWAYS branch


; ***************************************************************************************
;
; Tape opt byte table
;
; Options are stored in top four bits (LOAD/SAVE) and bottom four bits (sequential access)
; See .tapeCurrentOptionsByte.
;
;   bit 0/4 = Abort bit
;   bit 1/5 = Retry bit
;   bit 2/6 } Message type: 00 = no messages
;   bit 3/7 }             : 10 = short messages
;           }             : 11 = long messages
;
; 0000     Ignore errors         no messages
; 0001     Abort if error        no messages
; 0010     Retry after error     no messages
; 1000     Ignore error          short messages
; 1001     Abort if error        short messages
; 1010     Retry after error     short messages
; 1100     Ignore error          long messages
; 1101     Abort if error        long messages
; 1110     Retry after error     long messages
;
; ***************************************************************************************
.tapeOptByteTable
    !byte %10100001                                     ; default value:
                                                        ; LOAD/SAVE: Retry; short messages
                                                        ; SEQUENTIAL: Abort; no messages
    !byte %00000000                                     ; ignore error
    !byte %00100010                                     ; retry if error
    !byte %00010001                                     ; abort if error
    !byte %00000000                                     ; no messages
    !byte %10001000                                     ; short messages
    !byte %11001100                                     ; long messages

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 19: Low Level Tape Operations
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Update ACIA
;
; If necessary, read or write a byte to cassette, or read a byte from ROMFS.
; Can either be called from interrupt routine, or when loading from cassette.
;
; ***************************************************************************************
.updateACIA
    DEC .fsGotACharacterToReadOrWriteFlag               ; Used when writing to tape,
                                                        ; to decrement the value from zero to
                                                        ; 255 indicating the byte has been
                                                        ; written (which happens below)

    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ .updateACIATape                                 ; if (tape filing system active) then branch

    ; deal with reading a byte from ROM / PHROM
    JSR .readByteFromROMFSorPHROM                       ; read ROMFS data ROM or PHROM
    TAY                                                 ; Y=A
    CLC                                                 ; clear carry flag
    BCC .postReadByte                                   ; ALWAYS branch

.updateACIATape
    ; deal with reading or writing to tape
    LDA .acia6850StatusRegister                         ; ACIA status register
    PHA                                                 ; save A on stack
    AND #2                                              ; clear all but bit 1
    BEQ .readByteFromTape                               ; if (transmit data register full,
                                                        ; i.e. not ready to send) then branch
                                                        ; (read from tape)
    LDY .tapeSendingFlag                                ; check we are sending to tape
    BEQ .readByteFromTape                               ; if (not sending to tape) then
                                                        ; branch (read from tape)

    ; send a byte to tape
    PLA                                                 ; get back A
    LDA .fsCharacterJustReadOrCharToWrite               ; get character to send
    STA .acia6850DataRegister                           ; ACIA transmit data register
    RTS                                                 ;

    ; read a byte from tape
.readByteFromTape
    LDY .acia6850DataRegister                           ; read ACIA receive data register
    PLA                                                 ; get back A
    LSR                                                 ; }
    LSR                                                 ; } shift bit 2 to carry
    LSR                                                 ; } (data carrier detect)
    ; fall through

; ***************************************************************************************
;
; Process byte after being read from tape or ROMFS
;
; This is called from the 100Hz interrupt routine. It updates the read progress state as
; needed, and stores the byte for later processing in .readBlockHeader and
; .readTapeBlockHeader.
; See .readBlockHeader.
; See .readTapeBlockHeader.
;
; The progress in reading a block is tracked by a progress byte (0-5):
;
; See .fsReadProgressState
;
;     0 - exit
;     1 - looking for carrier tone
;     2 - found carrier tone, waiting for sync byte $2A
;     3 - found sync byte $2A, now reading header
;     4 - have read the header with non-zero block data length, now reading actual block data
;     5 - finished reading data in block
;
; On Entry:
;       Y = byte just read
;       Carry set if it's the tape filing system and 'data carrier detect' bit is set
;
; ***************************************************************************************
.postReadByte
    LDX .fsReadProgressState                            ; read progress state
    BEQ .exit31                                         ; if (.fsReadProgressState = 0) then branch (exit)
    DEX                                                 ; X=X-1
    BNE .fsReadProgress2FoundCarrierTone                ; if (.fsReadProgressState > 1) then branch

    ; deal with progress state = 1 (looking for carrier tone)
    BCC .exit31                                         ; if (reading from ROM OR carrier
                                                        ; tone from cassette not detected)
                                                        ; then branch (exit)
    LDY #2                                              ; Y=2
    BNE .storeTapeProgress                              ; ALWAYS branch (store progress and
                                                        ; return)

; ***************************************************************************************
.fsReadProgress2FoundCarrierTone
    DEX                                                 ; X=X-1
    BNE .fsReadProgress3FoundSyncByte                   ; if (.fsReadProgressState > 2) then branch

    ; deal with progress state = 2 (found carrier tone, waiting for it to finish)
    BCS .exit31                                         ; if (carrier tone from cassette
                                                        ; still detected) then branch (exit)

    TYA                                                 ; A=Y=byte read
    JSR .zeroChecksumAndFSFlag                          ; initialise CRC checksum to zero
    LDY #3                                              ; Y=3
    CMP #.fsSynchronisationByte                         ; check for the sync byte $2A
    BEQ .storeTapeProgress                              ; if (found sync byte) then branch
                                                        ; (store state and return)

    ; sync byte not found, revert back to progress state 1
    JSR .flipRelayOffAndOnThenSetToReadFromTape         ; control cassette system
    LDY #1                                              ; Y=1
    BNE .storeTapeProgress                              ; ALWAYS branch

; ***************************************************************************************
.fsReadProgress3FoundSyncByte
    DEX                                                 ; X=X-1
    BNE .fsReadProgress4FoundBlockData                  ; if (.fsReadProgressState > 3) then branch

    ; deal with progress state = 3 (found sync byte $2A, reading block header)
    BCS +                                               ; if (carrier detected) then branch
    STY .fsCharacterJustReadOrCharToWrite               ; store byte just read
    BEQ .exit31                                         ; if (zero) then branch (exit)
+
    LDA #$80                                            ; A=$80
    STA .fsGotACharacterToReadOrWriteFlag               ; note that we have just read a byte
    BNE .exit31                                         ; ALWAYS branch (exit)

; ***************************************************************************************
.fsReadProgress4FoundBlockData
    DEX                                                 ; X=X-1
    BNE .fsReadProgress5FinishedReadingBlockData        ; if (.fsReadProgressState > 4) then branch

    ; deal with progress state = 4 (found non-zero length block, reading block data)

    ; if carrier detected then reset progress to zero
    BCS .resetACIAAndResetProgress                      ; if (carry set) then branch (reset and return)

    TYA                                                 ; A=Y=byte just read
    JSR .updateCRC                                      ; perform CRC
    LDY .fsTempStorage                                  ; get length of block read
    INC .fsTempStorage                                  ; increment length of block read
    BIT .fsCharacterJustReadOrCharToWrite               ; check if bit 7 set (meaning
                                                        ; searching, not loading)
    BMI .checkForEndOfBlock                             ; if (searching) then branch

    ; send byte to second processor if needed, or store byte in regular memory
    JSR .checkLoadAddressIsForSecondProcessor           ; check load address is ok
                                                        ; also puts value of A (the byte
                                                        ; just read) into X
    BEQ +                                               ; if (load address is not for second
                                                        ; processor) then branch
    STX .tubeULADataRegister3                           ; Write byte to Tube. This triggers
                                                        ; an NMI on the co-processor.
    BNE .checkForEndOfBlock                             ; ALWAYS branch

+
    TXA                                                 ; A=X restore value
    STA (.loadAddressLow),Y                             ; store byte at current load address

.checkForEndOfBlock
    INY                                                 ; Y=Y+1
    CPY .fsBlockLengthLow                               ; block length
    BNE .exit31                                         ; if (not equal) then branch (exit)

    ; reached end of block data
    LDA #1                                              ; A=1
    STA .fsTempStorage                                  ; loop counter
    LDY #5                                              ; Y=5
    BNE .storeTapeProgress                              ; ALWAYS branch (store progress and return)

; ***************************************************************************************
.fsReadProgress5FinishedReadingBlockData
    ; this first section reads two more bytes (one byte at a time) by using .fsTempStorage
    ; (which was initialised to 1 on the previous progress state above) as a loop counter.
    TYA                                                 ; A=Y=byte read
    JSR .updateCRC                                      ; update CRC
    DEC .fsTempStorage                                  ; decrement loop counter (1,0)
    BPL .exit31                                         ; exit if loop is not done

.resetACIAAndResetProgress
    JSR .resetACIA                                      ; reset ACIA
    LDY #0                                              ; Y=0
.storeTapeProgress
    STY .fsReadProgressState                            ; progress flag
.exit31
    RTS                                                 ;


; ***************************************************************************************
;
; Check for EOF on an open file
;
; On Entry:
;       X = file handle
; On Exit:
;       Preserves A,Y
;       X is 0 if EOF reached
;
; ***************************************************************************************
.checkEOFEntryPoint
    PHA                                                 ; save A on stack
    TYA                                                 ;
    PHA                                                 ; save Y on stack
    TXA                                                 ; }
    TAY                                                 ; } Y=X=file handle
    LDA #3                                              ; A=3 (meaning check for file being
                                                        ; open for read or write)
    JSR .checkFileIsOpen                                ; confirm file is open (otherwise
                                                        ; BRK with 'Channel' error)
    LDA .fsStatusByte                                   ; tape / ROM FS status byte
    AND #%01000000                                      ; mask for just the EOF flag
    TAX                                                 ; X=A
    PLA                                                 ; get back A
    TAY                                                 ; Y=A
    PLA                                                 ; get back A
    RTS                                                 ;

; ***************************************************************************************
.searchForFile
    LDA #0                                              ; }
    STA .currentBlockNumberLow                          ; } reset current block number
    STA .currentBlockNumberHigh                         ; }

.searchForSpecifiedBlock
    LDA .currentBlockNumberLow                          ; current block number (low byte)
    PHA                                                 ; save A on stack
    STA .nextBlockNumberLow                             ; save as next block number (low byte)
    LDA .currentBlockNumberHigh                         ; current block number (high byte)
    PHA                                                 ; save A on stack
    STA .nextBlockNumberHigh                            ; save as next block number (high byte)

    JSR .safePrintFollowingMessage                      ; print message following call
    !text "Searching"                                   ;
    !text .charRETURN,0                                 ;

    LDA #$FF                                            ; A=$FF (Meaning 'Must match filename
                                                        ; and block number')
    JSR .searchForBlockCheckFilingSystem                ; read data from tape filing system/ROMFS
    PLA                                                 ; get back A
    STA .currentBlockNumberHigh                         ; current block number high
    PLA                                                 ; get back A
    STA .currentBlockNumberLow                          ; current block number low
    LDA .nextBlockNumberLow                             ; next block number low
    ORA .nextBlockNumberHigh                            ; next block number high
    BNE +                                               ;
    STA .currentBlockNumberLow                          ; zero current block number low
    STA .currentBlockNumberHigh                         ; zero current block number high
    LDA .checksumIsValidFlag                            ; checksum result
    BNE +                                               ;
    LDX #(.fsFilename-1) - .vduVariablesStart           ;
    JSR .copyToSoughtFilename                           ; copy filename from .fsFilename to .filenameToSearchFor
+
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape filing system; 2=ROMFS
    BEQ .setBlockFlagsAndExit                           ; if (tape filing system active) then branch
    BVS .setBlockFlagsAndExit                           ; if (V set) then branch

.fileNotFoundError
    BRK                                                 ;
    !byte $D6                                           ; Error number
    !text "File not found",0                            ;

; ***************************************************************************************
.setBlockFlagsAndExit
    LDY #$FF                                            ; Y=$FF
    STY .fsLastBlockReadFlagsCopy                       ; copy of last read block flag
    RTS                                                 ;


; ***************************************************************************************
;
; Close a SPOOL / EXEC file
;
; ***************************************************************************************
.closeSpoolOrExecFile
    LDA #0                                              ; A=0, Z=0
    ; fall through...

; ***************************************************************************************
;
; Close EXEC file and optionally open a new EXEC file
;
; On Entry:
;       A = 0
;       Z = 0 means close any open EXEC file.
;       Z = 1 means open the exec file whose filename is in address XY.
;
; ***************************************************************************************
.closeAndOptionallyOpenANewEXECFile
    PHP                                                 ; save flags on stack
    STY .tempWorkspaceE6                                ; .tempWorkspaceE6 = Y
    LDY .execFileHandle                                 ; file handle of EXEC file to be closed
    STA .execFileHandle                                 ; record EXEC file closed (A=0)
    BEQ +                                               ; if (closing an exec file) then branch
    JSR .OSFIND                                         ; close EXEC file (A=0; Y=file handle)
+
    LDY .tempWorkspaceE6                                ; Y = original Y
    PLP                                                 ; get back flags
    BEQ +                                               ; if (zero flag set on entry) then branch (exit)
    LDA #$40                                            ; A is value for opening an input file
    JSR .OSFIND                                         ; open an EXEC file
    TAY                                                 ; Y=A
    BEQ .fileNotFoundError                              ; If (Y ===0) then branch ('File not found')
    STA .execFileHandle                                 ; store EXEC file handle
+
    RTS                                                 ;

; ***************************************************************************************
.bgetReadBlockAndHeader
    LDX #(.bgetFilename-1) - .vduVariablesStart         ;
    JSR .copyToSoughtFilename                           ; copy filename from .bgetFilename to .filenameToSearchFor
    JSR .readBlockHeader                                ; read block header. On exit V is clear for last block of ROMFS.
.checkLockedFlag
    LDA .fsBlockFlagByte                                ; block flag
    LSR                                                 ; move bit 0 into carry to check for a 'locked' file
    BCC .setLoadAddressAndLoadBlock                     ; if (not locked) then branch (skip next instruction)
    JMP .fileLocked                                     ; 'locked' file routine

; ***************************************************************************************
;
; Set Load Address and Load Block
;
; ***************************************************************************************
.setLoadAddressAndLoadBlock
    LDA .nextBGETBlockLow                               ; Expected BGET file block number low
    STA .currentBlockNumberLow                          ; current block number low
    LDA .nextBGETBlockHigh                              ; expected BGET file block number high
    STA .currentBlockNumberHigh                         ; current block number high
    LDA #<.tapeOrRS423InputBuffer                       ; }
    STA .loadAddressLow                                 ; }
    LDA #>.tapeOrRS423InputBuffer                       ; }
    STA .loadAddressMid1                                ; } set load address to $FFFF0A00
    LDA #$FF                                            ; } (i.e. .tapeOrRS423InputBuffer)
    STA .loadAddressMid2                                ; }
    STA .loadAddressHigh                                ; }
    JSR .setStateForLoadingBlockDataOrReset             ; set progress to read block data
    JSR .loadBlock                                      ; load block from tape
    BNE .searchForBlock                                 ; if (non zero) then branch
    LDA .tapeOrRS423InputBuffer + $FF                   ; get last character from input buffer
    STA .lastCharacterOfCurrentlyResidentBlock          ; last character currently resident block
    JSR .incrementBlockNumbers                          ; inc. current block number
    STX .nextBGETBlockLow                               ; expected BGET file block number low
    STY .nextBGETBlockHigh                              ; expected BGET file block number high

    LDX #2                                              ; X = loop counter
-
    LDA .fsBlockLengthLow,X                             ; read bytes from block flag/block length
    STA .tapeInputCurrentBlockSizeLow,X                 ; store into current values of above
    DEX                                                 ; X=X-1
    BPL -                                               ; until X=-1 ($FF)

    BIT .blockFlagOfCurrentlyResidentBlock              ; block flag of currently resident block
    BPL +                                               ; if (not last block) then branch (don't print newline)
    JSR .printReturnSafely                              ; print newline if needed
+
    JMP .cancelTapeOperationAndMotor                    ;

; ***************************************************************************************
.searchForBlock
    JSR .searchForSpecifiedBlock                        ; search for a specified block
    BNE .checkLockedFlag                                ; ALWAYS branch (check for locked condition)

; ***************************************************************************************
.checkForROMBlockMarker
    CMP #.fsSynchronisationByte                         ; check for synchronising byte $2A (at start of first block)
    BEQ .startOfBlock                                   ; if (found synchronising byte for first block) then branch
    CMP #.romFSMiddleBlockHeaderByte                    ; check for header byte for a middle block
    BNE .clearCatalogueStatusBadROM                     ; if (middle block header not found) then branch (error 'Bad ROM')

    INC .fsBlockNumberLow                               ; block number
    BNE +                                               ;
    INC .fsBlockNumberHigh                              ; block number high
+
    LDX #$FF                                            ; X=$FF
    BIT .allBitsSet                                     ; set N and V flags
    BNE .clearChecksumTapeProgress                      ; ALWAYS branch

; ***************************************************************************************
.clearCatalogueStatusBadROM
    LDA #%11110111                                      ; }
    JSR .clearTapeStatusBits                            ; } clear current catalogue status
                                                        ; [this could just call
                                                        ;  JSR .clearCatalogueStatus
                                                        ;  instead of the LDA/JSR instructions
                                                        ;  above, for a 2 byte saving]

.badROMError
    BRK                                                 ; cause error
    !byte $D7                                           ; error number
    !text "Bad ROM"                                     ; message
    !byte 0                                             ; terminator

; ***************************************************************************************
.readTapeBlockHeader
    LDY #$FF                                            ;
    JSR .storeFileHandleAndMotorOn                      ; switch Motor on
    LDA #1                                              ; A=1
    STA .fsReadProgressState                            ; start the read progress state
    JSR .flipRelayOffAndOnThenSetToReadFromTape         ; control serial system

-
    JSR .checkForEscapeDuringCassetteOperation          ; confirm ESC not set and tape filing system not executing
    LDA #3                                              ; A=3
    CMP .fsReadProgressState                            ; progress flag
    BNE -                                               ; back until .fsReadProgressState=3

.startOfBlock
    LDY #0                                              ; Y=0
    JSR .setChecksumBytesToY                            ; zero checksum bytes

    ; read filename
-
    JSR .readByteFromTapeOrROM                          ; get character from file and do CRC
    BVC .reachedEndOfHeader                             ; if (V clear) then branch
    STA .fsFilename,Y                                   ; store
    BEQ +                                               ; or if A=0 then branch
    INY                                                 ; Y=Y+1
    CPY #11                                             ; check Y against 11
    BNE -                                               ; if (Y != 11) then branch (go back for next character)
    DEY                                                 ; Y=10

+
    ; read rest of header
    LDX #12                                             ; X=loop counter (from 12 to 31) to read rest of header
-
    JSR .readByteFromTapeOrROM                          ; get character from file and do CRC
    BVC .reachedEndOfHeader                             ; if (V clear) then branch
    STA .fsFilename,X                                   ; store byte
    INX                                                 ; X=X+1
    CPX #$1F                                            ; check X for 31
    BNE -                                               ; if (X is not 31) then loop back

.reachedEndOfHeader
    TYA                                                 ; }
    TAX                                                 ; } X=Y=length of filename
    LDA #0                                              ; A=0
    STA .fsFilename,Y                                   ; store terminator
    LDA .tapeChecksumLow                                ; }
    ORA .tapeChecksumHigh                               ; } Check if the CRC value is zero
    STA .checksumIsValidFlag                            ; Checksum result is zero if valid

.clearChecksumTapeProgress
    JSR .zeroChecksumAndFSFlag                          ; reset checksum etc
    STY .fsReadProgressState                            ; reset progress (Y=0)
    TXA                                                 ; A=X=length of filename
    BNE .exit32                                         ; The tape filename is always non-zero
                                                        ; in length so:
                                                        ; ALWAYS branch (exit)
                                                        ; [In which case, RTS would be shorter]

; ***************************************************************************************
;
; Read block header
;
; On Exit:
;       V = clear if final block
;
; ***************************************************************************************
.readBlockHeader
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ .readTapeBlockHeader                            ; if (tape filing system active) then branch

    ; Read ROM file header
    ; See NAUG Section 17.5.6, Page 317 for ROM data format
-
    JSR .readByteFromROMFSorPHROM                       ; read ROMFS data ROM or PHROM
    CMP #.romFSFinalBlockHeaderByte                     ; check for ROM file terminator
    BNE .checkForROMBlockMarker                         ; if (not terminator) then branch

    ; ROM file terminator found
    LDA #%00001000                                      ; A=isolating bit 3 (catalogue status)
    AND .fsStatusByte                                   ; check catalogue status
    BEQ +                                               ; if (clear) then branch (skip next instruction)
    JSR .saveFlagsPrintCR                               ; print CR safely
+
    JSR .readByteFromROMOrPHROM                         ; get byte from data ROM
    BCC -                                               ; if (carry clear) then branch (loop back and try again)
    CLV                                                 ; clear overflow flag
    RTS                                                 ;

; ***************************************************************************************
;
; Read byte from tape or ROM
;
; ***************************************************************************************
.readByteFromTapeOrROM
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ +                                               ; if (tape filing system active) then branch

    ; deal with ROMFS read byte
    TXA                                                 ; }
    PHA                                                 ; }
    TYA                                                 ; } save X and Y
    PHA                                                 ; }
    JSR .readByteFromROMFSorPHROM                       ; read ROMFS data ROM or PHROM
    STA .fsCharacterJustReadOrCharToWrite               ; store character just read
    LDA #$FF                                            ; Top bit set
    STA .fsGotACharacterToReadOrWriteFlag               ; note that we have just read a byte
                                                        ; set 'flag' to $FF to avoid waiting for
                                                        ; byte to be read (c.f. from tape)
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } restore X and Y
    TAX                                                 ; }
+
    JSR .waitForByteToReadOrWrite                       ; check for Escape and loop till bit 7 of FS buffer flag=1
    ; fall through...

; ***************************************************************************************
;
; Update CRC
;
; A cyclic redundancy check is updated one byte at a time.
;
; Pseudo-code is as follows. HL = high and low bytes of the CRC. A = byte on input.
;
;   H = A EOR H
;   FOR X = 1 TO 8
;       Carry=bit 7 of H
;       IF (Carry = 1) THEN HL=HL EOR $0810
;       HL=(HL*2 + Carry) AND $FFFF
;   NEXT X
;
; On Entry:
;       A = byte just written or read
;       Preserves A, X and Y
;
; ***************************************************************************************
.updateCRC
    PHP                                                 ; save flags on stack
    PHA                                                 ; save A on stack
    SEC                                                 ; } Set top bit of CRC bit counter
    ROR .tapeCRCBitCounter                              ; } This acts as a loop counter

    EOR .tapeChecksumHigh                               ; }
    STA .tapeChecksumHigh                               ; } H = A EOR H
-
    LDA .tapeChecksumHigh                               ;
    ROL                                                 ; Carry = bit 7 (A = A * 2)
    BCC +                                               ;
    ROR                                                 ; A = A / 2 = H

    EOR #$08                                            ; }
    STA .tapeChecksumHigh                               ; }
    LDA .tapeChecksumLow                                ; } HL=HL EOR $0810
    EOR #$10                                            ; }
    STA .tapeChecksumLow                                ; }
    SEC                                                 ; set carry flag

+
    ROL .tapeChecksumLow                                ; }
    ROL .tapeChecksumHigh                               ; } HL=(HL*2 + Carry) AND &FFFF

    LSR .tapeCRCBitCounter                              ; shift loop counter right
    BNE -                                               ; if (eight bits not processed) then branch

    PLA                                                 ; get back A
    PLP                                                 ; get back flags
.exit32
    RTS                                                 ;

; ***************************************************************************************
;
; Set state ready for loading block data (or reset)
;
; Set the character just read to zero, and the progress state to 4.
; Together this signifies we are ready to load block data.
; If V is clear, then we instead reset to progress state zero.
;
; On Entry:
;       If V clear, then reset to state zero
;       otherwise set to state 4, ready to read the block data bytes
;
; ***************************************************************************************
.setStateForLoadingBlockDataOrReset
    LDA #0                                              ; A=0
    ; fall through...

; ***************************************************************************************
;
; Set state ready for loading block data or searching (or reset state)
;
; Store the character just read. If all is well (V set and non-zero block length), then
; progress state is set to 4. Otherwise we revert back to progress state zero.
;
; On Entry:
;       A is $FF when searching, $00 when loading
;       V clear means reset progress state to zero
;       .fsBlockLengthLow/High holds the block length
;
; ***************************************************************************************
.setCharAThenProgressState4OrReset
    STA .fsCharacterJustReadOrCharToWrite               ; store character just read
    LDX #0                                              ; X=0
    STX .fsTempStorage                                  ;
    BVC +                                               ;
    LDA .fsBlockLengthLow                               ; block length
    ORA .fsBlockLengthHigh                              ; block length high
    BEQ +                                               ; if (block length is zero) then branch
    LDX #4                                              ; X=4 (block length not zero)
+
    STX .fsReadProgressState                            ; save progress flag
    RTS                                                 ;

; ***************************************************************************************
;
; Save a block to tape
;
; When saving to tape, we record a five second delay before the first block, then a delay
; specified by the interblock gap for all subsequent blocks. After all blocks are recorded
; there is a further five second delay.
;
; ***************************************************************************************
.saveABlockToTape
    PHP                                                 ; save flags on stack
    LDX #3                                              ; X=loop counter
    LDA #0                                              ; A=value to store
-
    STA .fsSpareByteA,X                                 ; clear the four spare bytes of file system block
    DEX                                                 ; X=X-1
    BPL -                                               ;

    LDA .fsBlockNumberLow                               ; block number
    ORA .fsBlockNumberHigh                              ; block number high
    BNE .waitForInterblockGap                           ; if (block number is not zero) then branch
    JSR .waitFiveSeconds                                ; generate a 5 second delay
    BEQ +                                               ; ALWAYS branch

.waitForInterblockGap
    JSR .generateInterBlockGapDelay                     ; generate delay set by interblock gap

    ; initialise and save value $2A to tape
+
    LDA #.fsSynchronisationByte                         ; A=synchronisation byte (byte to save to tape)
    STA .fsCharacterJustReadOrCharToWrite               ; store character to write
    JSR .zeroChecksumAndFSFlag                          ; initialise checksum and file system buffer flag
    JSR .activateRequestToSend                          ; request send to tape
    JSR .waitForByteToReadOrWrite                       ; wait for byte to be saved to tape
    DEY                                                 ; Y=Y-1

    ; save filename
-
    INY                                                 ; Y=Y+1
    LDA .filenameToSearchFor,Y                          ; move sought filename
    STA .fsFilename,Y                                   ; into filename block
    JSR .saveByteAToTapeAndUpdateCRC                    ; transfer byte to tape filing system and do CRC
    BNE -                                               ; if (filename not yet complete) then branch (do it again)

    ; save rest of header:
    ;   load address      (4 bytes)
    ;   execution address (4 bytes)
    ;   block number      (2 bytes)
    ;   block length      (2 bytes)
    ;   block flag byte   (1 byte)
    ;   spare bytes       (4 bytes)
    LDX #.fsLoadAddressLow - .fsFilename                ; X=offset to load address
-
    LDA .fsFilename,X                                   ; get filename byte
    JSR .saveByteAToTapeAndUpdateCRC                    ; transfer byte to tape filing system and do CRC
    INX                                                 ; X=X+1
    CPX #.fsChecksumLow - .fsFilename                   ; until X reaches the end of the header block (just before the start of the two checksum bytes)
    BNE -                                               ;

    JSR .saveChecksumToTape                             ; save checksum to TAPE reset buffer flag
    LDA .fsBlockLengthLow                               ; block length
    ORA .fsBlockLengthHigh                              ; block length high
    BEQ .saveFinalTwoBytes                              ; if (block length is zero) then branch

    LDY #0                                              ; Y=0
    JSR .setChecksumBytesToY                            ; zero checksum bytes

-
    LDA (.tapeSaveStartAddressLow),Y                    ; get a data byte to save
    JSR .checkLoadAddressIsForSecondProcessor           ; check if load address is from second processor
    BEQ +                                               ; if (not from second processor) then branch
    LDX .tubeULADataRegister3                           ; read byte from second processor
+
    TXA                                                 ; A=X
    JSR .saveByteAToTapeAndUpdateCRC                    ; transfer byte to tape filing system and do CRC
    INY                                                 ; Y=Y+1
    CPY .fsBlockLengthLow                               ; check block length
    BNE -                                               ; if (block not done yet) then branch (loop back)

    JSR .saveChecksumToTape                             ; save checksum to TAPE

.saveFinalTwoBytes
    JSR .waitForByteToReadOrWrite                       ; save byte
    JSR .waitForByteToReadOrWrite                       ; save byte
    JSR .resetACIA                                      ; reset ACIA

    LDA #1                                              ; A=1
    JSR .generateDelay                                  ; generate 0.1 second delay
    PLP                                                 ; get back flags
    JSR .updateBlockFlagAndDisplayProgress              ; update block flag, PRINT filename (and address if reqd)
    BIT .fsBlockFlagByte                                ; block flag
    BPL +                                               ; if (this is NOT last block) then branch
    PHP                                                 ; save flags on stack
    JSR .waitFiveSeconds                                ; generate a 5 second delay
    JSR .beepCancelAndPrintReturn                       ; sound bell and cancel
    PLP                                                 ; get back flags
+
    RTS                                                 ;

; ***************************************************************************************
.saveByteAToTapeAndUpdateCRC
    JSR .saveByteAToTape                                ; save byte
    JMP .updateCRC                                      ; update CRC

; ***************************************************************************************
.saveChecksumToTape
    LDA .tapeChecksumHigh                               ;
    JSR .saveByteAToTape                                ; save byte to buffer, transfer to
                                                        ; tape filing system and reset flag
    LDA .tapeChecksumLow                                ;
    ; fall through...

; ***************************************************************************************
;
; Save a byte to tape
;
; On Entry:
;       A = character to write
; On Exit:
;       A is preserved
;
; ***************************************************************************************
.saveByteAToTape
    STA .fsCharacterJustReadOrCharToWrite               ; store character to write

.waitForByteToReadOrWrite
    JSR .checkForEscapeDuringCassetteOperation          ; confirm ESC not set and tape filing
                                                        ; system not executing
    BIT .fsGotACharacterToReadOrWriteFlag               ; check if we have read / written a byte
    BPL .waitForByteToReadOrWrite                       ; loop back until we have read / written a byte

    ; byte is now read / written
    LDA #0                                              ; A=0
    STA .fsGotACharacterToReadOrWriteFlag               ; clear flag, we no longer have a byte
    LDA .fsCharacterJustReadOrCharToWrite               ; get character just read
    RTS                                                 ;

; ***************************************************************************************
.waitFiveSeconds
    LDA #50                                             ; Set A for 50 tenths of a second
                                                        ; delay
    BNE .generateDelay                                  ; ALWAYS branch. generate delay
                                                        ; 100ms * A (= 5 seconds)

; ***************************************************************************************
;
; Delay for the (temporary) interblock gap time
;
; ***************************************************************************************
.generateInterBlockGapDelay
    LDA .tapeInterBlockGap                              ; get current interblock flag
    ; fall through...

; ***************************************************************************************
;
; Wait for A/10 seconds, or until ESCAPE is pressed
;
; On Entry:
;       A = amount of delay in 10ths of a second
;
; ***************************************************************************************
.generateDelay
    LDX #5                                              ; X=loop counter

.delayLoop
    STA .verticalSyncCounter                            ; set vsync counter
-
    JSR .checkForEscapeDuringCassetteOperation          ; check for ESCAPE
    BIT .verticalSyncCounter                            ; check vsync counter (decremented 50 times a second)
    BPL -                                               ; if (not negative) then branch back
    DEX                                                 ; X--
    BNE .delayLoop                                      ;
    RTS                                                 ;

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 20: Filing System Messaging and Error Reporting
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.generateScreenReports
    LDA .fsBlockNumberLow                               ; block number low
    ORA .fsBlockNumberHigh                              ; block number high
    BEQ .newlineAndContinue                             ; if (block number is zero) then branch (print newline and continue)
    BIT .fsLastBlockReadFlagsCopy                       ; copy of last read block flags
    BPL .updateBlockFlagAndDisplayProgress              ; update block flag, PRINT filename (and address if required)

.newlineAndContinue
    JSR .printReturnSafely                              ; print newline if needed
    ; fall through...

; ***************************************************************************************
;
; Display progress
;
; ***************************************************************************************
.updateBlockFlagAndDisplayProgress
    LDY #0                                              ; Y=0
    STY .currentBlockHasDataErrorFlag                   ; reset data error flag to zero
    LDA .fsBlockFlagByte                                ; get block flag byte
    STA .fsLastBlockReadFlagsCopy                       ; store as copy of last read block flag
    JSR .shouldPrintMessage                             ; check if free to print message
    BEQ .exit33                                         ; if (not safe to print messages) then branch (return)

    ; print just a carriage return, to return text cursor to the start of the current line
    ; (without emitting a linefeed to go down to the next line)
    LDA #.charRETURN                                    ; carriage return
    JSR .OSWRCH                                         ; print it (note no linefeed; so text will overwrite any previous block's message)

    ; display filename as printable characters, or '?' otherwise
.filenameLoop
    LDA .fsFilename,Y                                   ; get byte from filename (zero terminated)
    BEQ .filenameDone                                   ; if (filename is ended) then branch
    CMP #.charSPACE                                     ; }
    BCC .displayQuestionMark                            ; } if (control code found) then branch (show '?')
    CMP #.charDELETE                                    ; check for being less than DELETE
    BCC .displayPrintableCharacter                      ; if (it's a printable character) then branch
.displayQuestionMark
    LDA #.charQUESTIONMARK                              ; A='?'
.displayPrintableCharacter
    JSR .OSWRCH                                         ; and print it
    INY                                                 ; Y=Y+1
    BNE .filenameLoop                                   ; ALWAYS branch (back to get rest of filename)
    ; fall through...

; ***************************************************************************************
;
; Display Progress (post-filename)
;
; John Kortink found a couple of bugs in the filing systems. See .reachedFinalBlock.
;
; The first is that in the ROM filing system, .tapeFileLengthLow / High only get set here
; if long messages are enabled, otherwise we early out of this routine. This means OSFILE
; can return an invalid size.
;
; See .reachedFinalBlock for more information
;
; ***************************************************************************************
.filenameDone
    LDA .tapeOrROMSwitch                                ; filing system switch (0=cassette, 2=ROM filing system)
    BEQ +                                               ; if (tape filing system active) then branch
    BIT .tapeCurrentOptionsByte                         ; check bit 6 of current options
    BVC .exit33                                         ; if (long messages not needed) then branch (exit)

    ; print spaces after filename up to 11 characters total
+
    JSR .printSpace                                     ; print a space
    INY                                                 ; Y=Y+1
    CPY #11                                             ;
    BCC .filenameDone                                   ; if (Y<11) then branch (loop again to fill out filename with spaces)

    ; print block number
    LDA .fsBlockNumberLow                               ; block number
    TAX                                                 ; remember block number in X
    JSR .printHexByte                                   ; print hex byte as ASCII
    BIT .fsBlockFlagByte                                ; block flag byte (bit 7 is 'last block' flag)
    BPL .exit33                                         ; if (not end of file) then branch (return)

    ; at this point we are on the last block of the file
    ; print the file length in hex
    TXA                                                 ; recall block number from X
    CLC                                                 ;
    ADC .fsBlockLengthHigh                              ; add block length high byte (to get total file length high)
    STA .tapeFileLengthHigh                             ; store as file length (high byte)
    JSR .printSpaceThenHexByte                          ; print space then hex byte as ASCII
    LDA .fsBlockLengthLow                               ; get block length (low byte)
    STA .tapeFileLengthLow                              ; store as file length (low byte)
    JSR .printHexByte                                   ; print hex byte as ASCII
    BIT .tapeCurrentOptionsByte                         ; current options
    BVC .exit33                                         ; if (long messages not required) then branch (return)

    ; print four spaces
    LDX #4                                              ; X=loop counter
-
    JSR .printSpace                                     ; print a space
    DEX                                                 ;
    BNE -                                               ; loop to print 4 spaces

    ; display load address, a space, then executable address
    LDX #.fsLoadAddressHigh - .fsFilename               ; X = offset to load address (high byte)
    JSR .printFourByteAddress                           ; print 4 bytes from tape filing system block header
    JSR .printSpace                                     ; print a space
    LDX #.fsExecutionAddressHigh - .fsFilename          ; X = offset to execution address (high byte)
    ; fall through...

; ***************************************************************************************
;
; Print four bytes from tape filing system block header
;
; On Entry:
;       X is offset to high byte of address from .fsFilename
;
; ***************************************************************************************
.printFourByteAddress
    LDY #4                                              ; loop counter
-
    LDA .fsFilename,X                                   ; block header
    JSR .printHexByte                                   ; print ASCII equivalent of hex byte
    DEX                                                 ; X=X-1
    DEY                                                 ; Y=Y-1
    BNE -                                               ;
.exit33
    RTS                                                 ;

; ***************************************************************************************
.promptToRecordOnTape
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ +                                               ; if (tape filing system active) then branch
    JMP .badCommandError                                ; 'Bad command error message'
+
    JSR .zeroFileHandleAndMotorOn                       ; switch motor on
    JSR .setupForCassetteWrite                          ; set up tape filing system for write operation
    JSR .shouldPrintMessage                             ; check if free to print message
    BEQ .exit33                                         ; if (not free to print message) exit
    JSR .safePrintFollowingMessage                      ; print message following call
    !text "RECORD then RETURN"                          ; message
    !byte 0                                             ; terminator

-
    JSR .checkForEscapeDuringCassetteOperation          ; check for ESCAPE
    JSR .OSRDCH                                         ; wait for keypress
    CMP #.charRETURN                                    ; check for the RETURN key
    BNE -                                               ; if (not RETURN key) then branch (loop back to test again)
    JMP .OSNEWL                                         ; output Carriage RETURN and LINE FEED then return

; ***************************************************************************************
;
; Increment load or save address (by one page)
;
; Add a page onto the load address (.loadAddress) when loading,
; or save start address (.tapeSaveStartAddress) when saving.
;
; ***************************************************************************************
.incrementLoadOrSaveAddress
    INC .loadAddressMid1                                ; increment page
    BNE +                                               ;
    INC .loadAddressMid2                                ; increment higher bytes as needed
    BNE +                                               ;
    INC .loadAddressHigh                                ; increment higher bytes as needed
+
    RTS                                                 ;

; ***************************************************************************************
.printSpaceThenHexByte
    PHA                                                 ; save A on stack
    JSR .printSpace                                     ; print a space
    PLA                                                 ; get back A
    ; fall through...

; ***************************************************************************************
;
; Print ASCII version of a hex value
;
; On Entry:
;       A = value to print
;       Preserves X and Y
;
; ***************************************************************************************
.printHexByte
    PHA                                                 ; save A on stack
    LSR                                                 ; }
    LSR                                                 ; }
    LSR                                                 ; } divide by 16 to put high nybble in low
    LSR                                                 ; }
    JSR .printHexDigit                                  ; print its ASCII equivalent
    PLA                                                 ; get back A
.printHexDigit
    CLC                                                 ; clear carry flag
    AND #%00001111                                      ; clear high nybble. A=0-15
    ADC #.charZERO                                      ; A = $30 to $3F
    CMP #.charNINE + 1                                  ; }
    BCC .writeCharJumper                                ; } if A <= ASC('9') then print
    ADC #.charA - (.charNINE + 1) - 1                   ; Convert $3A-$3F to A=$41-$46 ('A' to 'F')

.writeCharJumper
    JMP .OSWRCH                                         ; print character and return

;[ This routine could be three bytes smaller...
;.printHexByte
;    PHA                                                 ; save A on stack
;    LSR                                                 ; }
;    LSR                                                 ; }
;    LSR                                                 ; } divide by 16 to put high nybble in low
;    LSR                                                 ; }
;    JSR .printHexDigit                                  ; print its ASCII equivalent
;    PLA                                                 ; get back A
;    AND #%00001111                                      ; just the lower nybble
;.printHexDigit
;    SED                                                 ; set decimal mode
;    CMP #10                                             ; }
;    ADC #.charZERO                                      ; } decimal mode arithmetic trick
;    CLD                                                 ; clear decimal mode
;    JMP .OSWRCH                                         ; print character and return
;]

; ***************************************************************************************
.printSpace
    LDA #.charSPACE                                     ; A=' '
    BNE .writeCharJumper                                ; ALWAYS branch (to print it)

; ***************************************************************************************
.checkForEscapeDuringCassetteOperation
    PHP                                                 ; save flags on stack
    BIT .tapeCritical                                   ; first read tape critical flag
    BMI .skipESCAPECheck                                ; if (tape critical) then branch
    BIT .escapeFlag                                     ; }
    BMI .foundEscapeCondition                           ; } if (ESCAPE condition found) then branch
.skipESCAPECheck
    PLP                                                 ; get back flags
    RTS                                                 ;

; ***************************************************************************************
.foundEscapeCondition
    JSR .clearCatalogueStatus                           ; clear catalogue status
    JSR .cancelTapeOperationAndMotor                    ;
    LDA #126                                            ; }
    JSR .OSBYTE                                         ; } Acknowledge ESCAPE condition
.escapeError
    BRK                                                 ; cause error
    !byte $11                                           ; error 17
    !text "Escape"                                      ; message
    !byte 0                                             ; terminator

; ***************************************************************************************
; On Entry:
;       Y = 0 for no messages
;       otherwise show messages
.loadBlock
    TYA                                                 ; A=Y
    BEQ +                                               ;
    JSR .safePrintFollowingMessage                      ; print message following call

    !text .charRETURN,"Loading",.charRETURN             ; message text
    !byte 0                                             ; terminator

+
    STA .currentBlockHasDataErrorFlag                   ; data error = zero
    LDX #$FF                                            ; X=$FF
    LDA .checksumIsValidFlag                            ; Checksum result
    BNE .checkForChecksumError                          ; if (checksum failed) then branch

    ; check if we have the right filename
    JSR .compareFilenames                               ; check filename header block matches searched filename.
    PHP                                                 ; save flags on stack
    LDX #$FF                                            ; X=$FF
    LDY #<.fileError                                    ; }
    LDA #>.fileError                                    ; } YA is set to point to 'File?' error
    PLP                                                 ; get back flags
    BNE .printNewlineThenReportError                    ; if (filenames don't match) then branch (report a query unexpected file name)

.checkForChecksumError
    LDY #<.dataError                                    ; making Y/A point to 'Data' for CRC error
    LDA .checksumIsValidFlag                            ; Checksum result
    BEQ .checksumOK                                     ; if (no checksum error) then branch
    LDA #>.dataError                                    ; point to dataError
    BNE .printNewlineThenReportError                    ; ALWAYS branch (to report issue)

; ***************************************************************************************
.checksumOK
    LDA .fsBlockNumberLow                               ; block number
    CMP .currentBlockNumberLow                          ; current block number low
    BNE .reportBlockError                               ; if (block numbers low byte dont match) then branch
    LDA .fsBlockNumberHigh                              ; block number high
    CMP .currentBlockNumberHigh                         ; current block number high
    BEQ .blockNumbersMatch                              ; if (block numbers high byte matches) then branch

.reportBlockError
    LDY #<.blockError                                   ; } an error has occurred
    LDA #>.blockError                                   ; } point AY to 'Block?' error (unexpected block number)
                                                        ;
.printNewlineThenReportError
    PHA                                                 ; }
    TYA                                                 ; }
    PHA                                                 ; } save registers AYX on stack
    TXA                                                 ; }
    PHA                                                 ; }
    JSR .newlineAndContinue                             ; print CR if indicated by current block flag
    PLA                                                 ; }
    TAX                                                 ; }
    PLA                                                 ; } restore XYA from stack
    TAY                                                 ; }
    PLA                                                 ; }
    BNE .checkIfWeShouldShowError                       ; ALWAYS branch (since the high byte of the error message address in A is never zero)

; ***************************************************************************************
.blockNumbersMatch
    TXA                                                 ; A=X
    PHA                                                 ; save A on stack
    JSR .generateScreenReports                          ; report
    JSR .waitForBlockToFinish                           ; wait for block to finish
    PLA                                                 ; get back A
    TAX                                                 ; X=A
    LDA .tapeChecksumLow                                ;
    ORA .tapeChecksumHigh                               ;
    BEQ .exit34                                         ; if (checksum succeeded) then branch (exit)

    ; checksum error
    LDY #<.dataError                                    ; }
    LDA #>.dataError                                    ; } AY points to 'Data?'

.checkIfWeShouldShowError
    DEC .currentBlockHasDataErrorFlag                   ; set current block flag to $FF
    PHA                                                 ; save A on stack
    BIT .tapeCritical                                   ; read tape critical flag
    BMI .tidyUpAndDisplayError                          ; if (tape critical) then branch
    TXA                                                 ; A=X
    AND .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BNE .tidyUpAndDisplayError                          ; if (ROMFS) then branch
    TXA                                                 ; A=X
    AND #%00010001                                      ;
    AND .tapeCurrentOptionsByte                         ; current options (check for abort)
    BEQ .dontAbortOnError                               ; if (not abort on error) then branch

.tidyUpAndDisplayError
    PLA                                                 ; get back A
    STA .printMessageAddressHigh                        ; store A
    STY .printMessageAddressLow                         ; store Y
    JSR .closeSpoolOrExecFile                           ; do *EXEC 0 to tidy up
    LSR .tapeCritical                                   ; clear tape critical flag
    JSR .beepAndCancelTapeOperation                     ; bell, reset ACIA and motor
    JMP (.printMessageAddressLow)                       ; display selected error report

; ***************************************************************************************
.dontAbortOnError
    PLA                                                 ; get A from stack
    INY                                                 ; }
    BNE +                                               ; } increment AY
    CLC                                                 ; }
    ADC #1                                              ; }
+
    PHA                                                 ; }
    TYA                                                 ; } save AY on stack. This is the
    PHA                                                 ; } (byte before) the error message
                                                        ; } which will be printed by
                                                        ; } .printFollowingMessage below
    ; fall through...

; ***************************************************************************************
.safePrintFollowingMessage
    JSR .shouldPrintMessage                             ; check if free to print message
    TAY                                                 ; Y=A
    ; fall through...

; ***************************************************************************************
;
; Print the following message
;
; Prints the message at the address on the top of the stack (this is usually the
; return address, so represents the data that follows a JSR to this function).
; The alternative route here is that we fall through from .dontAbortOnError above, which
; has put the appropriate address on the stack.
;
; On returning from this routine, execution continues from the byte directly after the
; message.
;
; On Entry:
;       The top two bytes on the stack hold the address of the message - 1
;       Y = zero means don't actually output the message
;       otherwise print each character of the message using .OSASCI
; On Exit:
;       A = 0
;       Z is clear (not equal to zero)
; ***************************************************************************************
.printFollowingMessage
    PLA                                                 ; }
    STA .printMessageAddressLow                         ; } get calling address
    PLA                                                 ; } and store it in .printMessageAddressLow/High
    STA .printMessageAddressHigh                        ; }
    TYA                                                 ; A=Y (used to set Z flag if Y=0)
    PHP                                                 ; save Z flag on stack
-
    INC .printMessageAddressLow                         ;
    BNE +                                               ;
    INC .printMessageAddressHigh                        ;
+
    LDY #0                                              ; Y=0
    LDA (.printMessageAddressLow),Y                     ; get byte of message to print
    BEQ .printingFinished                               ; if (terminator found) then branch
                                                        ; (jump back to calling function after
                                                        ; message)
    PLP                                                 ; restore flags from stack
    PHP                                                 ; save flags on stack again
    BEQ -                                               ; if (Z=1, i.e. don't output message)
                                                        ; then branch (loop back to get next
                                                        ; character)
    JSR .OSASCI                                         ; print character
    JMP -                                               ; jump back to get next character

.printingFinished
    PLP                                                 ; get back flags
    INC .printMessageAddressLow                         ; increment pointers
    BNE +                                               ;
    INC .printMessageAddressHigh                        ;
+
    JMP (.printMessageAddressLow)                       ; return control to just after the error message


; ***************************************************************************************
.compareFilenames
    LDX #$FF                                            ; loop counter
.checkNextCharacter
    INX                                                 ; X=X+1
    LDA .filenameToSearchFor,X                          ; get sought filename byte
    BNE .checkCharacter                                 ; if (non zero) then branch (check this character)
    TXA                                                 ; A = filename length
    BEQ +                                               ; if (zero length) then branch (exit)
    LDA .fsFilename,X                                   ; A = filename byte
+
    RTS                                                 ;

.checkCharacter
    JSR .isLetter                                       ; set carry if byte in A is NOT a letter
    EOR .fsFilename,X                                   ; compare with filename character
    BCS +                                               ; if (carry set, i.e. not a letter) then branch
    AND #$DF                                            ; convert to upper case
+
    BEQ .checkNextCharacter                             ; if (zero, i.e. filename characters match) then branch (check the next character)
.exit34
    RTS                                                 ;

; ***************************************************************************************
;
; Filing System Data Errors
;
; Note that these error routines are called if the abort flag is set in the current options.
; If the abort flag is not set, then the routine is not called, but by manipulating the
; address of the routine, the message contained within is printed and execution continues
; after the message. See .blockNumbersMatch for an example which executes .dontAbortOnError
; See .dontAbortOnError.
;
; ***************************************************************************************
.dataError
    BRK                                                 ;
    !byte $D8                                           ; error number
    !text .charRETURN, "Data?"                          ; message
    !byte 0                                             ; terminator
    BNE .postFileError                                  ; ALWAYs branch

.fileError
    BRK                                                 ;
    !byte $DB                                           ; error number
    !text .charRETURN, "File?"                          ; message
    !byte 0                                             ; terminator
    BNE .postFileError                                  ; ALWAYs branch

.blockError
    BRK                                                 ;
    !byte $DA                                           ; error number
    !text .charRETURN, "Block?"                         ; message
    !byte 0                                             ; terminator
    ; fall through...

; ***************************************************************************************
.postFileError
    LDA .currentBlockHasDataErrorFlag                   ; get current block flag
    BEQ .skipRewindTapeMessage                          ; if (zero) then branch
    TXA                                                 ; A=X
    BEQ .skipRewindTapeMessage                          ; if (X == 0) then branch (no retry)
    LDA #%00100010                                      ; A=$22
    BIT .tapeCurrentOptionsByte                         ; check current options
    BEQ .skipRewindTapeMessage                          ; if (not retry) then branch (no retry)

    ; rewind tape
    JSR .resetACIA                                      ; reset ACIA
    TAY                                                 ; Y=A
    JSR .printFollowingMessage                          ; print following message
    !byte .charRETURN                                   ; Carriage Return
    !byte .charBELL                                     ; Beep
    !text "Rewind tape"                                 ; Message
    !byte .charRETURN, .charRETURN                      ; Carriage Return, Carriage Return
    !byte 0                                             ; terminator
.exit35
    RTS                                                 ;

.skipRewindTapeMessage
    JSR .saveFlagsPrintCR                               ; print CR if tape filing system not critical
    ; fall through...

; ***************************************************************************************
.waitForBlockToFinish
    LDA .fsReadProgressState                            ; get progress state
    BEQ .exit35                                         ; if (zero) then branch (return)
    JSR .checkForEscapeDuringCassetteOperation          ; check for ESCAPE
    LDA .tapeOrROMSwitch                                ; filing system flag 0=tape; 2=ROMFS
    BEQ .waitForBlockToFinish                           ; if (tape filing system active) then branch (loop back)
    JSR .updateACIA                                     ; set up ACIA etc
    JMP .waitForBlockToFinish                           ; loop back again

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 21: More Low Level Tape Operations
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
.beepAndCancelTapeOperation
    JSR .shouldPrintMessage                             ; check if free to print message
    BEQ .cancelTapeOperationAndMotor                    ;
    LDA #.charBELL                                      ; beep
    JSR .OSWRCH                                         ;
    ; fall through...

; ***************************************************************************************
; Cancel the tape operation:
;       relinquish the Tube
;       switch off the cassette motor
;       reset ACIA
.cancelTapeOperationAndMotor
    LDA #$80                                            ;
    JSR .secondProcessorTransfer                        ; relinquish the Tube (NAUG Section 18.8, Page 339)
    LDX #0                                              ;
    JSR .controlMotor                                   ; switch off motor
.cancelTapeOperation
    PHP                                                 ; save flags on stack
    SEI                                                 ; prevent IRQ interrupts
    LDA .serialULARegisterCopy                          ; get serial ULA control register setting
    STA .serialULAControlRegister                       ; write to serial ULA control register setting
    LDA #0                                              ; A=0
    STA .rs423TimeoutCounter                            ; zero RS-423 timeout counter
    BEQ +                                               ; ALWAYS branch

; ***************************************************************************************
.setupACIA
    PHP                                                 ; save flags on stacksave flags
+
    JSR .resetACIA                                      ; reset the ACIA
    LDA .rs423ControlRegisterCopy                       ; get last setting of ACIA
    JMP .storeACIAAndPull                               ; set ACIA and OS Copy from A before exit


; ***************************************************************************************
.checkForEscapeFlag
    PLP                                                 ; get back flags
    BIT .escapeFlag                                     ; check bit 7 of ESCAPE flag
    BPL .waitForRS423ToTimeout                          ; if (ESCAPE flag not set) then branch
    RTS                                                 ; return (ESCAPE is pending)

; ***************************************************************************************
.claimSerialSystemForSequentialAccess
    LDA .tapeOptionsByte                                ; get cassette filing system options byte
                                                        ; high nybble used for LOAD and SAVE operations
                                                        ; low nybble used for sequential access
                                                        ; See .tapeOptByteTable

    ASL                                                 ; }
    ASL                                                 ; }
    ASL                                                 ; } move low nybble into high nybble
    ASL                                                 ; }
    STA .tapeCurrentOptionsByte                         ; save current OPTions
    LDA .tapeSequentialAccessInterBlockGap              ; get sequential block gap (>0)
    BNE .claimSerialSystem                              ; ALWAYS branch

; ***************************************************************************************
.claimSerialSystemForLoadSave
    LDA .tapeOptionsByte                                ; get cassette filing system options byte
                                                        ; high nybble used for LOAD and SAVE operations
                                                        ; low nybble used for sequential access
                                                        ; See .tapeOptByteTable

    AND #%11110000                                      ; clear low nybble
    STA .tapeCurrentOptionsByte                         ; store as current OPTions
    LDA #6                                              ; set current interblock gap to 6/10ths of a second

.claimSerialSystem
    STA .tapeInterBlockGap                              ; set current interblock gap

    ; wait for the RS-423 system to timeout, so that the cassette system can take over
.waitForRS423ToTimeout
    CLI                                                 ; allow interrupts briefly
    PHP                                                 ; save flags on stack (with interrupts enabled)
    SEI                                                 ; disable interrupts
    BIT .rs423ReadyFlag                                 ;
    BPL .checkForEscapeFlag                             ; if (RS-423 is busy) then branch
                                                        ; (check escape flag and try again)
    LDA .rs423TimeoutCounter                            ;
    BMI .checkForEscapeFlag                             ; if (RS-423 has NOT timed out) then
                                                        ; branch (check for escape flag and try again)

    LDA #1                                              ; } store RS-423 timeout counter with
    STA .rs423TimeoutCounter                            ; } one to indicate that cassette has
                                                        ; } control of the ACIA 6850

    JSR .resetACIA                                      ; reset ACIA
    PLP                                                 ; get back flags (enabling interrupts)
    RTS                                                 ;

; ***************************************************************************************
.resetACIA
    LDA #%00000011                                      ; A=3 (bits CR0 and CR1 set means
                                                        ;      'master reset')
    BNE .storeAToACIARegister                           ; ALWAYS branch (to reset ACIA)

; ***************************************************************************************
.activateRequestToSend
    LDA #%00110000                                      ; set current ACIA control register
                                                        ; 8 bit word, 2 stop bits, RTS low
                                                        ; (this is the active state), transmit
                                                        ; interrupt enabled
    STA .tapeSendingFlag                                ; set non-zero value to indicate
                                                        ; sending to tape
    BNE .setACIA6850ControlRegister                     ; ALWAYS branch

; ***************************************************************************************
.flipRelayOffAndOnThenSetToReadFromTape
    LDA #%00000101                                      ; set .serialULAControlRegister
    STA .serialULAControlRegister                       ; which sets transmit to 300 baud
                                                        ;           receive to 19200 baud
                                                        ;              tape system in use
                                                        ;                       motor off
    LDX #$FF                                            ; loop counter
-
    DEX                                                 ; } delay loop
    BNE -                                               ; }
    STX .tapeSendingFlag                                ; .tapeSendingFlag = 0
    LDA #%10000101                                      ;     transmit baud rate 300 baud
                                                        ;           receive to 19200 baud
                                                        ;              tape system in use
                                                        ;                        motor on
    STA .serialULAControlRegister                       ;

    LDA #%11010000                                      ; A=%11010000
                                                        ; bit 7     - enable interrupts
                                                        ; bit 6/5   - RTS high, transmit
                                                        ;             interrupt disabled
                                                        ; bit 4/3/2 - 8 bit word, 2 stop bits
                                                        ; bit 1/0   - divide counter by 1
.setACIA6850ControlRegister
    ORA .tapeBaudRate                                   ; set bits for baud rate:
                                                        ; 5 = %101 means 1200 baud
                                                        ; (divide by 16; 1 stop bit)
                                                        ; 6 = %110 means  300 baud
                                                        ; (divide by 64; 1 stop bit)
.storeAToACIARegister
    STA .acia6850ControlRegister                        ; set up ACIA control register
    RTS                                                 ;

; ***************************************************************************************
.incrementBlockNumbers
    LDX .fsBlockNumberLow                               ; block number
    LDY .fsBlockNumberHigh                              ; block number high
    INX                                                 ; X=X+1
    STX .currentBlockNumberLow                          ; current block number low
    BNE +                                               ;
    INY                                                 ; Y=Y+1
+
    STY .currentBlockNumberHigh                         ; current block number high
    RTS                                                 ;

; ***************************************************************************************
.zeroChecksumAndFSFlag
    LDY #0                                              ;
    STY .fsGotACharacterToReadOrWriteFlag               ; clear 'just read character' flag
    ; fall through...

; ***************************************************************************************
;
; Set (zero) checksum bytes
;
; On Entry:
;       Y = value to store (always zero in practice)
.setChecksumBytesToY
    STY .tapeChecksumLow                                ;
    STY .tapeChecksumHigh                               ;
    RTS                                                 ;

; ***************************************************************************************
;
; Copy zero terminated string to .filenameToSearchFor
;
; On Entry:
;       X is offset from $301 for source string
; ***************************************************************************************
.copyToSoughtFilename
    LDY #$FF                                            ; Y=$FF
-
    INY                                                 ; Y=Y+1
    INX                                                 ; X=X+1
    LDA .vduVariablesStart,X                            ;
    STA .filenameToSearchFor,Y                          ; sought filename
    BNE -                                               ; until end of filename (0)
    RTS                                                 ;

; ***************************************************************************************
.zeroFileHandleAndMotorOn
    LDY #0                                              ; Y=0
    ; fall through...

; ***************************************************************************************
.storeFileHandleAndMotorOn
    CLI                                                 ; enable interrupts
    LDX #1                                              ; X=1 (relay on)
    STY .tapeCurrentFileHandle                          ; store Y as current file handle
    ; fall through...

; ***************************************************************************************
;
; Control Tape Relay (On / Off)
;
; On Entry:
;       X = 0 for relay off
;       X = 1 for relay on
.controlMotor
    LDA #137                                            ; do OSBYTE 137
    LDY .tapeCurrentFileHandle                          ; get back file handle (preserved through OSBYTE)
    JMP .OSBYTE                                         ; turn on motor

; ***************************************************************************************
;
; Check file is open
;
; On Entry:
;       A = 1 means check file is open for reading (check bit 0 of tape status byte)
;       A = 2 means check file is open for writing (check bit 1 of tape status byte)
;       A = 3 means check file is open for reading or writing
;       Y = file handle ('channel')
;
; On Exit:
;       If file is not open then a 'Channel' error occurs
;
; ***************************************************************************************
.checkFileIsOpen
    STA .fsTempStorage                                  ; remember action type (1-3)
    TYA                                                 ; A=Y=channel:
                                                        ;   1 = input file on tape
                                                        ;   2 = output file on tape
                                                        ;   3 = input file from ROMFS

    EOR .tapeOrROMSwitch                                ; EOR with filing system flag
    TAY                                                 ; Y=A
                                                        ; now, Y = 1 for input
                                                        ;      Y = 2 for output
    LDA .fsStatusByte                                   ; tape / ROM FS status byte
    AND .fsTempStorage                                  ; file status or temporary store
    LSR                                                 ; set carry if open for input
    DEY                                                 ; Y = Y - 1
    BEQ +                                               ; if (checking open for input) then branch
    LSR                                                 ; set carry if open for output
    DEY                                                 ; Y = Y - 1
    BNE .channelError                                   ; if (not checking open for output) then branch
+
    BCS .exit36                                         ; if (file is open as expected) then branch (exit)

.channelError
    BRK                                                 ;
    !byte $DE                                           ; error number
    !text "Channel"                                     ; message
    !byte 0                                             ; terminator

; ***************************************************************************************
; See NAUG Section 18.8, Page 340
.startSendToSecondProcessor
    LDA #1                                              ; A=1 (Multiple single byte transfer:
                                                        ; main processor to second processor)
.secondProcessorTransfer
    JSR .checkLoadAddressIsForSecondProcessor           ; check if load address is valid
    BEQ .exit36                                         ; if (load address is for main processor) then branch (exit)
    TXA                                                 ; A=1
    LDX #<.loadAddressLow                               ; }
    LDY #>.loadAddressLow                               ; } set up parameter block address
.secondProcessorCall
    PHA                                                 ; save A=1 on stack
    LDA #.tubeClaimReasonCode + .tubeCallerIDCassetteFS ; Claim the Tube, caller is the
                                                        ; Cassette Filing System
-
    JSR .tubeTransferData                               ; call out to Tube
    BCC -                                               ; keep trying to claim until claim is done
    PLA                                                 ; pull A=1 (Multiple single byte
                                                        ; transfer: main processor to second
                                                        ; processor)
    JMP .tubeTransferData                               ;

; ***************************************************************************************
;
; Check load address for destination
;
; Check the top two bytes of the 32 bit load address. If they are both $FF, then it is for
; the main processor and we return with Z set. If the Tube is not present, then we also
; return with Z set. Otherwise it's for the Tube, we return with Z clear.
;
; On Exit:
;       Z set if load address is for the second processor
;       X is value of A on entry
;
; ***************************************************************************************
.checkLoadAddressIsForSecondProcessor
    TAX                                                 ; X=A
    LDA .loadAddressMid2                                ; current load address high word
    AND .loadAddressHigh                                ; current load address high word
    CMP #$FF                                            ;
    BEQ +                                               ; if ($FF, i.e. it's for base processor) then branch
    LDA .tubePresentFlag                                ; $FF if Tube is present
    AND #%10000000                                      ; Set bit 7 alone if Tube is present
+
    RTS                                                 ;

; ***************************************************************************************
.setupForCassetteWrite
    LDA #%10000101                                      ; } switch on the cassette motor and relay
    STA .serialULAControlRegister                       ; } and set 300 baud
    JSR .resetACIA                                      ; reset ACIA
    LDA #%00010000                                      ; } even parity
                                                        ; } 2 stop bits
                                                        ; } 8 bit word
                                                        ; } 'Request To Send' ('RTS') low (active)
                                                        ; } disable interrupts
    JSR .setACIA6850ControlRegister                     ; set ACIA to tape filing system baud rate

-
    JSR .checkForEscapeDuringCassetteOperation          ; check for ESCAPE
    LDA .acia6850StatusRegister                         ; read ACIA status register
    AND #%00000010                                      ; check bit 1 (transmit interrupt generated)
    BEQ -                                               ; if (bit 1 clear, i.e. transmit
                                                        ; interrupt generated) then branch
                                                        ; (loop back and try again)

    LDA #%10101010                                      ; A=$AA
    STA .acia6850DataRegister                           ; send byte to tape
                                                        ; [Why? Perhaps this is to
                                                        ;  deliberately break the carrier
                                                        ;  tone, so we can start afresh?]
.exit36
    RTS                                                 ;

    !byte 0                                             ; [unused]

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 22: Credits
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Credits
;
; ***************************************************************************************
; This area of memory from $FC00-$FF00 is the memory mapped IO space, so this memory cannot
; be used as a normal part of the OS. Instead the memory locations store a string of credits.
; For memory mapped I/O, see Chapter 3.
;
;   Herman Hauser       Co-founder of Acorn
;                       Vice-president for research at Olivetti; Co-founder of Olivetti
;                       Research Laboratory in Cambridge; involved with spinning out ARM from
;                       Acorn; Serial entrepreneur; Holds honorary doctorates from three
;                       universities; Serves on educational advisory boards; Fellow of the
;                       Institute of Physics; International Fellow of the Royal Academy of
;                       Engineering; Honorary fellowship of King's College, Cambridge; Patron
;                       of The Centre for Computing History; Awarded the Mountbatten Medal.
;                       Became a Fellow of the Royal Society in 2012.
;                       Awarded the KBE in 2015.
;                       https://en.wikipedia.org/wiki/Hermann_Hauser
;
;   Christopher Curry   Co-founder of Acorn
;                       Sinclair Radionics; co-founded Redwood Publishing and bought Acorn
;                       User; Founded General Information Systems Ltd (GIS) and remains a
;                       director.
;
;                       Led the development of the Atom.
;                       https://en.wikipedia.org/wiki/Christopher_Curry
;
;   Andy Hopper         Co-founder of Acorn
;                       Treasurer and Vice-President of the Royal Society; Professor of
;                       Computer Technology; Former Head of the University of Cambridge
;                       Department of Computer Science and Technology; an Honorary Fellow
;                       of Trinity Hall, Cambridge and Corpus Christi College, Cambridge;
;                       Serial entrepreneur; Awarded CBE in 2006.
;
;                       Head of the University of Cambridge computer lab;
;                       His academic research lead to the Cambridge Ring Interface (Econet);
;                       Contributed to chip designs;
;                       Wrote an Acorn Atom game (a clone of Asteroids);
;                       A qualified pilot with over 6000 hours logged;
;                       Technical director at Olivetti
;                       Became a Fellow of the Royal Society in 2006.
;                       Awarded the CBE in 2007.
;                       https://en.wikipedia.org/wiki/Andy_Hopper
;                       http://news.bbc.co.uk/1/hi/technology/6217447.stm
;
;   Chris Turner        Chief Engineer and Manufacturing; Employee number one;
;                       Owned the overall circuit diagram; Integrated Teletext chip;
;                       Named Fred, Jim, and Sheila; Testing Equipment;
;                       Managed over 200 engineering staff; Product Manager for Domesday
;                       system; Operations Director in the business systems division.
;                       http://www.computinghistory.org.uk/det/40132/Chris-Turner-Acorn-and-the-BBC-Micro/
;                       https://youtu.be/GKHEsp8MYTM?t=1225
;                       https://www.linkedin.com/in/cbturner/?originalSubdomain=uk
;
;   Steve Furber        Principal Hardware Designer; Productionisation;
;                       "I was sort of deputy manager of advanced R&D";
;                       Responsible for the 6502 Second Processor;
;                       Responsible for sorting out the manufacturing troubles with the
;                       Ferranti gate arrays (ULAs);
;                       Went on to lead ARM development;
;                       Wrote a reference model for ARM in BBC BASIC;
;                       ICL Professor of Computer Engineering at the School of Computer
;                       Science at the University of Manchester.
;                       Awarded the CBE in 2008.
;                       https://en.wikipedia.org/wiki/Steve_Furber
;                       https://sounds.bl.uk/Oral-history/Science/021M-C1379X0078XX-0003V0
;
;   Sophie Wilson       (formerly Roger Wilson)
;                       Major architect involved in both software and hardware;
;                       Wrote the BASIC interpreter software for the Atom, the BBC Micro, and
;                       Archimedes;
;                       Wrote the instruction set architecture for the ARM;
;                       Became a Fellow of the Royal Society in 2013.
;                       Awarded the CBE in 2019.
;                       https://en.wikipedia.org/wiki/Sophie_Wilson
;
;   Laurence Hardwick   Network Product Manager (1980-1990)
;                       Management of all aspects of company network product strategy,
;                       product definition, sales forecasting, marketing materials and
;                       marketing events.
;                       https://www.linkedin.com/in/laurencehardwick/?originalSubdomain=uk
;
;   Peter Robinson      Video processor custom design with Jeremy Dion;
;                       Worked for Andy Hopper;
;                       Involved with the Cambridge University computer lab.
;                       Researching and developing computer systems that understand emotions.
;                       https://en.wikipedia.org/wiki/Peter_Robinson_(computer_scientist)
;                       https://www.youtube.com/watch?v=whCJ4NLUSB8
;                       http://www.bbc.co.uk/ahistoryoftheworld/objects/MKG9WQ8WSyasxVeM0Z9T3A
;
;   Jeremy Dion         Video processor custom design with Peter Robinson;
;                       Worked for Andy Hopper;
;                       http://www.bbc.co.uk/ahistoryoftheworld/objects/MKG9WQ8WSyasxVeM0Z9T3A
;
;   Allen Boothroyd     BBC Micro and Atom case and keyboard design. Industrial design for a
;                       number of companies.
;                       https://en.wikipedia.org/wiki/Allen_Boothroyd
;
;   Paul Bond           Led a team of around "30 software developers" that wrote the MOS.
;                       Also led the software team for the Acorn Communicator.
;                       https://stardot.org.uk/forums/viewtopic.php?f=3&t=15786&p=216537&hilit=Paul+Bond#p216537
;                       https://sounds.bl.uk/Oral-history/Science/021M-C1379X0078XX-0003V0
;                       https://en.wikipedia.org/wiki/Acorn_Communicator
;
;   Andrew Cripps       Software Engineer (1981–1983)
;                       Developed operating system software, drivers and supporting utilities
;                       for the BBC Microcomputer and for server operating systems.
;                       https://www.linkedin.com/in/cripps/?originalSubdomain=ca
;
;   Kim Spence-Jones    A consultant for Acorn, worked on the cassette interface software
;                       with Paul Bond; Formed SJ Research which made Econet peripherals.
;                       https://youtu.be/GKHEsp8MYTM?t=1108
;                       https://stardot.org.uk/forums/viewtopic.php?p=6542#p6542
;                       http://www.spencejones.com/Kim_CV_2012.pdf
;
;   Chris Jordan        Acorn Design Team Member
;                       Publications Editor, Acornsoft
;                       Programmed the BBC Micro's sound chip; Designed the Acorn Music 500
;                       and Hybrid Music System.
;                       https://en.wikipedia.org/wiki/Acornsoft
;                       http://www.muzines.co.uk/articles/midi-what-s-wrong-with-it/1398
;                       https://stardot.org.uk/forums/viewtopic.php?f=13&t=7704
;
;   Tim Dobson          Acornsoft programmer
;                       Wrote Monsters, Maze, co-wrote Magic Mushrooms
;                       https://en.wikipedia.org/wiki/Acornsoft
;
;   Martin Jackson      Responsible for the Tube interface?
;                       Founded Tadpole technology
;                       https://youtu.be/GKHEsp8MYTM?t=1162
;
;   Andrew Gordon       "Andrew Gordon I think was responsible for the ECONET component"
;                       https://stardot.org.uk/forums/viewtopic.php?f=3&t=1178&p=6326
;
;   Joe Dunn            Engineering Project Management (1980-1988)
;                       Worked on Econet.
;                       https://www.linkedin.com/in/joeddunn/
;
;   Arthur Norman       Norcroft C Compiler; Lisp on the BBC Micro; Functional programming;
;                       Fellow of Trinity College, Cambridge; Former Director of Studies for
;                       Computer Science at Trinity College, Cambridge
;                       https://en.wikipedia.org/wiki/Arthur_Norman_(computer_scientist)
;
;   Jon Thackray        Co-wrote Acheton (with David Seal and Jonathan Partington)
;                       Wrote early test programs for the ARM
;
;   Ram Banerjee        (Ramanuj Banerjee)
;                       Wire wrapped the prototype machine to show the BBC.
;                       https://youtu.be/GKHEsp8MYTM?t=1895
;
;   Dylan Harris        Programmer (Jul 1981–Sep 1981)
;                       As a summer job helped finish a 6502 Assembler, used to build the MOS.
;                       https://dylanharris.org/blog/1981/b1.shtml
;                       https://www.linkedin.com/in/devongarde/?originalSubdomain=lu
;
;   John Cox            As a school pupil, as a summer job, wrote tools that helped design the
;                       Electron ULA; Author of Computer Concepts Snake.
;                       http://bbcmicro.co.uk/game.php?id=682
;                       https://stardot.org.uk/forums/viewtopic.php?f=3&t=13806&p=181329&hilit=John+Cox#p181329
;
;   Brian Jones         Wrote Advanced Graphics with the Acorn Electron;
;                             Advanced Graphics with the BBC Model B Microcomputer
;                       https://link.springer.com/book/10.1007/978-1-349-07340-5
;
;   From the BBC
;   ------------
;   John Radcliffe      Executive Producer, BBC Computer Literacy Project
;                       https://www.theregister.co.uk/Print/2008/03/20/ft_bbc_micro/
;                       https://clp.bbcrewind.co.uk/aef4287b5161099b147d9c4a75f9c1d3
;
;   David Allen         Project Leader, BBC Computer Literacy Project; Producer of the BBC TV
;                       show Micro Live, Making the Most of the Micro; Edited the User Guide;
;                       Commissioned the Welcome Tape, which led to the need to control the
;                       tape motor.
;                       https://www.theregister.co.uk/Print/2008/03/20/ft_bbc_micro/
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;                       https://clp.bbcrewind.co.uk/aef4287b5161099b147d9c4a75f9c1d3
;
;   John Coll           Primary author of the User Guide ('for which he received £150,000');
;                       wrote initial functional description of the BBC Micro; wrote for
;                       Personal Computer World; Worked on the Micro Live programme.
;                       Ended up working for Acorn as an employee.
;                       https://en.wikipedia.org/wiki/John_Coll
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;
;   David Kitson        Design Engineering Manager
;                       Worked with Richard Russell; Liaised with Chris Turner to track
;                       progress, reported to John Radcliffe.
;                       https://clp.bbcrewind.co.uk/4412a4e642f6bc04b47f09ec7953a6bf
;
;   David King          The BBC's cassette and ROM filing system expert. Tested the
;                       functionality. Worked under David Kitson.
;                       https://stardot.org.uk/forums/viewtopic.php?p=216681#p216681
;                       https://stardot.org.uk/forums/viewtopic.php?p=216639#p216639
;
;   Richard Russell     Design engineer at the BBC; 'Led the BBC's efforts'; Specification of
;                       BBC BASIC, working with Sophie Wilson; helped with the BBC User Guide;
;                       Domesday Project; BBC BASIC for Windows; Television 'Chroma dot'
;                       colour recovery system.
;                       https://en.wikipedia.org/wiki/Richard_T._Russell
;                       http://www.rtrussell.co.uk
;
;   Paul Kriwaczek      Producer 'The Computer Programme', BBC Computer Literacy Project;
;                       Dialogue Coach; Dentist to the Afghan royal family; Programmes on
;                       Yiddish and Islamic history and culture.
;                       https://en.wikipedia.org/wiki/Paul_Kriwaczek
;                       https://www.independent.co.uk/news/obituaries/paul-kriwaczek-bbc-tv-producer-and-author-of-engaging-books-on-the-ancient-world-2266387.html
;
;   Other
;   -----
;   6502 designers      Chuck Peddle, Rod Orgill, and Wil Mathys
;                       https://en.wikipedia.org/wiki/MOS_Technology_6502#Design_notes
;
;   Hitachi             supplied DRAM chips
;                       https://youtu.be/GKHEsp8MYTM?t=1816
;
;   Ferranti            made the custom ULAs for Acorn
;
;   ICL and Cleartone   Manufacturers
;                       According to Acorn User issue 1 - July/Aug 1982: "Acorn currently
;                       use two manufacturing plants in the UK. ICL at Kidsgrove are largely
;                       responsible for manufacturing the model B and Cleartone in Gwent for
;                       model A computers. Cleartone have recently been taken over by AB
;                       Electronics. A third UK plant is starting production of both models
;                       this month."
;                       https://archive.org/details/Acorn_User_Number_001_1982-08_Adn-Wesley_GB/page/n5/mode/2up
;
;   Cambridge           Home of Acorn; University town in Cambridgeshire, England
;                       https://en.wikipedia.org/wiki/Cambridge
;
;   Computer Laboratory Academic department within the University of Cambridge
;                       https://www.cl.cam.ac.uk
;
;   Wilberforce Road    A road in Cambridge. The maths building wasn't there back in the day,
;                       so possibly listed for its sports facilities?
;                       https://map.cam.ac.uk/Wilberforce+Road#52.209604,0.100091,17
;
;   Unknown
;   -------
;   Bob Austin          Speculatively could have been part of the motherboard design team
;                       since "Bob's board" is printed on the motherboard, underneath the
;                       6502 chip.
;                       https://stardot.org.uk/forums/viewtopic.php?p=20687#p20687
;   Paul Farrell
;   Jon Gibbons
;   Lawrence Hardwick
;   Peter Miller
;   Glyn Phillips
;   Mike Prees
;   Graham Tebby        Possibly https://www.linkedin.com/in/graham-tebby-93a7208/?originalSubdomain=uk
;                       But not really much detail.
;   Adrian Warner
;   Alan Wright

    !text "(C) 1981 Acorn Computers Ltd.Thanks are due to the following contributors to "
    !text "the development of the BBC Computer (among others too numerous to mention):- "
    !text "David Allen,Bob Austin,Ram Banerjee,Paul Bond,Allen Boothroyd,Cambridge,"
    !text "Cleartone,John Coll,John Cox,Andy Cripps,Chris Curry,6502 designers,"
    !text "Jeremy Dion,Tim Dobson,Joe Dunn,Paul Farrell,Ferranti,Steve Furber,Jon Gibbons,"
    !text "Andrew Gordon,Lawrence Hardwick,Dylan Harris,Hermann Hauser,Hitachi,Andy Hopper,"
    !text "ICL,Martin Jackson,Brian Jones,Chris Jordan,David King,David Kitson,"
    !text "Paul Kriwaczek,Computer Laboratory,Peter Miller,Arthur Norman,Glyn Phillips,"
    !text "Mike Prees,John Radcliffe,Wilberforce Road,Peter Robinson,Richard Russell,"
    !text "Kim Spence-Jones,Graham Tebby,Jon Thackray,Chris Turner,Adrian Warner,"
    !text "Roger Wilson,Alan Wright."
    !word .resetEntryPoint                              ; [unused]


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 23: Extended vectors
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; Extended Vector Entry Points
;
; ***************************************************************************************
; See NAUG Section 17.4.3 - Extended Vectors, Page 312
;
; There is a mechanism by which Paged ROMs can intercept the standard vectors at $0200
; upwards, instead getting them to point to a specific address *in a specified ROM*.
;
; To intercept vector N:
;
;   - Disable interrupts during this change over
;   - Get memory base address (call it V) using OSBYTE 168
;           (V is address '.extendedVectorSpace' in this particular version of the ROM)
;   - Store desired ROM address for routine at the two byte starting at V+3*N
;   - Store desired ROM number in the following byte
;   - Make a copy of the original contents of the vector at $0200+2*N if needed
;   - Store the address '$FF00+3*N' in OS vector at '$0200+2*N'
;
.extendedVectorTable
    JSR .extendedVectorEntryPoint                       ; E_USERV
    JSR .extendedVectorEntryPoint                       ; E_BRKV
    JSR .extendedVectorEntryPoint                       ; E_IRQ1V
    JSR .extendedVectorEntryPoint                       ; E_IRQ2V
    JSR .extendedVectorEntryPoint                       ; E_CLIV
    JSR .extendedVectorEntryPoint                       ; E_BYTEV
    JSR .extendedVectorEntryPoint                       ; E_WORDV
    JSR .extendedVectorEntryPoint                       ; E_WRCHV
    JSR .extendedVectorEntryPoint                       ; E_RDCHV
    JSR .extendedVectorEntryPoint                       ; E_FILEV
    JSR .extendedVectorEntryPoint                       ; E_ARGSV
    JSR .extendedVectorEntryPoint                       ; E_BGETV
    JSR .extendedVectorEntryPoint                       ; E_BPUTV
    JSR .extendedVectorEntryPoint                       ; E_GBPBV
    JSR .extendedVectorEntryPoint                       ; E_FINDV
    JSR .extendedVectorEntryPoint                       ; E_FSCV
    JSR .extendedVectorEntryPoint                       ; E_EVENTV
    JSR .extendedVectorEntryPoint                       ; E_UPTV
    JSR .extendedVectorEntryPoint                       ; E_NETV
    JSR .extendedVectorEntryPoint                       ; E_VDUV
    JSR .extendedVectorEntryPoint                       ; E_KEYV
    JSR .extendedVectorEntryPoint                       ; E_INSV
    JSR .extendedVectorEntryPoint                       ; E_REMV
    JSR .extendedVectorEntryPoint                       ; E_CNPV
    JSR .extendedVectorEntryPoint                       ; E_IND1V
    JSR .extendedVectorEntryPoint                       ; E_IND2V
    JSR .extendedVectorEntryPoint                       ; E_IND3V

; ***************************************************************************************
.extendedVectorEntryPoint
    PHA                                                 ; save A on stack - make space for currently selected ROM (address '$109,X' in code below)
    PHA                                                 ; save A on stack - make space for return address low     (address '$108,X' in code below)
    PHA                                                 ; save A on stack - make space for return address high    (address '$107,X' in code below)
    PHA                                                 ; save A on stack - make space for ROM address low        (address '$106,X' in code below)
    PHA                                                 ; save A on stack - make space for ROM address high       (address '$105,X' in code below)

    PHP                                                 ; }
    PHA                                                 ; }
    TXA                                                 ; } save Flags,A,X,Y to the stack
    PHA                                                 ; }
    TYA                                                 ; }
    PHA                                                 ; }
    TSX                                                 ; get stack pointer into X

    LDA #>(.returnFromROM-1)                            ; }
    STA .stackPage + 8,X                                ; }
    LDA #<(.returnFromROM-1)                            ; } store return address in the stack (the .returnFromROM routine below)
    STA .stackPage + 7,X                                ; }

    LDY .stackPage + 10,X                               ; Y=3*N+2 (low byte of caller address)
    LDA .extendedVectorSpace-2,Y                        ; get low byte of action address
    STA .stackPage + 5,X                                ; store it on stack
    LDA .extendedVectorSpace-1,Y                        ; get high byte of action address
    STA .stackPage + 6,X                                ; store it on stack
    LDA .currentlySelectedROM                           ; get the current ROM number
    STA .stackPage + 9,X                                ; store it on stack
    LDA .extendedVectorSpace,Y                          ; get new ROM number
    STA .currentlySelectedROM                           ; store RAM copy of current ROM
    STA .romSelectRegister                              ; switch the ROM into the memory map
    PLA                                                 ; }
    TAY                                                 ; }
    PLA                                                 ; } Restore Y,X,A from stack
    TAX                                                 ; }
    PLA                                                 ; }

    RTI                                                 ; the RTI instruction restores the
                                                        ; flags, and jumps to the (ROM)
                                                        ; address we've put on the stack.
                                                        ; i.e. this jumps to the ROM routine.
                                                        ; When that returns, the address on
                                                        ; the stack jumps us to the routine
                                                        ; below.

; ***************************************************************************************
;
; Return from ROM
;
; Once the ROM routine from above is finished, the return address takes us here, which restores
; the registers and returns to the proper calling routine.
;
.returnFromROM
    PHP                                                 ; }
    PHA                                                 ; }
    TXA                                                 ; } save Flags,A,X to the stack
    PHA                                                 ; }
    TSX                                                 ;
    LDA .stackPage + 2,X                                ; }
    STA .stackPage + 5,X                                ; }
    LDA .stackPage + 3,X                                ; } store real return address onto stack (ready for RTS)
    STA .stackPage + 6,X                                ; }

    PLA                                                 ; }
    TAX                                                 ; } recall X
    PLA                                                 ; recall A - lose these 2 bytes. They are the address of this routine.
    PLA                                                 ; recall A - lose these 2 bytes. They are the address of this routine.
    PLA                                                 ; get back A (original ROM number)
    STA .currentlySelectedROM                           ; store it as RAM copy of current ROM number
    STA .romSelectRegister                              ; switch the ROM into the memory map

    PLA                                                 ; get back A
    PLP                                                 ; get back flags
.return
    RTS                                                 ; return (pulls real return address from stack)


; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 24: OS entry points; Tube; FRED; JIM; SHEILA
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE 157 - Fast Tube BPUT
;
; By default this uses the standard OSBPUT routine.
;
; ***************************************************************************************
.osbyte157EntryPoint
    TXA                                                 ; A=X
    BCS .OSBPUT                                         ; ALWAYS branch

; ***************************************************************************************
;
; OSBYTE 146 - Read a byte from FRED
;
; ***************************************************************************************
.osbyte146EntryPoint
    LDY .fredPage,X                                     ; read a byte from FRED area
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 148 - Read a byte from JIM
;
; ***************************************************************************************
.osbyte148EntryPoint
    LDY .jimPage,X                                      ; read a byte from JIM area
    RTS                                                 ;

; ***************************************************************************************
;
; OSBYTE 150 - Read a byte from SHEILA
;
; ***************************************************************************************
.osbyte150EntryPoint
    LDY .sheilaPage,X                                   ; read a byte from SHEILA area
    RTS                                                 ;

; ***************************************************************************************
;
; Unused default vector table pointer
;
; This may have been intended for user programs to be able to read the default handler
; addresses, but is not documented, and is not used by the ROM. New in MOS 1.20.
;
; ***************************************************************************************
    !byte .defaultVectorTableEnd - .defaultVectorTable  ; length of table         [unused]
    !word .defaultVectorTable                           ; table of addresses - the
                                                        ; default vector routines [unused]

; ***************************************************************************************
;
; Operating System function calls
;
; Historical note: The Acorn System 2 began the practice of placing entry points like
; these at the high end of the ROM, (mostly) spaced three bytes apart so that each can
; jump directly back into the ROM or through a vector, and still be called as if they
; were subroutines. This practice protected user programs from breaking when the MOS was
; revised, since it meant there were reliable addresses to call. Though System 2, and
; similarly the Atom, have a slightly smaller set of entry points, so addresses are not
; the same (OSWRCH is at $FFF4 on the System 2 and Atom, not $FFEE as here), the basic
; design is identical. System 2 and the Atom both perform the CR/LF manoeuvre below in
; which OSASCI, OSNEWL and OSWRCH are combined.
;
; ***************************************************************************************
.OSRDRM
    JMP .osrdrmEntryPoint                               ; get a byte from sideways ROM [new in MOS 1.20]
.VDUCHR
    JMP .vduChrEntryPoint                               ; output a character to screen
.OSEVEN
    JMP .eventEntryPoint                                ; generate an EVENT
.GSINIT
    JMP .gsinitEntryPoint                               ; initialise for parsing a string
.GSREAD
    JMP .gsreadEntryPoint                               ; parse character from string
.NVRDCH
    JMP .osrdchEntryPoint                               ; non vectored .OSRDCH
.NVWRCH
    JMP .oswrchEntryPoint                               ; non vectored .OSWRCH
.OSFIND
    JMP (.vectorFINDV)                                  ; open or close a file
.OSGBPB
    JMP (.vectorGBPBV)                                  ; transfer data to or from a file
.OSBPUT
    JMP (.vectorBPUTV)                                  ; save a byte to file
.OSBGET
    JMP (.vectorBGETV)                                  ; get a byte from file
.OSARGS
    JMP (.vectorARGSV)                                  ; read or write file arguments
.OSFILE
    JMP (.vectorFILEV)                                  ; read or write a file
.OSRDCH
    JMP (.vectorRDCHV)                                  ; get byte from current input stream
.OSASCI
    CMP #.charRETURN                                    ; output byte, expanding carriage
    BNE .OSWRCH                                         ; returns to CR/LF ($0A,$0D)
.OSNEWL
    LDA #.charLINEFEED                                  ; output a CR/LF to VDU stream
    JSR .OSWRCH                                         ;
    LDA #.charRETURN                                    ;
.OSWRCH
    JMP (.vectorWRCHV)                                  ; output a character (to the screen
                                                        ; and/or other output streams)
.OSWORD
    JMP (.vectorWORDV)                                  ; perform operation with data from
                                                        ; a parameter table
.OSBYTE
    JMP (.vectorBYTEV)                                  ; perform operation with three
                                                        ; parameters <A>,<X>,<Y>
                                                        ; (equivalent to BASIC's *FX command)
.OSCLI
    JMP (.vectorCLIV)                                   ; pass string to command line
                                                        ; interpreter


; ***************************************************************************************
;
; 6502 Vectors
;
; See 6502.png
;
; Finally the last 6 bytes are designated (by the design of the 6502 chip) to contain the
; addresses of the routines that handle an NMI, a RESET and an IRQ condition.
;
; ***************************************************************************************
* = $FFFA
    !word .nmiEntryPoint                                ; NMI   address
    !word .resetEntryPoint                              ; RESET address
    !word .irqEntryPoint                                ; IRQ   address

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 25: Appendix
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; 'Broader horizons' advertisement
;
; See AU6-Jan83P66.png
;
; ***************************************************************************************

; ***************************************************************************************
;
; Circuit diagrams in vector format
;
; Circuit diagram for the motherboard, see CircuitDiagram.pdf
; Circuit diagram for the keyboard, see CircuitKeyboard.pdf
;
; ***************************************************************************************

; ***************************************************************************************
; ***************************************************************************************
;
; Chapter 26: Index
;
; ***************************************************************************************
; ***************************************************************************************

; ***************************************************************************************
;
; OSWRCH
;
; This is the 'VDU' command in BBC BASIC. The non-printable characters are handled by
; individual routines. See .oswrchEntryPoint
;
; VDU   0    - Does nothing                                   See .vdu0EntryPoint
; VDU   1    - Send next character to printer only            See .vdu1EntryPoint
; VDU   2    - Enable printer                                 See .vdu2EntryPoint
; VDU   3    - Disable printer                                See .vdu3EntryPoint
; VDU   4    - Write text at text cursor                      See .vdu4EntryPoint
; VDU   5    - Write text at graphics cursor                  See .vdu5EntryPoint
; VDU   6    - Enable VDU drivers                             See .vdu6EntryPoint
; VDU   7    - Make a short beep                              See .vdu7EntryPoint
; VDU   8    - Move cursor left                               See .vdu8EntryPoint
; VDU   9    - Move cursor right                              See .vdu9EntryPoint
; VDU  10    - Move cursor down                               See .vdu10EntryPoint
; VDU  11    - Move cursor up                                 See .vdu11EntryPoint
; VDU  12    - Clear text window                              See .vdu12EntryPoint
; VDU  13    - Move cursor to start of current line           See .vdu13EntryPoint
; VDU  14    - Paged mode on                                  See .vdu14EntryPoint
; VDU  15    - Paged mode off                                 See .vdu15EntryPoint
; VDU  16    - Clear graphics window                          See .vdu16EntryPoint
; VDU  17    - Define text colour                             See .vdu17EntryPoint
; VDU  18    - Define graphics colour                         See .vdu18EntryPoint
; VDU  19    - Change palette colour                          See .vdu19EntryPoint
; VDU  20    - Restore default palette                        See .vdu20EntryPoint
; VDU  21    - Disable VDU drivers / delete line              See .vdu21EntryPoint
; VDU  22    - Select screen MODE                             See .vdu22EntryPoint
; VDU  23    - Define character shape (etc)                   See .vdu23EntryPoint
; VDU  24    - Define graphics window                         See .vdu24EntryPoint
; VDU  25    - PLOT                                           See .vdu25EntryPoint
; VDU  26    - Restore default windows                        See .vdu26EntryPoint
; VDU  27    - Does nothing                                   See .vdu27EntryPoint
; VDU  28    - Define text window                             See .vdu28EntryPoint
; VDU  29    - Define graphics origin                         See .vdu29EntryPoint
; VDU  30    - Move text cursor to top left                   See .vdu30EntryPoint
; VDU  31    - Move text cursor to X,Y                        See .vdu31EntryPoint
; VDU 127    - Delete                                         See .vdu127EntryPoint
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSBYTE
;
; See .osbyteEntryPoint
;
; OSBYTE   0 - Display version number                       See .osbyte0EntryPoint
; OSBYTE   1 - Read/Write user flag                         See .osbyte1EntryPoint
; OSBYTE   2 - select input stream                          See .osbyte2EntryPoint
; OSBYTE   3 - Select output stream                         See .osbyte3EntryPoint
; OSBYTE   4 - Enable / disable cursor editing              See .osbyte4EntryPoint
; OSBYTE   5 - Select printer type                          See .osbyte5EntryPoint
; OSBYTE   6 - Set printer ignore character                 See .osbyte6EntryPoint
; OSBYTE   7 - Set RS-423 baud rate for receiving data      See .osbyte7EntryPoint
; OSBYTE   8 - Set RS-423 baud rate for transmitting data   See .osbyte8EntryPoint
; OSBYTE   9 - Duration of first colour                     See .osbyte9EntryPoint
; OSBYTE  10 - Duration of second colour                    See .osbyte10EntryPoint
; OSBYTE  11 - Set keyboard autorepeat delay                See .osbyte11EntryPoint
; OSBYTE  12 - Set keyboard autorepeat rate                 See .osbyte12EntryPoint
; OSBYTE  13 - Disable events                               See .osbyte13EntryPoint
; OSBYTE  14 - Enable events                                See .osbyte14EntryPoint
; OSBYTE  15 - Flush selected buffer class                  See .osbyte15EntryPoint
; OSBYTE  16 - Select ADC channels                          See .osbyte16EntryPoint
; OSBYTE  17 - Start ADC conversions                        See .osbyte17EntryPoint
; OSBYTE  18 - Reset soft keys                              See .osbyte18EntryPoint
; OSBYTE  19 - Wait for vertical sync                       See .osbyte19EntryPoint
; OSBYTE  20 - 'Explode' soft character definitions         See .osbyte20EntryPoint
; OSBYTE  21 - Flush specific buffer                        See .osbyte21EntryPoint
;
; OSBYTEs 22-116 are undefined
;
; OSBYTE 117 - Read VDU status                              See .osbyte117EntryPoint
; OSBYTE 118 - Set keyboard LEDs based on keyboard status   See .osbyte118EntryPoint
; OSBYTE 119 - Close Spool / Exec files                     See .osbyte119EntryPoint
; OSBYTE 120 - Write key pressed data                       See .osbyte120EntryPoint
; OSBYTE 121 - Keyboard scan from value in X                See .osbyte121EntryPoint
; OSBYTE 122 - Keyboard scan from 16 decimal                See .osbyte122EntryPoint
; OSBYTE 123 - Warn OS about printer going dormant          See .osbyte123EntryPoint
; OSBYTE 124 - Clear ESCAPE condition                       See .osbyte124EntryPoint
; OSBYTE 125 - Set ESCAPE condition                         See .osbyte125EntryPoint
; OSBYTE 126 - Acknowledge detection of ESCAPE condition    See .osbyte126EntryPoint
; OSBYTE 127 - Check for EOF on open file                   See .osbyte127EntryPoint
; OSBYTE 128 - Read ADC Channel / get buffer status         See .osbyte128EntryPoint
; OSBYTE 129 - Read key within time limit                   See .osbyte129EntryPoint
; OSBYTE 130 - Read machine high order address              See .osbyte130EntryPoint
; OSBYTE 131 - Read OSHWM (OS High Water Mark)              See .osbyte131EntryPoint
; OSBYTE 132 - Read HIMEM (start of screen memory)          See .osbyte132EntryPoint
; OSBYTE 133 - Read start of screen memory for given MODE   See .osbyte133EntryPoint
; OSBYTE 134 - Read text cursor position                    See .osbyte134EntryPoint
; OSBYTE 135 - Read character at text cursor position       See .osbyte135EntryPoint
; OSBYTE 136 - Execute code via User Vector (*CODE)         See .osbyte136EntryPoint
; OSBYTE 137 - Turn on tape motor                           See .osbyte137EntryPoint
; OSBYTE 138 - Put byte into buffer                         See .osbyte138EntryPoint
; OSBYTE 139 - Select file options (*OPT)                   See .osbyte139EntryPoint
; OSBYTE 140 - Select TAPE file system                      See .osbyte140EntryPoint
; OSBYTE 141 - Select ROM file system                       See .osbyte141EntryPoint
; OSBYTE 142 - Enter language ROM (at $8000)                See .osbyte142EntryPoint
; OSBYTE 143 - Pass service commands to sideways ROMs       See .osbyte143EntryPoint
; OSBYTE 144 - *TV                                          See .osbyte144EntryPoint
; OSBYTE 145 - Get byte from buffer                         See .osbyte145EntryPoint
; OSBYTE 146 - Read a byte from FRED                        See .osbyte146EntryPoint
; OSBYTE 147 - Write a byte to FRED                         See .osbyte147EntryPoint
; OSBYTE 148 - Read a byte from JIM                         See .osbyte148EntryPoint
; OSBYTE 149 - Write a byte to JIM                          See .osbyte149EntryPoint
; OSBYTE 150 - Read a byte from SHEILA                      See .osbyte150EntryPoint
; OSBYTE 151 - Write a byte to SHEILA                       See .osbyte151EntryPoint
; OSBYTE 152 - Examine buffer status                        See .osbyte152EntryPoint
; OSBYTE 153 - Put byte in input buffer                     See .osbyte153EntryPoint
; OSBYTE 154 - Write to Video ULA's Video Control Register  See .osbyte154EntryPoint
; OSBYTE 155 - Set palette value                            See .osbyte155EntryPoint
; OSBYTE 156 - Update ACIA Control Register and OS Copy     See .osbyte156EntryPoint
; OSBYTE 157 - Fast Tube BPUT                               See .osbyte157EntryPoint
; OSBYTE 158 - Read byte from speech processor              See .osbyte158EntryPoint
; OSBYTE 159 - Write byte to speech processor               See .osbyte159EntryPoint
; OSBYTE 160 - Read VDU Variable                            See .osbyte160EntryPoint
;
; OSBYTEs 161-165 are undefined.
;
; OSBYTEs 166-255 affect MOS variables (bytes $0236-$028F respectively). They are handled
; by one routine, see .osbyte166to255EntryPoint.
;
; OSBYTE 166 - Address of MOS variables - 166 (Low byte)    See .mosVariables
; OSBYTE 167 - Address of MOS variables - 166 (High byte)   See .mosVariables
; OSBYTE 168 - Address of extended vector space (Low byte)  See .romPointerTable
; OSBYTE 169 - Address of extended vector space (High byte) See .romPointerTable
; OSBYTE 170 - Address of table of type of each ROM (Low)   See .romInformationTable
; OSBYTE 171 - Address of table of type of each ROM (High)  See .romInformationTable
; OSBYTE 172 - Address of keyboard translation table (Low)  See .keyTranslationTable
; OSBYTE 173 - Address of keyboard translation table (High) See .keyTranslationTable
; OSBYTE 174 - Address of VDU variables (Low byte)          See .vduVariablesTable
; OSBYTE 175 - Address of VDU variables (High byte)         See .vduVariablesTable
; OSBYTE 176 - Vertical sync counter                        See .verticalSyncCounter
; OSBYTE 177 - Current input buffer                         See .currentInputBuffer
; OSBYTE 178 - Process keyboard under interrupt flag        See .enableKeyboardInterruptProcessingFlag
; OSBYTE 179 - Default/Primary High Water Mark (OSHWM)      See .defaultOSHWM
; OSBYTE 180 - Current High Water Mark (OSHWM)              See .currentOSHWM
; OSBYTE 181 - RS-423 mode                                  See .rs423Mode
; OSBYTE 182 - Soft character definition ranges             See .softCharacterDefinitionsSwitch
; OSBYTE 183 - Tape or ROM Filing System active             See .tapeOrROMSwitch
; OSBYTE 184 - OS copy of the Video ULA VCR register        See .videoULAVideoControlRegisterCopy
; OSBYTE 185 - Last value written to palette                See .videoULAPaletteValue
; OSBYTE 186 - ROM number from last BRK                     See .romNumberActiveLastBRK
; OSBYTE 187 - ROM number containing BASIC                  See .basicROMNumber
; OSBYTE 188 - Current ADC channel number                   See .adcCurrentChannel
; OSBYTE 189 - Maximum ADC channel number                   See .maximumADCChannelNumber
; OSBYTE 190 - ADC Conversion type                          See .adcConversionType
; OSBYTE 191 - RS_423 ready flag                            See .rs423ReadyFlag
; OSBYTE 192 - OS copy of the RS-423 control flag           See .rs423ControlRegisterCopy
; OSBYTE 193 - Countdown timer for flashing colours         See .videoULAFlashingColourIntervalCount
; OSBYTE 194 - First colour time interval                   See .videoULAFirstFlashingColourInterval
; OSBYTE 195 - Second colour time interval                  See .videoULASecondFlashingColourInterval
; OSBYTE 196 - Delay before autorepeat                      See .keyboardAutoRepeatDelay
; OSBYTE 197 - Keyboard autorepeat rate                     See .keyboardAutoRepeatRate
; OSBYTE 198 - File handle of open EXEC file                See .execFileHandle
; OSBYTE 199 - File handle of open SPOOL file               See .spoolFileHandle
; OSBYTE 200 - Escape and break effect                      See .escapeAndBreakEffect
; OSBYTE 201 - Keyboard disable flag                        See .keyboardDisableFlag
; OSBYTE 202 - Keyboard modifier keys status                See .keyboardStatusFlags
; OSBYTE 203 - RS-423 handshake extent                      See .rs423HandshakeExtent
; OSBYTE 204 - RS-423 input suppression flag                See .rs423InputSuppressionFlag
; OSBYTE 205 - Tape or RS-423 selection                     See .tapeRS423SelectionFlag
; OSBYTE 206 - Econet intercept for OSBYTE 166-255 / OSWORD 224-255 See .econetOSCallInterceptionFlag
; OSBYTE 207 - Read character from Econet flag              See .econetReadCharacterInterceptionFlag
; OSBYTE 208 - Write character to Econet flag               See .econetWriteCharacterInterceptionFlag
; OSBYTE 209 - Enable or disable speech                     See .speechSuppressionStatus
; OSBYTE 210 - Disable sound flag                           See .soundDisableFlag
; OSBYTE 211 - Channel for BELL                             See .soundBELLChannel
; OSBYTE 212 - Amplitude or Envelope for BELL               See .soundBELLAmplitudeEnvelope
; OSBYTE 213 - Pitch for BELL                               See .soundBELLPitch
; OSBYTE 214 - Duration for BELL                            See .soundBELLDuration
; OSBYTE 215 - Startup options                            See .startupMessageSuppressionAndBootOptions
; OSBYTE 216 - Length of *KEY string being decoded          See .softKeyStringLength
; OSBYTE 217 - Paged mode line count                        See .pagedModeCounter
; OSBYTE 218 - Bytes in VDU queue                         See .twosComplimentOfNumberOfBytesInVDUQueue
; OSBYTE 219 - ASCII code to produce when TAB pressed       See .asciiCodeGeneratedByTABKey
; OSBYTE 220 - ASCII code that generates ESCAPE condition   See .asciiCodeThatGeneratesESCAPEAction
; OSBYTE 221-228 - How to interpret special keys            See .functionAndCursorKeyCodes
; OSBYTE 229 - ESCAPE action                                See .escapeAction
; OSBYTE 230 - ESCAPE effects                               See .escapeEffects
; OSBYTE 231 - User VIA IRQ bit mask                        See .userVIAIRQBitMask
; OSBYTE 232 - RS-423 IRQ bit mask                          See .rs423IRQBitMask
; OSBYTE 233 - System VIA IRQ bit mask                      See .systemVIAIRQBitMask
; OSBYTE 234 - Tube present flag                            See .tubePresentFlag
; OSBYTE 235 - Speech system present flag                   See .speechSystemPresentFlag
; OSBYTE 236 - Character destination availability           See .characterDestinationsAvailableFlags
; OSBYTE 237 - Cursor editing type                          See .cursorEditingType
; OSBYTE 238 - Unused byte                                  See .unused27E
; OSBYTE 239 - Unused byte                                  See .unused27F
; OSBYTE 240 - Country code                                 See .countryCode
; OSBYTE 241 - User flag                                    See .userFlag
; OSBYTE 242 - Serial ULA register copy                     See .serialULARegisterCopy
; OSBYTE 243 - Time clock switch                            See .timeClockSwitch
; OSBYTE 244 - Soft key consistency flag                    See .softKeyConsistencyFlag
; OSBYTE 245 - Printer destination                          See .printerDestination
; OSBYTE 246 - Printer character to ignore                  See .printerIgnoreCharacter
; OSBYTE 247 - Break intercept JMP instruction              See .breakInterceptJMPInstruction
; OSBYTE 248 - Break intercept address (low)                See .breakInterceptLowAddress
; OSBYTE 249 - Break intercept address (high)               See .breakInterceptHighAddress
; OSBYTE 250 - Unused byte                                  See .unused28A
; OSBYTE 251 - Unused byte                                  See .unused28B
; OSBYTE 252 - Current language ROM number                  See .languageROMNumber
; OSBYTE 253 - Last reset type                              See .lastResetType
; OSBYTE 254 - System available RAM                         See .systemAvailableRAM
; OSBYTE 255 - Startup options                              See .startUpOptions
;
; ***************************************************************************************

; ***************************************************************************************
;
; OSWORD
;
; See .oswordEntryPoint
;
; OSWORD   0 - Read line from current input into memory     See .osword0EntryPoint
; OSWORD   1 - Read system clock                            See .osword1EntryPoint
; OSWORD   2 - Write system clock                           See .osword2EntryPoint
; OSWORD   3 - Read interval timer                          See .osword3EntryPoint
; OSWORD   4 - Write interval timer                         See .osword4EntryPoint
; OSWORD   5 - Read a byte from I/O memory                  See .osword5EntryPoint
; OSWORD   6 - Write a byte to I/O memory                   See .osword6EntryPoint
; OSWORD   7 - Make a sound                                 See .osword7EntryPoint
; OSWORD   8 - Define an envelope                           See .osword8EntryPoint
; OSWORD   9 - Read a pixel                                 See .osword9EntryPoint
; OSWORD  10 - Read character definition                    See .osword10EntryPoint
; OSWORD  11 - Read palette                                 See .osword11EntryPoint
; OSWORD  12 - Write palette                                See .osword12EntryPoint
; OSWORD  13 - Read last two graphic cursor positions       See .osword13EntryPoint
;
; OSWORDs 14-255 are undefined.
; OSWORDs 224-255 are routed through USERV.
;
; ***************************************************************************************

; ***************************************************************************************
;
; OS Entry Points
;
; OS Call       Vector             Default handler         Description
; ---------------------------------------------------------------------------------------
; See .GSINIT   -                  See .gsinitEntryPoint   Initialise for parsing a string
; See .GSREAD   -                  See .gsreadEntryPoint   Parse a character from string
; See .NVRDCH   -                  See .osrdchEntryPoint   Non-vectored .OSRDCH
; See .NVWRCH   -                  See .oswrchEntryPoint   Non-vectored .OSWRCH
; See .OSARGS   See .vectorARGSV   See .osargsEntryPoint   Read or write file arguments
; See .OSASCI   -                  See .OSASCI             Output byte, expanding CR
; See .OSBGET   See .vectorBGETV   See .osbgetEntryPoint   Get a byte from file
; See .OSBPUT   See .vectorBPUTV   See .osbputEntryPoint   Save a byte to file
; See .OSBYTE   See .vectorBYTEV   See .osbyteEntryPoint   OS call with A,X,Y parameters
; See .OSCLI    See .vectorCLIV    See .oscliEntryPoint    Execute star command string
; See .OSEVEN   -                  See .eventEntryPoint    Generate an EVENT
; See .OSFILE   See .vectorFILEV   See .osfileEntryPoint   Read or write a file
; See .OSFIND   See .vectorFINDV   See .osfindEntryPoint   Open or close a file
; See .OSGBPB   See .vectorGBPBV   -                       Transfer block to or from a file
; See .OSNEWL   -                  See .OSNEWL             Output CR/LF
; See .OSRDCH   See .vectorRDCHV   See .osrdchEntryPoint   Get byte from current input stream
; See .OSRDRM   -                  See .osrdrmEntryPoint   Get a byte from sideways ROM
; See .OSWORD   See .vectorWORDV   See .oswordEntryPoint   OS call with parameter block
; See .OSWRCH   See .vectorWRCHV   See .oswrchEntryPoint   Output a character
; See .VDUCHR   -                  See .vduChrEntryPoint   Output a character to screen
;
; ***************************************************************************************

; ***************************************************************************************
;
; Vectors
;
; Vector              Address   Default handler          Description
; ---------------------------------------------------------------------------------------
; See .vectorARGSV    $0214     See .osargsEntryPoint    Load / Save file parameters
; See .vectorBGETV    $0216     See .osbgetEntryPoint    Get byte from file
; See .vectorBPUTV    $0218     See .osbputEntryPoint    Put byte to file
; See .vectorBRKV     $0202     See .brkHandler          BRK vector
; See .vectorBYTEV    $020A     See .osbyteEntryPoint    OSBYTE call
; See .vectorCLIV     $0208     See .oscliEntryPoint     Command line interpreter
; See .vectorCNPV     $022E     See .cnpEntryPoint       Count or purge buffer
; See .vectorEVNTV    $0220     -                        Events
; See .vectorFILEV    $0212     See .osfileEntryPoint    Load / Save file
; See .vectorFINDV    $021C     See .osfindEntryPoint    Open / Close file
; See .vectorFSCV     $021E     See .fscEntryPoint       Filing system control
; See .vectorGBPBV    $021A     -                        Multiple BPUT/BGET
; See .vectorIND1V    $0230     -                        Unused vector
; See .vectorIND2V    $0232     -                        Unused vector
; See .vectorIND3V    $0234     -                        Unused vector
; See .vectorINSV     $022A     See .insEntryPoint       Insert character into buffer
; See .vectorIRQ1V    $0204     See .irq1Handler         Primary IRQ vector
; See .vectorIRQ2V    $0206     See .irq2Handler         Unrecognised IRQ vector
; See .vectorKEYV     $0228     See .keyEntryPoint       Keyboard
; See .vectorNETV     $0224     -                        Econet
; See .vectorRDCHV    $0210     See .osrdchEntryPoint    OSRDCH call
; See .vectorREMV     $022C     See .remEntryPoint       Remove character from buffer
; See .vectorUPTV     $0222     -                        User print
; See .vectorUSERV    $0200     See .badCommandError     User vector
; See .vectorVDUV     $0226     -                        Unrecognised PLOT / VDU 23 commands
; See .vectorWORDV    $020C     See .oswordEntryPoint    OSWORD call
; See .vectorWRCHV    $020E     See .oswrchEntryPoint    OSWRCH call
;
; ***************************************************************************************

; ***************************************************************************************
;
; 6502 Vectors
;
; NMI         See .nmiEntryPoint
; RESET       See .resetEntryPoint
; IRQ         See .irqEntryPoint
;
; ***************************************************************************************
