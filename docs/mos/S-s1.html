<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Chapter 1: Introduction</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Carousel.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Downloads.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ACME-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<p>BBC Computer 32K</p>
<h1>*CAT</h1>
<ul><li><a href="../index.html">&#x21A9; home</a></li><li><a href="index.html"><span class="selectedlink">contents</span></a></li>
<li><span class="unlink">introduction</span></li>
<li><a href="S-s2.html">constants</a></li>
<li><a href="S-s3.html">memory-mapped i/o</a></li>
<li><a href="S-s4.html"><b>$C000</b>: chapter 4</a></li>
<li><a href="S-s5.html"><b>$C4C0</b>: chapter 5</a></li>
<li><a href="S-s6.html"><b>$CB1D</b>: chapter 6</a></li>
<li><a href="S-s7.html"><b>$CCF8</b>: chapter 7</a></li>
<li><a href="S-s8.html"><b>$D060</b>: chapter 8</a></li>
<li><a href="S-s9.html"><b>$D7C2</b>: chapter 9</a></li>
<li><a href="S-s10.html"><b>$D940</b>: chapter 10</a></li>
<li><a href="S-s11.html"><b>$DC1C</b>: chapter 11</a></li>
<li><a href="S-s12.html"><b>$DEC5</b>: chapter 12</a></li>
<li><a href="S-s13.html"><b>$E0A4</b>: chapter 13</a></li>
<li><a href="S-s14.html"><b>$E20E</b>: chapter 14</a></li>
<li><a href="S-s15.html"><b>$E5B3</b>: chapter 15</a></li>
<li><a href="S-s16.html"><b>$EB03</b>: chapter 16</a></li>
<li><a href="S-s17.html"><b>$EEDA</b>: chapter 17</a></li>
<li><a href="S-s18.html"><b>$F135</b>: chapter 18</a></li>
<li><a href="S-s19.html"><b>$F588</b>: chapter 19</a></li>
<li><a href="S-s20.html"><b>$F8A9</b>: chapter 20</a></li>
<li><a href="S-s21.html"><b>$FAE8</b>: chapter 21</a></li>
<li><a href="S-s22.html"><b>$FC00</b>: chapter 22</a></li>
<li><a href="S-s23.html"><b>$FF00</b>: chapter 23</a></li>
<li><a href="S-s24.html"><b>$FFA7</b>: chapter 24</a></li>
<li><a href="S-s25.html">appendix</a></li>
<li><a href="S-s26.html">index</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Chapter 1: Introduction' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">MOS 1.20</a></li><li><b>Chapter 1: Introduction</b></li></ul></div>
<p class="purpose">About the BBC Microcomputer, its memory map, and the scope of its operating system</p>

<ul class="toc"><li><a href="S-s1.html#SP1">&#167;1. About this document</a></li><li><a href="S-s1.html#SP2">&#167;2. Building with the ACME Assembler</a></li><li><a href="S-s1.html#SP3">&#167;3. The Machine Operating System (MOS)</a></li><li><a href="S-s1.html#SP4">&#167;4. Memory Mapped IO ($FC00-$FEFF)</a></li><li><a href="S-s1.html#SP5">&#167;5. The Internal Hardware We Talk Directly To (via SHEILA)</a></li><li><a href="S-s1.html#SP6">&#167;6. Power On / Reset</a></li><li><a href="S-s1.html#SP7">&#167;7. Interrupts</a></li><li><a href="S-s1.html#SP8">&#167;8. BRK instruction</a></li><li><a href="S-s1.html#SP9">&#167;9. Paged ROMs (aka "Sideways" ROMs)</a></li><li><a href="S-s1.html#SP10">&#167;10. Calling the Operating System</a></li><li><a href="S-s1.html#SP11">&#167;11. OSWRCH (For displaying text and graphics) ($FFEE)</a></li><li><a href="S-s1.html#SP12">&#167;12. OSRDCH ($FFE0)</a></li><li><a href="S-s1.html#SP13">&#167;13. OSBYTE ($FFF4) (aka *FX)</a></li><li><a href="S-s1.html#SP14">&#167;14. OSWORD ($FFF1)</a></li><li><a href="S-s1.html#SP15">&#167;15. Filing System ($FFCE - $FFDD)</a></li><li><a href="S-s1.html#SP16">&#167;16. OSCLI (aka 'star commands') ($FFF7)</a></li><li><a href="S-s1.html#SP17">&#167;17. Others</a></li><li><a href="S-s1.html#SP18">&#167;18. Extended vectors</a></li><li><a href="S-s1.html#SP19">&#167;19. Memory Map for RAM</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. About this document. </b></p>

<p class="center-p"><img src="mos.png" alt="mos.png"></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> This is a fully annotated reassembly of the operating system of the BBC Micro, v1.20.</span>

<span class="ACME-plain-syntax"> It attempts to explain every corner of the 16K ROM in some detail, hopefully throwing light</span>
<span class="ACME-plain-syntax"> onto often poorly understood sections, and in general to admire its vision, scope, ingenuity</span>
<span class="ACME-plain-syntax"> and succinctness. It also documents some of its few quirks / bugs. By creating this document</span>
<span class="ACME-plain-syntax"> I understand it a lot better now, and I hope that readers will gain some insight too.</span>

<span class="ACME-plain-syntax"> In the comments I often refer to 'NAUG' the 'New Advanced User Guide'</span>
<span class="ACME-plain-syntax"> see </span><a href="https://stardot.org.uk/forums/viewtopic.php?f=42&t=17243." class="external">https://stardot.org.uk/forums/viewtopic.php?f=42&t=17243.</a>

<span class="ACME-plain-syntax"> This document was originally based on the annotated disassembly by Geoff Cox (Micronet,</span>
<span class="ACME-plain-syntax"> 1991) for which I am indebted. It has evolved considerably since it started development</span>
<span class="ACME-plain-syntax"> in late 2019, and development has continued well into 2020.</span>

<span class="ACME-plain-syntax"> Just as the BBC Micro hardware contained both innovation and also points of similarity</span>
<span class="ACME-plain-syntax"> with Acorn's System 2 to 5 and Atom microcomputers, so too the MOS operating system</span>
<span class="ACME-plain-syntax"> design shows clear signs of having evolved from their "monitors". As noted above, the</span>
<span class="ACME-plain-syntax"> Atom monitor occupied just 4K, and the System 2 was even smaller, at 2K: nevertheless</span>
<span class="ACME-plain-syntax"> they contributed design ideas to the MOS, and occasional "Historical Notes" below give</span>
<span class="ACME-plain-syntax"> details. The tiny System 1, a control keypad now best known for having appeared in an</span>
<span class="ACME-plain-syntax"> episode of "Blake's 7", had only 512 bytes of ROM and is not really in the same family.</span>

<span class="ACME-plain-syntax"> Thanks to Graham Nelson whose Inweb software is used to format/layout the HTML version of</span>
<span class="ACME-plain-syntax"> this document, and for his helpful comments, corrections and suggestions and to Adrian</span>
<span class="ACME-plain-syntax"> Nelson for more corrections and suggestions.</span>

<span class="ACME-plain-syntax"> tobymnelson@gmail.com</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Building with the ACME Assembler. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> This document is downloadable ('os120_acme.a') in the syntax for the ACME assembler (as</span>
<span class="ACME-plain-syntax"> well as being browsable in HTML format).</span>

<span class="ACME-plain-syntax"> To assemble, producing os120.bin as a binary, and a report file os120_report.txt:</span>

<span class="ACME-plain-syntax">       acme -r os120_report.txt -o os120.bin os120_acme.a</span>

<span class="ACME-plain-syntax"> When assembled it should produce a binary file that is byte for byte identical to the</span>
<span class="ACME-plain-syntax"> original OS1.20 ROM image. Its MD5 checksum is 0a59a5ba15fe8557b5f7fee32bbd393a</span>

<span class="ACME-plain-syntax"> To explain some perhaps non-obvious points of the ACME assembler syntax:</span>

<span class="ACME-plain-syntax">     * When a branch uses the '+' symbol, the destination is the next     '+' label.</span>
<span class="ACME-plain-syntax">     * When a branch uses the '-' symbol, the destination is the previous '-' label.</span>
<span class="ACME-plain-syntax">     * Symbols '++' and '--' work similarly.</span>
<span class="ACME-plain-syntax">     * !word outputs a 16 bit value as two bytes in little endian order</span>
<span class="ACME-plain-syntax">     * !be16 outputs a 16 bit value as two bytes in big endian order</span>
<span class="ACME-plain-syntax">     * "&gt;.address" means the high byte of .address</span>
<span class="ACME-plain-syntax">     * "&lt;.address" means the low byte of .address</span>

<span class="ACME-plain-syntax"> To download the ACME assembler, see </span><a href="https://github.com/meonwax/acme" class="external">https://github.com/meonwax/acme</a>
<span class="ACME-plain-syntax"> To download this document as assembly language source, see:</span>
</pre>
<div class="download-container">
	<p>
		<a href="os120_acme.a" download>
			<button class="download-button">
				<img src="../docs-assets/download.png" alt="download icon" height=16 width=16>
				Download <b>os120_acme.a</b> (ACME assembly, 1MB)
			</button>
		</a>
	</p>
</div>


<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. The Machine Operating System (MOS). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> An operating system initialises and keeps a computer running properly. This includes</span>
<span class="ACME-plain-syntax"> servicing requests from hardware in a timely manner. An OS also provides a standardised</span>
<span class="ACME-plain-syntax"> set of useful functionality available to user programs.</span>

<span class="ACME-plain-syntax"> The 6502 can directly address up to 64k of memory which is broadly assigned as follows:</span>

<span class="ACME-plain-syntax">    $0000-$7FFF (32k) = RAM        (or $0000-$3FFF (16k) = RAM for Model A computer)</span>
<span class="ACME-plain-syntax">    $8000-$BFFF (16k) = BASIC or other Paged ROM (aka "Sideways ROM")</span>
<span class="ACME-plain-syntax">    $C000-$FFFF (16k) = Operating System ROM</span>

<span class="ACME-plain-syntax"> Each 256 bytes of memory is called a 'page', so addresses $0000 to $00FF is called 'page</span>
<span class="ACME-plain-syntax"> zero', $0100-$01FF is 'page one', etc. Page zero is also known as 'zero page'.</span>
</pre>
<p class="center-p"><img src="circuit_mos.png" alt="circuit_mos.png"></p>

<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. Memory Mapped IO ($FC00-$FEFF). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> Addresses in the range $FC00-$FEFF are not mapped to the OS ROM as might be expected, but</span>
<span class="ACME-plain-syntax"> are connected to hardware devices. Consequently the CPU can communicate with hardware</span>
<span class="ACME-plain-syntax"> devices by reading and writing to specific addresses in this range.</span>

<span class="ACME-plain-syntax"> See </span><a href="S-s3.html" class="internal">Chapter 3: Memory Mapped IO</a><span class="ACME-plain-syntax">.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. The Internal Hardware We Talk Directly To (via SHEILA). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> We use an area of memory mapped I/O called SHEILA ($FE00-$FEFF) to talk to hardware devices</span>
<span class="ACME-plain-syntax"> inside the computer:</span>

<span class="ACME-plain-syntax"> Chip              What it does</span>
<span class="ACME-plain-syntax"> ---------------------------------------------------------------------------------------</span>
<span class="ACME-plain-syntax"> CRTC 6845         Cathode Ray Tube Controller. Handles the video screen format and the</span>
<span class="ACME-plain-syntax">                   cursor height.</span>
<span class="ACME-plain-syntax"> ACIA 6850         } The ACIA and Serial ULA together control the RS-423 and cassette,</span>
<span class="ACME-plain-syntax"> Serial ULA        } including serial printers connected to the RS-423 port.</span>
<span class="ACME-plain-syntax"> Video ULA         Controls video output: timing, logical and physical colours, cursor width.</span>
<span class="ACME-plain-syntax"> System VIA 6522   Controls Sound, Speech, Keyboard, and selects one of four screen hardware</span>
<span class="ACME-plain-syntax">                   addresses for scrolling purposes</span>
<span class="ACME-plain-syntax"> User VIA 6522     Parallel Printer (Port A) and User Port (Port B).</span>
<span class="ACME-plain-syntax"> ADC 7002          Analogue to Digital Convertor. Analogue input, often for Joysticks.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Power On / Reset. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> When powered on or reset (via the BREAK key) the 6502 executes code at the address</span>
<span class="ACME-plain-syntax"> retrieved from $FFFC/D (See .</span><a href="S-s10.html#SP3" class="internal">resetEntryPoint</a><span class="ACME-plain-syntax">).</span>
<span class="ACME-plain-syntax"> The 'BREAK' key causes a soft reset. 'CTRL BREAK' causes a hard reset. A hard reset</span>
<span class="ACME-plain-syntax"> clears RAM and resets more of the OS variables.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Interrupts. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> The BBC Micro is a single processor with no threads or job queues. It uses interrupts</span>
<span class="ACME-plain-syntax"> to run code concurrently with regular code. Interrupt code must finish executing in a</span>
<span class="ACME-plain-syntax"> short amount of time to allow the system to continue updating effectively. Acorn</span>
<span class="ACME-plain-syntax"> recommends it should last less than 2ms (4000 clock cycles).</span>

<span class="ACME-plain-syntax"> The CPU receives interrupts generated by hardware devices when they need attention.</span>

<span class="ACME-plain-syntax"> There are three interrupt types (NMI; IRQ1; IRQ2)</span>

<span class="ACME-plain-syntax"> NMI = non-maskable interrupts</span>
<span class="ACME-plain-syntax">   These are the highest priority of interrupt. They cannot be disabled. They are only</span>
<span class="ACME-plain-syntax">   produced by certain additional hardware (hard disk controllers and Econet).</span>
<span class="ACME-plain-syntax">   When an NMI is generated the 6502 interrupts its normal operation and executes from</span>
<span class="ACME-plain-syntax">   the location given in the OS at $FFFA-B (i.e. $0D00 = .nmiEntryPoint). This is the</span>
<span class="ACME-plain-syntax">   NMI handling code. By default this just returns immediately by executing an RTI</span>
<span class="ACME-plain-syntax">   instruction.</span>

<span class="ACME-plain-syntax"> IRQ1 = interrupt request 1</span>
<span class="ACME-plain-syntax">   This occurs when hardware generates an IRQ, or a BRK instruction occurs. The OS uses</span>
<span class="ACME-plain-syntax">   this IRQ extensively. If a BRK instruction was the cause then the BRKV vector is used</span>
<span class="ACME-plain-syntax">   to handle it (the OS uses this to output error messages). Otherwise the operating</span>
<span class="ACME-plain-syntax">   system checks each hardware in turn to see what needs attention. The OS services the</span>
<span class="ACME-plain-syntax">   RS-423, cassette, vertical sync, 100Hz timer, interval timer, ADC conversion (e.g. used</span>
<span class="ACME-plain-syntax">   for analogue joysticks), keyboard, speech (if speech hardware is present), and printer</span>
<span class="ACME-plain-syntax">   as needed. Based on the 100Hz timers, it also updates sounds and updates the flashing</span>
<span class="ACME-plain-syntax">   colours.</span>

<span class="ACME-plain-syntax">   Finally any unhandled interrupt gets passed on to IRQ2.</span>

<span class="ACME-plain-syntax"> IRQ2 = interrupt request 2</span>
<span class="ACME-plain-syntax">   This is available for user code to intercept unhandled interrupts. It is the lowest</span>
<span class="ACME-plain-syntax">   priority of interrupt.</span>

<span class="ACME-plain-syntax"> Calls to IRQ1 and IRQ2 handlers are indirected through 'vectors' (2 byte addresses</span>
<span class="ACME-plain-syntax"> stored in RAM at $0200 upwards), meaning the user can intercept them and do their own</span>
<span class="ACME-plain-syntax"> processing (often then passing through any unwanted interrupts back into the original</span>
<span class="ACME-plain-syntax"> default interrupt routine). NMIs cannot be redirected.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. BRK instruction. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> The BRK instruction is used for error handling. It pushes the program counter and flags</span>
<span class="ACME-plain-syntax"> onto the stack (including a set bit for the BRK flag) and starts executing from the address</span>
<span class="ACME-plain-syntax"> stored at $FFFE/F (which is set to .irqEntryPoint).</span>

<span class="ACME-plain-syntax"> The OS uses BRK to display error messages (as does the BASIC ROM). The BRK instruction</span>
<span class="ACME-plain-syntax"> is followed by an error number then the error string to display. The .brkHandler code</span>
<span class="ACME-plain-syntax"> displays the error message then enters the current language. Typically though, as soon</span>
<span class="ACME-plain-syntax"> as the machine has started up it will be running a language such as BASIC. BASIC installs</span>
<span class="ACME-plain-syntax"> its own BRK handler, at which point the OS BRK handler is no longer used.</span>

<span class="ACME-plain-syntax"> Note that the BRK instruction is unrelated to the BREAK key. Pressing BREAK causes the 6502</span>
<span class="ACME-plain-syntax"> to RESET.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Paged ROMs (aka "Sideways" ROMs). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> Functionality of the BBC Micro can be extended via the use of Paged ROMs. These ROMs</span>
<span class="ACME-plain-syntax"> can be quickly switched ('paged in') into the memory map as needed at address range</span>
<span class="ACME-plain-syntax"> $8000-$BFFF. Once the ROM code has finished executing the ROM is 'paged out' and the</span>
<span class="ACME-plain-syntax"> previous ROM reinstated into the memory map (which is normally the current language, often</span>
<span class="ACME-plain-syntax"> BASIC).</span>

<span class="ACME-plain-syntax"> Paged ROMs can implement programming languages, provide more commands (star commands) to</span>
<span class="ACME-plain-syntax"> the user, or even act as a Read Only filing system (using ROMFS).</span>

<span class="ACME-plain-syntax"> An optional speech ROM is also supported, which generates speech from text. It is used</span>
<span class="ACME-plain-syntax"> alongside a Phrase ROM or 'PHROM' that provides the word and phoneme data for generating</span>
<span class="ACME-plain-syntax"> speech.</span>

<span class="ACME-plain-syntax"> The BBC Micro has 5 ROM sockets available for Paged ROMs (and the MOS supports up to 16 with</span>
<span class="ACME-plain-syntax"> some additional hardware). In a default configuration (as shipped) the first two ROM sockets</span>
<span class="ACME-plain-syntax"> hold the OS and BASIC.</span>

<span class="ACME-plain-syntax"> 'Sideways RAM'</span>
<span class="ACME-plain-syntax"> Later in the BBC Micro's life it was discovered that you could add 'Sideways RAM' instead</span>
<span class="ACME-plain-syntax"> of a ROM. This requires a write signal as the BBC Micro is hard-wired to prevent writing to</span>
<span class="ACME-plain-syntax"> the Sideways area.</span>

<span class="ACME-plain-syntax"> A common 'Sideways RAM' implementation consists of an expansion board (aka 'daughter board')</span>
<span class="ACME-plain-syntax"> that plugs into a ROM socket with a flying lead connected to the motherboard. This can</span>
<span class="ACME-plain-syntax"> then be used as either additional program RAM or (perhaps more often) to hold a ROM image.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. Calling the Operating System. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> There is a standard set of specific addresses (high in memory, between $FFB9 and $FFF7)</span>
<span class="ACME-plain-syntax"> that the user calls to access OS routines. These are detailed below.</span>

<span class="ACME-plain-syntax"> The following entry points are the API for user programs, or other ROMs, which want to</span>
<span class="ACME-plain-syntax"> access MOS facilities. Note that they occur at addresses which are guaranteed not to</span>
<span class="ACME-plain-syntax"> change: for example, in all versions of the MOS, OSBYTE is at $FFF4. It is therefore safe</span>
<span class="ACME-plain-syntax"> for a user program to 'JSR .OSBYTE' without knowing which MOS version is present. No other</span>
<span class="ACME-plain-syntax"> addresses in the ROM are safe to jump to from outside the ROM.</span>

<span class="ACME-plain-syntax"> Many of these calls are then indirected through a set of 'standard vectors' located in RAM</span>
<span class="ACME-plain-syntax"> at $0200-$0235. A vector is a two byte address. By default each vector contains the address</span>
<span class="ACME-plain-syntax"> within the OS ROM of the relevant routine. Advanced users can change a vector to point to</span>
<span class="ACME-plain-syntax"> their own routine in RAM to handle the call. This allows the user to extend or replace the</span>
<span class="ACME-plain-syntax"> existing functionality provided by the OS.</span>

<span class="ACME-plain-syntax"> If a Paged ROM wishes to change the vectors (for example a filing system ROM would want to</span>
<span class="ACME-plain-syntax"> redirect filing system calls to its own routines within its ROM) then a different system of</span>
<span class="ACME-plain-syntax"> overriding these vectors is used. See the 'Extended Vectors' section below.</span>

<span class="ACME-plain-syntax"> Incidentally the 6502 based Commodore computers from the Commodore PET, the VIC 20 through</span>
<span class="ACME-plain-syntax"> to the Commodore 64 have a similar arrangement of vectors, with its KERNAL functions.</span>
<span class="ACME-plain-syntax"> See </span><a href="https://www.pagetable.com/?p=926" class="external">https://www.pagetable.com/?p=926</a><span class="ACME-plain-syntax"> .</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. OSWRCH (For displaying text and graphics) ($FFEE). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> OSWRCH is generally used to output text or graphics. Output is usually sent to the screen,</span>
<span class="ACME-plain-syntax"> but it can be redirected to other output devices, such as a printer or a file.</span>

<span class="ACME-plain-syntax"> OSWRCH is the equivalent of the 'VDU' command from BASIC, which we use here for brevity.</span>

<span class="ACME-plain-syntax"> VDU 32-126 shows ASCII text characters on screen.</span>
<span class="ACME-plain-syntax"> VDU 127 is delete, which removes the previous character.</span>
<span class="ACME-plain-syntax"> VDU 128-255 displays custom characters on screen (or Teletext codes in MODE 7).</span>
<span class="ACME-plain-syntax"> VDU 0-31 have individual special meanings, and often require more VDU calls that act as</span>
<span class="ACME-plain-syntax"> parameters. For example VDU 22 is the code to change display MODE. Calling this does</span>
<span class="ACME-plain-syntax"> nothing on it's own, as it's waiting for the next VDU call (e.g. VDU 2) specifying the</span>
<span class="ACME-plain-syntax"> MODE number to change to.</span>

<span class="ACME-plain-syntax"> Complex code is found within VDU 25 (the equivalent of BASIC's PLOT command) and is used</span>
<span class="ACME-plain-syntax"> to plot points, lines, dotted lines, filled triangles, and perform horizontal line fills.</span>
<span class="ACME-plain-syntax"> See </span><a href="S-s8.html" class="internal">Chapter 8: PLOT</a><span class="ACME-plain-syntax">.</span>

<span class="ACME-plain-syntax"> Because OSWRCH does so much, a large chuck (37%) of the operating system is devoted to it.</span>

<span class="ACME-plain-syntax"> See .</span><a href="S-s13.html#SP1" class="internal">oswrchEntryPoint</a><span class="ACME-plain-syntax">.</span>

<span class="ACME-plain-syntax"> The BBC Micro defines eight screen MODEs (0-7) each with different combinations of pixel</span>
<span class="ACME-plain-syntax"> resolutions, colours, text vs graphics capability, and therefore memory usage.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. OSRDCH ($FFE0). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> Reads a character from the keyboard (or other input source such as RS-423 or file).</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s12.html#SP2" class="internal">osrdchEntryPoint</a><span class="ACME-plain-syntax">.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. OSBYTE ($FFF4) (aka *FX). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> OSBYTE provides a wide range of miscellaneous functionality. This can be accessed from</span>
<span class="ACME-plain-syntax"> BASIC as a '*FX' command. For example:</span>

<span class="ACME-plain-syntax">   *FX 12,2</span>

<span class="ACME-plain-syntax"> sets the keyboard auto-repeat rate to a faster value than the default. This is equivalent</span>
<span class="ACME-plain-syntax"> to the assembler version:</span>

<span class="ACME-plain-syntax">   LDA #12</span>
<span class="ACME-plain-syntax">   LDX #2</span>
<span class="ACME-plain-syntax">   JSR .OSBYTE</span>

<span class="ACME-plain-syntax"> The A,X,Y registers are the parameters to this call to the OS. Register 'A' determines</span>
<span class="ACME-plain-syntax"> the type of the call, and X and Y are the parameters for that type.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s15.html#SP21" class="internal">osbyteEntryPoint</a><span class="ACME-plain-syntax">.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. OSWORD ($FFF1). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> Some calls to the OS needs more parameters than an OSBYTE can provide. In this case OSWORD</span>
<span class="ACME-plain-syntax"> is used. Registers X and Y together form an address that holds a parameter block of data</span>
<span class="ACME-plain-syntax"> specific to the type of OSWORD given by register 'A'.</span>

<span class="ACME-plain-syntax"> OSWORD calls are available to machine code programs but there is no equivalent star</span>
<span class="ACME-plain-syntax"> command like *FX.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s15.html#SP26" class="internal">oswordEntryPoint</a><span class="ACME-plain-syntax">.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s15.html#SP1" class="internal">osbyteAndOSWORDRoutineTable</a><span class="ACME-plain-syntax"> (end of table for OSWORD entry points)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. Filing System ($FFCE - $FFDD). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> A filing system is selected via a star command. The OS ships with support for tape (*TAPE)</span>
<span class="ACME-plain-syntax"> and ROM filing systems (*ROM). Support for other filing systems (e.g. *ADFS, the</span>
<span class="ACME-plain-syntax"> Advanced Disk Filing System) can be added using Paged ROMs. There is a range of OS calls</span>
<span class="ACME-plain-syntax"> designed to perform operations on the current filing system:</span>

<span class="ACME-plain-syntax">           OSFIND ($FFCE) - Open or close a file (See .</span><a href="S-s18.html#SP28" class="internal">osfindEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax">           OSGBPB ($FFD1) - Read / write multiple bytes to an open file. This is not</span>
<span class="ACME-plain-syntax">                            implemented in this OS for the TAPE/ROM filing systems.</span>
<span class="ACME-plain-syntax">                            Filing System Paged ROMs implement this.</span>
<span class="ACME-plain-syntax">           OSBPUT ($FFD4) - Write a single byte to an open file (See .</span><a href="S-s18.html#SP35" class="internal">osbputEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax">           OSBGET ($FFD7) - Read a single byte to an open file (See .</span><a href="S-s18.html#SP33" class="internal">osbgetEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax">           OSARGS ($FFDA) - Read / write a file's attributes (See .</span><a href="S-s18.html#SP6" class="internal">osargsEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax">           OSFILE ($FFDD) - Load / Save an entire file (See .</span><a href="S-s18.html#SP17" class="internal">osfileEntryPoint</a><span class="ACME-plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. OSCLI (aka 'star commands') ($FFF7). </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> The OS is shipped with a Command Line Interpreter (CLI). This is a primitive form of</span>
<span class="ACME-plain-syntax"> shell. Commands can be accessed from BASIC or via the OSCLI routine.</span>

<span class="ACME-plain-syntax"> BASIC prefixes these with an asterisk, e.g. '*FX' etc. Hence these commands are known as</span>
<span class="ACME-plain-syntax"> 'star commands'. OSCLI executes a command supplied as a string. The OS provides a standard</span>
<span class="ACME-plain-syntax"> set, and Paged ROMs can add more.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s12.html#SP5" class="internal">oscliEntryPoint</a><span class="ACME-plain-syntax">.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s12.html#SP4" class="internal">starCommandTable</a><span class="ACME-plain-syntax">.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. Others. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> OSRDRM ($FFB9)                  - Read byte from Paged ROM (new in MOS 1.20)</span>
<span class="ACME-plain-syntax">                                   (See .</span><a href="S-s10.html#SP32" class="internal">osrdrmEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax"> VDUCHR ($FFBC)                  - A cut down form of OSWRCH just for writing to the screen</span>
<span class="ACME-plain-syntax">                                   (See .</span><a href="S-s5.html#SP2" class="internal">vduChrEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax"> OSEVEN ($FFBF)                  - Generates an EVENT, a kind of managed interrupt</span>
<span class="ACME-plain-syntax">                                   (See .</span><a href="S-s14.html#SP25" class="internal">eventEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax"> GSINIT ($FFC2) / GSREAD ($FFC5) - Parse a string in memory (e.g. from an OSCLI command)</span>
<span class="ACME-plain-syntax">                                   (See .</span><a href="S-s15.html#SP62" class="internal">gsinitEntryPoint</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax"> NVRDCH ($FFC8) / NVWRCH ($FFCB) - Non vectored versions of OSRDCH / OSWRCH</span>
<span class="ACME-plain-syntax"> OSASCI ($FFE3)                  - Write character using OSWRCH, or write CR/LF if CR found</span>
<span class="ACME-plain-syntax">                                   (See .</span><a href="S-s24.html#SP6" class="internal">OSASCI</a><span class="ACME-plain-syntax">)</span>
<span class="ACME-plain-syntax"> OSNEWL ($FFE7)                  - Write CR/LF (See .</span><a href="S-s24.html#SP6" class="internal">OSNEWL</a><span class="ACME-plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Extended vectors. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> Extended vectors allow Paged ROMs to intercept the standard vectors at $0200 upwards,</span>
<span class="ACME-plain-syntax"> effectively getting them to point to an address *within a specified Paged ROM*.</span>
<span class="ACME-plain-syntax"> A table containing 27 entries is stored at $0D9F (.extendedVectorSpace) with 3 bytes per</span>
<span class="ACME-plain-syntax"> entry:</span>
<span class="ACME-plain-syntax">      the two byte address</span>
<span class="ACME-plain-syntax">      a single byte holding the ROM number</span>

<span class="ACME-plain-syntax"> To use an extended vector write appropriate values into these locations, then store</span>
<span class="ACME-plain-syntax"> the address '$FF00+3*N' in OS vector at '$0200+2*N' (remembering the old address at</span>
<span class="ACME-plain-syntax"> $0200+2*N if required).</span>
<span class="ACME-plain-syntax"> See </span><a href="S-s23.html" class="internal">Chapter 23: Extended vectors</a><span class="ACME-plain-syntax">.</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19. Memory Map for RAM. </b></p>

<pre class="ACME-undisplayed-code all-displayed-code code-font">
<span class="ACME-plain-syntax"> $0000-$008F   Current language workspace</span>
<span class="ACME-plain-syntax"> $0090-$009F   Econet workspace</span>
<span class="ACME-plain-syntax"> $00A0-$00A7   NMI workspace       [unused by the OS, can be used by Paged ROMs]</span>
<span class="ACME-plain-syntax"> $00A8-$00AF   "OS temp workspace" [unused by the OS, can be used by Paged ROMs]</span>
<span class="ACME-plain-syntax"> $00B0-$00CF   Filing System workspace</span>
<span class="ACME-plain-syntax"> $00D0-$00FF   VDU/OS workspace</span>
<span class="ACME-plain-syntax"> $0100-$01FF   6502 stack (the stack works downwards from $01FF)</span>
<span class="ACME-plain-syntax"> $0200-$0235   OS vectors</span>
<span class="ACME-plain-syntax"> $0236-$02FF   OS variables</span>
<span class="ACME-plain-syntax"> $0300-$037F   VDU variables</span>
<span class="ACME-plain-syntax"> $0380-$03DF   Cassette Filing System workspace</span>
<span class="ACME-plain-syntax"> $03E0-$03FF   Keyboard input buffer</span>
<span class="ACME-plain-syntax"> $0400-$07FF   Workspace for the currently active language (e.g. BASIC)</span>
<span class="ACME-plain-syntax"> $0800-$08FF   Sound workspace; Sound buffers; Printer buffer; Envelope storage</span>
<span class="ACME-plain-syntax"> $0900-$09FF   Envelope/Speech/Cassette buffers</span>
<span class="ACME-plain-syntax"> $0A00-$0AFF   Cassette/RS-423 input buffer</span>
<span class="ACME-plain-syntax"> $0B00-$0BFF   Soft key buffer</span>
<span class="ACME-plain-syntax"> $0C00-$0CFF   Soft character ('font') definitions</span>
<span class="ACME-plain-syntax"> $0D00-$0D9E   NMI routine (used by Disc Controllers and Econet)</span>
<span class="ACME-plain-syntax"> $0D9F-$0DEF   Expanded vector set</span>
<span class="ACME-plain-syntax"> $0DF0-$0DFF   Paged ROM workspace storage locations</span>
<span class="ACME-plain-syntax"> $0E00-$7FFF   Available user memory</span>

<span class="ACME-plain-syntax"> Available user memory starts at $0E00 for a standard TAPE based machine. At reset time,</span>
<span class="ACME-plain-syntax"> Paged ROMs such as disc controllers can request more RAM pages from $0E00 upwards. This</span>
<span class="ACME-plain-syntax"> will commonly raise the start of user memory to $1900. Soft character definitions (aka</span>
<span class="ACME-plain-syntax"> 'font explosions') also raise the start of available memory.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s7.html#SP2" class="internal">osbyte20EntryPoint</a>

<span class="ACME-plain-syntax"> OSBYTE 131 reads the current OSHWM (OS High Water Mark), the true address of the start</span>
<span class="ACME-plain-syntax"> of user memory after ROMs and font explosions have claimed memory. This often has the</span>
<span class="ACME-plain-syntax"> same value as the PAGE variable in BASIC (unless PAGE is manually changed), which is</span>
<span class="ACME-plain-syntax"> where BASIC programs are located.</span>
<span class="ACME-plain-syntax"> See .</span><a href="S-s17.html#SP24" class="internal">osbyte131EntryPoint</a>
<span class="ACME-plain-syntax"> See .</span><a href="S-s2.html#SP14" class="internal">currentOSHWM</a>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprevoff">&#10094;</li><li class="progresscurrent">1</li><li class="progresssection"><a href="S-s2.html">2</a></li><li class="progresssection"><a href="S-s3.html">3</a></li><li class="progresssection"><a href="S-s4.html">4</a></li><li class="progresssection"><a href="S-s5.html">5</a></li><li class="progresssection"><a href="S-s6.html">6</a></li><li class="progresssection"><a href="S-s7.html">7</a></li><li class="progresssection"><a href="S-s8.html">8</a></li><li class="progresssection"><a href="S-s9.html">9</a></li><li class="progresssection"><a href="S-s10.html">10</a></li><li class="progresssection"><a href="S-s11.html">11</a></li><li class="progresssection"><a href="S-s12.html">12</a></li><li class="progresssection"><a href="S-s13.html">13</a></li><li class="progresssection"><a href="S-s14.html">14</a></li><li class="progresssection"><a href="S-s15.html">15</a></li><li class="progresssection"><a href="S-s16.html">16</a></li><li class="progresssection"><a href="S-s17.html">17</a></li><li class="progresssection"><a href="S-s18.html">18</a></li><li class="progresssection"><a href="S-s19.html">19</a></li><li class="progresssection"><a href="S-s20.html">20</a></li><li class="progresssection"><a href="S-s21.html">21</a></li><li class="progresssection"><a href="S-s22.html">22</a></li><li class="progresssection"><a href="S-s23.html">23</a></li><li class="progresssection"><a href="S-s24.html">24</a></li><li class="progresssection"><a href="S-s25.html">25</a></li><li class="progresssection"><a href="S-s26.html">26</a></li><li class="progressnext"><a href="S-s2.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

